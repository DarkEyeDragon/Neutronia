Index: src/main/java/net/hdt/neutronia/entity/render/RenderDrownedVillager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderDrownedVillager.java	(date 1523987842000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderDrownedVillager.java	(date 1523987842000)
@@ -0,0 +1,52 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityMummyVillager;
+import net.hdt.neutronia.entity.render.model.ModelMummyVillager;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderDrownedVillager extends RenderBiped<EntityMummyVillager> {
+    /**
+     * TODO: Change Textures
+     * Set to Zombie Villager for now
+     */
+    private static final ResourceLocation ZOMBIE_VILLAGER_TEXTURES = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_villager.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_FARMER_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_farmer.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_LIBRARIAN_LOC = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_librarian.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_PRIEST_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_priest.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_SMITH_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_smith.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_BUTCHER_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_butcher.png");
+
+    public RenderDrownedVillager(RenderManager renderManagerIn) {
+        super(renderManagerIn, new ModelMummyVillager(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityMummyVillager entity) {
+        if (true) return entity.getForgeProfession().getZombieSkin();
+
+        switch (entity.getProfession()) {
+            case 0:
+                return ZOMBIE_VILLAGER_FARMER_LOCATION;
+            case 1:
+                return ZOMBIE_VILLAGER_LIBRARIAN_LOC;
+            case 2:
+                return ZOMBIE_VILLAGER_PRIEST_LOCATION;
+            case 3:
+                return ZOMBIE_VILLAGER_SMITH_LOCATION;
+            case 4:
+                return ZOMBIE_VILLAGER_BUTCHER_LOCATION;
+            case 5:
+            default:
+                return ZOMBIE_VILLAGER_TEXTURES;
+        }
+    }
+
+    @Override
+    protected void applyRotations(EntityMummyVillager entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        if (entityLiving.isConverting())
+            rotationYaw += (float) (Math.cos((double) entityLiving.ticksExisted * 3.25D) * Math.PI * 0.25D);
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/SandyBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/SandyBricks.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/SandyBricks.java	(date 1525606901000)
@@ -0,0 +1,54 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:44:08 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockSandyBricks;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockSandyBricksSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockSandyBricksStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class SandyBricks extends Feature {
+
+    public static Block sandy_bricks;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        sandy_bricks = new BlockSandyBricks();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(sandy_bricks, 0, new BlockSandyBricksStairs());
+            BlockModSlab.initSlab(sandy_bricks, 0, new BlockSandyBricksSlab(false), new BlockSandyBricksSlab(true));
+        }
+        VanillaWalls.add("sandy_bricks", sandy_bricks, 0, enableWalls);
+
+//		RecipeHandler.addShapelessOreDictRecipe(ProxyRegistry.newStack(sandy_bricks), ProxyRegistry.newStack(Blocks.BRICK_BLOCK), ProxyRegistry.newStack(Blocks.SAND));
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/wall/BlockSnowBricksWall.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/wall/BlockSnowBricksWall.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/wall/BlockSnowBricksWall.java	(date 1525606879000)
@@ -0,0 +1,43 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [19/04/2016, 16:59:04 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.wall;
+
+import net.hdt.neutronia.blocks.base.BlockModWall;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.Item;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+
+import java.util.Random;
+
+public class BlockSnowBricksWall extends BlockModWall {
+
+    public BlockSnowBricksWall(String name, IBlockState state) {
+        super(name, state);
+    }
+
+    @Override
+    public boolean isToolEffective(String type, IBlockState state) {
+        return type.equals("shovel");
+    }
+
+    @Override
+    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player) {
+        return true;
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockBark.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockBark.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockBark.java	(date 1525606879000)
@@ -0,0 +1,29 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockBark extends BlockMetaVariants implements IModBlock {
+
+    public BlockBark() {
+        super("bark", MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+        BARK_OAK,
+        BARK_SPRUCE,
+        BARK_BIRCH,
+        BARK_JUNGLE,
+        BARK_ACACIA,
+        BARK_DARK_OAK
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/idk/ReflectionUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/ReflectionUtil.java	(date 1525606903000)
+++ src/main/java/net/hdt/neutronia/util/idk/ReflectionUtil.java	(date 1525606903000)
@@ -0,0 +1,68 @@
+package net.hdt.neutronia.util.idk;
+
+import net.minecraftforge.fml.relauncher.ReflectionHelper;
+
+import javax.annotation.Nullable;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+/**
+ * Utility methods for reflection.
+ *
+ * @author Choonster
+ */
+public class ReflectionUtil {
+    /**
+     * Get a {@link MethodHandle} for a method.
+     *
+     * @param clazz       The class
+     * @param methodNames The possible names of the method
+     * @param methodTypes The argument types of the method
+     * @param <T>         The class
+     * @return The MethodHandle
+     */
+    public static MethodHandle findMethod(final Class<?> clazz, final String methodName, @Nullable final String methodObfName, final Class<?>... parameterTypes) {
+        final Method method = ReflectionHelper.findMethod(clazz, methodName, methodObfName, parameterTypes);
+        try {
+            return MethodHandles.lookup().unreflect(method);
+        } catch (IllegalAccessException e) {
+            throw new ReflectionHelper.UnableToFindMethodException(e);
+        }
+    }
+
+    /**
+     * Get a {@link MethodHandle} for a field's getter.
+     *
+     * @param clazz      The class
+     * @param fieldNames The possible names of the field
+     * @return The MethodHandle
+     */
+    public static MethodHandle findFieldGetter(Class<?> clazz, String... fieldNames) {
+        final Field field = ReflectionHelper.findField(clazz, fieldNames);
+
+        try {
+            return MethodHandles.lookup().unreflectGetter(field);
+        } catch (IllegalAccessException e) {
+            throw new ReflectionHelper.UnableToAccessFieldException(fieldNames, e);
+        }
+    }
+
+    /**
+     * Get a {@link MethodHandle} for a field's setter.
+     *
+     * @param clazz      The class
+     * @param fieldNames The possible names of the field
+     * @return The MethodHandle
+     */
+    public static MethodHandle findFieldSetter(Class<?> clazz, String... fieldNames) {
+        final Field field = ReflectionHelper.findField(clazz, fieldNames);
+
+        try {
+            return MethodHandles.lookup().unreflectSetter(field);
+        } catch (IllegalAccessException e) {
+            throw new ReflectionHelper.UnableToAccessFieldException(fieldNames, e);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/LibMisc.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/LibMisc.java	(date 1523986197000)
+++ src/main/java/net/hdt/neutronia/util/LibMisc.java	(date 1523986197000)
@@ -0,0 +1,25 @@
+package net.hdt.neutronia.util;
+
+import java.util.Arrays;
+import java.util.List;
+
+public final class LibMisc {
+
+    public static final List<String> OREDICT_DYES = Arrays.asList("dyeBlack",
+            "dyeRed",
+            "dyeGreen",
+            "dyeBrown",
+            "dyeBlue",
+            "dyePurple",
+            "dyeCyan",
+            "dyeLightGray",
+            "dyeGray",
+            "dyePink",
+            "dyeLime",
+            "dyeYellow",
+            "dyeLightBlue",
+            "dyeMagenta",
+            "dyeOrange",
+            "dyeWhite");
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/QuiltedWool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/QuiltedWool.java	(date 1525606893000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/QuiltedWool.java	(date 1525606893000)
@@ -0,0 +1,29 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockQuiltedWool;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+
+public class QuiltedWool extends Feature {
+
+    public static Block quilted_wool;
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        quilted_wool = new BlockQuiltedWool();
+		
+		/*for(int i = 0; i < 16; i++)
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(quilted_wool, 3, i),
+					" S ", "WWW", " S ",
+					'S', ProxyRegistry.newStack(Items.STRING),
+					'W', ProxyRegistry.newStack(Blocks.WOOL, 1, i));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/StoneInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/StoneInfo.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/world/utils/StoneInfo.java	(date 1525606899000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.world.utils;
+
+import net.hdt.neutronia.util.handlers.DimensionConfig;
+import net.hdt.neutronia.world.utils.handlers.BiomeTypeConfigHandler;
+import net.minecraftforge.common.BiomeDictionary;
+import net.minecraftforge.common.config.Configuration;
+
+import java.util.List;
+
+public class StoneInfo {
+
+    private static Configuration config;
+    public final boolean enabled;
+    public final int clusterSize, clusterRarity, upperBound, lowerBound;
+    public final boolean clustersRarityPerChunk;
+    public final DimensionConfig dims;
+    public final List<BiomeDictionary.Type> allowedBiomes;
+
+    public StoneInfo(String category, int clusterSize, int clusterRarity, int upperBound, int lowerBound, boolean enabled, String dimStr, BiomeDictionary.Type... biomes) {
+        this.enabled = config.getBoolean("Enabled", category, true, "") && enabled;
+        this.clusterSize = config.getInt("Cluster Radius", category, clusterSize, 0, Integer.MAX_VALUE, "");
+        this.clusterRarity = config.getInt("Cluster Rarity", category, clusterRarity, 0, Integer.MAX_VALUE, "Out of how many chunks would one of these clusters generate");
+        this.upperBound = config.getInt("Y Level Max", category, upperBound, 0, 255, "");
+        this.lowerBound = config.getInt("Y Level Min", category, lowerBound, 0, 255, "");
+        clustersRarityPerChunk = config.getBoolean("Invert Cluster Rarity", category, false, "Setting this to true will make the 'Cluster Rarity' feature be X per chunk rather than 1 per X chunks");
+
+        dims = new DimensionConfig(category, dimStr);
+        allowedBiomes = BiomeTypeConfigHandler.parseBiomeTypeArrayConfig("Allowed Biome Types", category, biomes);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/ReedBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/ReedBlock.java	(date 1525606897000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/ReedBlock.java	(date 1525606897000)
@@ -0,0 +1,57 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:37:35 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockReed;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockReedSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockReedStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class ReedBlock extends Feature {
+
+    public static Block reed_block;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        reed_block = new BlockReed();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(reed_block, 0, new BlockReedStairs());
+            BlockModSlab.initSlab(reed_block, 0, new BlockReedSlab(false), new BlockReedSlab(true));
+        }
+        VanillaWalls.add("reed_block", reed_block, 0, enableWalls);
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(reed_block),
+				"RRR", "RRR", "RRR",
+				'R', ProxyRegistry.newStack(Items.REEDS));
+		RecipeHandler.addShapelessOreDictRecipe(ProxyRegistry.newStack(Items.REEDS, 9), ProxyRegistry.newStack(reed_block));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenOasis.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenOasis.java	(date 1523986183000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenOasis.java	(date 1523986183000)
@@ -0,0 +1,43 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenReed;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenOasis extends WorldGenerator {
+    public WorldGenOasis() {
+        super(false);
+    }
+
+    public boolean generate(World world, Random random, BlockPos position) {
+        int x;
+        int z;
+        for (x = -2; x < 3; ++x) {
+            for (z = -2; z < 3; ++z) {
+                if (!world.getBlockState(position.add(x, -1, z)).getMaterial().isSolid()) {
+                    return false;
+                }
+            }
+        }
+
+        for (x = -3; x < 4; ++x) {
+            for (z = -3; z < 4; ++z) {
+                world.setBlockState(position.add(x, 0, z), Blocks.WATER.getDefaultState());
+                if (x == -3 || x == 3 || z == -3 || z == 3) {
+                    world.setBlockState(position.add(x, 0, z), random.nextInt(2) == 0 ? Blocks.LOG.getDefaultState() : Blocks.LEAVES.getDefaultState());
+                }
+
+                if (x == 0 && z == 0) {
+                    world.setBlockState(position, Blocks.GRASS.getDefaultState());
+                }
+            }
+        }
+
+        (new WorldGenReed()).generate(world, random, position);
+        return true;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Calibrator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Calibrator.java	(date 1523986187000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Calibrator.java	(date 1523986187000)
@@ -0,0 +1,170 @@
+package net.hdt.neutronia.world.gen.misc;
+
+
+import net.minecraft.block.Block;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.io.IOException;
+import java.text.DecimalFormat;
+import java.util.Random;
+
+/* Calibrates posture in the world */
+public class Calibrator {
+
+    private double variance = 0; // Characterizes roughness
+    private double varianceUnderLiquid = 0; // Characterizes roughness under liquids
+    private double averageHeight = 0; // Average blocks height
+    private double averageHeightUnderLiquid = 0; // Average blocks height under liquids
+    private int maxHeight = 0; // Max block height in region
+    private int maxHeightUnderLiquid = 0; // Max block height under liquids
+    private int minHeight = 255; // Min block height in region
+    private int minHeightUnderLiquid = 255; // Min block height under liquids
+
+    public Calibrator(World world, Posture posture) throws IOException {
+        double totalHeight = 0;
+        double squareHeightSum = 0;
+        double totalHeightUnderLiquid = 0;
+        double squareHeightSumUnderLiquid = 0;
+        boolean[] overlook = Decorator.overlook;
+        boolean[] liquid = Decorator.liquid;
+        int sx = posture.getPosX();
+        int sz = posture.getPosZ();
+        int ex = posture.getEndX() - 1;
+        int ez = posture.getEndZ() - 1;
+        String dimName = world.provider.getDimensionType().getName();
+        int startHeight = 255;
+        startHeight = dimName.equalsIgnoreCase("Nether") ? 63 : startHeight;
+        startHeight = dimName.equalsIgnoreCase("End") ? 127 : startHeight;
+        double area = 0;
+        for (int wx = sx; wx <= ex; ++wx) {
+            for (int wz = sz; wz <= ez; ++wz) {
+                if (wx != sx && wx != ex && wz != sz && wz != ez) {
+                    continue;
+                }
+                area++;
+                int hg = startHeight;
+                while (hg > 0) {
+                    int blockID = Block.getIdFromBlock(world.getBlockState(new BlockPos(wx, hg, wz)).getBlock());
+                    if (blockID >= 0 && blockID < 256 && overlook[blockID]) {
+                        --hg;
+                    } else {
+                        break;
+                    }
+                }
+                maxHeight = Math.max(maxHeight, hg + 1);
+                minHeight = Math.min(minHeight, hg + 1);
+                totalHeight += hg + 1;
+                squareHeightSum += (hg + 1) * (hg + 1);
+                while (hg > 0) {
+                    int blockID = Block.getIdFromBlock(world.getBlockState(new BlockPos(wx, hg, wz)).getBlock());
+                    if (blockID >= 0 && blockID < 256 && (overlook[blockID] || liquid[blockID])) {
+                        --hg;
+                    } else {
+                        break;
+                    }
+                }
+                maxHeightUnderLiquid = Math.max(maxHeightUnderLiquid, hg + 1);
+                minHeightUnderLiquid = Math.min(minHeightUnderLiquid, hg + 1);
+                totalHeightUnderLiquid += hg + 1;
+                squareHeightSumUnderLiquid += (hg + 1) * (hg + 1);
+            }
+        }
+        if (area <= 0) {
+            throw new IOException("Incorrect calibration area: " + area);
+        }
+        minHeight = Math.min(minHeight, maxHeight);
+        minHeightUnderLiquid = Math.min(minHeightUnderLiquid, maxHeightUnderLiquid);
+        variance = area > 1 ? Math.abs((squareHeightSum - (totalHeight * totalHeight) / area) / (area - 1)) : 0;
+        varianceUnderLiquid = area > 1 ? Math.abs((squareHeightSumUnderLiquid - (totalHeightUnderLiquid * totalHeightUnderLiquid) / area) / (area - 1)) : 0;
+        averageHeight = totalHeight / area;
+        averageHeightUnderLiquid = totalHeightUnderLiquid / area;
+    }
+
+    /* Calibrates structure height. Throw exceptions if it impossible. */
+    public int calibrate(Structure structure, long seed) throws IOException {
+        Random random = new Random(seed);
+        double liquidHeight = averageHeight - averageHeightUnderLiquid;
+        DecimalFormat decimal = new DecimalFormat("######0.00");
+        int height = structure.flags.getShort("Height");
+        double lift = structure.flags.getInteger("Lift");
+        boolean water = structure.flags.getString("Method").equalsIgnoreCase("Water");
+        boolean underwater = structure.flags.getString("Method").equalsIgnoreCase("Underwater");
+        boolean floating = structure.flags.getString("Method").equalsIgnoreCase("Floating");
+        boolean underground = structure.flags.getString("Method").equalsIgnoreCase("Underground");
+        int sy;
+        double roughness = Math.sqrt(variance);
+        double underLiquidRoughness = Math.sqrt(varianceUnderLiquid);
+        if (water) {
+            if (roughness > 3.0 * Decorator.roughnessFactor) {
+                throw new IOException("Rough water: " + decimal.format(roughness));
+            }
+            if (liquidHeight < 6.0) {
+                throw new IOException("Too shallow: " + decimal.format(liquidHeight));
+            }
+            sy = (int) (averageHeight - roughness);
+        } else {
+            if (underwater) {
+                if (underLiquidRoughness > (height / 3.0 + 2) * Decorator.roughnessFactor) {
+                    throw new IOException("Rough bottom: " + decimal.format(underLiquidRoughness));
+                }
+                if (liquidHeight < height * 0.35 && liquidHeight + lift < height) {
+                    throw new IOException("Too shallow: " + decimal.format(liquidHeight));
+                }
+            } else if (!floating && !underground) {
+                if (underLiquidRoughness > (height / 8.0 + 2) * Decorator.roughnessFactor) {
+                    throw new IOException("Rough area: " + decimal.format(underLiquidRoughness));
+                }
+                if (liquidHeight > 1.5) {
+                    throw new IOException("Too deep: " + decimal.format(liquidHeight));
+                }
+            }
+            sy = (int) (averageHeightUnderLiquid - underLiquidRoughness);
+        }
+        if (floating) {
+            sy += 8 + height + random.nextInt() % (height / 2);
+        } else if (underground) {
+            sy = Math.max(2, Math.min(sy - height, 30 + random.nextInt() % 25));
+        } else {
+            sy -= lift;
+            sy += Decorator.forceLift;
+        }
+        if (sy < 2 || sy > 250) {
+            throw new IOException("Abnormal height: " + sy);
+        }
+        return sy;
+    }
+
+    public double getVariance() {
+        return variance;
+    }
+
+    public double getVarianceUnderLiquid() {
+        return varianceUnderLiquid;
+    }
+
+    public double getAverageHeight() {
+        return averageHeight;
+    }
+
+    public double getAverageHeightUnderLiquid() {
+        return averageHeightUnderLiquid;
+    }
+
+    public int getMaxHeight() {
+        return maxHeight;
+    }
+
+    public int getMaxHeightUnderLiquid() {
+        return maxHeightUnderLiquid;
+    }
+
+    public int getMinHeight() {
+        return minHeight;
+    }
+
+    public int getMinHeightUnderLiquid() {
+        return minHeightUnderLiquid;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/dungeons/TFFeature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/dungeons/TFFeature.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/world/dungeons/TFFeature.java	(date 1525606895000)
@@ -0,0 +1,802 @@
+package net.hdt.neutronia.world.dungeons;
+
+import com.google.common.collect.Lists;
+import net.minecraft.client.Minecraft;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.entity.monster.*;
+import net.minecraft.entity.passive.EntityBat;
+import net.minecraft.entity.passive.EntitySquid;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Items;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.nbt.NBTTagString;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.text.ITextComponent;
+import net.minecraft.util.text.TextComponentTranslation;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.Biome.SpawnListEntry;
+import net.minecraft.world.gen.MapGenBase;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class TFFeature {
+
+    public static final TFFeature[] featureList = new TFFeature[256];
+
+    public static final TFFeature nothing = new TFFeature(0, 0, "no_feature").enableDecorations().disableStructure();
+    public static final TFFeature hill1 = new TFFeature(1, 1, "small_hollow_hill").enableDecorations().enableTerrainAlterations();
+    public static final TFFeature hill2 = new TFFeature(2, 2, "medium_hollow_hill").enableDecorations().enableTerrainAlterations();
+    public static final TFFeature hill3 = new TFFeature(3, 3, "large_hollow_hill").enableDecorations().enableTerrainAlterations();
+    public static final TFFeature hedgeMaze = new TFFeature(4, 2, "hedge_maze").enableTerrainAlterations();
+    public static final TFFeature nagaCourtyard = new TFFeature(5, 3, "naga_courtyard").enableTerrainAlterations();
+    public static final TFFeature lichTower = new TFFeature(6, 1, "lich_tower");
+    public static final TFFeature iceTower = new TFFeature(7, 2, "ice_tower");
+    public static final TFFeature questIsland = new TFFeature(8, 1, "quest_island").disableStructure();
+    public static final TFFeature questGrove = new TFFeature(9, 1, "quest_grove").enableTerrainAlterations();
+    public static final TFFeature druidGrove = new TFFeature(10, 1, "druid_grove").disableStructure();
+    public static final TFFeature floatRuins = new TFFeature(11, 3, "floating_ruins").disableStructure();
+    public static final TFFeature hydraLair = new TFFeature(12, 2, "hydra_lair").enableTerrainAlterations();
+    public static final TFFeature labyrinth = new TFFeature(13, 3, "labyrinth").enableDecorations();
+    public static final TFFeature darkTower = new TFFeature(14, 1, "dark_tower");
+    public static final TFFeature tfStronghold = new TFFeature(15, 3, "knight_stronghold").enableDecorations().disableProtectionAura();
+    public static final TFFeature worldTree = new TFFeature(16, 3, "world_tree").disableStructure();
+    public static final TFFeature yetiCave = new TFFeature(17, 2, "yeti_lairs").enableDecorations().enableTerrainAlterations();
+    public static final TFFeature trollCave = new TFFeature(18, 3, "troll_lairs").enableDecorations().enableTerrainAlterations().disableProtectionAura();
+    public static final TFFeature finalCastle = new TFFeature(19, 3, "final_castle");
+    public static final TFFeature mushroomTower = new TFFeature(20, 2, "mushroom_tower");
+    private static int maxSize;
+
+    static {
+        // spawn lists!
+        lichTower.addMonster(EntityZombie.class, 10, 4, 4);
+        lichTower.addMonster(EntitySkeleton.class, 10, 4, 4);
+        lichTower.addMonster(EntityCreeper.class, 1, 4, 4);
+        lichTower.addMonster(EntityEnderman.class, 1, 1, 4);
+        lichTower.addMonster(EntityWitch.class, 1, 1, 1);
+
+        hill1.addMonster(EntitySpider.class, 10, 4, 4);
+        hill1.addMonster(EntityZombie.class, 10, 4, 4);
+
+        hill2.addMonster(EntitySkeleton.class, 10, 4, 4);
+        hill2.addMonster(EntitySpider.class, 10, 4, 4);
+        hill2.addMonster(EntityCreeper.class, 10, 4, 4);
+        hill2.addMonster(EntityWitch.class, 1, 1, 1);
+
+        hill3.addMonster(EntitySkeleton.class, 10, 4, 4);
+        hill3.addMonster(EntityCaveSpider.class, 10, 4, 4);
+        hill3.addMonster(EntityCreeper.class, 10, 4, 4);
+        hill3.addMonster(EntityEnderman.class, 1, 1, 4);
+        hill3.addMonster(EntityWitch.class, 1, 1, 1);
+
+        labyrinth.addMonster(EntityCaveSpider.class, 10, 4, 4);
+        labyrinth.addMonster(EntityCreeper.class, 10, 4, 4);
+        labyrinth.addMonster(EntityEnderman.class, 1, 1, 4);
+
+        darkTower.addMonster(EntitySkeleton.class, 10, 4, 4);
+        darkTower.addMonster(EntityCreeper.class, 10, 4, 4);
+        darkTower.addMonster(EntityEnderman.class, 2, 1, 4);
+        darkTower.addMonster(EntityWitch.class, 1, 1, 1);
+        // aquarium squids (only in aquariums between y = 35 and y = 64. :/
+        darkTower.addWaterCreature(EntitySquid.class, 10, 4, 4);
+
+        tfStronghold.addMonster(EntityCreeper.class, 10, 4, 4);
+        tfStronghold.addMonster(EntitySlime.class, 5, 4, 4);
+
+        trollCave.addMonster(EntityCreeper.class, 5, 4, 4);
+        trollCave.addMonster(EntitySkeleton.class, 10, 4, 4);
+        trollCave.addMonster(EntityWitch.class, 5, 1, 1);
+
+        // plain parts of the castle, like the tower maze
+        finalCastle.addMonster(EntityEnderman.class, 10, 1, 1);
+
+        // forge
+        finalCastle.addMonster(3, EntityBlaze.class, 10, 1, 1);
+
+    }
+
+    public int featureID;
+    public int size;
+    public String name;
+    public boolean areChunkDecorationsEnabled;
+    public boolean isStructureEnabled;
+    public boolean isTerrainAltered;
+    public boolean hasProtectionAura;
+    private List<List<SpawnListEntry>> spawnableMonsterLists;
+    private List<SpawnListEntry> ambientCreatureList;
+    private List<SpawnListEntry> waterCreatureList;
+    private ResourceLocation requiredAchievement = null;
+    private long lastSpawnedHintMonsterTime;
+
+    public TFFeature(int parID, int parSize, String parName) {
+        this.featureID = parID;
+        TFFeature.featureList[parID] = this;
+        this.size = parSize;
+        this.name = parName;
+        this.areChunkDecorationsEnabled = false;
+        this.isStructureEnabled = true;
+        this.isTerrainAltered = false;
+        this.spawnableMonsterLists = new ArrayList<>();
+        this.ambientCreatureList = new ArrayList<>();
+        this.waterCreatureList = new ArrayList<>();
+        this.hasProtectionAura = true;
+
+        ambientCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
+
+        maxSize = Math.max(maxSize, parSize);
+    }
+
+    public static int getMaxSize() {
+        return maxSize;
+    }
+
+    /**
+     * doesn't require modid
+     */
+    public static TFFeature getFeatureByName(String name) {
+        for (TFFeature feature : featureList) {
+            if (feature != null && feature.name.equalsIgnoreCase(name))
+                return feature;
+        }
+        return nothing;
+    }
+
+    /**
+     * modid sensitive
+     */
+    public static TFFeature getFeatureByName(ResourceLocation name) {
+        if (name.getResourceDomain().equalsIgnoreCase(MOD_ID))
+            return getFeatureByName(name.getResourcePath());
+        return nothing;
+    }
+
+    public static TFFeature getFeatureByID(int id) {
+        for (TFFeature feature : featureList) {
+            if (feature != null && feature.featureID == id)
+                return feature;
+        }
+        return nothing;
+    }
+
+    public static int getFeatureID(int mapX, int mapZ, World world) {
+        return getFeatureAt(mapX, mapZ, world).featureID;
+    }
+
+    public static TFFeature getFeatureAt(int mapX, int mapZ, World world) {
+        return generateFeature(mapX >> 4, mapZ >> 4, world);
+    }
+
+    public static boolean isInFeatureChunk(World world, int mapX, int mapZ) {
+        int chunkX = mapX >> 4;
+        int chunkZ = mapZ >> 4;
+        BlockPos cc = getNearestCenterXYZ(chunkX, chunkZ, world);
+
+        return chunkX == (cc.getX() >> 4) && chunkZ == (cc.getZ() >> 4);
+    }
+
+    /**
+     * @return The type of feature directly at the specified Chunk coordinates
+     */
+    public static TFFeature getFeatureDirectlyAt(int chunkX, int chunkZ, World world) {
+
+        if (isInFeatureChunk(world, chunkX << 4, chunkZ << 4)) {
+            return getFeatureAt(chunkX << 4, chunkZ << 4, world);
+        } else {
+            return nothing;
+        }
+    }
+
+    /**
+     * What feature would go in this chunk.  Called when we know there is a feature, but there is no cache data,
+     * either generating this chunk for the first time, or using the magic map to forecast beyond the edge of the world.
+     */
+    public static TFFeature generateFeature(int chunkX, int chunkZ, World world) {
+        // set the chunkX and chunkZ to the center of the biome
+        chunkX = Math.round(chunkX / 16F) * 16;
+        chunkZ = Math.round(chunkZ / 16F) * 16;
+
+        // what biome is at the center of the chunk?
+        Biome biomeAt = world.getBiome(new BlockPos((chunkX << 4) + 8, 0, (chunkZ << 4) + 8));
+
+		/*
+		// Remove above block comment start marker to enable debug
+		// noinspection ConstantConditions
+		if (true) {
+			return nagaCourtyard;
+		}//*/
+
+        // glaciers have ice towers
+        if (biomeAt == Biomes.ICE_PLAINS) {
+            return iceTower;
+        }
+        // snow has yeti lair
+        if (biomeAt == Biomes.ICE_MOUNTAINS) {
+            return yetiCave;
+        }
+
+        // lakes have quest islands
+        if (biomeAt == Biomes.RIVER) {
+            return questIsland;
+        }
+
+        // enchanted forests have groves
+        if (biomeAt == Biomes.FOREST) {
+            return questGrove;
+        }
+
+        // fire swamp has hydra lair
+        if (biomeAt == Biomes.SWAMPLAND) {
+            return hydraLair;
+        }
+        // swamp has labyrinth
+        if (biomeAt == Biomes.SWAMPLAND) {
+            return labyrinth;
+        }
+
+        // dark forests have their own things
+        if (biomeAt == Biomes.BIRCH_FOREST) {
+            return tfStronghold;
+        }
+        if (biomeAt == Biomes.BIRCH_FOREST_HILLS) {
+            return darkTower;
+        }
+
+		/*// highlands center has castle
+		if (biomeAt == TFBiomes.highlandsCenter) {
+			return finalCastle;
+		}
+		// highlands has trolls
+		if (biomeAt == TFBiomes.highlands) {
+			return trollCave;
+		}
+
+		// deep mushrooms has mushroom tower
+		if (biomeAt == TFBiomes.deepMushrooms) {
+			return mushroomTower;
+		}*/
+
+        int regionOffsetX = Math.abs((chunkX + 64 >> 4) % 8);
+        int regionOffsetZ = Math.abs((chunkZ + 64 >> 4) % 8);
+
+        // plant two lich towers near the center of each 2048x2048 map area
+        if ((regionOffsetX == 4 && regionOffsetZ == 5) || (regionOffsetX == 4 && regionOffsetZ == 3)) {
+            return lichTower;
+        }
+
+        // also two nagas
+        if ((regionOffsetX == 5 && regionOffsetZ == 4) || (regionOffsetX == 3 && regionOffsetZ == 4)) {
+            return nagaCourtyard;
+        }
+
+        // get random value
+        Random hillRNG = new Random(world.getSeed() + chunkX * 25117 + chunkZ * 151121);
+        int randnum = hillRNG.nextInt(16);
+
+        // okay, well that takes care of most special cases
+        switch (randnum) {
+            default:
+            case 0:
+            case 1:
+            case 2:
+            case 3:
+            case 4:
+            case 5:
+                return hill1;
+            case 6:
+            case 7:
+            case 8:
+                return hill2;
+            case 9:
+                return hill3;
+            case 10:
+            case 11:
+                return hedgeMaze;
+            case 12:
+            case 13:
+                return nagaCourtyard;
+            case 14:
+            case 15:
+                return lichTower;
+        }
+    }
+
+    /**
+     * What feature would go in this chunk.  Called when we know there is a feature, but there is no cache data,
+     * either generating this chunk for the first time, or using the magic map to forecast beyond the edge of the world.
+     */
+    public static TFFeature generateFeaturePreset5x5(int chunkX, int chunkZ, World world) {
+        int cf = 16;
+
+        if (chunkX % cf != 0 || chunkZ % cf != 0) {
+            return TFFeature.nothing;
+        }
+
+        int mx = (chunkX / cf) + 4;
+        int mz = (chunkZ / cf) + 4;
+
+
+        int[][] map = {
+                {0, 0, 0, 0, 0, 0, 0, 0},
+                {0, 0, 0, 0, 0, 0, 0, 0},
+                {0, 0, 19, 18, 8, 15, 14, 0},
+                {0, 0, 18, 18, 2, 3, 15, 0},
+                {0, 0, 4, 4, 5, 16, 9, 0},
+                {0, 0, 13, 6, 1, 2, 17, 0},
+                {0, 0, 12, 13, 3, 17, 7, 0},
+                {0, 0, 0, 0, 0, 0, 0, 0}};
+
+        if (mx >= 0 && mx < 8 && mz >= 0 && mz < 8) {
+            return TFFeature.featureList[map[mz][mx]];
+        } else {
+            return TFFeature.nothing;
+        }
+    }
+
+    /**
+     * What feature would go in this chunk.  Called when we know there is a feature, but there is no cache data,
+     * either generating this chunk for the first time, or using the magic map to forecast beyond the edge of the world.
+     */
+    public static TFFeature generateFeaturePreset6x6(int chunkX, int chunkZ, World world) {
+        int cf = 16;
+
+        if (chunkX % cf != 0 || chunkZ % cf != 0) {
+            return TFFeature.nothing;
+        }
+
+        int mx = (chunkX / cf) + 3;
+        int mz = (chunkZ / cf) + 3;
+
+
+        int[][] map = {
+                {0, 0, 0, 0, 0, 0, 0, 0},
+                {0, 19, 19, 18, 15, 0, 0, 0},
+                {0, 18, 18, 18, 0, 14, 0, 0},
+                {0, 0, 4, 1, 2, 3, 15, 0},
+                {0, 4, 1, 5, 16, 9, 17, 0},
+                {0, 0, 13, 2, 3, 17, 17, 0},
+                {0, 0, 12, 13, 6, 17, 7, 0},
+                {0, 0, 0, 0, 0, 0, 0, 0}};
+
+        if (mx >= 0 && mx < 8 && mz >= 0 && mz < 8) {
+            return TFFeature.featureList[map[mz][mx]];
+        } else {
+            return TFFeature.nothing;
+        }
+    }
+
+    /**
+     * @return The feature nearest to the specified chunk coordinates
+     */
+    public static TFFeature getNearestFeature(int cx, int cz, World world) {
+        for (int rad = 1; rad <= 4; rad++) {
+            for (int x = -rad; x <= rad; x++) {
+                for (int z = -rad; z <= rad; z++) {
+                    TFFeature directlyAt = getFeatureDirectlyAt(x + cx, z + cz, world);
+                    if (directlyAt.size == rad) {
+                        return directlyAt;
+                    }
+                }
+            }
+        }
+
+        return nothing;
+    }
+
+    // [Vanilla Copy] from MapGenStructure#findNearestStructurePosBySpacing; changed 2nd param to be TFFeature instead of MapGenStructure
+    public static BlockPos findNearestFeaturePosBySpacing(World worldIn, TFFeature feature, BlockPos blockPos, int p_191069_3_, int p_191069_4_, int p_191069_5_, boolean p_191069_6_, int p_191069_7_, boolean findUnexplored) {
+        int i = blockPos.getX() >> 4;
+        int j = blockPos.getZ() >> 4;
+        int k = 0;
+
+        for (Random random = new Random(); k <= p_191069_7_; ++k) {
+            for (int l = -k; l <= k; ++l) {
+                boolean flag = l == -k || l == k;
+
+                for (int i1 = -k; i1 <= k; ++i1) {
+                    boolean flag1 = i1 == -k || i1 == k;
+
+                    if (flag || flag1) {
+                        int j1 = i + p_191069_3_ * l;
+                        int k1 = j + p_191069_3_ * i1;
+
+                        if (j1 < 0) {
+                            j1 -= p_191069_3_ - 1;
+                        }
+
+                        if (k1 < 0) {
+                            k1 -= p_191069_3_ - 1;
+                        }
+
+                        int l1 = j1 / p_191069_3_;
+                        int i2 = k1 / p_191069_3_;
+                        Random random1 = worldIn.setRandomSeed(l1, i2, p_191069_5_);
+                        l1 = l1 * p_191069_3_;
+                        i2 = i2 * p_191069_3_;
+
+                        if (p_191069_6_) {
+                            l1 = l1 + (random1.nextInt(p_191069_3_ - p_191069_4_) + random1.nextInt(p_191069_3_ - p_191069_4_)) / 2;
+                            i2 = i2 + (random1.nextInt(p_191069_3_ - p_191069_4_) + random1.nextInt(p_191069_3_ - p_191069_4_)) / 2;
+                        } else {
+                            l1 = l1 + random1.nextInt(p_191069_3_ - p_191069_4_);
+                            i2 = i2 + random1.nextInt(p_191069_3_ - p_191069_4_);
+                        }
+
+                        MapGenBase.setupChunkSeed(worldIn.getSeed(), random, l1, i2);
+                        random.nextInt();
+
+                        // Check changed for TFFeature
+                        if (TFFeature.getFeatureAt(l1 << 4, i2 << 4, worldIn) == feature) {
+                            if (!findUnexplored || !worldIn.isChunkGeneratedAt(l1, i2)) {
+                                return new BlockPos((l1 << 4) + 8, 64, (i2 << 4) + 8);
+                            }
+                        } else if (k == 0) {
+                            break;
+                        }
+                    }
+                }
+
+                if (k == 0) {
+                    break;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * @return The feature in the chunk "region"
+     */
+    public static TFFeature getFeatureForRegion(int chunkX, int chunkZ, World world) {
+        //just round to the nearest multiple of 16 chunks?
+        int featureX = Math.round(chunkX / 16F) * 16;
+        int featureZ = Math.round(chunkZ / 16F) * 16;
+
+        return TFFeature.generateFeature(featureX, featureZ, world);
+
+    	/* old version
+    	for (int rad = 1; rad <= 3; rad++)
+    	{
+    		for (int x = -rad; x <= rad; x++)
+    		{
+    			for (int z = -rad; z <= rad; z++)
+    			{
+    				TFFeature directlyAt = getFeatureDirectlyAt(x + chunkX, z + chunkZ, world);
+    				if (directlyAt != TFFeature.nothing)
+    				{
+    					return directlyAt;
+    				}
+    			}
+    		}
+    	}
+
+    	return nothing;
+    	*/
+    }
+
+    /**
+     * If we're near a hollow hill, this returns relative block coordinates indicating the center of that hill relative to the current chunk block coordinate system.
+     */
+    public static int[] getNearestCenter(int cx, int cz, World world) {
+        for (int rad = 1; rad <= 4; rad++) {
+            for (int x = -rad; x <= rad; x++) {
+                for (int z = -rad; z <= rad; z++) {
+                    if (getFeatureDirectlyAt(x + cx, z + cz, world).size == rad) {
+                        int[] center = {x * 16 + 8, z * 16 + 8};
+                        return center;
+                    }
+                }
+            }
+        }
+        int[] no = {0, 0};
+        return no;
+    }
+
+    /**
+     * Given some coordinates, return the center of the nearest feature.
+     * <p>
+     * At the moment, with how features are distributed, just get the closest multiple of 256 and add +8 in both directions.
+     * <p>
+     * Maybe in the future we'll have to actually search for a feature chunk nearby, but for now this will work.
+     */
+    public static BlockPos getNearestCenterXYZ(int cx, int cz, World world) {
+        int chunkX = cx;
+        int chunkZ = cz;
+
+        // generate random number for the whole biome area
+        int regionX = (chunkX + 8) >> 4;
+        int regionZ = (chunkZ + 8) >> 4;
+
+        long seed = (long) (regionX * 3129871) ^ (long) regionZ * 116129781L;
+        seed = seed * seed * 42317861L + seed * 7L;
+
+        int num0 = (int) (seed >> 12 & 3L);
+        int num1 = (int) (seed >> 15 & 3L);
+        int num2 = (int) (seed >> 18 & 3L);
+        int num3 = (int) (seed >> 21 & 3L);
+
+        // slightly randomize center of biome (+/- 3)
+        int centerX = 8 + num0 - num1;
+        int centerZ = 8 + num2 - num3;
+
+        // centers are offset strangely depending on +/-
+        int ccz;
+        if (regionZ >= 0) {
+            ccz = (regionZ * 16 + centerZ - 8) * 16 + 8;
+        } else {
+            ccz = (regionZ * 16 + (16 - centerZ) - 8) * 16 + 9;
+        }
+
+        int ccx;
+        if (regionX >= 0) {
+            ccx = (regionX * 16 + centerX - 8) * 16 + 8;
+        } else {
+            ccx = (regionX * 16 + (16 - centerX) - 8) * 16 + 9;
+        }
+
+        return new BlockPos(ccx, Minecraft.getMinecraft().world.getSeaLevel(), ccz);//  Math.abs(chunkX % 16) == centerX && Math.abs(chunkZ % 16) == centerZ;
+    }
+
+    /**
+     * Turns on biome-specific decorations like grass and trees near this feature.
+     */
+    public TFFeature enableDecorations() {
+        this.areChunkDecorationsEnabled = true;
+        return this;
+    }
+
+    /**
+     * Tell the chunkgenerator that we don't have an associated structure.
+     */
+    public TFFeature disableStructure() {
+        this.isStructureEnabled = false;
+        return this;
+    }
+
+    /**
+     * Tell the chunkgenerator that we want the terrain changed nearby.
+     */
+    public TFFeature enableTerrainAlterations() {
+        this.isTerrainAltered = true;
+        return this;
+    }
+
+    public TFFeature disableProtectionAura() {
+        this.hasProtectionAura = false;
+        return this;
+    }
+
+    /**
+     * Add a monster to spawn list 0
+     */
+    public TFFeature addMonster(Class<? extends EntityLiving> monsterClass, int weight, int minGroup, int maxGroup) {
+        this.addMonster(0, monsterClass, weight, minGroup, maxGroup);
+        return this;
+    }
+
+    /**
+     * Add a monster to a specific spawn list
+     */
+    public TFFeature addMonster(int listIndex, Class<? extends EntityLiving> monsterClass, int weight, int minGroup, int maxGroup) {
+        List<SpawnListEntry> monsterList;
+        if (this.spawnableMonsterLists.size() > listIndex) {
+            monsterList = this.spawnableMonsterLists.get(listIndex);
+        } else {
+            monsterList = new ArrayList<SpawnListEntry>();
+            this.spawnableMonsterLists.add(listIndex, monsterList);
+        }
+
+        monsterList.add(new SpawnListEntry(monsterClass, weight, minGroup, maxGroup));
+        return this;
+    }
+
+    /**
+     * Add a water creature
+     */
+    public TFFeature addWaterCreature(Class<? extends EntityLiving> monsterClass, int weight, int minGroup, int maxGroup) {
+        this.waterCreatureList.add(new SpawnListEntry(monsterClass, weight, minGroup, maxGroup));
+        return this;
+    }
+
+    /**
+     * Returns a list of hostile monsters.  Are we ever going to need passive or water creatures?
+     */
+    public List<SpawnListEntry> getSpawnableList(EnumCreatureType par1EnumCreatureType) {
+        if (par1EnumCreatureType == EnumCreatureType.MONSTER) {
+            return this.getSpawnableList(EnumCreatureType.MONSTER, 0);
+        } else if (par1EnumCreatureType == EnumCreatureType.AMBIENT) {
+            return this.ambientCreatureList;
+        } else if (par1EnumCreatureType == EnumCreatureType.WATER_CREATURE) {
+            return this.waterCreatureList;
+        } else {
+            return Lists.newArrayList();
+        }
+    }
+
+    /**
+     * Returns a list of hostile monsters in the specified indexed category
+     */
+    public List<SpawnListEntry> getSpawnableList(EnumCreatureType par1EnumCreatureType, int index) {
+        if (par1EnumCreatureType == EnumCreatureType.MONSTER) {
+            if (index >= 0 && index < this.spawnableMonsterLists.size()) {
+                return this.spawnableMonsterLists.get(index);
+            } else {
+                return Lists.newArrayList();
+            }
+        } else {
+            return getSpawnableList(par1EnumCreatureType);
+        }
+    }
+
+    /**
+     * Try to spawn a hint monster near the specified player
+     */
+    public void trySpawnHintMonster(World world, EntityPlayer player) {
+        this.trySpawnHintMonster(world, player, MathHelper.floor(player.posX), MathHelper.floor(player.posY), MathHelper.floor(player.posZ));
+    }
+
+    /**
+     * Try several times to spawn a hint monster
+     */
+    public void trySpawnHintMonster(World world, EntityPlayer player, int x, int y, int z) {
+        // check if the timer is valid
+        long currentTime = world.getTotalWorldTime();
+
+        // if someone set the time backwards, fix the spawn timer
+        if (currentTime < this.lastSpawnedHintMonsterTime) {
+            this.lastSpawnedHintMonsterTime = 0;
+        }
+
+        if (currentTime - this.lastSpawnedHintMonsterTime > 1200) {
+            // okay, time is good, try several times to spawn one
+            for (int i = 0; i < 20; i++) {
+                if (didSpawnHintMonster(world, player, x, y, z)) {
+                    this.lastSpawnedHintMonsterTime = currentTime;
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Try once to spawn a hint monster near the player.  Return true if we did.
+     * <p>
+     * We could change up the monster depending on what feature this is, but we currently are not doing that
+     */
+    private boolean didSpawnHintMonster(World world, EntityPlayer player, int x, int y, int z) {
+        // find a target point
+        int dx = x + world.rand.nextInt(16) - world.rand.nextInt(16);
+        int dy = y + world.rand.nextInt(4) - world.rand.nextInt(4);
+        int dz = z + world.rand.nextInt(16) - world.rand.nextInt(16);
+
+		/*// make our hint monster
+		EntityTFKobold hinty = new EntityTFKobold(world);
+		hinty.setPosition(dx, dy, dz);
+
+		// check if the bounding box is clear
+		if (hinty.isNotColliding() && hinty.getEntitySenses().canSee(player)) {
+
+			// add items and hint book
+			ItemStack book = this.createHintBook();
+
+			hinty.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, book);
+			hinty.setDropChance(EntityEquipmentSlot.MAINHAND, 1.0F);
+
+			world.spawnEntity(hinty);
+			return true;
+		} else {
+			return false;
+		}*/
+        return false;
+    }
+
+
+    /**
+     * Create a hint book for the specified feature.  Only features with block protection will need this.
+     */
+    public ItemStack createHintBook() {
+        ItemStack book = new ItemStack(Items.WRITTEN_BOOK);
+
+        NBTTagList bookPages = new NBTTagList();
+
+        if (this == TFFeature.lichTower) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.lichtower.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.lichtower.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.lichtower.3"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.lichtower.4"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on a Pointy Tower"));
+        } else if (this == TFFeature.labyrinth) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.labyrinth.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.labyrinth.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.labyrinth.3"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.labyrinth.4"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.labyrinth.5"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on a Swampy Labyrinth"));
+
+        } else if (this == TFFeature.hydraLair) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.hydralair.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.hydralair.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.hydralair.3"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.hydralair.4"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on the Fire Swamp"));
+
+        } else if (this == TFFeature.tfStronghold) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.tfstronghold.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.tfstronghold.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.tfstronghold.3"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.tfstronghold.4"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.tfstronghold.5"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on a Stronghold"));
+
+        } else if (this == TFFeature.darkTower) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.darktower.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.darktower.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.darktower.3"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on a Wooden Tower"));
+
+        } else if (this == TFFeature.yetiCave) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.yeticave.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.yeticave.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.yeticave.3"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.yeticave.4"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on an Icy Cave"));
+
+        } else if (this == TFFeature.iceTower) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.icetower.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.icetower.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.icetower.3"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on Auroral Fortification"));
+
+        } else if (this == TFFeature.trollCave) {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.trollcave.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.trollcave.2"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.trollcave.3"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on an the Highlands"));
+
+        } else {
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.unknown.1"))));
+            bookPages.appendTag(new NBTTagString(ITextComponent.Serializer.componentToJson(new TextComponentTranslation(MOD_ID + ".book.unknown.2"))));
+
+            book.setTagInfo("pages", bookPages);
+            book.setTagInfo("author", new NBTTagString("A Forgotten Explorer"));
+            book.setTagInfo("title", new NBTTagString("Notes on the Unexplained"));
+        }
+
+
+        return book;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/handlers/ConfigHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/ConfigHandler.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/util/handlers/ConfigHandler.java	(date 1525606895000)
@@ -0,0 +1,181 @@
+/*
+ * NetherEx
+ * Copyright (c) 2016-2018 by MineEx
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.Main;
+import net.minecraftforge.common.config.Config;
+import net.minecraftforge.common.config.ConfigManager;
+import net.minecraftforge.fml.client.event.ConfigChangedEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+@Config.LangKey("config." + MOD_ID + ":title")
+@Config(modid = MOD_ID, name = "Neutronia/" + MOD_ID, category = "neutronia")
+public class ConfigHandler {
+
+    @Config.Name("client")
+    @Config.LangKey("config." + MOD_ID + ":client")
+    public static ClientConfig clientConfig = new ClientConfig();
+
+    @Config.Name("compatibility")
+    @Config.LangKey("config." + MOD_ID + ":compatibility")
+    public static CompatibilityConfig compatibilityConfig = new CompatibilityConfig();
+
+    @Config.Name("dimension")
+    @Config.LangKey("config." + MOD_ID + ":dimension")
+    public static DimensionConfig dimensionConfig = new DimensionConfig();
+
+    @Config.Name("block")
+    @Config.LangKey("config." + MOD_ID + ":block")
+    public static BlockConfig blockConfig = new BlockConfig();
+
+    @Config.Name("biome")
+    @Config.LangKey("config." + MOD_ID + ":biome")
+    public static BiomeConfig biomeConfig = new BiomeConfig();
+
+    public static class ClientConfig {
+        @Config.Name("visual")
+        @Config.LangKey("config." + MOD_ID + ":client.visual")
+        public Visual visual = new Visual();
+
+        public class Visual {
+            @Config.LangKey("config." + MOD_ID + ":client.visual.disableNetherFog")
+            public boolean disableNetherFog = true;
+        }
+    }
+
+    public static class CompatibilityConfig {
+        @Config.Name("biomesoplenty")
+        @Config.LangKey("config." + MOD_ID + ":compatibility.biomesoplenty")
+        public BiomesOPlenty biomesOPlenty = new BiomesOPlenty();
+
+        public class BiomesOPlenty {
+            @Config.LangKey("config." + MOD_ID + ":compatibility.biomesoplenty.enableCompat")
+            public boolean enableCompat = true;
+        }
+    }
+
+    public static class DimensionConfig {
+        @Config.Name("nether")
+        @Config.LangKey("config." + MOD_ID + ":dimension.nether")
+        public Nether nether = new Nether();
+
+        public class Nether {
+            @Config.LangKey("config." + MOD_ID + ":dimension.nether.generateSoulSand")
+            public boolean generateSoulSand = false;
+
+            @Config.LangKey("config." + MOD_ID + ":dimension.nether.generateGravel")
+            public boolean generateGravel = false;
+
+            @Config.LangKey("config." + MOD_ID + ":dimension.nether.isLavaInfinite")
+            public boolean isLavaInfinite = false;
+        }
+    }
+
+    public static class BlockConfig {
+        @Config.Name("nether_portal")
+        @Config.LangKey("config." + MOD_ID + ":block.netherPortal")
+        public NetherPortal netherPortal = new NetherPortal();
+
+        @Config.Name("netherrack")
+        @Config.LangKey("config." + MOD_ID + ":block.netherrack")
+        public Netherrack netherrack = new Netherrack();
+
+        @Config.Name("soul_sand")
+        @Config.LangKey("config." + MOD_ID + ":block.soulSand")
+        public SoulSand soulSand = new SoulSand();
+
+        @Config.Name("magma")
+        @Config.LangKey("config." + MOD_ID + ":block.magma")
+        public Magma magma = new Magma();
+
+        public class NetherPortal {
+            @Config.LangKey("config." + MOD_ID + ":block.netherPortal.allowPigmanSpawning")
+            public boolean allowPigmanSpawning = true;
+
+            @Config.RangeInt(min = 4, max = 2048)
+            @Config.LangKey("config." + MOD_ID + ":block.netherPortal.pigmanSpawnRarity")
+            @Config.Comment({"The higher the number, the rarer it is for Pigman to spawn", "The lower the number, the more common it is for Pigman to spawn"})
+            public int pigmanSpawnRarity = 2000;
+        }
+
+        public class Netherrack {
+            @Config.LangKey("config." + MOD_ID + ":block.netherrack.allowAllShovelsToFlatten")
+            public boolean allowAllShovelsToFlatten = false;
+        }
+
+        public class SoulSand {
+            @Config.LangKey("config." + MOD_ID + ":block.soulSand.doesNetherwartUseNewGrowthSystem")
+            public boolean doesNetherwartUseNewGrowthSystem = true;
+
+            @Config.LangKey("config." + MOD_ID + ":block.soulSand.allowAllHoesToTill")
+            public boolean allowAllHoesToTill = false;
+
+            @Config.LangKey("config." + MOD_ID + ":block.soulSand.doesRequireIchor")
+            public boolean doesRequireIchor = true;
+        }
+
+        public class Magma {
+            @Config.LangKey("config." + MOD_ID + ":block.magma.turnIntoLava")
+            public boolean turnIntoLava = false;
+        }
+    }
+
+    public static class BiomeConfig {
+        @Config.Name("hell")
+        @Config.LangKey("config." + MOD_ID + ":biome.hell")
+        public Hell hell = new Hell();
+
+        @Config.Name("soulsand_desert")
+        @Config.LangKey("config." + MOD_ID + ":biome.soulsandDesert")
+        public SoulsandDesert soulsandDesert = new SoulsandDesert();
+
+        @Config.Name("thorny_forest")
+        @Config.LangKey("config." + MOD_ID + ":biome.thornyForest")
+        public ThornyForest thornyForest = new ThornyForest();
+
+        @Config.Name("glowing_mushroom_forest")
+        @Config.LangKey("config." + MOD_ID + ":biome.glowingMushroomForest")
+        public GlowingMushroomForest glowingMushroomForest = new GlowingMushroomForest();
+
+        public class Hell {
+        }
+
+        public class SoulsandDesert {
+        }
+
+        public class ThornyForest {
+        }
+
+        public class GlowingMushroomForest {
+        }
+    }
+
+    @Mod.EventBusSubscriber(modid = MOD_ID)
+    public static class ConfigSyncHandler {
+        @SubscribeEvent
+        public static void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent event) {
+            if (event.getModID().equals(MOD_ID)) {
+                ConfigManager.sync(MOD_ID, Config.Type.INSTANCE);
+                Main.LOGGER.info("Configuration has been saved.");
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockPolishedNetherrackBricksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockPolishedNetherrackBricksStairs.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockPolishedNetherrackBricksStairs.java	(date 1525606884000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.blocks.BlockPolishedNetherrack;
+import net.hdt.neutronia.modules.building.features.PolishedNetherrack;
+
+public class BlockPolishedNetherrackBricksStairs extends BlockOverworldStairBase {
+
+    public BlockPolishedNetherrackBricksStairs() {
+        super("polished_netherrack_bricks_stairs", PolishedNetherrack.polished_netherrack.getDefaultState().withProperty(PolishedNetherrack.polished_netherrack.getVariantProp(), BlockPolishedNetherrack.Variants.POLISHED_NETHERRACK_BRICKS));
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/RandomizedTemplateProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/RandomizedTemplateProcessor.java	(date 1525606872000)
+++ src/main/java/net/hdt/neutronia/world/utils/RandomizedTemplateProcessor.java	(date 1525606872000)
@@ -0,0 +1,52 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.gen.structure.template.ITemplateProcessor;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+
+import java.util.Random;
+
+public abstract class RandomizedTemplateProcessor implements ITemplateProcessor {
+    protected final Random random;
+    private final float integrity;
+
+    public RandomizedTemplateProcessor(BlockPos pos, PlacementSettings settings) {
+        this.integrity = settings.getIntegrity();
+        this.random = settings.getRandom(pos);
+    }
+
+    protected static IBlockState translateState(IBlockState stateIn, Block blockOut, IProperty property) {
+        //noinspection unchecked
+        return blockOut.getDefaultState().withProperty(property, stateIn.getValue(property));
+    }
+
+    protected static IBlockState translateState(IBlockState stateIn, Block blockOut, IProperty p1, IProperty p2, IProperty p3, IProperty p4) {
+        //noinspection unchecked
+        return blockOut.getDefaultState()
+                .withProperty(p1, stateIn.getValue(p1))
+                .withProperty(p2, stateIn.getValue(p2))
+                .withProperty(p3, stateIn.getValue(p3))
+                .withProperty(p4, stateIn.getValue(p4));
+    }
+
+    protected static IBlockState translateState(IBlockState stateIn, Block blockOut, IProperty p1, IProperty p2, IProperty p3, IProperty p4, IProperty p5) {
+        //noinspection unchecked
+        return blockOut.getDefaultState()
+                .withProperty(p1, stateIn.getValue(p1))
+                .withProperty(p2, stateIn.getValue(p2))
+                .withProperty(p3, stateIn.getValue(p3))
+                .withProperty(p4, stateIn.getValue(p4))
+                .withProperty(p5, stateIn.getValue(p5));
+    }
+
+    protected boolean shouldPlaceBlock() {
+        return integrity >= 1.0F || random.nextFloat() > integrity;
+    }
+
+    protected Block randomBlock(Block... blocks) {
+        return blocks[random.nextInt(blocks.length)];
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderWhale.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderWhale.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderWhale.java	(date 1523987836000)
@@ -0,0 +1,27 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityWhale;
+import net.hdt.neutronia.entity.render.model.ModelWhale;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderWhale extends RenderLiving<EntityWhale> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/whale.png");
+
+    public RenderWhale(RenderManager manager) {
+        super(manager, new ModelWhale(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityWhale entity) {
+        return SCORP_TEXTURE;
+    }
+
+    @Override
+    protected void applyRotations(EntityWhale entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/api/world/biome/IBiomeWrapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/api/world/biome/IBiomeWrapper.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/api/world/biome/IBiomeWrapper.java	(date 1525606885000)
@@ -0,0 +1,27 @@
+package net.hdt.neutronia.api.world.biome;
+
+import net.hdt.neutronia.api.world.gen.feature.IFeature;
+import net.hdt.neutronia.world.gen.GenerationStage;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.world.biome.Biome;
+
+import java.util.List;
+
+public interface IBiomeWrapper {
+    Biome getBiome();
+
+    IBlockState getBlock(String key, IBlockState fallbackValue);
+
+    IBlockState getBlock(String key);
+
+    List<IBlockState> getBlocks();
+
+    List<IFeature> getFeatures(GenerationStage generationStage);
+
+    List<Biome.SpawnListEntry> getSpawnableMobs(EnumCreatureType creatureType);
+
+    boolean isEnabled();
+
+    boolean shouldGenDefaultFeatures();
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndStairBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndStairBase.java	(date 1523987842000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndStairBase.java	(date 1523987842000)
@@ -0,0 +1,25 @@
+package net.hdt.neutronia.blocks.end;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.state.IBlockState;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+
+public class BlockEndStairBase extends BlockModStairs {
+
+    public BlockEndStairBase(String name, IBlockState state) {
+        super(name, state);
+        setCreativeTab(Main.END_EXPANSION_TAB);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeSuperDeepOcean.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeSuperDeepOcean.java	(date 1523986169000)
+++ src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeSuperDeepOcean.java	(date 1523986169000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.world.biome.overworld;
+
+import net.minecraft.world.biome.Biome;
+
+public class BiomeSuperDeepOcean extends Biome {
+
+    public BiomeSuperDeepOcean() {
+        super(new Biome.BiomeProperties("Super Deep Ocean").setBaseHeight(-4.0F).setHeightVariation(0.8F).setBaseBiome("ocean"));
+    }
+
+    public Biome.TempCategory getTempCategory() {
+        return Biome.TempCategory.OCEAN;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRuinedRuins.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRuinedRuins.java	(date 1523986178000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRuinedRuins.java	(date 1523986178000)
@@ -0,0 +1,395 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.block.BlockStairs;
+import net.minecraft.block.BlockStoneBrick;
+import net.minecraft.block.BlockStoneBrick.EnumType;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenRuinedRuins extends WorldGenerator {
+
+    public boolean generate(World world, Random random, BlockPos pos) {
+        IBlockState surfaceState = Blocks.DIRT.getDefaultState();
+
+        int chest;
+        for (int newPos = -7; newPos < 5; ++newPos) {
+            if (newPos == -6 || newPos == -5) {
+                world.setBlockState(pos.add(newPos, 0, -6), this.getRandomState(random));
+            }
+
+            if (newPos == -7 || newPos >= -4 && newPos <= 2) {
+                world.setBlockState(pos.add(newPos, 0, -4), this.getRandomState(random));
+            }
+
+            if (newPos >= -4 && newPos <= 3) {
+                world.setBlockState(pos.add(newPos, 0, -3), this.getRandomState(random));
+                world.setBlockState(pos.add(newPos, 0, 4), surfaceState);
+                if (newPos != 3) {
+                    world.setBlockState(pos.add(newPos, 0, 5), surfaceState);
+                }
+            }
+
+            if (newPos == -2) {
+                world.setBlockState(pos.add(newPos, 0, -7), this.getRandomState(random));
+            }
+
+            if (newPos == 4) {
+                world.setBlockState(pos.add(newPos, 0, 6), this.getRandomState(random));
+            }
+
+            if (newPos == 2) {
+                world.setBlockState(pos.add(newPos, 0, 7), this.getRandomState(random));
+            }
+
+            if (newPos >= -5) {
+                for (chest = -2; chest < 4; ++chest) {
+                    world.setBlockState(pos.add(newPos, 0, chest), random.nextInt(10) == 0 ? surfaceState : this.getRandomState(random));
+                }
+            }
+        }
+
+        BlockPos var9 = pos.up();
+
+        for (chest = -5; chest < 8; ++chest) {
+            BlockPos usedLootTable;
+            if (chest == 4 || chest == 5 || chest <= -3) {
+                usedLootTable = var9.add(chest, 0, -2);
+                world.setBlockState(usedLootTable, this.getRandomState(random));
+                if (chest == 5) {
+                    world.setBlockState(var9.add(chest, 0, 7), this.getRandomState(random));
+                }
+
+                if (chest == 4) {
+                    world.setBlockState(var9.add(chest, 0, -1), this.getRandomState(random));
+                    world.setBlockState(var9.add(chest, 0, 0), this.getRandomState(random));
+                    world.setBlockState(var9.add(chest, 0, 1), this.getRandomState(random));
+                    world.setBlockState(var9.add(chest, 0, 2), this.getRandomState(random));
+                }
+
+                if (chest == -3) {
+                    world.setBlockState(usedLootTable, Blocks.STONE_BRICK_STAIRS.getDefaultState());
+                }
+            }
+
+            if (chest >= -4 && chest <= 2) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, -1), Blocks.COBBLESTONE.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, -6), this.getRandomState(random));
+                }
+
+                if (chest == 1) {
+                    world.setBlockState(var9.add(chest, 0, -1), this.getRandomState(random));
+                    world.setBlockState(var9.add(chest, 0, 1), this.getRandomState(random));
+                    world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+                }
+
+                if (chest == 2) {
+                    world.setBlockState(var9.add(chest, 0, -1), Blocks.STONE_BRICK_STAIRS.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 1), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == -5 || chest == -4 || chest == 4) {
+                world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+            }
+
+            if (chest == -4 || chest == -3 || chest == -2 || chest == 4) {
+                usedLootTable = var9.add(chest, 0, -2);
+                world.setBlockState(usedLootTable, this.getRandomState(random));
+                if (chest == -2) {
+                    world.setBlockState(usedLootTable, Blocks.FIRE.getDefaultState());
+                }
+            }
+
+            if (chest >= -3 && chest <= 2 || chest == 5) {
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == -4 || chest == -1 || chest == 2 || chest == 3) {
+                if (chest == -1) {
+                    world.setBlockState(var9.add(chest, 0, -2), Blocks.COBBLESTONE.getDefaultState());
+                }
+
+                world.setBlockState(var9.add(chest, 0, -3), this.getRandomState(random));
+            }
+        }
+
+        var9 = pos.up(2);
+
+        int var10;
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -3 && chest <= 1) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == -4 || chest == -2 || chest == -1 || chest == 3) {
+                if (chest == -4) {
+                    world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -3), random.nextInt(4) == 0 ? this.getRandomState(random) : Blocks.COBBLESTONE.getDefaultState());
+            }
+
+            if (chest == -5) {
+                world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+            }
+
+            if (chest == 2) {
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == 4) {
+                for (var10 = -2; var10 < 3; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+        }
+
+        var9 = pos.up(3);
+
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -3 && chest <= 2) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == -4 || chest == -1 || chest == 1 || chest == 3) {
+                if (chest == -1) {
+                    world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+                }
+
+                if (chest == -4) {
+                    world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -3), random.nextInt(4) == 0 ? this.getRandomState(random) : Blocks.COBBLESTONE.getDefaultState());
+            }
+
+            if (chest == -5) {
+                world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+            }
+
+            if (chest == 4) {
+                for (var10 = -2; var10 < 3; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+        }
+
+        var9 = pos.up(4);
+
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -2 && chest <= 2) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 2), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == -4 || chest == 2 || chest == 3) {
+                if (chest == 3) {
+                    world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                }
+
+                if (chest == -4) {
+                    world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, -3), random.nextInt(4) == 0 ? this.getRandomState(random) : Blocks.COBBLESTONE.getDefaultState());
+            }
+
+            if (chest == -3) {
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == -5) {
+                world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+            }
+
+            if (chest == 4) {
+                for (var10 = -2; var10 < 2; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+        }
+
+        var9 = pos.up(5);
+
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -2 && chest <= 2) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, -1), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                    world.setBlockState(var9.add(chest, 0, 3), Blocks.LOG.getDefaultState());
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest >= -1 && chest <= 2) {
+                world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+            }
+
+            if (chest == -4) {
+                world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+            }
+
+            if (chest == 3) {
+                world.setBlockState(var9.add(chest, 0, -3), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 0), this.getRandomState(random));
+            }
+
+            if (chest == 4) {
+                for (var10 = -2; var10 < 2; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+
+            if (chest == -1 || chest == -2 || chest == -3) {
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == -5) {
+                for (var10 = -2; var10 < 3; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+        }
+
+        var9 = pos.up(6);
+
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -3 && chest <= 2) {
+                if (chest == 0) {
+                    world.setBlockState(var9.add(chest, 0, 1), Blocks.LOG.getDefaultState());
+                }
+
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == -1 || chest == -2 || chest == -3) {
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == -4) {
+                world.setBlockState(var9.add(chest, 0, -3), this.getRandomState(random));
+            }
+
+            if (chest == -4) {
+                world.setBlockState(var9.add(chest, 0, -3), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+            }
+
+            if (chest == 4) {
+                world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, -1), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 1), this.getRandomState(random));
+            }
+
+            if (chest == -5) {
+                for (var10 = -2; var10 < 4; ++var10) {
+                    if (var10 != 0) {
+                        world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                    }
+                }
+            }
+        }
+
+        var9 = pos.up(7);
+
+        for (chest = -5; chest < 5; ++chest) {
+            if (chest >= -3 && chest <= 0) {
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, -3), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 4), this.getRandomState(random));
+            }
+
+            if (chest == 4 || chest == -2 || chest == -3 || chest == -5) {
+                world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, -1), this.getRandomState(random));
+                world.setBlockState(var9.add(chest, 0, 0), this.getRandomState(random));
+            }
+
+            if (chest == -1 || chest == -2 || chest == -3) {
+                world.setBlockState(var9.add(chest, 0, 5), this.getRandomState(random));
+            }
+
+            if (chest == 0 || chest == -1 || chest == -3 || chest == -5) {
+                if (chest == -1) {
+                    world.setBlockState(var9.add(chest, 0, -2), this.getRandomState(random));
+                }
+
+                if (chest == -5) {
+                    world.setBlockState(var9.add(chest, 0, 1), this.getRandomState(random));
+                }
+
+                world.setBlockState(var9.add(chest, 0, 3), this.getRandomState(random));
+            }
+
+            if (chest == 2 || chest == 1) {
+                world.setBlockState(var9.add(chest, 0, -4), this.getRandomState(random));
+            }
+
+            if (chest == -4) {
+                for (var10 = -3; var10 < 5; ++var10) {
+                    world.setBlockState(var9.add(chest, 0, var10), this.getRandomState(random));
+                }
+            }
+        }
+
+        var9 = pos.up(8);
+        world.setBlockState(var9.add(4, 0, -1), this.getRandomState(random));
+        world.setBlockState(var9.add(-2, 0, 5), this.getRandomState(random));
+        world.setBlockState(var9.add(-3, 0, -4), this.getRandomState(random));
+        world.setBlockState(var9.add(-4, 0, -3), this.getRandomState(random));
+        world.setBlockState(var9.add(-4, 0, -2), Blocks.CHEST.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.EAST));
+        TileEntityChest var11 = (TileEntityChest) world.getTileEntity(var9.add(-4, 0, -2));
+
+        world.setBlockState(var9.add(-4, 0, 4), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -2), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -1), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, 0), this.getRandomState(random));
+        var9 = pos.up(9);
+        world.setBlockState(var9.add(-3, 0, -4), this.getRandomState(random));
+        world.setBlockState(var9.add(-4, 0, -3), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -2), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -1), this.getRandomState(random));
+        var9 = pos.up(10);
+        world.setBlockState(var9.add(-4, 0, -3), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -2), this.getRandomState(random));
+        var9 = pos.up(11);
+        world.setBlockState(var9.add(-4, 0, -3), this.getRandomState(random));
+        world.setBlockState(var9.add(-5, 0, -2), this.getRandomState(random));
+        return false;
+    }
+
+    private IBlockState getRandomState(Random random) {
+        IBlockState block = Blocks.STONEBRICK.getDefaultState();
+        return random.nextInt(5) == 0 ? block.withProperty(BlockStoneBrick.VARIANT, EnumType.CRACKED) : block;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityCod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityCod.java	(date 1523986197000)
+++ src/main/java/net/hdt/neutronia/entity/EntityCod.java	(date 1523986197000)
@@ -0,0 +1,242 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.MoverType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBase;
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+
+public class EntityCod extends EntityWaterMob {
+
+    public float squidPitch;
+    public float prevSquidPitch;
+    public float squidYaw;
+    public float prevSquidYaw;
+    /**
+     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
+     */
+    public float squidRotation;
+    /**
+     * previous squidRotation in radians
+     */
+    public float prevSquidRotation;
+    /**
+     * angle of the tentacles in radians
+     */
+    public float tentacleAngle;
+    /**
+     * the last calculated angle of the tentacles in radians
+     */
+    public float lastTentacleAngle;
+    private float randomMotionSpeed;
+    /**
+     * change in squidRotation in radians.
+     */
+    private float rotationVelocity;
+    private float rotateSpeed;
+    private float randomMotionVecX;
+    private float randomMotionVecY;
+    private float randomMotionVecZ;
+
+    public EntityCod(World worldIn) {
+        super(worldIn);
+        this.setSize(0.5F, 0.3F);
+        this.rand.setSeed((long) (1 + this.getEntityId()));
+        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityCod.AIMoveRandom(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
+    }
+
+    public float getEyeHeight() {
+        return this.height;
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SQUID_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SQUID_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SQUID_DEATH;
+    }
+
+    /**
+     * Returns the volume for the sounds this mob makes.
+     */
+    protected float getSoundVolume() {
+        return 0.4F;
+    }
+
+    /**
+     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
+     * prevent them from trampling crops
+     */
+    protected boolean canTriggerWalking() {
+        return false;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_SQUID;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+        this.prevSquidPitch = this.squidPitch;
+        this.prevSquidYaw = this.squidYaw;
+        this.prevSquidRotation = this.squidRotation;
+        this.lastTentacleAngle = this.tentacleAngle;
+        this.squidRotation += this.rotationVelocity;
+
+        if ((double) this.squidRotation > (Math.PI * 2D)) {
+            if (this.world.isRemote) {
+                this.squidRotation = ((float) Math.PI * 2F);
+            } else {
+                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
+
+                if (this.rand.nextInt(10) == 0) {
+                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+                }
+
+                this.world.setEntityState(this, (byte) 19);
+            }
+        }
+
+        if (this.inWater) {
+            if (this.squidRotation < (float) Math.PI) {
+                float f = this.squidRotation / (float) Math.PI;
+                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
+
+                if ((double) f > 0.75D) {
+                    this.randomMotionSpeed = 1.0F;
+                    this.rotateSpeed = 1.0F;
+                } else {
+                    this.rotateSpeed *= 0.8F;
+                }
+            } else {
+                this.tentacleAngle = 0.0F;
+                this.randomMotionSpeed *= 0.9F;
+                this.rotateSpeed *= 0.99F;
+            }
+
+            if (!this.world.isRemote) {
+                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
+                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
+                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
+            }
+
+            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
+            this.rotationYaw = this.renderYawOffset;
+            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
+            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
+        } else {
+            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
+
+            if (!this.world.isRemote) {
+                this.motionX = 0.0D;
+                this.motionZ = 0.0D;
+
+                if (this.isPotionActive(MobEffects.LEVITATION)) {
+                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
+                } else if (!this.hasNoGravity()) {
+                    this.motionY -= 0.08D;
+                }
+
+                this.motionY *= 0.9800000190734863D;
+            }
+
+            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
+        }
+    }
+
+    public void travel(float strafe, float vertical, float forward) {
+        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+    }
+
+    /**
+     * Checks if the entity's current position is a valid location to spawn this entity.
+     */
+    public boolean getCanSpawnHere() {
+        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
+    }
+
+    /**
+     * Handler for {@link World#setEntityState}
+     */
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 19) {
+            this.squidRotation = 0.0F;
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
+        this.randomMotionVecX = randomMotionVecXIn;
+        this.randomMotionVecY = randomMotionVecYIn;
+        this.randomMotionVecZ = randomMotionVecZIn;
+    }
+
+    public boolean hasMovementVector() {
+        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
+    }
+
+    static class AIMoveRandom extends EntityAIBase {
+        private final EntityCod squid;
+
+        public AIMoveRandom(EntityCod p_i45859_1_) {
+            this.squid = p_i45859_1_;
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            return true;
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            int i = this.squid.getIdleTime();
+
+            if (i > 100) {
+                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
+            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
+                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
+                float f1 = MathHelper.cos(f) * 0.2F;
+                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
+                float f3 = MathHelper.sin(f) * 0.2F;
+                this.squid.setMovementVector(f1, f2, f3);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenSurvivalTent.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenSurvivalTent.java	(date 1523986183000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenSurvivalTent.java	(date 1523986183000)
@@ -0,0 +1,106 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenSurvivalTent extends WorldGenerator {
+    public boolean generate(World world, Random random, BlockPos position) {
+        position = position.down();
+
+        int chest;
+        for (chest = -3; chest < 3; ++chest) {
+            world.setBlockState(position.add(-2, 0, chest), Blocks.DIRT.getDefaultState());
+        }
+
+        for (chest = -3; chest < 0; ++chest) {
+            world.setBlockState(position.add(-1, 0, chest), Blocks.DIRT.getDefaultState());
+        }
+
+        world.setBlockState(position.west(1), Blocks.CHEST.getDefaultState());
+
+        int zCoord;
+
+
+        world.setBlockState(position.add(-1, 0, 1), Blocks.DIRT.getDefaultState());
+        world.setBlockState(position.add(-1, 0, 2), Blocks.DIRT.getDefaultState());
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(0, 0, zCoord), Blocks.DIRT.getDefaultState());
+            if (zCoord == -1 || zCoord == 0 || zCoord == 1) {
+                world.setBlockState(position.add(0, 0, zCoord), Blocks.PLANKS.getDefaultState());
+                if (zCoord == 0) {
+                    world.setBlockState(position.add(0, -1, zCoord), Blocks.TNT.getDefaultState());
+                }
+            }
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(1, 0, zCoord), Blocks.DIRT.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(2, 0, zCoord), Blocks.DIRT.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(-2, 1, zCoord), Blocks.WOOL.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(-1, 1, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(0, 1, zCoord), Blocks.AIR.getDefaultState());
+            if (zCoord == 0) {
+                world.setBlockState(position.add(0, 1, zCoord), Blocks.WOODEN_PRESSURE_PLATE.getDefaultState());
+            }
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(1, 1, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(2, 1, zCoord), Blocks.WOOL.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(-2, 2, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(-1, 2, zCoord), Blocks.WOOL.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(0, 2, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(1, 2, zCoord), Blocks.WOOL.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(2, 2, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(-1, 3, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(0, 3, zCoord), Blocks.WOOL.getDefaultState());
+        }
+
+        for (zCoord = -3; zCoord < 3; ++zCoord) {
+            world.setBlockState(position.add(1, 3, zCoord), Blocks.AIR.getDefaultState());
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockHardenedClayTilesStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockHardenedClayTilesStairs.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockHardenedClayTilesStairs.java	(date 1525606881000)
@@ -0,0 +1,22 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 18:05:24 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.HardenedClayTiles;
+
+public class BlockHardenedClayTilesStairs extends BlockOverworldStairBase {
+
+    public BlockHardenedClayTilesStairs() {
+        super("hardened_clay_tiles_stairs", HardenedClayTiles.hardened_clay_tiles.getDefaultState());
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockWaterPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockWaterPlantBase.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockWaterPlantBase.java	(date 1525606887000)
@@ -0,0 +1,140 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+import static net.minecraft.block.BlockLiquid.LEVEL;
+
+public class BlockWaterPlantBase extends BlockModBush {
+
+    private static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
+
+    public BlockWaterPlantBase(String name) {
+        super(Material.WATER, name, Reference.MOD_ID);
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEVEL};
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        switch (face) {
+            case DOWN:
+                return false;
+            case UP:
+                return isWater(world, pos.add(0, 1, 0));
+            case NORTH:
+                return isWater(world, pos.add(0, 0, -1));
+            case SOUTH:
+                return isWater(world, pos.add(0, 0, 1));
+            case EAST:
+                return isWater(world, pos.add(1, 0, 0));
+            case WEST:
+                return isWater(world, pos.add(-1, 0, 0));
+        }
+        return false;
+    }
+
+    private boolean isWater(IBlockAccess world, BlockPos pos) {
+        return world.getBlockState(pos).getMaterial() == Material.WATER;
+    }
+
+    @Override
+    public boolean isTranslucent(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand) {
+        IBlockState state = super.getStateForPlacement(world, pos, facing, hitX, hitY, hitZ, meta, placer, hand);
+        return state.withProperty(FACING, placer.getHorizontalFacing());
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(FACING, EnumFacing.getHorizontal(meta));
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING, LEVEL);
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canBlockStay(IBlockAccess worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        Block ground = worldIn.getBlockState(pos.add(0, -1, 0)).getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL && worldIn.getBlockState(pos.add(0, 2, 0)).getBlock() != Blocks.AIR;
+    }
+
+    public boolean isReplaceable(IBlockAccess access, BlockPos pos) {
+        return access.getBlockState(pos).getBlock() == Blocks.WATER && canBlockStay(access, pos, getDefaultState()) && access.getBlockState(pos.add(0, 1, 0)).getBlock() != Blocks.AIR;
+    }
+
+    protected boolean canSustainBush(IBlockState state) {
+        Block ground = state.getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL;
+    }
+
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        checkAndDropBlock(worldIn, pos, state);
+        super.onBlockAdded(worldIn, pos, state);
+    }
+
+    public boolean isReplaceable(World worldIn, BlockPos pos) {
+        return false;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/ItemChestBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemChestBlock.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/items/ItemChestBlock.java	(date 1525606879000)
@@ -0,0 +1,56 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.blocks.overworld.BlockCustomChest;
+import net.hdt.neutronia.properties.ChestType;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.ItemStack;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+
+public class ItemChestBlock extends ItemModBlock {
+
+    private BlockCustomChest block;
+
+    public ItemChestBlock(BlockCustomChest block, ResourceLocation res) {
+        super(block, res);
+        this.block = block;
+    }
+
+    @Override
+    public boolean placeBlockAt(ItemStack stack, EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, IBlockState newState) {
+        int typeCnt = 0;
+
+        BlockPos posN = pos.north();
+        BlockPos posS = pos.south();
+        BlockPos posW = pos.west();
+        BlockPos posE = pos.east();
+
+        ChestType myType = block.getCustomType(stack);
+
+        if (world.getBlockState(posN).getBlock() == block && block.getCustomType(world, posN) == myType)
+            typeCnt += block.isDoubleChest(world, posN, myType) ? 2 : 1;
+        if (world.getBlockState(posS).getBlock() == block && block.getCustomType(world, posS) == myType)
+            typeCnt += block.isDoubleChest(world, posS, myType) ? 2 : 1;
+        if (world.getBlockState(posW).getBlock() == block && block.getCustomType(world, posW) == myType)
+            typeCnt += block.isDoubleChest(world, posW, myType) ? 2 : 1;
+        if (world.getBlockState(posE).getBlock() == block && block.getCustomType(world, posE) == myType)
+            typeCnt += block.isDoubleChest(world, posE, myType) ? 2 : 1;
+
+        if (typeCnt <= 1 && super.placeBlockAt(stack, player, world, pos, side, hitX, hitY, hitZ, newState)) {
+            TileEntity te = world.getTileEntity(pos);
+            if (te instanceof TileCustomChest) {
+                ((TileCustomChest) te).chestType = myType;
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredVase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredVase.java	(date 1523987840000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredVase.java	(date 1523987840000)
@@ -0,0 +1,137 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockFlowerPot;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.client.renderer.color.IBlockColor;
+import net.minecraft.client.renderer.color.IItemColor;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IBlockColorProvider;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import java.util.Random;
+
+public class BlockColoredVase extends BlockFlowerPot implements IModBlock, IBlockColorProvider, IRecipeGrouped {
+
+    private final String[] variants;
+    private final String bareName;
+
+    public BlockColoredVase(EnumDyeColor color) {
+        String name = color.getName() + "_colored_vase";
+        variants = new String[]{name};
+        bareName = name;
+
+        setHardness(0.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+
+        setUnlocalizedName(name);
+    }
+
+    @Override
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(new ItemModBlock(this, new ResourceLocation(getPrefix(), name)));
+        return this;
+    }
+
+    @Override
+    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
+        ItemStack stack = super.getItem(worldIn, pos, state);
+        if (stack.getItem() == Items.FLOWER_POT)
+            stack = new ItemStack(Item.getItemFromBlock(this));
+
+        return stack;
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    @Override
+    public String getLocalizedName() {
+        return I18n.translateToLocal(getUnlocalizedName() + ".name");
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEGACY_DATA};
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IItemColor getItemColor() {
+        return (stack, i) -> 0xFFFFFF;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IBlockColor getBlockColor() {
+        return (state, world, pos, i) -> Minecraft.getMinecraft().getBlockColors().colorMultiplier(Blocks.FLOWER_POT.getDefaultState(), world, pos, i);
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "colored_vase";
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureFluid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureFluid.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureFluid.java	(date 1525606896000)
@@ -0,0 +1,86 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public class FeatureFluid extends Feature {
+    private IBlockState blockToSpawn;
+    private IBlockState blockToTarget;
+    private boolean hidden;
+
+    public FeatureFluid(IConfig config) {
+        super(config);
+        blockToSpawn = config.getBlock("blockToSpawn", Blocks.BARRIER.getDefaultState());
+        blockToTarget = config.getBlock("blockToTarget", Blocks.BARRIER.getDefaultState());
+        hidden = config.getBoolean("hidden", true);
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (blockToSpawn.getBlock() == Blocks.BARRIER || blockToTarget.getBlock() == Blocks.BARRIER) {
+            return false;
+        }
+
+        if (world.getBlockState(pos.up()) != blockToTarget) {
+            return false;
+        } else if (!world.isAirBlock(pos) && world.getBlockState(pos) != blockToTarget) {
+            return false;
+        } else {
+            int i = 0;
+
+            if (world.getBlockState(pos.west()) == blockToTarget) {
+                i++;
+            }
+
+            if (world.getBlockState(pos.east()) == blockToTarget) {
+                i++;
+            }
+
+            if (world.getBlockState(pos.north()) == blockToTarget) {
+                i++;
+            }
+
+            if (world.getBlockState(pos.south()) == blockToTarget) {
+                i++;
+            }
+
+            if (world.getBlockState(pos.down()) == blockToTarget) {
+                i++;
+            }
+
+            int j = 0;
+
+            if (world.isAirBlock(pos.west())) {
+                j++;
+            }
+
+            if (world.isAirBlock(pos.east())) {
+                j++;
+            }
+
+            if (world.isAirBlock(pos.north())) {
+                j++;
+            }
+
+            if (world.isAirBlock(pos.south())) {
+                j++;
+            }
+
+            if (world.isAirBlock(pos.down())) {
+                j++;
+            }
+
+            if (!hidden && i == 4 && j == 1 || i == 5) {
+                world.setBlockState(pos, blockToSpawn, 2);
+                world.immediateBlockTick(pos, blockToSpawn, rand);
+            }
+
+            return true;
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockCharredNetherBrickStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockCharredNetherBrickStairs.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockCharredNetherBrickStairs.java	(date 1525606884000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherStairBase;
+import net.hdt.neutronia.modules.building.features.CharredNetherBricks;
+
+public class BlockCharredNetherBrickStairs extends BlockNetherStairBase {
+
+    public BlockCharredNetherBrickStairs() {
+        super("charred_nether_brick_stairs", CharredNetherBricks.charred_nether_bricks.getDefaultState());
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/items/ItemFishFood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemFishFood.java	(date 1525307439000)
+++ src/main/java/net/hdt/neutronia/items/ItemFishFood.java	(date 1525307439000)
@@ -0,0 +1,46 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.properties.FishType;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.MobEffects;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.world.World;
+
+public class ItemFishFood extends ItemFood {
+    /**
+     * Indicates whether this fish is "cooked" or not.
+     */
+    private final boolean cooked;
+    private FishType fishType;
+
+    public ItemFishFood(String name, CreativeTabs creativeTabs, FishType fishType, boolean cooked) {
+        super(name + fishType.getName(), creativeTabs, 0, 0.0F, false);
+        this.cooked = cooked;
+        this.fishType = fishType;
+    }
+
+    public int getHealAmount(ItemStack stack) {
+        fishType = FishType.byItemStack(stack);
+        return this.cooked && fishType.canCook() ? fishType.getCookedHealAmount() : fishType.getUncookedHealAmount();
+    }
+
+    public float getSaturationModifier(ItemStack stack) {
+        fishType = FishType.byItemStack(stack);
+        return this.cooked && fishType.canCook() ? fishType.getCookedSaturationModifier() : fishType.getUncookedSaturationModifier();
+    }
+
+    protected void onFoodEaten(ItemStack stack, World worldIn, EntityPlayer player) {
+        fishType = FishType.byItemStack(stack);
+
+        if (fishType == FishType.PUFFERFISH) {
+            player.addPotionEffect(new PotionEffect(MobEffects.POISON, 1200, 3));
+            player.addPotionEffect(new PotionEffect(MobEffects.HUNGER, 300, 2));
+            player.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 300, 1));
+        }
+
+        super.onFoodEaten(stack, worldIn, player);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/PolishedNetherrack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/PolishedNetherrack.java	(date 1525606888000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/PolishedNetherrack.java	(date 1525606888000)
@@ -0,0 +1,49 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockPolishedNetherrack;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockPolishedNetherrackBricksSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockPolishedNetherrackBricksStairs;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class PolishedNetherrack extends Feature {
+
+    public static BlockMod polished_netherrack;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        polished_netherrack = new BlockPolishedNetherrack();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(polished_netherrack, 1, new BlockPolishedNetherrackBricksStairs());
+            BlockModSlab.initSlab(polished_netherrack, 1, new BlockPolishedNetherrackBricksSlab(false), new BlockPolishedNetherrackBricksSlab(true));
+        }
+        VanillaWalls.add("polished_netherrack_bricks", polished_netherrack, 1, enableWalls);
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(polished_netherrack),
+				"RR", "RR",
+				'R', ProxyRegistry.newStack(Blocks.NETHERRACK));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(polished_netherrack, 4, 1),
+				"RR", "RR",
+				'R', ProxyRegistry.newStack(polished_netherrack));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockVoidSandstone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockVoidSandstone.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockVoidSandstone.java	(date 1524853001000)
@@ -0,0 +1,79 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockVoidSandstone extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockVoidSandstone()
+    {
+        super("void_sandstone", Material.ROCK);
+        setHardness(0.8F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        SMOOTH,
+        CHISELED;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/modules/building/features/PolishedStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/PolishedStone.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/PolishedStone.java	(date 1525606880000)
@@ -0,0 +1,46 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/03/2016, 18:22:12 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockPolishedStone;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.oredict.OreDictionary;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+
+public class PolishedStone extends Feature {
+
+    public static Block polished_stone;
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        polished_stone = new BlockPolishedStone();
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(polished_stone, 2),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(Blocks.STONE_SLAB));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(Blocks.STONE_SLAB, 6),
+				"SSS",
+				'S', ProxyRegistry.newStack(polished_stone));*/
+    }
+
+    @Override
+    public void init(FMLInitializationEvent event) {
+        OreDictionary.registerOre("stonePolished", polished_stone);
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedClayTilesStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedClayTilesStairs.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedClayTilesStairs.java	(date 1525606883000)
@@ -0,0 +1,29 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 18:32:01 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedClayTiles;
+import net.hdt.neutronia.modules.building.features.HardenedClayTiles;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedClayTilesStairs extends BlockOverworldStairBase implements IRecipeGrouped {
+
+    public BlockStainedClayTilesStairs(BlockStainedClayTiles.Variants variant) {
+        super(variant.getName() + "_stairs", HardenedClayTiles.stained_clay_tiles.getDefaultState().withProperty(HardenedClayTiles.stained_clay_tiles.getVariantProp(), variant));
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_clay_tiles_stairs";
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityShadowPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityShadowPhantom.java	(date 1523986180000)
+++ src/main/java/net/hdt/neutronia/entity/EntityShadowPhantom.java	(date 1523986180000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.world.World;
+
+public class EntityShadowPhantom extends EntityLiving {
+
+    public EntityShadowPhantom(World worldIn) {
+        super(worldIn);
+        this.setHealth(this.getMaxHealth());
+        setSize(0.5F, 0.5F);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockLogEndEx.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockLogEndEx.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockLogEndEx.java	(date 1524853001000)
@@ -0,0 +1,112 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+
+public abstract class BlockLogEndEx extends BlockEndEx
+{
+    public static final PropertyEnum<EnumAxis> AXIS = PropertyEnum.create("axis", EnumAxis.class);
+
+    public BlockLogEndEx(String name, Material material)
+    {
+        super(name, material);
+    }
+
+    @Override
+    public boolean canSustainLeaves(IBlockState state, IBlockAccess world, BlockPos pos)
+    {
+        return true;
+    }
+
+    @Override
+    public boolean isWood(IBlockAccess world, BlockPos pos)
+    {
+        return true;
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand)
+    {
+        return getStateFromMeta(meta).withProperty(AXIS, EnumAxis.fromAxis(facing.getAxis()));
+    }
+
+    @Override
+    public void breakBlock(World worldIn, BlockPos pos, IBlockState state)
+    {
+        if(worldIn.isAreaLoaded(pos.add(-5, -5, -5), pos.add(5, 5, 5)))
+        {
+            for(BlockPos blockpos : BlockPos.getAllInBox(pos.add(-4, -4, -4), pos.add(4, 4, 4)))
+            {
+                IBlockState iblockstate = worldIn.getBlockState(blockpos);
+
+                if(iblockstate.getBlock().isLeaves(iblockstate, worldIn, blockpos))
+                {
+                    iblockstate.getBlock().beginLeavesDecay(iblockstate, worldIn, blockpos);
+                }
+            }
+        }
+    }
+
+    @Override
+    public IBlockState withRotation(IBlockState state, Rotation rot)
+    {
+        switch(rot)
+        {
+            case COUNTERCLOCKWISE_90:
+            case CLOCKWISE_90:
+
+                switch(state.getValue(AXIS))
+                {
+                    case X:
+                        return state.withProperty(AXIS, EnumAxis.Z);
+                    case Z:
+                        return state.withProperty(AXIS, EnumAxis.X);
+                    default:
+                        return state;
+                }
+
+            default:
+                return state;
+        }
+    }
+
+    public enum EnumAxis implements IStringSerializable
+    {
+        X,
+        Y,
+        Z,
+        NONE;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumAxis fromAxis(EnumFacing.Axis axis)
+        {
+            switch(axis)
+            {
+                case X:
+                    return X;
+                case Y:
+                    return Y;
+                case Z:
+                    return Z;
+                default:
+                    return NONE;
+            }
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/properties/EnumBasaltTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumBasaltTypes.java	(date 1523986186000)
+++ src/main/java/net/hdt/neutronia/properties/EnumBasaltTypes.java	(date 1523986186000)
@@ -0,0 +1,54 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumBasaltTypes implements IStringSerializable {
+
+    PAVER(1, "paver"),
+    BRICK_SMALL(4, "brick_small"),
+    TILE(5, "tile"),
+    PILLAR(6, "pillar"),
+    ARCH(7, "arch"),
+    ENGRAVED(8, "engraved"),
+    RUNED(9, "runed"),
+    PILLAR_TOP(10, "pillar_top"),
+    PILLAR_BOTTOM(11, "pillar_bottom"),
+    PILLAR_MIDDLE(12, "pillar_middle"),
+    BRICKS_CRACKED(14, "bricks_cracked"),
+    CRACKED_LAVA(15, "cracked_lava");
+
+    private static final EnumBasaltTypes[] METADATA_LOOKUP = new EnumBasaltTypes[values().length];
+
+    static {
+        for (EnumBasaltTypes type : values()) {
+            METADATA_LOOKUP[type.getMetadata()] = type;
+        }
+    }
+
+    private final int metadata;
+    private final String name;
+
+    EnumBasaltTypes(int metadata, String name) {
+
+        this.metadata = metadata;
+        this.name = name;
+    }
+
+    public static EnumBasaltTypes byMetadata(int metadata) {
+
+        if (metadata < 0 || metadata >= METADATA_LOOKUP.length) {
+            metadata = 0;
+        }
+        return METADATA_LOOKUP[metadata];
+    }
+
+    public int getMetadata() {
+        return this.metadata;
+    }
+
+    @Override
+    public String getName() {
+
+        return this.name;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/handlers/RenderHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/RenderHandler.java	(date 1525364886000)
+++ src/main/java/net/hdt/neutronia/util/handlers/RenderHandler.java	(date 1525364886000)
@@ -0,0 +1,26 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.entity.*;
+import net.hdt.neutronia.entity.render.*;
+import net.minecraftforge.fml.client.registry.RenderingRegistry;
+
+public class RenderHandler {
+
+    public static void registerEntityRenders() {
+        RenderingRegistry.registerEntityRenderingHandler(EntityMummy.class, RenderMummy::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityMummyVillager.class, RenderMummyVillager::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityScorp.class, RenderScorp::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityDrowned.class, RenderDrowned::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityCod.class, RenderCod::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityPhantom.class, RenderPhantom::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityRedPhantom.class, RenderRedPhantom::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityEnderPhantom.class, RenderEnderPhantom::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityShadowPhantom.class, RenderShadowPhantom::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntitySeaTurtle.class, RenderSeaTurtle::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityWhale.class, RenderWhale::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityHoveringInferno.class, RenderHoveringInferno::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityAnchored.class, RenderAnchored::new);
+        RenderingRegistry.registerEntityRenderingHandler(EntityLostMiner.class, RenderLostMiner::new);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumTallNetherPlantTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumTallNetherPlantTypes.java	(date 1524944097000)
+++ src/main/java/net/hdt/neutronia/properties/EnumTallNetherPlantTypes.java	(date 1524944097000)
@@ -0,0 +1,27 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumTallNetherPlantTypes implements IStringSerializable {
+
+    TALL_GRASS(0, "tall_nether_grass"),
+    TALL_NETHER_MUSHROOM(1, "tall_nether_mushroom");
+
+    private String name;
+    private int ID;
+
+    EnumTallNetherPlantTypes(int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockCrackedEndStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockCrackedEndStoneBricks.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockCrackedEndStoneBricks.java	(date 1524853001000)
@@ -0,0 +1,82 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockCrackedEndStoneBricks extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockCrackedEndStoneBricks()
+    {
+        super("end_stone_bricks_cracked", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_black_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/limestone_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/limestone_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/limestone_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/limestone_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/raw_natural_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_natural_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/raw_natural_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_natural_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/MoreSandstone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/MoreSandstone.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/MoreSandstone.java	(date 1525606886000)
@@ -0,0 +1,97 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [06/06/2016, 23:08:40 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockNewSandstone;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockVanillaSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockVanillaStairs;
+import net.minecraft.block.state.IBlockState;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+import net.thegaminghuskymc.huskylib2.module.ModuleLoader;
+
+public class MoreSandstone extends Feature {
+
+    public static BlockMod sandstone_new;
+
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        sandstone_new = new BlockNewSandstone();
+		
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 8, 0),
+				"SSS", "S S", "SSS",
+				'S', ProxyRegistry.newStack(Blocks.SANDSTONE));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 4, 1),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(sandstone_new, 1, 0));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 8, 2),
+				"SSS", "S S", "SSS",
+				'S', ProxyRegistry.newStack(Blocks.RED_SANDSTONE));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 4, 3),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(sandstone_new, 1, 2));*/
+
+        if (enableStairsAndSlabs) {
+            boolean soulSandstone = ModuleLoader.isFeatureEnabled(SoulSandstone.class);
+
+            for (BlockNewSandstone.Variants variant : BlockNewSandstone.Variants.class.getEnumConstants()) {
+                if (!variant.stairs)
+                    continue;
+                if (variant.ordinal() > 3 && !soulSandstone)
+                    break;
+
+                IBlockState state = sandstone_new.getDefaultState().withProperty(sandstone_new.getVariantProp(), variant);
+                String name = variant.getName() + "_stairs";
+                BlockModStairs.initStairs(sandstone_new, variant.ordinal(), new BlockVanillaStairs(name, state));
+            }
+
+            for (BlockNewSandstone.Variants variant : BlockNewSandstone.Variants.class.getEnumConstants()) {
+                if (!variant.slabs)
+                    continue;
+                if (variant.ordinal() > 3 && !soulSandstone)
+                    break;
+
+                IBlockState state = sandstone_new.getDefaultState().withProperty(sandstone_new.getVariantProp(), variant);
+                String name = variant.getName() + "_slab";
+                BlockModSlab.initSlab(sandstone_new, variant.ordinal(), new BlockVanillaSlab(name, state, false), new BlockVanillaSlab(name, state, true));
+            }
+        }
+    }
+
+    @Override
+    public void postPreInit(FMLPreInitializationEvent event) {
+		/*if(ModuleLoader.isFeatureEnabled(SoulSandstone.class)) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 8, 4),
+					"SSS", "S S", "SSS",
+					'S', ProxyRegistry.newStack(SoulSandstone.soul_sandstone));
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sandstone_new, 4, 5),
+					"SS", "SS",
+					'S', ProxyRegistry.newStack(sandstone_new, 1, 4));
+		}*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/chiseled_basalt.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/chiseled_basalt.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/chiseled_basalt.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/chiseled_basalt"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/ZedUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/ZedUtil.java	(date 1523986195000)
+++ src/main/java/net/hdt/neutronia/world/ZedUtil.java	(date 1523986195000)
@@ -0,0 +1,159 @@
+// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
+// Jad home page: http://www.kpdus.com/jad.html
+// Decompiler options: packimports(3) 
+// Source File Name:   ZedUtil.java
+
+package net.hdt.neutronia.world;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonIOException;
+import com.google.gson.stream.JsonReader;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Vec3d;
+
+import javax.vecmath.Vector3d;
+import java.io.*;
+
+public final class ZedUtil {
+
+    public ZedUtil() {
+    }
+
+    public static Vector3d AddVect(Vector3d v1, Vector3d v2) {
+        Vector3d v = new Vector3d(v1);
+        v.add(v2);
+        return v;
+    }
+
+    public static Vector3d BlockPosVector3d(BlockPos bp) {
+        return new Vector3d(bp.getX(), bp.getY(), bp.getZ());
+    }
+
+    public static Vec3d AddVect(Vec3d v1, Vec3d v2) {
+        Vec3d v = new Vec3d(v1.x, v1.y, v1.z);
+        return v.add(v2);
+    }
+
+    public static Vector3d Vec3dVector3d(Vec3d v1) {
+        return new Vector3d(v1.x, v1.y, v1.z);
+    }
+
+    public static Vec3d Vector3dVec3d(Vector3d v1) {
+        return new Vec3d(v1.x, v1.y, v1.z);
+    }
+
+    public static Vector3d SubVect(Vector3d v1, Vector3d v2) {
+        Vector3d v = new Vector3d(v1);
+        v.sub(v2);
+        return v;
+    }
+
+    public static Vec3d SubVect(Vec3d v1, Vec3d v2) {
+        Vec3d v = new Vec3d(v1.x, v1.y, v1.z);
+        return v.subtract(v2);
+    }
+
+    public static Vector3d MultVect(Vector3d v1, float mult) {
+        Vector3d v = new Vector3d(v1);
+        v.scale(mult);
+        return v;
+    }
+
+    public static Vec3d MultVect(Vec3d v1, float mult) {
+        Vec3d v = new Vec3d(v1.x, v1.y, v1.z);
+        return v.scale(mult);
+    }
+
+    public static BlockPos newBlPos(Vector3d v1) {
+        BlockPos nbp = new BlockPos(v1.x, v1.y, v1.z);
+        return nbp;
+    }
+
+    public static BlockPos newBlPos(Vec3d v1) {
+        BlockPos nbp = new BlockPos(v1.x, v1.y, v1.z);
+        return nbp;
+    }
+
+    public static float VectorDist(Vector3d v1, Vector3d v2) {
+        return (float) SubVect(v2, v1).length();
+    }
+
+    public static float VectorDistSqr(Vector3d v1, Vector3d v2) {
+        return (float) SubVect(v2, v1).lengthSquared();
+    }
+
+    public static BlockArray loadFromFile(String path) {
+        BlockArray BA;
+        try {
+            FileInputStream fileIn = new FileInputStream(path);
+            ObjectInputStream in = new ObjectInputStream(fileIn);
+            BA = (BlockArray) in.readObject();
+            in.close();
+            fileIn.close();
+            System.out.println("Serialized data is loaded");
+            BA.LoadFromSave();
+            return BA;
+        } catch (IOException i) {
+            i.printStackTrace();
+        } catch (ClassNotFoundException c) {
+            System.out.println("BlockArrayClass not found");
+            c.printStackTrace();
+        }
+        return null;
+    }
+
+    public static boolean saveToFile(String path, String filename, BlockArray BA) {
+        BA.PrepareSave();
+        try {
+            File directory = new File(path);
+            if (!directory.exists())
+                directory.mkdirs();
+            FileOutputStream fileOut = new FileOutputStream((new StringBuilder()).append(path).append("\\").append(filename).toString());
+            ObjectOutputStream out = new ObjectOutputStream(fileOut);
+            out.writeObject(BA);
+            out.close();
+            fileOut.close();
+            return true;
+        } catch (IOException i) {
+            i.printStackTrace();
+        }
+        return false;
+    }
+
+    public static BlockArray loadFromJson(String path) {
+        BlockArray BA;
+        try {
+            FileReader fileIn = new FileReader(path);
+            JsonReader jr = new JsonReader(fileIn);
+            BA = (new Gson()).fromJson(jr, BlockArray.class);
+            jr.close();
+            fileIn.close();
+            BA.LoadFromSave();
+            return BA;
+        } catch (IOException i) {
+            i.printStackTrace();
+        } catch (JsonIOException c) {
+            System.out.println("BlockArrayClass not found");
+            c.printStackTrace();
+        }
+        return null;
+    }
+
+    public static boolean saveToJson(String path, String filename, BlockArray BA) {
+        BA.PrepareSave();
+        try {
+            Gson gson = (new GsonBuilder()).setPrettyPrinting().create();
+            String json = gson.toJson(BA);
+            File directory = new File(path);
+            if (!directory.exists())
+                directory.mkdirs();
+            FileWriter fileOut = new FileWriter((new StringBuilder()).append(path).append("\\").append(filename).toString());
+            fileOut.write(json, 0, json.length());
+            fileOut.close();
+        } catch (IOException i) {
+            i.printStackTrace();
+        }
+        return false;
+    }
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_light_blue_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_lime_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_magenta_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_white_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_white_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/raw_marble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_marble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/raw_marble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_marble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/base/tools/BaseHoe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/tools/BaseHoe.java	(date 1523988241000)
+++ src/main/java/net/hdt/neutronia/items/base/tools/BaseHoe.java	(date 1523988241000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.items.base.tools;
+
+import net.hdt.neutronia.items.ItemModHoe;
+import net.hdt.neutronia.util.Reference;
+
+public class BaseHoe extends ItemModHoe {
+
+    public BaseHoe(String name, ToolMaterial material) {
+        super(material, name, Reference.MOD_ID);
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/chiseled_marble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/chiseled_marble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/chiseled_marble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/chiseled_marble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_purple_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_silver_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_green_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_pink_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/meteorite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/meteorite_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/meteorite_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/meteorite_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/natural_smooth_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/natural_smooth_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/natural_smooth_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/natural_smooth_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelMummyVillager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelMummyVillager.java	(date 1523987841000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelMummyVillager.java	(date 1523987841000)
@@ -0,0 +1,84 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.hdt.neutronia.entity.EntityMummy;
+import net.minecraft.client.model.ModelBiped;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.MathHelper;
+
+public class ModelMummyVillager extends ModelBiped {
+
+    public ModelMummyVillager() {
+        this(0.0F, 0.0F, false);
+    }
+
+    public ModelMummyVillager(float p_i1165_1_, float p_i1165_2_, boolean p_i1165_3_) {
+        super(p_i1165_1_, 0.0F, 64, p_i1165_3_ ? 32 : 64);
+
+        if (p_i1165_3_) {
+            this.bipedHead = new ModelRenderer(this, 0, 0);
+            this.bipedHead.addBox(-4.0F, -10.0F, -4.0F, 8, 8, 8, p_i1165_1_);
+            this.bipedHead.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
+            this.bipedBody = new ModelRenderer(this, 16, 16);
+            this.bipedBody.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
+            this.bipedBody.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, p_i1165_1_ + 0.1F);
+            this.bipedRightLeg = new ModelRenderer(this, 0, 16);
+            this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F + p_i1165_2_, 0.0F);
+            this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_ + 0.1F);
+            this.bipedLeftLeg = new ModelRenderer(this, 0, 16);
+            this.bipedLeftLeg.mirror = true;
+            this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F + p_i1165_2_, 0.0F);
+            this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_ + 0.1F);
+        } else {
+            this.bipedHead = new ModelRenderer(this, 0, 0);
+            this.bipedHead.setRotationPoint(0.0F, p_i1165_2_, 0.0F);
+            this.bipedHead.setTextureOffset(0, 0).addBox(-4.0F, -10.0F, -4.0F, 8, 10, 8, p_i1165_1_);
+            this.bipedHead.setTextureOffset(24, 0).addBox(-1.0F, -3.0F, -6.0F, 2, 4, 2, p_i1165_1_);
+            this.bipedBody = new ModelRenderer(this, 16, 20);
+            this.bipedBody.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
+            this.bipedBody.addBox(-4.0F, 0.0F, -3.0F, 8, 12, 6, p_i1165_1_);
+            this.bipedBody.setTextureOffset(0, 38).addBox(-4.0F, 0.0F, -3.0F, 8, 18, 6, p_i1165_1_ + 0.05F);
+            this.bipedRightArm = new ModelRenderer(this, 44, 38);
+            this.bipedRightArm.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, p_i1165_1_);
+            this.bipedRightArm.setRotationPoint(-5.0F, 2.0F + p_i1165_2_, 0.0F);
+            this.bipedLeftArm = new ModelRenderer(this, 44, 38);
+            this.bipedLeftArm.mirror = true;
+            this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, p_i1165_1_);
+            this.bipedLeftArm.setRotationPoint(5.0F, 2.0F + p_i1165_2_, 0.0F);
+            this.bipedRightLeg = new ModelRenderer(this, 0, 22);
+            this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F + p_i1165_2_, 0.0F);
+            this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_);
+            this.bipedLeftLeg = new ModelRenderer(this, 0, 22);
+            this.bipedLeftLeg.mirror = true;
+            this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F + p_i1165_2_, 0.0F);
+            this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_);
+        }
+    }
+
+    /**
+     * Sets the model's various rotation angles. For bipeds, par1 and par2 are used for animating the movement of arms
+     * and legs, where par1 represents the time(so that arms and legs swing back and forth) and par2 represents how
+     * "far" arms and legs can swing at most.
+     */
+    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn) {
+        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);
+        EntityMummy entityMummy = (EntityMummy) entityIn;
+        float f = MathHelper.sin(this.swingProgress * (float) Math.PI);
+        float f1 = MathHelper.sin((1.0F - (1.0F - this.swingProgress) * (1.0F - this.swingProgress)) * (float) Math.PI);
+        this.bipedRightArm.rotateAngleZ = 0.0F;
+        this.bipedLeftArm.rotateAngleZ = 0.0F;
+        this.bipedRightArm.rotateAngleY = -(0.1F - f * 0.6F);
+        this.bipedLeftArm.rotateAngleY = 0.1F - f * 0.6F;
+        float f2 = -(float) Math.PI / (entityMummy.isArmsRaised() ? 1.5F : 2.25F);
+        this.bipedRightArm.rotateAngleX = f2;
+        this.bipedLeftArm.rotateAngleX = f2;
+        this.bipedRightArm.rotateAngleX += f * 1.2F - f1 * 0.4F;
+        this.bipedLeftArm.rotateAngleX += f * 1.2F - f1 * 0.4F;
+        this.bipedRightArm.rotateAngleZ += MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
+        this.bipedLeftArm.rotateAngleZ -= MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
+        this.bipedRightArm.rotateAngleX += MathHelper.sin(ageInTicks * 0.067F) * 0.05F;
+        this.bipedLeftArm.rotateAngleX -= MathHelper.sin(ageInTicks * 0.067F) * 0.05F;
+    }
+
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_white_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/MidoriBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/MidoriBlocks.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/MidoriBlocks.java	(date 1525606882000)
@@ -0,0 +1,60 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [29/06/2016, 17:48:35 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockMidori;
+import net.hdt.neutronia.modules.building.blocks.BlockMidoriPillar;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockMidoriSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockMidoriStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class MidoriBlocks extends Feature {
+
+    public static Block midori_block;
+    public static Block midori_pillar;
+
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        midori_block = new BlockMidori();
+        midori_pillar = new BlockMidoriPillar();
+
+        BlockModSlab slab = new BlockMidoriSlab(false);
+        BlockModStairs.initStairs(midori_block, 0, new BlockMidoriStairs());
+        BlockModSlab.initSlab(midori_block, 0, slab, new BlockMidoriSlab(true));
+
+        VanillaWalls.add("midori_block", midori_block, 0, enableWalls);
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(midori_block, 4),
+				"GG", "GG",
+				'G', ProxyRegistry.newStack(Items.DYE, 1, 2));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(midori_pillar),
+				"S", "S",
+				'S', ProxyRegistry.newStack(slab));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/andesite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/andesite_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/andesite_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/andesite_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/granite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/granite_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/granite_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/granite_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/init/HMDimension.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMDimension.java	(date 1525332612000)
+++ src/main/java/net/hdt/neutronia/init/HMDimension.java	(date 1525332612000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.init;
+
+import net.minecraft.world.DimensionType;
+import net.minecraft.world.WorldProvider;
+import net.minecraft.world.WorldProviderSurface;
+
+public class HMDimension {
+
+    public static void registerDimensions() {
+        createDimension("test", "_test", 2, WorldProviderSurface.class, false);
+    }
+
+    public static void createDimension(String name, String suffix, int ID, Class<? extends WorldProvider> provider, boolean keepLoaded) {
+        DimensionType type = DimensionType.register(name, suffix, ID, provider, keepLoaded);
+        type.createDimension();
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/small_basalt_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/small_basalt_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/small_basalt_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/small_basalt_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_orange_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/init/HMRecipes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMRecipes.java	(date 1524922138000)
+++ src/main/java/net/hdt/neutronia/init/HMRecipes.java	(date 1524922138000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.init;
+
+import net.minecraft.item.crafting.IRecipe;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+public class HMRecipes {
+
+    public static void registerRecipes(IRecipe recipe) {
+        ForgeRegistries.RECIPES.register(recipe);
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/raw_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/raw_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/init/HMBiomes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMBiomes.java	(date 1525596331000)
+++ src/main/java/net/hdt/neutronia/init/HMBiomes.java	(date 1525596331000)
@@ -0,0 +1,54 @@
+package net.hdt.neutronia.init;
+
+import net.hdt.neutronia.world.biome.overworld.BiomeBasaltOverworld;
+import net.hdt.neutronia.world.biome.overworld.BiomeBlackDesert;
+import net.hdt.neutronia.world.biome.overworld.BiomeFrozenMesa;
+import net.hdt.neutronia.world.biome.overworld.BiomeRedDesert;
+import net.minecraft.world.biome.Biome;
+import net.minecraftforge.common.BiomeDictionary;
+import net.minecraftforge.common.BiomeManager;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class HMBiomes {
+
+    public static final Biome BASALT = new BiomeBasaltOverworld();
+    public static final Biome RED_DESERT = new BiomeRedDesert();
+    public static final Biome BLACK_DESERT = new BiomeBlackDesert();
+    public static final Biome MESA = new BiomeFrozenMesa(false, false, (new Biome.BiomeProperties("Frozen Mesa")).setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+    public static final Biome MESA_ROCK = new BiomeFrozenMesa(false, true, (new Biome.BiomeProperties("Frozen Mesa Plateau F")).setBaseHeight(1.5F).setHeightVariation(0.025F).setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+    public static final Biome MESA_CLEAR_ROCK = new BiomeFrozenMesa(false, false, (new Biome.BiomeProperties("Frozen Mesa Plateau")).setBaseHeight(1.5F).setHeightVariation(0.025F).setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+    public static final Biome MUTATED_MESA = new BiomeFrozenMesa(false, true, (new Biome.BiomeProperties("Frozen Mesa (Bryce)")).setBaseBiome("frozen_mesa").setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+    public static final Biome MUTATED_MESA_ROCK = new BiomeFrozenMesa(false, true, (new Biome.BiomeProperties("Frozen Mesa Plateau F M")).setBaseBiome("frozen_mesa_rock").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+    public static final Biome MUTATED_MESA_CLEAR_ROCK = new BiomeFrozenMesa(false, false, (new Biome.BiomeProperties("Frozen Mesa Plateau F M")).setBaseBiome("frozen_mesa_clear_rock").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.0F).setRainfall(0.0F).setRainDisabled());
+
+    public static void registerBiomes() {
+        initBiome(BASALT, "basalt", 3, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.SPOOKY, BiomeDictionary.Type.MAGICAL, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DEAD);
+        initBiome(RED_DESERT, "red_desert", 20, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DRY, BiomeDictionary.Type.SANDY);
+        initBiome(BLACK_DESERT, "black_desert", 10, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DRY, BiomeDictionary.Type.SANDY);
+
+        initBiome(MESA, "frozen_mesa", 1, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+        initBiome(MESA_ROCK, "frozen_mesa_rock", 1, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+        initBiome(MESA_CLEAR_ROCK, "frozen_mesa_clear_rock", 1, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+        initBiome(MUTATED_MESA, "frozen_mutated_mesa", 60, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+        initBiome(MUTATED_MESA_ROCK, "frozen_mutated_mesa_rock", 90, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+        initBiome(MUTATED_MESA_CLEAR_ROCK, "frozen_mutated_mesa_clear_rock", 114, BiomeManager.BiomeType.ICY, BiomeDictionary.Type.COLD, BiomeDictionary.Type.DEAD, BiomeDictionary.Type.SANDY);
+    }
+
+    private static Biome initBiome(Biome biome, String name, int weight, BiomeManager.BiomeType biomeType, BiomeDictionary.Type... types) {
+        biome.setRegistryName(MOD_ID, name);
+        ForgeRegistries.BIOMES.register(biome);
+        System.out.println(String.format("Biome: %s is now registered", name));
+        BiomeDictionary.addTypes(biome, types);
+        BiomeManager.addBiome(biomeType, new BiomeManager.BiomeEntry(biome, weight));
+        BiomeManager.addSpawnBiome(biome);
+        /*if (biome.isMutation())
+        {
+            Biome.MUTATION_TO_BASE_ID_MAP.put(biome, Biome.getIdForBiome(Objects.requireNonNull(Biome.REGISTRY.getObject(new ResourceLocation(biome.getBiomeName())))));
+        }*/
+        System.out.println(String.format("Biome: %s is now added to the spawn biome's", name));
+        return biome;
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_brown_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndPlants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndPlants.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndPlants.java	(date 1524853001000)
@@ -0,0 +1,91 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import eex.init.EndExPlantTypes;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.common.EnumPlantType;
+
+public class BlockEndPlants extends BlockBushEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockEndPlants()
+    {
+        super("end_plants", Material.PLANTS);
+        setHardness(0.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public EnumPlantType getPlantType(IBlockAccess world, BlockPos pos)
+    {
+        return EndExPlantTypes.END;
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        AIR,
+        CHALK,
+        CHORUS_BLOOM,
+        LITHOPS,
+        SPIKEY_BLOB;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/modules/building/features/MagmaBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/MagmaBricks.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/MagmaBricks.java	(date 1525606887000)
@@ -0,0 +1,37 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockMagmaBricks;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockMagmaBricksSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockMagmaBricksStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class MagmaBricks extends Feature {
+
+    public static Block magma_bricks;
+
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        magma_bricks = new BlockMagmaBricks();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(magma_bricks, 0, new BlockMagmaBricksStairs());
+            BlockModSlab.initSlab(magma_bricks, 0, new BlockMagmaBricksSlab(false), new BlockMagmaBricksSlab(true));
+        }
+		
+		/*RecipeHandler.addShapelessOreDictRecipe(ProxyRegistry.newStack(magma_bricks, 4),
+				ProxyRegistry.newStack(Blocks.STONEBRICK), ProxyRegistry.newStack(Blocks.STONEBRICK), ProxyRegistry.newStack(Blocks.MAGMA), ProxyRegistry.newStack(Blocks.MAGMA));*/
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_red_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedPlanksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedPlanksStairs.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockStainedPlanksStairs.java	(date 1525606881000)
@@ -0,0 +1,19 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedPlanks;
+import net.hdt.neutronia.modules.building.features.StainedPlanks;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedPlanksStairs extends BlockOverworldStairBase implements IRecipeGrouped {
+
+    public BlockStainedPlanksStairs(BlockStainedPlanks.Variants variant) {
+        super(variant.getName() + "_stairs", StainedPlanks.stained_planks.getDefaultState().withProperty(StainedPlanks.stained_planks.getVariantProp(), variant));
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_planks_stairs";
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_purple_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_purple_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/natural_chiseled_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/natural_chiseled_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/natural_chiseled_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/natural_chiseled_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_white_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_white_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_red_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_orange_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/marble_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/marble_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/marble_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/marble_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_silver_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_silver_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModAnvil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModAnvil.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModAnvil.java	(date 1525606880000)
@@ -0,0 +1,212 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyDirection;
+import net.minecraft.block.properties.PropertyInteger;
+import net.minecraft.block.state.BlockFaceShape;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityFallingBlock;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.InventoryPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.inventory.Container;
+import net.minecraft.inventory.ContainerRepair;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.ITextComponent;
+import net.minecraft.util.text.TextComponentTranslation;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.IInteractionObject;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class BlockModAnvil extends BlockFalling {
+    public static final PropertyDirection FACING = BlockHorizontal.FACING;
+    public static final PropertyInteger DAMAGE = PropertyInteger.create("damage", 0, 2);
+    protected static final AxisAlignedBB X_AXIS_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.125D, 1.0D, 1.0D, 0.875D);
+    protected static final AxisAlignedBB Z_AXIS_AABB = new AxisAlignedBB(0.125D, 0.0D, 0.0D, 0.875D, 1.0D, 1.0D);
+    protected static final Logger LOGGER = LogManager.getLogger();
+
+    public BlockModAnvil(String name, CreativeTabs creativeTabs) {
+        super(Material.ANVIL, name);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH).withProperty(DAMAGE, 0));
+        this.setLightOpacity(0);
+        this.setCreativeTab(creativeTabs);
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    /**
+     * Get the geometry of the queried face at the given position and state. This is used to decide whether things like
+     * buttons are allowed to be placed on the face, or how glass panes connect to the face, among other things.
+     * <p>
+     * Common values are {@code SOLID}, which is the default, and {@code UNDEFINED}, which represents something that
+     * does not fit the other descriptions and will generally cause other things not to connect to the face.
+     *
+     * @return an approximation of the form of the given face
+     */
+    public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face) {
+        return BlockFaceShape.UNDEFINED;
+    }
+
+    /**
+     * Used to determine ambient occlusion and culling when rebuilding chunks for render
+     */
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    /**
+     * Called by ItemBlocks just before a block is actually set in the world, to allow for adjustments to the
+     * IBlockstate
+     */
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer) {
+        EnumFacing enumfacing = placer.getHorizontalFacing().rotateY();
+
+        try {
+            return super.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, meta, placer).withProperty(FACING, enumfacing).withProperty(DAMAGE, Integer.valueOf(meta >> 2));
+        } catch (IllegalArgumentException var11) {
+            if (!worldIn.isRemote) {
+                LOGGER.warn(String.format("Invalid damage property for anvil at %s. Found %d, must be in [0, 1, 2]", pos, meta >> 2));
+
+                if (placer instanceof EntityPlayer) {
+                    placer.sendMessage(new TextComponentTranslation("Invalid damage property. Please pick in [0, 1, 2]"));
+                }
+            }
+
+            return super.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, 0, placer).withProperty(FACING, enumfacing).withProperty(DAMAGE, Integer.valueOf(0));
+        }
+    }
+
+    /**
+     * Called when the block is right clicked by a player.
+     */
+    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
+        if (!worldIn.isRemote) {
+            playerIn.displayGui(new BlockModAnvil.Anvil(worldIn, pos));
+        }
+
+        return true;
+    }
+
+    /**
+     * Gets the metadata of the item this Block can drop. This method is called when the block gets destroyed. It
+     * returns the metadata of the dropped item based on the old metadata of the block.
+     */
+    public int damageDropped(IBlockState state) {
+        return state.getValue(DAMAGE).intValue();
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        EnumFacing enumfacing = state.getValue(FACING);
+        return enumfacing.getAxis() == EnumFacing.Axis.X ? X_AXIS_AABB : Z_AXIS_AABB;
+    }
+
+    /**
+     * returns a list of blocks with the same ID, but different meta (eg: wood returns 4 blocks)
+     */
+    public void getSubBlocks(CreativeTabs itemIn, NonNullList<ItemStack> items) {
+        items.add(new ItemStack(this));
+        items.add(new ItemStack(this, 1, 1));
+        items.add(new ItemStack(this, 1, 2));
+    }
+
+    protected void onStartFalling(EntityFallingBlock fallingEntity) {
+        fallingEntity.setHurtEntities(true);
+    }
+
+    public void onEndFalling(World worldIn, BlockPos pos, IBlockState p_176502_3_, IBlockState p_176502_4_) {
+        worldIn.playEvent(1031, pos, 0);
+    }
+
+    public void onBroken(World worldIn, BlockPos pos) {
+        worldIn.playEvent(1029, pos, 0);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        return true;
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(FACING, EnumFacing.getHorizontal(meta & 3)).withProperty(DAMAGE, Integer.valueOf((meta & 15) >> 2));
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        int i = 0;
+        i = i | state.getValue(FACING).getHorizontalIndex();
+        i = i | state.getValue(DAMAGE).intValue() << 2;
+        return i;
+    }
+
+    /**
+     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
+     * blockstate.
+     */
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        return state.getBlock() != this ? state : state.withProperty(FACING, rot.rotate(state.getValue(FACING)));
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING, DAMAGE);
+    }
+
+    public static class Anvil implements IInteractionObject {
+        private final World world;
+        private final BlockPos position;
+
+        public Anvil(World worldIn, BlockPos pos) {
+            this.world = worldIn;
+            this.position = pos;
+        }
+
+        /**
+         * Get the name of this object. For players this returns their username
+         */
+        public String getName() {
+            return "anvil";
+        }
+
+        /**
+         * Returns true if this thing is named
+         */
+        public boolean hasCustomName() {
+            return false;
+        }
+
+        /**
+         * Get the formatted ChatComponent that will be used for the sender's username in chat
+         */
+        public ITextComponent getDisplayName() {
+            return new TextComponentTranslation(Blocks.ANVIL.getUnlocalizedName() + ".name");
+        }
+
+        public Container createContainer(InventoryPlayer playerInventory, EntityPlayer playerIn) {
+            return new ContainerRepair(playerInventory, this.world, this.position, playerIn);
+        }
+
+        public String getGuiID() {
+            return "minecraft:anvil";
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/basalt_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/basalt_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/basalt_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/basalt_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_gray_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_yellow_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_yellow_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/natural_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/natural_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/natural_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/natural_aquamarine_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/cracked_limestone_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/cracked_limestone_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/cracked_limestone_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/cracked_limestone_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/properties/EnumAquamarineVariants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumAquamarineVariants.java	(date 1524921399000)
+++ src/main/java/net/hdt/neutronia/properties/EnumAquamarineVariants.java	(date 1524921399000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumAquamarineVariants implements IStringSerializable {
+
+    BRICKS(0, "aquamarine_bricks"),
+    CHISELED(0, "chiseled_aquamarine"),
+    RAW(0, "raw_aquamarine"),
+    SMALL_BRICKS(0, "small_aquamarine_bricks"),
+    SMOOTH(0, "smooth_aquamarine");
+
+    private String name;
+    private int ID;
+
+    EnumAquamarineVariants(int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/dungeons/DungeonGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/dungeons/DungeonGenerator.java	(date 1524924208000)
+++ src/main/java/net/hdt/neutronia/world/dungeons/DungeonGenerator.java	(date 1524924208000)
@@ -0,0 +1,128 @@
+package net.hdt.neutronia.world.dungeons;
+
+import net.hdt.neutronia.world.dungeons.generator.HallwayStructure;
+import net.hdt.neutronia.world.dungeons.generator.RoomStructure;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldType;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+
+public class DungeonGenerator implements IWorldGenerator {
+
+    private static final RoomStructure room1 = new RoomStructure("room_0");
+    private static final RoomStructure room2 = new RoomStructure("room_1");
+    private static final RoomStructure room3 = new RoomStructure("room_2");
+    private static final RoomStructure room4 = new RoomStructure("room_3");
+    private static final RoomStructure room5 = new RoomStructure("room_4");
+    private static final RoomStructure room6 = new RoomStructure("room_5");
+    private static final RoomStructure room7 = new RoomStructure("room_6");
+    private static final RoomStructure room8 = new RoomStructure("room_7");
+    private static final RoomStructure room9 = new RoomStructure("room_8");
+    private static final RoomStructure room10 = new RoomStructure("room_9");
+    private static final HallwayStructure hallway_s = new HallwayStructure("hallway_straight");
+    private static final HallwayStructure hallway_cl = new HallwayStructure("hallway_corner_left");
+    //    private static final HallwayStructure hallway_cr = new HallwayStructure("hallway_corner_right");
+    private static final HallwayStructure hallway_u = new HallwayStructure("hallway_up");
+    private static final HallwayStructure hallway_d = new HallwayStructure("hallway_down");
+    private static List<RoomStructure> structures = new ArrayList<>();
+
+    private static int calculateGenerationHeight(World world, int x, int z, Block topBlock) {
+        int y = world.getHeight();
+        boolean foundGround = false;
+
+        while (!foundGround && y-- >= 0) {
+            Block block = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = block == topBlock;
+        }
+
+        return y;
+    }
+
+    public static int getGroundFromAbove(World world, int x, int z) {
+        int y = 255;
+        boolean foundGround = false;
+        while (!foundGround && y-- >= 31) {
+            Block blockAt = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = blockAt == Blocks.WATER || blockAt == Blocks.FLOWING_WATER || blockAt == Blocks.GRASS || blockAt == Blocks.SAND || blockAt == Blocks.SNOW || blockAt == Blocks.SNOW_LAYER || blockAt == Blocks.GLASS || blockAt == Blocks.MYCELIUM;
+        }
+
+        return y;
+    }
+
+    public static int getLakeFromAbove(World world, int x, int z) {
+        int y = 255;
+        boolean foundGround = false;
+        while (!foundGround && y-- >= 31) {
+            Block blockAt = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = blockAt == Blocks.WATER || blockAt == Blocks.FLOWING_WATER;
+        }
+
+        return y;
+    }
+
+    public static boolean canSpawnHere(Template template, World world, BlockPos posAboveGround) {
+        int zwidth = template.getSize().getZ();
+        int xwidth = template.getSize().getX();
+
+        // check all the corners to see which ones are replaceable
+        boolean corner1 = isCornerValid(world, posAboveGround);
+        boolean corner2 = isCornerValid(world, posAboveGround.add(xwidth, 0, zwidth));
+
+        // if Y > 20 and all corners pass the test, it's okay to spawn the structure
+        return posAboveGround.getY() > 31 && corner1 && corner2;
+    }
+
+    public static boolean isCornerValid(World world, BlockPos pos) {
+        int variation = 3;
+        int highestBlock = getGroundFromAbove(world, pos.getX(), pos.getZ());
+
+        return highestBlock > pos.getY() - variation && highestBlock < pos.getY() + variation;
+    }
+
+    @Override
+    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
+        for (int i = 0; i > random.nextInt(10); i++) {
+            structures.add(new RoomStructure(String.format("rooms/room_%d", i)));
+            switch (world.provider.getDimension()) {
+                case 1:
+                    break;
+                case 0:
+//                    generateStructure(structures.get(random.nextInt(10)), world, random, chunkX, chunkZ, 1, Blocks.SAND, Biomes.DESERT, Biomes.DESERT_HILLS, HMBiomes.BLACK_DESERT, HMBiomes.RED_DESERT);
+                    break;
+                case -1:
+            }
+        }
+    }
+
+    private void generateStructure(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance, Block topBlock, Biome... classes) {
+        ArrayList<Biome> classesList = new ArrayList<>(Arrays.asList(classes));
+
+        int x = (chunkX * 16) + random.nextInt(15);
+        int z = (chunkZ * 16) + random.nextInt(15);
+        int y = calculateGenerationHeight(world, x, z, topBlock);
+        BlockPos pos = new BlockPos(x, y, z);
+
+        Class<?> biome = world.provider.getBiomeForCoords(pos).getClass();
+
+        if (world.getWorldType() != WorldType.FLAT) {
+            if (classesList.contains(biome)) {
+                if (random.nextInt(chance) == 0) {
+                    generator.generate(world, random, pos);
+                }
+            }
+        }
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_lime_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/small_marble_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/small_marble_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/small_marble_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/small_marble_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/basalt_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/basalt_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/basalt_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/basalt_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_light_blue_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_light_blue_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/andesite_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/andesite_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/andesite_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/andesite_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSoulSandstoneStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSoulSandstoneStairs.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSoulSandstoneStairs.java	(date 1525606884000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherStairBase;
+import net.hdt.neutronia.modules.building.features.SoulSandstone;
+
+public class BlockSoulSandstoneStairs extends BlockNetherStairBase {
+
+    public BlockSoulSandstoneStairs() {
+        super("soul_sandstone_stairs", SoulSandstone.soul_sandstone.getDefaultState());
+    }
+
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_light_blue_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_light_blue_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_brown_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_brown_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/IronPlates.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/IronPlates.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/IronPlates.java	(date 1525606883000)
@@ -0,0 +1,63 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/06/2016, 14:52:57 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockIronPlate;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockIronPlateSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockIronPlateStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class IronPlates extends Feature {
+
+    public static Block iron_plate;
+
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        iron_plate = new BlockIronPlate();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(iron_plate, 0, new BlockIronPlateStairs());
+            BlockModSlab.initSlab(iron_plate, 0, new BlockIronPlateSlab(false), new BlockIronPlateSlab(true));
+        }
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(iron_plate, 24),
+				"III", "I I", "III",
+				'I', "ingotIron");
+		
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(iron_plate, 24, 1),
+				"III", "IBI", "III",
+				'I', "ingotIron",
+				'B', ProxyRegistry.newStack(Items.WATER_BUCKET));
+		
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(iron_plate, 8, 1),
+				"III", "IBI", "III",
+				'I', ProxyRegistry.newStack(iron_plate),
+				'B', ProxyRegistry.newStack(Items.WATER_BUCKET));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_cyan_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_cyan_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_yellow_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_pink_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_pink_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/limestone_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/limestone_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/limestone_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/limestone_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/raw_basalt.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_basalt.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/raw_basalt.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_basalt"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/aquamarine_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/HardenedClayTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/HardenedClayTiles.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/HardenedClayTiles.java	(date 1525606883000)
@@ -0,0 +1,83 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [19/03/2016, 01:24:16 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockHardenedClayTiles;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedClayTiles;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockHardenedClayTilesSlab;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockStainedClayTilesSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockHardenedClayTilesStairs;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockStainedClayTilesStairs;
+import net.minecraft.init.Blocks;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+import net.thegaminghuskymc.huskylib2.recipie.RecipeHandler;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class HardenedClayTiles extends Feature {
+
+    public static BlockMod hardened_clay_tiles;
+    public static BlockMod stained_clay_tiles;
+
+    boolean enableStainedClay;
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStainedClay = loadPropBool("Enable stained tiles", "", true) && GlobalConfig.enableVariants;
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        hardened_clay_tiles = new BlockHardenedClayTiles();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(hardened_clay_tiles, 0, new BlockHardenedClayTilesStairs());
+            BlockModSlab.initSlab(hardened_clay_tiles, 0, new BlockHardenedClayTilesSlab(false), new BlockHardenedClayTilesSlab(true));
+        }
+
+        RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(hardened_clay_tiles, 4, 0),
+                "BB", "BB",
+                'B', ProxyRegistry.newStack(Blocks.HARDENED_CLAY));
+
+        if (enableStainedClay) {
+            stained_clay_tiles = new BlockStainedClayTiles();
+
+            if (enableStairsAndSlabs) {
+                for (BlockStainedClayTiles.Variants variant : BlockStainedClayTiles.Variants.class.getEnumConstants())
+                    BlockModStairs.initStairs(stained_clay_tiles, variant.ordinal(), new BlockStainedClayTilesStairs(variant));
+                for (BlockStainedClayTiles.Variants variant : BlockStainedClayTiles.Variants.class.getEnumConstants())
+                    BlockModSlab.initSlab(stained_clay_tiles, variant.ordinal(), new BlockStainedClayTilesSlab(variant, false), new BlockStainedClayTilesSlab(variant, true));
+            }
+
+			/*for(int i = 0; i < 16; i++) {
+				RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(stained_clay_tiles, 4, i),
+						"BB", "BB",
+						'B', ProxyRegistry.newStack(Blocks.STAINED_HARDENED_CLAY, 1, i));
+				RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(stained_clay_tiles, 8, i),
+						"BBB", "BDB", "BBB",
+						'B', ProxyRegistry.newStack(hardened_clay_tiles, 1),
+						'D', LibMisc.OREDICT_DYES.get(15 - i));
+			}*/
+        }
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/render/RenderMummy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderMummy.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderMummy.java	(date 1523987839000)
@@ -0,0 +1,27 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityMummy;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+@SideOnly(Side.CLIENT)
+public class RenderMummy extends RenderBiped<EntityMummy> {
+
+    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation(MOD_ID, "textures/entity/mummy/mummy.png");
+
+    public RenderMummy(RenderManager rendermanagerIn) {
+        super(rendermanagerIn, new ModelZombie(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityMummy entity) {
+        return MUMMY_TEXTURE;
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_orange_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_orange_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_orange_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/chiseled_limestone.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/chiseled_limestone.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/chiseled_limestone.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/chiseled_limestone"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeaturePool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeaturePool.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeaturePool.java	(date 1525606901000)
@@ -0,0 +1,108 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public class FeaturePool extends Feature {
+    private IBlockState blockToSpawn;
+    private IBlockState blockToSurround;
+
+    public FeaturePool(IConfig config) {
+        super(config);
+        blockToSpawn = config.getBlock("blockToSpawn", Blocks.BARRIER.getDefaultState());
+        blockToSurround = config.getBlock("blockToSurround", Blocks.BARRIER.getDefaultState());
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (blockToSpawn.getBlock() == Blocks.BARRIER || blockToSurround.getBlock() == Blocks.BARRIER) {
+            return false;
+        }
+
+        for (pos = pos.add(-8, 0, -8); pos.getY() > minHeight && world.isAirBlock(pos); pos = pos.down()) {
+
+        }
+
+        if (pos.getY() <= 4 || pos.getY() < minHeight) {
+            return false;
+        } else {
+            pos = pos.down(4);
+            boolean[] hasSpace = new boolean[2048];
+            int i = rand.nextInt(4) + 4;
+
+            for (int j = 0; j < i; ++j) {
+                double d0 = rand.nextDouble() * 6.0D + 3.0D;
+                double d1 = rand.nextDouble() * 4.0D + 2.0D;
+                double d2 = rand.nextDouble() * 6.0D + 3.0D;
+                double d3 = rand.nextDouble() * (16.0D - d0 - 2.0D) + 1.0D + d0 / 2.0D;
+                double d4 = rand.nextDouble() * (8.0D - d1 - 4.0D) + 2.0D + d1 / 2.0D;
+                double d5 = rand.nextDouble() * (16.0D - d2 - 2.0D) + 1.0D + d2 / 2.0D;
+
+                for (int l = 1; l < 15; ++l) {
+                    for (int i1 = 1; i1 < 15; ++i1) {
+                        for (int j1 = 1; j1 < 7; ++j1) {
+                            double d6 = ((double) l - d3) / (d0 / 2.0D);
+                            double d7 = ((double) j1 - d4) / (d1 / 2.0D);
+                            double d8 = ((double) i1 - d5) / (d2 / 2.0D);
+                            double d9 = d6 * d6 + d7 * d7 + d8 * d8;
+
+                            if (d9 < 1.0D) {
+                                hasSpace[(l * 16 + i1) * 8 + j1] = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            for (int k1 = 0; k1 < 16; ++k1) {
+                for (int l2 = 0; l2 < 16; ++l2) {
+                    for (int k = 0; k < 8; ++k) {
+                        boolean flag = !hasSpace[(k1 * 16 + l2) * 8 + k] && (k1 < 15 && hasSpace[((k1 + 1) * 16 + l2) * 8 + k] || k1 > 0 && hasSpace[((k1 - 1) * 16 + l2) * 8 + k] || l2 < 15 && hasSpace[(k1 * 16 + l2 + 1) * 8 + k] || l2 > 0 && hasSpace[(k1 * 16 + (l2 - 1)) * 8 + k] || k < 7 && hasSpace[(k1 * 16 + l2) * 8 + k + 1] || k > 0 && hasSpace[(k1 * 16 + l2) * 8 + (k - 1)]);
+
+                        if (flag) {
+                            Material material = world.getBlockState(pos.add(k1, k, l2)).getMaterial();
+
+                            if (k >= 4 && material.isLiquid()) {
+                                return false;
+                            }
+
+                            if (k < 4 && !material.isSolid() && world.getBlockState(pos.add(k1, k, l2)) != blockToSpawn) {
+                                return false;
+                            }
+                        }
+                    }
+                }
+            }
+
+            for (int l1 = 0; l1 < 16; ++l1) {
+                for (int i3 = 0; i3 < 16; ++i3) {
+                    for (int i4 = 0; i4 < 8; ++i4) {
+                        if (hasSpace[(l1 * 16 + i3) * 8 + i4]) {
+                            world.setBlockState(pos.add(l1, i4, i3), i4 >= 4 ? Blocks.AIR.getDefaultState() : blockToSpawn, 2);
+                        }
+                    }
+                }
+            }
+
+            for (int j2 = 0; j2 < 16; ++j2) {
+                for (int k3 = 0; k3 < 16; ++k3) {
+                    for (int k4 = 0; k4 < 8; ++k4) {
+                        boolean flag1 = !hasSpace[(j2 * 16 + k3) * 8 + k4] && (j2 < 15 && hasSpace[((j2 + 1) * 16 + k3) * 8 + k4] || j2 > 0 && hasSpace[((j2 - 1) * 16 + k3) * 8 + k4] || k3 < 15 && hasSpace[(j2 * 16 + k3 + 1) * 8 + k4] || k3 > 0 && hasSpace[(j2 * 16 + (k3 - 1)) * 8 + k4] || k4 < 7 && hasSpace[(j2 * 16 + k3) * 8 + k4 + 1] || k4 > 0 && hasSpace[(j2 * 16 + k3) * 8 + (k4 - 1)]);
+
+                        if (flag1 && (k4 < 4 || rand.nextInt(2) != 0) && world.getBlockState(pos.add(j2, k4, k3)).getMaterial().isSolid()) {
+                            world.setBlockState(pos.add(j2, k4, k3), blockToSurround, 2);
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_green_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_green_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/smooth_meteorite.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/smooth_meteorite.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/smooth_meteorite.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/smooth_meteorite"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModBush.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModBush.java	(date 1523986200000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModBush.java	(date 1523986200000)
@@ -0,0 +1,82 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockBush;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.util.ResourceLocation;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class BlockModBush extends BlockBush implements IModBlock {
+
+    private final String[] variants;
+    private final String bareName, modid;
+
+    public BlockModBush(Material material, String name, String modid) {
+        super(material);
+        variants = new String[]{name};
+        bareName = name;
+        this.modid = modid;
+
+        setUnlocalizedName(name);
+        setCreativeTab(CreativeTabs.SEARCH);
+    }
+
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        this.setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(createItemBlock(new ResourceLocation(getPrefix(), name)));
+        return this;
+    }
+
+    private ItemBlock createItemBlock(ResourceLocation res) {
+        return new ItemModBlock(this, res);
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    @Override
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[0];
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/small_natural_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/small_natural_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/small_natural_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/small_natural_aquamarine_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_cyan_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_purple_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_purple_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStoneBricks.java	(date 1524853000000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStoneBricks.java	(date 1524853000000)
@@ -0,0 +1,82 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockFilamentEndStoneBricks extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockFilamentEndStoneBricks()
+    {
+        super("end_stone_bricks_filament", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/resources/assets/neutronia/blockstates/cracked_basalt_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/cracked_basalt_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/cracked_basalt_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/cracked_basalt_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemSplashPotionBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemSplashPotionBase.java	(date 1523986182000)
+++ src/main/java/net/hdt/neutronia/items/ItemSplashPotionBase.java	(date 1523986182000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntityPotion;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemPotion;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionUtils;
+import net.minecraft.stats.StatList;
+import net.minecraft.util.ActionResult;
+import net.minecraft.util.EnumActionResult;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+
+public class ItemSplashPotionBase extends ItemPotion {
+    public String getItemStackDisplayName(ItemStack stack) {
+        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("splash_potion.effect."));
+    }
+
+    /**
+     * Called when the equipped item is right clicked.
+     */
+    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
+        ItemStack itemstack = playerIn.getHeldItem(handIn);
+        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
+        worldIn.playSound(null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_SPLASH_POTION_THROW, SoundCategory.PLAYERS, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
+
+        if (!worldIn.isRemote) {
+            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
+            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
+            worldIn.spawnEntity(entitypotion);
+        }
+
+        playerIn.addStat(StatList.getObjectUseStats(this));
+        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, itemstack);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/generators/MultiChunkFeatureGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/generators/MultiChunkFeatureGenerator.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/world/gen/generators/MultiChunkFeatureGenerator.java	(date 1525606902000)
@@ -0,0 +1,79 @@
+package net.hdt.neutronia.world.gen.generators;
+
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+import java.util.function.Consumer;
+
+public abstract class MultiChunkFeatureGenerator {
+
+    public void generate(int chunkX, int chunkZ, World world) {
+        if (!canGenerate(world, chunkX, chunkZ))
+            return;
+
+        int radius = getFeatureRadius();
+        int chunkRadius = (int) Math.ceil((double) radius / 16.0);
+
+        long worldSeed = modifyWorldSeed(world.getSeed());
+        Random worldRandom = new Random(worldSeed);
+        long xSeed = worldRandom.nextLong() >> 2 + 1;
+        long zSeed = worldRandom.nextLong() >> 2 + 1;
+
+        long ourChunkSeed = (xSeed * chunkX + zSeed * chunkZ) ^ worldSeed;
+
+        for (int x = chunkX - chunkRadius; x <= chunkX + chunkRadius; x++)
+            for (int z = chunkZ - chunkRadius; z <= chunkZ + chunkRadius; z++) {
+                long chunkSeed = (xSeed * x + zSeed * z) ^ worldSeed;
+                Random chunkRandom = new Random(chunkSeed);
+
+                BlockPos[] sources = getSourcesInChunk(chunkRandom, x, z, world);
+                for (BlockPos source : sources)
+                    if (source != null && isSourceValid(world, source))
+                        generateChunkPart(source, chunkRandom, chunkX, chunkZ, world);
+            }
+    }
+
+    public long modifyWorldSeed(long seed) {
+        return seed;
+    }
+
+    public boolean isSourceValid(World world, BlockPos pos) {
+        return true;
+    }
+
+    public boolean canGenerate(World world, int chunkX, int chunkZ) {
+        return true;
+    }
+
+    public boolean shouldOffset() {
+        return true;
+    }
+
+    public abstract int getFeatureRadius();
+
+    public abstract void generateChunkPart(BlockPos src, Random random, int chunkX, int chunkZ, World world);
+
+    public abstract BlockPos[] getSourcesInChunk(Random random, int chunkX, int chunkZ, World world);
+
+    public void forEachChunkBlock(int chunkX, int chunkZ, int minY, int maxY, Consumer<BlockPos> func) {
+        BlockPos first = new BlockPos(chunkX * 16, 0, chunkZ * 16);
+        minY = Math.max(1, minY);
+        maxY = Math.min(255, maxY);
+
+        if (shouldOffset())
+            first = first.add(8, 0, 8);
+
+        for (int x = 0; x < 16; x++)
+            for (int y = minY; y < maxY; y++)
+                for (int z = 0; z < 16; z++)
+                    func.accept(first.add(x, y, z));
+    }
+
+    public boolean isInsideChunk(BlockPos pos, int chunkX, int chunkZ) {
+        int x = chunkX * 16;
+        int z = chunkZ * 16;
+        return pos.getX() > x && pos.getZ() > z && pos.getX() < (x + 16) && pos.getZ() < (z + 16);
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_magenta_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_magenta_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSandyBricksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSandyBricksStairs.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSandyBricksStairs.java	(date 1525606881000)
@@ -0,0 +1,22 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:02:28 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.SandyBricks;
+
+public class BlockSandyBricksStairs extends BlockOverworldStairBase {
+
+    public BlockSandyBricksStairs() {
+        super("sandy_bricks_stairs", SandyBricks.sandy_bricks.getDefaultState());
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_green_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_green_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/api/village/ITrade.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/api/village/ITrade.java	(date 1525606877000)
+++ src/main/java/net/hdt/neutronia/api/village/ITrade.java	(date 1525606877000)
@@ -0,0 +1,9 @@
+package net.hdt.neutronia.api.village;
+
+import net.minecraft.village.MerchantRecipe;
+
+public interface ITrade {
+    MerchantRecipe randomize();
+
+    int getTradeLevel();
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumFloorTilePatterns.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumFloorTilePatterns.java	(date 1524515486000)
+++ src/main/java/net/hdt/neutronia/properties/EnumFloorTilePatterns.java	(date 1524515486000)
@@ -0,0 +1,47 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumFloorTilePatterns implements IStringSerializable {
+
+    BLANK(0, "frosted_dirt"),
+    STAR(1, "dark_dirt"),
+    ROCKET(2, "frosted_dark_dirt"),
+    LAVA_ROCKS(3, "frosted_gravel");
+
+    private static final EnumFloorTilePatterns[] META_LOOKUP = new EnumFloorTilePatterns[values().length];
+
+    static {
+        for (EnumFloorTilePatterns enumdyecolor : values()) {
+            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumFloorTilePatterns(int metaIn, String nameIn) {
+        this.meta = metaIn;
+        this.name = nameIn;
+    }
+
+    public static EnumFloorTilePatterns byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemAncientSword.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemAncientSword.java	(date 1523987838000)
+++ src/main/java/net/hdt/neutronia/items/ItemAncientSword.java	(date 1523987838000)
@@ -0,0 +1,29 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.items.base.tools.BaseSword;
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.text.TextFormatting;
+import net.minecraft.world.World;
+import net.minecraftforge.common.util.EnumHelper;
+
+import javax.annotation.Nullable;
+import java.util.List;
+
+public class ItemAncientSword extends BaseSword {
+
+    private static Item.ToolMaterial ancientToolMaterial = EnumHelper.addToolMaterial("egyptian", 1, 131, 8.0F, 3.5F, 22);
+
+    public ItemAncientSword() {
+        super("khopesh", ancientToolMaterial);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    @Override
+    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
+        tooltip.add(TextFormatting.GOLD + String.format(TextFormatting.ITALIC + "This is a khopesh from the old egyptian times. It was only used by the pharaohs best guards"));
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/idk/FoodValueHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/FoodValueHandler.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/util/idk/FoodValueHandler.java	(date 1525606898000)
@@ -0,0 +1,94 @@
+package net.hdt.neutronia.util.idk;
+
+import net.hdt.neutronia.config.AnimaniaConfig;
+import net.hdt.neutronia.items.ItemAnimaniaFood;
+import net.minecraft.item.Item;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class FoodValueHandler {
+    private static Map<ItemAnimaniaFood, String> food_values = new HashMap<ItemAnimaniaFood, String>();
+
+    public static void init() {
+        String[] overrides = AnimaniaConfig.foodValues.foodValueOverrides;
+        for (String s : overrides) {
+            if (!s.isEmpty()) {
+                String name = s;
+                boolean errored = false;
+
+                if (!name.contains("(")) {
+                    new InvalidConfigException("Missing ( in line: " + s).printException();
+                    errored = true;
+                }
+
+                if (!name.contains(")")) {
+                    new InvalidConfigException("Missing ) in line: " + s).printException();
+                    errored = true;
+                }
+
+                if (!errored) {
+                    String values = name.substring(name.indexOf("("));
+                    name = name.replace(values, "");
+
+                    Item item = StringParser.getItem(name);
+
+                    if (!(item instanceof ItemAnimaniaFood)) {
+                        new InvalidConfigException("The item specified is not a food item from Animania: " + name).printException();
+                        errored = true;
+                    }
+
+                    values = values.replace("(", "");
+                    values = values.replace(")", "");
+
+                    if (!values.contains(",")) {
+                        new InvalidConfigException("Missing number separator (comma) in line: " + s).printException();
+                        errored = true;
+                    }
+
+                    if (!errored) {
+                        String[] v = values.split(",");
+                        try {
+                            int healAmount = Integer.parseInt(v[0]);
+                        } catch (Exception e) {
+                            new InvalidConfigException(v[0] + " at line " + s + " is not a valid Integer").printException();
+                            errored = true;
+                        }
+
+                        try {
+                            float saturation = Float.parseFloat(v[1]);
+                        } catch (Exception e) {
+                            new InvalidConfigException(v[1] + " at line " + s + " is not a valid Float").printException();
+                            errored = true;
+                        }
+
+                        if (!errored)
+                            food_values.put((ItemAnimaniaFood) item, values);
+                    }
+                }
+            }
+        }
+    }
+
+    public static boolean hasOverride(Item item) {
+        return food_values.containsKey(item);
+    }
+
+    public static int getHealAmount(Item item) {
+        String s = food_values.get(item);
+        String[] values = s.split(",");
+
+        int healAmount = Integer.parseInt(values[0]);
+
+        return healAmount;
+    }
+
+    public static float getSaturation(Item item) {
+        String s = food_values.get(item);
+        String[] values = s.split(",");
+
+        float saturation = Float.parseFloat(values[1]);
+
+        return saturation;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_silver_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_silver_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_gray_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_gray_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/diorite_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/diorite_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/diorite_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/diorite_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenWastelandBigTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenWastelandBigTree.java	(date 1523986167000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenWastelandBigTree.java	(date 1523986167000)
@@ -0,0 +1,298 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenBigTree;
+
+import java.util.Random;
+
+public class WorldGenWastelandBigTree extends WorldGenBigTree {
+    static final byte[] otherCoordPairs = new byte[]{(byte) 2, (byte) 0, (byte) 0, (byte) 1, (byte) 2, (byte) 1};
+    Random rand = new Random();
+    private World worldObj;
+    private BlockPos basePos;
+    private int heightLimit;
+    private int height;
+    private double heightAttenuation;
+    private double branchSlope;
+    private double scaleWidth;
+    private double leafDensity;
+    private int leafDistanceLimit;
+    private int[][] leafNodes;
+
+    public WorldGenWastelandBigTree(boolean par1) {
+        super(par1);
+        this.basePos = BlockPos.ORIGIN;
+        this.heightLimit = 0;
+        this.heightAttenuation = 0.45D;
+        this.branchSlope = 0.2D;
+        this.scaleWidth = 1.0D;
+        this.leafDensity = 1.0D;
+        this.leafDistanceLimit = 4;
+    }
+
+    void generateLeafNodeList() {
+        this.height = (int) ((double) this.heightLimit * this.heightAttenuation);
+        if (this.height >= this.heightLimit) {
+            this.height = this.heightLimit - 1;
+        }
+
+        int var1 = (int) (1.382D + Math.pow(this.leafDensity * (double) this.heightLimit / 13.0D, 2.0D));
+        if (var1 < 1) {
+            var1 = 1;
+        }
+
+        int[][] var2 = new int[var1 * this.heightLimit][4];
+        int var3 = this.basePos.getY() + this.heightLimit - this.leafDistanceLimit;
+        int var4 = 1;
+        int var5 = this.basePos.getY() + this.height;
+        int var6 = var3 - this.basePos.getY();
+        var2[0][0] = this.basePos.getX();
+        var2[0][1] = var3;
+        var2[0][2] = this.basePos.getZ();
+        var2[0][3] = var5;
+        --var3;
+
+        while (true) {
+            while (var6 >= 0) {
+                int var7 = 0;
+                float var8 = this.layerSize(var6);
+                if (var8 < 0.0F) {
+                    --var3;
+                    --var6;
+                } else {
+                    for (double var9 = 0.5D; var7 < var1; ++var7) {
+                        double var11 = this.scaleWidth * (double) var8 * ((double) this.rand.nextFloat() + 0.328D);
+                        double var13 = (double) this.rand.nextFloat() * 2.0D * 3.141592653589793D;
+                        int var15 = MathHelper.floor(var11 * Math.sin(var13) + (double) this.basePos.getX() + var9);
+                        int var16 = MathHelper.floor(var11 * Math.cos(var13) + (double) this.basePos.getZ() + var9);
+                        int[] var17 = new int[]{var15, var3, var16};
+                        int[] var18 = new int[]{var15, var3 + this.leafDistanceLimit, var16};
+                        if (this.checkBlockLine(var17, var18) == -1) {
+                            int[] PositionData = new int[]{this.basePos.getX(), this.basePos.getY(), this.basePos.getZ()};
+                            double var20 = Math.sqrt(Math.pow((double) Math.abs(this.basePos.getX() - var17[0]), 2.0D) + Math.pow((double) Math.abs(this.basePos.getZ() - var17[2]), 2.0D));
+                            double var22 = var20 * this.branchSlope;
+                            if ((double) var17[1] - var22 > (double) var5) {
+                                PositionData[1] = var5;
+                            } else {
+                                PositionData[1] = (int) ((double) var17[1] - var22);
+                            }
+
+                            if (this.checkBlockLine(PositionData, var17) == -1) {
+                                var2[var4][0] = var15;
+                                var2[var4][1] = var3;
+                                var2[var4][2] = var16;
+                                var2[var4][3] = PositionData[1];
+                                ++var4;
+                            }
+                        }
+                    }
+
+                    --var3;
+                    --var6;
+                }
+            }
+
+            this.leafNodes = new int[var4][4];
+            System.arraycopy(var2, 0, this.leafNodes, 0, var4);
+            return;
+        }
+    }
+
+    void genTreeLayer(int par1, int par2, int par3, float par4, byte par5, Block log) {
+        int var7 = (int) ((double) par4 + 0.618D);
+        byte var8 = otherCoordPairs[par5];
+        byte var9 = otherCoordPairs[par5 + 3];
+        int[] var10 = new int[]{par1, par2, par3};
+        int[] positionData = new int[]{0, 0, 0};
+        int var12 = -var7;
+        int var13 = -var7;
+
+        label35:
+        for (positionData[par5] = var10[par5]; var12 <= var7; ++var12) {
+            positionData[var8] = var10[var8] + var12;
+            var13 = -var7;
+
+            while (true) {
+                while (true) {
+                    if (var13 > var7) {
+                        continue label35;
+                    }
+
+                    double var15 = Math.pow((double) Math.abs(var12) + 0.5D, 2.0D) + Math.pow((double) Math.abs(var13) + 0.5D, 2.0D);
+                    if (var15 > (double) (par4 * par4)) {
+                        ++var13;
+                    } else {
+                        positionData[var9] = var10[var9] + var13;
+                        BlockPos pos = new BlockPos(positionData[0], positionData[1], positionData[2]);
+                        Block block = this.worldObj.getBlockState(pos).getBlock();
+                        if (!this.worldObj.isAirBlock(pos) && block != Blocks.LEAVES && block != Blocks.LEAVES2) {
+                            ++var13;
+                        } else {
+                            this.setBlockAndNotifyAdequately(this.worldObj, pos, log.getDefaultState());
+                            ++var13;
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    float layerSize(int par1) {
+        if ((double) par1 < (double) this.heightLimit * 0.3D) {
+            return -1.618F;
+        } else {
+            float var2 = (float) this.heightLimit / 2.0F;
+            float var3 = (float) this.heightLimit / 2.0F - (float) par1;
+            float var4;
+            if (var3 == 0.0F) {
+                var4 = var2;
+            } else if (Math.abs(var3) >= var2) {
+                var4 = 0.0F;
+            } else {
+                var4 = (float) Math.sqrt(Math.pow((double) Math.abs(var2), 2.0D) - Math.pow((double) Math.abs(var3), 2.0D));
+            }
+
+            var4 *= 0.5F;
+            return var4;
+        }
+    }
+
+    void placeBlockLine(int[] par1ArrayOfInteger, int[] par2ArrayOfInteger, Block block) {
+        int[] var4 = new int[]{0, 0, 0};
+        byte var5 = 0;
+
+        byte var6;
+        for (var6 = 0; var5 < 3; ++var5) {
+            var4[var5] = par2ArrayOfInteger[var5] - par1ArrayOfInteger[var5];
+            if (Math.abs(var4[var5]) > Math.abs(var4[var6])) {
+                var6 = var5;
+            }
+        }
+
+        if (var4[var6] != 0) {
+            byte var7 = otherCoordPairs[var6];
+            byte var8 = otherCoordPairs[var6 + 3];
+            byte var9;
+            if (var4[var6] > 0) {
+                var9 = 1;
+            } else {
+                var9 = -1;
+            }
+
+            double var10 = (double) var4[var7] / (double) var4[var6];
+            double var12 = (double) var4[var8] / (double) var4[var6];
+            int[] positionData = new int[]{0, 0, 0};
+            int positionModifer = 0;
+
+            for (int baseModifier = var4[var6] + var9; positionModifer != baseModifier; positionModifer += var9) {
+                positionData[var6] = MathHelper.floor((double) (par1ArrayOfInteger[var6] + positionModifer) + 0.5D);
+                positionData[var7] = MathHelper.floor((double) par1ArrayOfInteger[var7] + (double) positionModifer * var10 + 0.5D);
+                positionData[var8] = MathHelper.floor((double) par1ArrayOfInteger[var8] + (double) positionModifer * var12 + 0.5D);
+                this.setBlockAndNotifyAdequately(this.worldObj, new BlockPos(positionData[0], positionData[1], positionData[2]), block.getDefaultState());
+            }
+        }
+
+    }
+
+    public boolean leafNodeNeedsBase(int par1) {
+        return (double) par1 >= (double) this.heightLimit * 0.2D;
+    }
+
+    public void generateTrunk() {
+        int var1 = this.basePos.getX();
+        int var2 = this.basePos.getY();
+        int var3 = this.basePos.getY() + this.height;
+        int var4 = this.basePos.getZ();
+        int[] var5 = new int[]{var1, var2, var4};
+        int[] var6 = new int[]{var1, var3, var4};
+        this.placeBlockLine(var5, var6, Blocks.LOG);
+    }
+
+    public void generateLeafNodeBases() {
+        int var1 = 0;
+        int var2 = this.leafNodes.length;
+
+        for (int[] var3 = new int[]{this.basePos.getX(), this.basePos.getY(), this.basePos.getZ()}; var1 < var2; ++var1) {
+            int[] var4 = this.leafNodes[var1];
+            int[] var5 = new int[]{var4[0], var4[1], var4[2]};
+            var3[1] = var4[3];
+            int var6 = var3[1] - this.basePos.getY();
+            if (this.leafNodeNeedsBase(var6)) {
+                this.placeBlockLine(var3, var5, Blocks.LOG);
+            }
+        }
+
+    }
+
+    public int checkBlockLine(int[] par1ArrayOfInteger, int[] par2ArrayOfInteger) {
+        int[] var3 = new int[]{0, 0, 0};
+        byte var4 = 0;
+
+        byte var5;
+        for (var5 = 0; var4 < 3; ++var4) {
+            var3[var4] = par2ArrayOfInteger[var4] - par1ArrayOfInteger[var4];
+            if (Math.abs(var3[var4]) > Math.abs(var3[var5])) {
+                var5 = var4;
+            }
+        }
+
+        if (var3[var5] == 0) {
+            return -1;
+        } else {
+            byte var6 = otherCoordPairs[var5];
+            byte var7 = otherCoordPairs[var5 + 3];
+            byte var8;
+            if (var3[var5] > 0) {
+                var8 = 1;
+            } else {
+                var8 = -1;
+            }
+
+            double var9 = (double) var3[var6] / (double) var3[var5];
+            double var11 = (double) var3[var7] / (double) var3[var5];
+            int[] positionData = new int[]{0, 0, 0};
+            int var14 = 0;
+
+            int var15;
+            for (var15 = var3[var5] + var8; var14 != var15; var14 += var8) {
+                positionData[var5] = par1ArrayOfInteger[var5] + var14;
+                positionData[var6] = MathHelper.floor((double) par1ArrayOfInteger[var6] + (double) var14 * var9);
+                positionData[var7] = MathHelper.floor((double) par1ArrayOfInteger[var7] + (double) var14 * var11);
+                BlockPos pos = new BlockPos(positionData[0], positionData[1], positionData[2]);
+                Block block = this.worldObj.getBlockState(pos).getBlock();
+                if (!this.worldObj.isAirBlock(pos) && block != Blocks.LEAVES && block != Blocks.LEAVES2) {
+                    break;
+                }
+            }
+
+            return var14 == var15 ? -1 : Math.abs(var14);
+        }
+    }
+
+    private boolean validBigTreeLocation() {
+        return this.worldObj.getBlockState(this.basePos.down()).getBlock() == Blocks.DIRT;
+    }
+
+    public boolean generate(World world, Random random, BlockPos pos) {
+        this.worldObj = world;
+        this.rand.setSeed(random.nextLong());
+        this.basePos = pos;
+        if (this.heightLimit == 0) {
+            this.heightLimit = 12 + random.nextInt(5);
+        }
+
+        if (this.validBigTreeLocation()) {
+            this.generateLeafNodeList();
+            this.generateTrunk();
+            this.generateLeafNodeBases();
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/marble_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/marble_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/marble_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/marble_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/small_limestone_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/small_limestone_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/small_limestone_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/small_limestone_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityWhale.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityWhale.java	(date 1523986183000)
+++ src/main/java/net/hdt/neutronia/entity/EntityWhale.java	(date 1523986183000)
@@ -0,0 +1,17 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.world.World;
+
+public class EntityWhale extends EntityWaterMob {
+
+    public EntityWhale(World worldIn) {
+        super(worldIn);
+        setSize(0.5F, 0.5F);
+    }
+
+    protected void initEntityAI() {
+        super.initEntityAI();
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_blue_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMagmaBricksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMagmaBricksStairs.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMagmaBricksStairs.java	(date 1525606882000)
@@ -0,0 +1,31 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.MagmaBricks;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public class BlockMagmaBricksStairs extends BlockOverworldStairBase {
+
+    public BlockMagmaBricksStairs() {
+        super("magma_bricks_stairs", MagmaBricks.magma_bricks.getDefaultState());
+        useNeighborBrightness = false;
+        setLightLevel(0.2F);
+    }
+
+    @Override
+    public boolean isFireSource(World world, BlockPos pos, EnumFacing side) {
+        return isSideSolid(world.getBlockState(pos), world, pos, side);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_blue_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_blue_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_brown_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_brown_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/utils/FormationCaveGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/FormationCaveGenerator.java	(date 1523988243000)
+++ src/main/java/net/hdt/neutronia/world/utils/FormationCaveGenerator.java	(date 1523988243000)
@@ -0,0 +1,160 @@
+package net.hdt.neutronia.world.utils;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+public class FormationCaveGenerator implements IWorldGenerator {
+
+    public FormationCaveGenerator() {
+
+    }
+
+    @Override
+    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
+        int x = chunkX * 16 + random.nextInt(16);
+        int z = chunkZ * 16 + random.nextInt(16);
+
+        for (int i = 15; i < 50; i++) {
+            BlockPos pos = new BlockPos(x, i, z);
+            BlockPos belowPos = pos.down();
+            IBlockState state = world.getBlockState(pos);
+            IBlockState stateBelow = world.getBlockState(belowPos);
+            if (state.getBlock().isAir(state, world, pos) && stateBelow.getBlock() == Blocks.STONE) {
+                makeFormationCaveAt(world, pos, random);
+                return;
+            }
+        }
+    }
+
+    public void makeFormationCaveAt(World world, BlockPos source, Random rand) {
+        double expandX = (rand.nextDouble() - 0.5) * 2;
+        double expandY = (rand.nextDouble() - 0.5) * 0.1F;
+        double expandZ = (rand.nextDouble() - 0.5) * 2;
+
+        double curveAngle = rand.nextDouble() * Math.PI * 2;
+        double curveRatio = rand.nextDouble() * 0.25 + 0.1;
+        double curveX = Math.cos(curveAngle) * curveRatio;
+        double curveY = (rand.nextFloat() - 0.5F) * 0.05F;
+        double curveZ = Math.sin(curveAngle) * curveRatio;
+
+        BlockPos hollowingCenter = source;
+        Vec3d expansion = new Vec3d(expandX, expandY, expandZ).normalize();
+        Vec3d curvature = new Vec3d(curveX, curveY, curveZ);
+
+        int color1 = rand.nextInt(5);
+        int color2;
+        do {
+            color2 = rand.nextInt(5);
+        } while (color2 == color1);
+
+        IBlockState crystal1 = HMBlocks.brain_coral[color1].getDefaultState();
+        IBlockState crystal2 = HMBlocks.brain_coral[color2].getDefaultState();
+
+        int length = 12 + rand.nextInt(10);
+        int size = 4 + rand.nextInt(3);
+        for (int i = 0; i < length; i++) {
+            hollowOut(world, hollowingCenter, rand, size, crystal1, crystal2);
+
+            BlockPos currentCenter = hollowingCenter;
+            hollowingCenter = currentCenter.add(expansion.x * size * 0.5, expansion.y * size * 0.5, expansion.z * size * 0.5);
+
+            if (hollowingCenter.getY() < 10) {
+                expansion = new Vec3d(expansion.x, -expansion.y, expansion.z);
+                curvature = new Vec3d(curvature.x, -curvature.y, curvature.z);
+                currentCenter = hollowingCenter.add(expansion.x * size * 0.5, expansion.y * size * 0.5, expansion.z * size * 0.5);
+            }
+
+            expansion = expansion.add(curvature).normalize();
+        }
+    }
+
+    private void hollowOut(World world, BlockPos source, Random rand, int width, IBlockState block1, IBlockState block2) {
+        List<BlockPos> blocks = new ArrayList<>();
+
+        int max = width * width;
+        for (int i = -width; i <= width; i++)
+            for (int j = -width; j <= width; j++)
+                for (int k = -width; k <= width; k++) {
+                    BlockPos pos = source.add(i, j, k);
+                    int dist = i * i + j * j + k * k;
+
+                    if (dist < max) {
+                        IBlockState state = world.getBlockState(pos);
+                        Block block = state.getBlock();
+
+                        if (block.getBlockHardness(state, world, pos) != -1)
+                            world.setBlockToAir(pos);
+                    } else if (dist - 1 < max)
+                        blocks.add(pos);
+                }
+
+        for (BlockPos pos : blocks) {
+            if (rand.nextInt(3) == 0)
+                makeFormation(world, pos, rand, rand.nextBoolean() ? block1 : block2);
+            else if (rand.nextInt(2) == 0) {
+                IBlockState stateAt = world.getBlockState(pos);
+                Block blockAt = stateAt.getBlock();
+                if (blockAt.isAir(stateAt, world, pos) || blockAt == block1.getBlock() || blockAt == block2.getBlock() || blockAt.getBlockHardness(stateAt, world, pos) == -1)
+                    continue;
+
+                IBlockState oreState = Blocks.GOLD_ORE.getDefaultState();
+                if (rand.nextInt(3) == 0) {
+                    if (rand.nextInt(3) == 0)
+                        oreState = Blocks.DIAMOND_ORE.getDefaultState();
+                    else oreState = Blocks.EMERALD_ORE.getDefaultState();
+                }
+
+                world.setBlockState(pos, oreState);
+            }
+        }
+
+    }
+
+    private void makeFormation(World world, BlockPos source, Random rand, IBlockState formationBlock) {
+        boolean up = rand.nextBoolean();
+        EnumFacing shift = up ? EnumFacing.UP : EnumFacing.DOWN;
+
+        BlockPos startPos = source;
+        IBlockState state = world.getBlockState(startPos);
+        if (state.getBlock() == formationBlock.getBlock())
+            return;
+
+        int tests = 0;
+
+        while (state.getBlock().isAir(state, world, startPos)) {
+            startPos = startPos.offset(shift.getOpposite());
+            state = world.getBlockState(startPos);
+
+            tests++;
+            if (tests >= 10)
+                return;
+        }
+
+        int size = 3 + rand.nextInt(4);
+
+        BlockPos pos = startPos;
+        for (int i = 0; i < size; i++) {
+            IBlockState stateAt = world.getBlockState(pos);
+            Block block = stateAt.getBlock();
+            if (block.getBlockHardness(stateAt, world, pos) == -1)
+                break;
+
+            world.setBlockState(pos, formationBlock);
+            pos = pos.offset(shift);
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesSlab.java	(date 1523986200000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesSlab.java	(date 1523986200000)
@@ -0,0 +1,24 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+
+public class BlockHardenedClayTilesSlab extends BlockOverworldSlabBase {
+
+    public BlockHardenedClayTilesSlab(boolean doubleSlab) {
+        super("hardened_clay_tiles_slab", Material.ROCK, doubleSlab);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_blue_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_blue_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_pink_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_pink_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_lime_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_lime_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_lime_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/small_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/small_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/small_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/small_aquamarine_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/raw_meteorite.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_meteorite.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/raw_meteorite.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_meteorite"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSnowBricksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSnowBricksStairs.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockSnowBricksStairs.java	(date 1525606878000)
@@ -0,0 +1,44 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [18/04/2016, 22:53:42 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.SnowBricks;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.Item;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+
+import java.util.Random;
+
+public class BlockSnowBricksStairs extends BlockOverworldStairBase {
+
+    public BlockSnowBricksStairs() {
+        super("snow_bricks_stairs", SnowBricks.snow_bricks.getDefaultState());
+    }
+
+    @Override
+    public boolean isToolEffective(String type, IBlockState state) {
+        return type.equals("shovel");
+    }
+
+    @Override
+    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player) {
+        return true;
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/smooth_basalt.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/smooth_basalt.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/smooth_basalt.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/smooth_basalt"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemWoodenChestBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemWoodenChestBlock.java	(date 1525012311000)
+++ src/main/java/net/hdt/neutronia/items/ItemWoodenChestBlock.java	(date 1525012311000)
@@ -0,0 +1,106 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.blocks.overworld.BlockCustomChest;
+import net.hdt.neutronia.init.HMBlocks;
+import net.hdt.neutronia.properties.ChestType;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.ItemStack;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IExtraVariantHolder;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ItemWoodenChestBlock extends ItemModBlock implements IExtraVariantHolder {
+
+    public ItemWoodenChestBlock(Block block, ResourceLocation res) {
+        super(block, res);
+        setHasSubtypes(true);
+    }
+
+    @Override
+    public int getMetadata(int damage) {
+        return 0;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return stack -> {
+            ChestType type = HMBlocks.customChest.getCustomType(stack);
+            return getBlock() == HMBlocks.customChestTrap ? type.trapModel : type.normalModel;
+        };
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack stack) {
+        ChestType type = HMBlocks.customChest.getCustomType(stack);
+        String name = type.name + (getBlock() == HMBlocks.customChestTrap ? "_trap" : "");
+        return "tile.custom_chest_" + name;
+    }
+
+    @Override
+    public boolean placeBlockAt(ItemStack stack, EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, IBlockState newState) {
+        int typeCnt = 0;
+
+        BlockPos posN = pos.north();
+        BlockPos posS = pos.south();
+        BlockPos posW = pos.west();
+        BlockPos posE = pos.east();
+
+        BlockCustomChest cChest = (BlockCustomChest) getBlock();
+        ChestType myType = cChest.getCustomType(stack);
+
+        if (world.getBlockState(posN).getBlock() == block && cChest.getCustomType(world, posN) == myType)
+            typeCnt += cChest.isDoubleChest(world, posN, myType) ? 2 : 1;
+        if (world.getBlockState(posS).getBlock() == block && cChest.getCustomType(world, posS) == myType)
+            typeCnt += cChest.isDoubleChest(world, posS, myType) ? 2 : 1;
+        if (world.getBlockState(posW).getBlock() == block && cChest.getCustomType(world, posW) == myType)
+            typeCnt += cChest.isDoubleChest(world, posW, myType) ? 2 : 1;
+        if (world.getBlockState(posE).getBlock() == block && cChest.getCustomType(world, posE) == myType)
+            typeCnt += cChest.isDoubleChest(world, posE, myType) ? 2 : 1;
+
+        if (typeCnt <= 1 && super.placeBlockAt(stack, player, world, pos, side, hitX, hitY, hitZ, newState)) {
+            TileEntity te = world.getTileEntity(pos);
+            if (te instanceof TileCustomChest) {
+                ((TileCustomChest) te).chestType = myType;
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> subItems) {
+        BlockCustomChest chest = (BlockCustomChest) Block.getBlockFromItem(this);
+        if (isInCreativeTab(tab))
+            for (ChestType type : ChestType.VALID_TYPES)
+                subItems.add(chest.setCustomType(new ItemStack(this, 1), type));
+    }
+
+    @Override
+    public String[] getExtraVariants() {
+        List<String> variants = new ArrayList();
+        for (ChestType type : ChestType.VALID_TYPES) {
+            variants.add("custom_chest_" + type.name);
+            variants.add("custom_chest_trap_" + type.name);
+        }
+
+        return variants.toArray(new String[variants.size()]);
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/chiseled_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/chiseled_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/chiseled_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/chiseled_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_gray_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_gray_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_black_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_magenta_terracotta.json	(date 1525306811000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/frosted_magenta_terracotta"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockDuskboundStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockDuskboundStairs.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockDuskboundStairs.java	(date 1525606880000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherStairBase;
+import net.hdt.neutronia.modules.building.features.DuskboundBlocks;
+
+public class BlockDuskboundStairs extends BlockNetherStairBase {
+
+    public BlockDuskboundStairs() {
+        super("duskbound_block_stairs", DuskboundBlocks.duskbound_block.getDefaultState());
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/smooth_marble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/smooth_marble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/smooth_marble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/smooth_marble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/smooth_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/smooth_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/blockstates/smooth_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/smooth_aquamarine"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockVanillaStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockVanillaStairs.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockVanillaStairs.java	(date 1525606885000)
@@ -0,0 +1,24 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 19:34:22 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockVanillaStairs extends BlockOverworldStairBase {
+
+    public BlockVanillaStairs(String name, IBlockState state) {
+        super(name, state);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/cracked_marble_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/cracked_marble_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/cracked_marble_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/cracked_marble_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_red_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_red_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_red_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/smooth_limestone.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/smooth_limestone.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/smooth_limestone.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/smooth_limestone"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_cyan_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_cyan_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/granite_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/granite_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/granite_cobble.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/granite_cobble"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderScorp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderScorp.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderScorp.java	(date 1525606862000)
@@ -0,0 +1,37 @@
+package net.hdt.neutronia.entity.render;
+
+import com.google.common.collect.Maps;
+import net.hdt.neutronia.entity.EntityScorp;
+import net.hdt.neutronia.entity.render.model.ModelScorpion;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+import java.util.Map;
+
+public class RenderScorp extends RenderLiving<EntityScorp> {
+
+    private static final Map<String, ResourceLocation> LAYERED_LOCATION_CACHE = Maps.newHashMap();
+
+    public RenderScorp(RenderManager manager) {
+        super(manager, new ModelScorpion(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityScorp entity) {
+        String s = entity.getHorseTexture();
+        ResourceLocation resourcelocation = LAYERED_LOCATION_CACHE.get(s);
+
+        if (resourcelocation == null) {
+            resourcelocation = new ResourceLocation(s);
+            LAYERED_LOCATION_CACHE.put(s, resourcelocation);
+        }
+
+        return resourcelocation;
+    }
+
+    @Override
+    protected void applyRotations(EntityScorp entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/properties/ChestType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/ChestType.java	(date 1525012657000)
+++ src/main/java/net/hdt/neutronia/properties/ChestType.java	(date 1525012657000)
@@ -0,0 +1,49 @@
+package net.hdt.neutronia.properties;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.util.ResourceLocation;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public enum ChestType {
+    NONE(""),
+    SPRUCE("spruce"),
+    BIRCH("birch"),
+    JUNGLE("jungle"),
+    ACACIA("acacia"),
+    DARK_OAK("dark_oak"),
+    REDWOOD("redwood"),
+    PALM("palm"),
+    CHERRY("cherry");
+
+    public static final ChestType[] VALID_TYPES;
+    public static final Map<String, ChestType> NAME_TO_TYPE;
+
+    static {
+        VALID_TYPES = new ChestType[]{SPRUCE, BIRCH, JUNGLE, ACACIA, DARK_OAK};
+        NAME_TO_TYPE = new HashMap<>();
+        for (ChestType type : VALID_TYPES)
+            NAME_TO_TYPE.put(type.name, type);
+    }
+
+    public final String name;
+    public final ResourceLocation nrmTex;
+    public final ResourceLocation dblTex;
+    public final ModelResourceLocation normalModel;
+    public final ModelResourceLocation trapModel;
+
+    ChestType(String name) {
+        this.name = name;
+        nrmTex = new ResourceLocation(Reference.MOD_ID, "textures/blocks/chests/" + name + ".png");
+        dblTex = new ResourceLocation(Reference.MOD_ID, "textures/blocks/chests/" + name + "_double.png");
+
+        normalModel = new ModelResourceLocation(new ResourceLocation(Reference.MOD_ID, "custom_chest_" + name), "inventory");
+        trapModel = new ModelResourceLocation(new ResourceLocation(Reference.MOD_ID, "custom_chest_trap_" + name), "inventory");
+    }
+
+    public static ChestType getType(String type) {
+        return NAME_TO_TYPE.getOrDefault(type, NONE);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockIronPlateStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockIronPlateStairs.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockIronPlateStairs.java	(date 1525606881000)
@@ -0,0 +1,22 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/06/2016, 14:51:44 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.IronPlates;
+
+public class BlockIronPlateStairs extends BlockOverworldStairBase {
+
+    public BlockIronPlateStairs() {
+        super("iron_plate_stairs", IronPlates.iron_plate.getDefaultState());
+    }
+
+}
Index: src/main/resources/assets/neutronia/blockstates/raw_limestone.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/raw_limestone.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/raw_limestone.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/raw_limestone"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab_double.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab_double.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_yellow_terracotta_slab_double.json	(date 1525306811000)
@@ -0,0 +1,11 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "prop": {
+      "blarg": {
+        "model": "neutronia:upper_frosted_yellow_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/base/tools/BaseAxe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/tools/BaseAxe.java	(date 1523988241000)
+++ src/main/java/net/hdt/neutronia/items/base/tools/BaseAxe.java	(date 1523988241000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.items.base.tools;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.items.ItemModAxe;
+
+public class BaseAxe extends ItemModAxe {
+
+    public BaseAxe(String name, ToolMaterial material) {
+        super(material.getAttackDamage(), 1.0f, material, name, Reference.MOD_ID);
+        setCreativeTab(CreativeTabs.TOOLS);
+    }
+}
Index: src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/blockstates/frosted_black_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,14 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "forge_marker": 1,
+  "variants": {
+    "half": {
+      "top": {
+        "model": "neutronia:upper_frosted_black_terracotta_slab"
+      },
+      "bottom": {
+        "model": "neutronia:half_frosted_black_terracotta_slab"
+      }
+    }
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/blockstates/diorite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/blockstates/diorite_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/blockstates/diorite_bricks.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "forge_marker": 1,
+  "defaults": {
+    "model": "cube_all",
+    "textures": {
+      "all": "neutronia:blocks/diorite_bricks"
+    },
+    "transform": "forge:default-block"
+  },
+  "variants": {
+    "normal": [
+      {}
+    ],
+    "inventory": [
+      {}
+    ]
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemBase.java	(date 1523988245000)
+++ src/main/java/net/hdt/neutronia/items/ItemBase.java	(date 1523988245000)
@@ -0,0 +1,14 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.items.ItemMod;
+
+public class ItemBase extends ItemMod {
+
+    public ItemBase(String name, CreativeTabs creativeTabs) {
+        super(name, Reference.MOD_ID);
+        setCreativeTab(creativeTabs);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockGlowingGrass.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockGlowingGrass.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockGlowingGrass.java	(date 1523987839000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.util.Reference;
+import net.thegaminghuskymc.huskylib2.blocks.BlockLightSource;
+
+public class BlockGlowingGrass extends BlockLightSource {
+
+    public BlockGlowingGrass() {
+        super(Reference.MOD_ID, "glowing_grass");
+        this.setLightLevel(2.0F);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/DuskboundBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/DuskboundBlocks.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/DuskboundBlocks.java	(date 1525606881000)
@@ -0,0 +1,58 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockDuskbound;
+import net.hdt.neutronia.modules.building.blocks.BlockDuskboundLantern;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockDuskboundSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockDuskboundStairs;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+import net.thegaminghuskymc.huskylib2.recipie.RecipeHandler;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class DuskboundBlocks extends Feature {
+
+    public static Block duskbound_block;
+    public static Block duskbound_lantern;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        duskbound_block = new BlockDuskbound();
+        duskbound_lantern = new BlockDuskboundLantern();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(duskbound_block, 0, new BlockDuskboundStairs());
+            BlockModSlab.initSlab(duskbound_block, 0, new BlockDuskboundSlab(false), new BlockDuskboundSlab(true));
+        }
+
+        VanillaWalls.add("duskbound_block", duskbound_block, 0, enableWalls);
+
+        RecipeHandler.addShapedRecipe(ProxyRegistry.newStack(duskbound_block, 16),
+                "PPP", "POP", "PPP",
+                'P', ProxyRegistry.newStack(Blocks.PURPUR_BLOCK),
+                'O', ProxyRegistry.newStack(Blocks.OBSIDIAN));
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(duskbound_lantern, 4),
+				"DDD", "DED", "DDD",
+				'D', ProxyRegistry.newStack(duskbound_block),
+				'E', ProxyRegistry.newStack(Items.ENDER_PEARL));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/interfaces/IStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/interfaces/IStructure.java	(date 1523986179000)
+++ src/main/java/net/hdt/neutronia/util/interfaces/IStructure.java	(date 1523986179000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.util.interfaces;
+
+import net.minecraft.util.Mirror;
+import net.minecraft.util.Rotation;
+import net.minecraft.world.WorldServer;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraftforge.fml.common.FMLCommonHandler;
+
+public interface IStructure {
+    WorldServer worldServer = FMLCommonHandler.instance().getMinecraftServerInstance().getWorld(0);
+    PlacementSettings settings = (new PlacementSettings()).setChunk(null).setIgnoreEntities(false).setIgnoreStructureBlock(false).setMirror(Mirror.NONE).setRotation(Rotation.NONE);
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/WorldStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/WorldStoneBricks.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/WorldStoneBricks.java	(date 1525606896000)
@@ -0,0 +1,126 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 19:56:42 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockWorldStoneBricks;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockVanillaSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockVanillaStairs;
+import net.minecraft.block.state.IBlockState;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.compat.ModIntegrationHandler;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class WorldStoneBricks extends Feature {
+
+    public static BlockMod world_stone_bricks;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        world_stone_bricks = new BlockWorldStoneBricks();
+
+        if (enableStairsAndSlabs) {
+            for (BlockWorldStoneBricks.Variants variant : BlockWorldStoneBricks.Variants.class.getEnumConstants()) {
+                if (!variant.isEnabled())
+                    continue;
+
+                IBlockState state = world_stone_bricks.getDefaultState().withProperty(world_stone_bricks.getVariantProp(), variant);
+                String name = variant.getName() + "_stairs";
+                BlockModStairs.initStairs(world_stone_bricks, variant.ordinal(), new BlockVanillaStairs(name, state));
+            }
+
+            for (BlockWorldStoneBricks.Variants variant : BlockWorldStoneBricks.Variants.class.getEnumConstants()) {
+                if (!variant.isEnabled())
+                    continue;
+
+                IBlockState state = world_stone_bricks.getDefaultState().withProperty(world_stone_bricks.getVariantProp(), variant);
+                String name = variant.getName() + "_slab";
+                BlockModSlab.initSlab(world_stone_bricks, variant.ordinal(), new BlockVanillaSlab(name, state, false), new BlockVanillaSlab(name, state, true));
+            }
+        }
+
+        if (enableWalls)
+            for (BlockWorldStoneBricks.Variants variant : BlockWorldStoneBricks.Variants.class.getEnumConstants()) {
+                if (!variant.isEnabled())
+                    continue;
+
+                world_stone_bricks.getDefaultState().withProperty(world_stone_bricks.getVariantProp(), variant);
+                String name = variant.getName();
+//			VanillaWalls.add(name, world_stone_bricks, variant.ordinal(), true);
+            }
+    }
+
+    @Override
+    public void postPreInit(FMLPreInitializationEvent event) {
+		/*for(int i = 0; i < 3; i++)
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(world_stone_bricks, 4, i),
+					"SS", "SS",
+					'S', ProxyRegistry.newStack(Blocks.STONE, 1, i * 2 + 2));*/
+
+		/*if(BlockWorldStoneBricks.Variants.STONE_BASALT_BRICKS.isEnabled()) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(world_stone_bricks, 4, 3),
+					"SS", "SS",
+					'S', ProxyRegistry.newStack(Basalt.basalt, 1, 1));
+		}
+		
+		if(BlockWorldStoneBricks.Variants.STONE_MARBLE_BRICKS.isEnabled()) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(world_stone_bricks, 4, 4),
+					"SS", "SS",
+					'S', ProxyRegistry.newStack(RevampStoneGen.marble, 1, 1));
+		}
+		
+		if(BlockWorldStoneBricks.Variants.STONE_LIMESTONE_BRICKS.isEnabled()) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(world_stone_bricks, 4, 5),
+					"SS", "SS",
+					'S', ProxyRegistry.newStack(RevampStoneGen.limestone, 1, 1));
+		}*/
+    }
+
+    @Override
+    public void init(FMLInitializationEvent event) {
+        ModIntegrationHandler.registerChiselVariant("granite", ProxyRegistry.newStack(world_stone_bricks, 1, 0));
+        ModIntegrationHandler.registerChiselVariant("diorite", ProxyRegistry.newStack(world_stone_bricks, 1, 1));
+        ModIntegrationHandler.registerChiselVariant("andesite", ProxyRegistry.newStack(world_stone_bricks, 1, 2));
+
+		/*if(BlockWorldStoneBricks.Variants.STONE_BASALT_BRICKS.isEnabled()) {
+			ModIntegrationHandler.registerChiselVariant("basalt", ProxyRegistry.newStack(world_stone_bricks, 1, 3));
+		}
+
+		if(BlockWorldStoneBricks.Variants.STONE_MARBLE_BRICKS.isEnabled()) {
+			ModIntegrationHandler.registerChiselVariant("marble", ProxyRegistry.newStack(world_stone_bricks, 1, 4));
+		}
+
+		if(BlockWorldStoneBricks.Variants.STONE_LIMESTONE_BRICKS.isEnabled()) {
+			ModIntegrationHandler.registerChiselVariant("limestone", ProxyRegistry.newStack(world_stone_bricks, 1, 5));
+		}*/
+
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/handlers/ItemEventHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/ItemEventHandler.java	(date 1523988240000)
+++ src/main/java/net/hdt/neutronia/util/handlers/ItemEventHandler.java	(date 1523988240000)
@@ -0,0 +1,78 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.GuiScreen;
+import net.minecraft.client.renderer.BufferBuilder;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.RenderHelper;
+import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.init.Items;
+import net.minecraft.item.ItemMap;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.storage.MapData;
+import net.minecraftforge.client.event.RenderTooltipEvent;
+import net.minecraftforge.event.entity.player.ItemTooltipEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.EventPriority;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@Mod.EventBusSubscriber(modid = Reference.MOD_ID, value = Side.CLIENT)
+public class ItemEventHandler {
+
+    private static final ResourceLocation RES_MAP_BACKGROUND = new ResourceLocation("textures/map/map_background.png");
+
+    boolean requireShift = false;
+
+    @SubscribeEvent(priority = EventPriority.HIGHEST)
+    public void makeTooltip(ItemTooltipEvent event) {
+        if (!event.getItemStack().isEmpty() && event.getItemStack().getItem() instanceof ItemMap) {
+            if (requireShift && !GuiScreen.isShiftKeyDown())
+                event.getToolTip().add(1, I18n.translateToLocal("neutronia.mapShift"));
+        }
+    }
+
+    @SubscribeEvent
+    @SideOnly(Side.CLIENT)
+    public void renderTooltip(RenderTooltipEvent.PostText event) {
+        if (event.getStack().getItem() instanceof ItemMap && (!requireShift || GuiScreen.isShiftKeyDown())) {
+            Minecraft mc = Minecraft.getMinecraft();
+
+            MapData mapdata = Items.FILLED_MAP.getMapData(event.getStack(), mc.world);
+            if (mapdata == null)
+                return;
+
+            GlStateManager.pushMatrix();
+            GlStateManager.color(1F, 1F, 1F);
+            RenderHelper.disableStandardItemLighting();
+            mc.getTextureManager().bindTexture(RES_MAP_BACKGROUND);
+            Tessellator tessellator = Tessellator.getInstance();
+            BufferBuilder vertexbuffer = tessellator.getBuffer();
+
+            int pad = 7;
+            float size = 135;
+            float scale = 0.5F;
+
+            GlStateManager.translate(event.getX(), event.getY() - size * scale - 5, 0);
+            GlStateManager.scale(scale, scale, scale);
+
+            vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
+            vertexbuffer.pos(-pad, size, 0.0D).tex(0.0D, 1.0D).endVertex();
+            vertexbuffer.pos(size, size, 0.0D).tex(1.0D, 1.0D).endVertex();
+            vertexbuffer.pos(size, -pad, 0.0D).tex(1.0D, 0.0D).endVertex();
+            vertexbuffer.pos(-pad, -pad, 0.0D).tex(0.0D, 0.0D).endVertex();
+            tessellator.draw();
+
+            mc.entityRenderer.getMapItemRenderer().renderMap(mapdata, false);
+
+
+            GlStateManager.enableLighting();
+            GlStateManager.popMatrix();
+        }
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomBookshelf.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomBookshelf.java	(date 1524550118000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomBookshelf.java	(date 1524550118000)
@@ -0,0 +1,48 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import javax.annotation.Nullable;
+import java.util.Random;
+
+public class BlockCustomBookshelf extends BlockMod implements IModBlock {
+
+    public BlockCustomBookshelf(String name) {
+        super(Material.WOOD, Reference.MOD_ID, name + "_bookshelf");
+        setHardness(1.5F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public float getEnchantPowerBonus(World world, BlockPos pos) {
+        return 1;
+    }
+
+    @Override
+    public int quantityDropped(Random random) {
+        return 3;
+    }
+
+    @Override
+    public int damageDropped(IBlockState state) {
+        return 0;
+    }
+
+    @Override
+    @Nullable
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Items.BOOK;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/ai/LargeSwimNodeProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/LargeSwimNodeProcessor.java	(date 1525328642000)
+++ src/main/java/net/hdt/neutronia/entity/ai/LargeSwimNodeProcessor.java	(date 1525328642000)
@@ -0,0 +1,19 @@
+package net.hdt.neutronia.entity.ai;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.pathfinding.SwimNodeProcessor;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.IBlockAccess;
+
+public class LargeSwimNodeProcessor extends SwimNodeProcessor {
+
+    public void init(IBlockAccess sourceIn, EntityLiving mob) {
+        this.blockaccess = sourceIn;
+        this.entity = mob;
+        this.pointMap.clearMap();
+        this.entitySizeX = MathHelper.floor(mob.width + 1.0F);
+        this.entitySizeY = 1;
+        this.entitySizeZ = MathHelper.floor(mob.width + 1.0F);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureRegistry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureRegistry.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureRegistry.java	(date 1525606902000)
@@ -0,0 +1,45 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.api.config.IConfig;
+import net.hdt.neutronia.api.world.gen.feature.IFeature;
+import net.minecraft.util.ResourceLocation;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.HashMap;
+import java.util.Map;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class FeatureRegistry {
+    private static final Map<ResourceLocation, Class<? extends Feature>> FEATURES = new HashMap<>();
+
+    static {
+        registerFeature(new ResourceLocation(MOD_ID + ":scatter"), FeatureScatter.class);
+        registerFeature(new ResourceLocation(MOD_ID + ":cluster"), FeatureCluster.class);
+        registerFeature(new ResourceLocation(MOD_ID + ":fluid"), FeatureFluid.class);
+        registerFeature(new ResourceLocation(MOD_ID + ":ore"), FeatureOre.class);
+        registerFeature(new ResourceLocation(MOD_ID + ":pool"), FeaturePool.class);
+        registerFeature(new ResourceLocation(MOD_ID + ":structure"), FeatureStructure.class);
+    }
+
+    public static void registerFeature(ResourceLocation name, Class<? extends Feature> cls) {
+        if (!FEATURES.containsKey(name)) {
+            FEATURES.put(name, cls);
+        } else {
+            Main.LOGGER.warn("A feature with the name, {}, is already registered!", name.toString());
+        }
+    }
+
+    public static IFeature createFeature(ResourceLocation name, IConfig config) {
+        if (FEATURES.containsKey(name)) {
+            try {
+                return FEATURES.get(name).getConstructor(IConfig.class).newInstance(config);
+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return null;
+    }
+}
Index: src/main/java/net/hdt/neutronia/proxy/ClientProxy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/proxy/ClientProxy.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/proxy/ClientProxy.java	(date 1525606901000)
@@ -0,0 +1,102 @@
+package net.hdt.neutronia.proxy;
+
+import net.hdt.neutronia.client.rendering.RenderTileCustomChest;
+import net.hdt.neutronia.client.rendering.ResourceProxy;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.hdt.neutronia.util.LibObfuscation;
+import net.hdt.neutronia.util.handlers.EntityEventHandler;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.model.ModelBiped;
+import net.minecraft.client.resources.IResourcePack;
+import net.minecraft.item.Item;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.fml.client.registry.ClientRegistry;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.fml.relauncher.ReflectionHelper;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class ClientProxy extends CommonProxy {
+
+    public static final Map<Item, ModelBiped> armorModels = new HashMap<>();
+
+    static ResourceProxy resourceProxy;
+
+    static {
+        List<IResourcePack> packs = ReflectionHelper.getPrivateValue(Minecraft.class, Minecraft.getMinecraft(), LibObfuscation.DEFAULT_RESOURCE_PACKS);
+        resourceProxy = new ResourceProxy();
+        packs.add(resourceProxy);
+    }
+
+    public static void registerArmorRenders() {
+
+        /*ModelCustomArmor custom_armor = new ModelCustomArmor(1F);
+        ModelCustomArmor custom_legs = new ModelCustomArmor(0.5F);
+
+        armorModels.put(HMItems.healmet, custom_armor);
+        armorModels.put(HMItems.chestplate, custom_armor);
+        armorModels.put(HMItems.leggings, custom_legs);
+        armorModels.put(HMItems.boots, custom_armor);*/
+
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        super.preInit(event);
+        MinecraftForge.EVENT_BUS.register(new EntityEventHandler());
+
+        overrideBlock("stone_granite", true);
+        overrideBlock("stone_andesite", true);
+        overrideBlock("stone_diorite", true);
+    }
+
+    @Override
+    public void init(FMLInitializationEvent event) {
+        super.init(event);
+
+        /*ItemColors itemColors = Minecraft.getMinecraft().getItemColors();
+        IItemColor floorTile = (stack, tintIndex) -> tintIndex < 2 && stack.hasTagCompound() ? Objects.requireNonNull(stack.getTagCompound()).getInteger("color" + tintIndex) : 0xFFFFFF;
+        itemColors.registerItemColorHandler(floorTile, HMBlocks.floorTile);
+
+        BlockColors blockColors = Minecraft.getMinecraft().getBlockColors();
+        IBlockColor floorTileBlock = (state, worldIn, pos, tintIndex) -> {
+            TileEntity te = worldIn.getTileEntity(pos);
+            if (te instanceof TileEntityFloorTile) {
+                return ((TileEntityFloorTile) te).getColor(tintIndex);
+            }
+            return 0xFFFFFF;
+        };
+        blockColors.registerBlockColorHandler(floorTileBlock, HMBlocks.floorTile);*/
+        ClientRegistry.bindTileEntitySpecialRenderer(TileCustomChest.class, new RenderTileCustomChest());
+    }
+
+    @Override
+    public void postInit(FMLPostInitializationEvent event) {
+        super.postInit(event);
+    }
+
+    @Override
+    public void addResourceOverride(String space, String dir, String file, String ext) {
+        resourceProxy.addResource(space, dir, file, ext);
+    }
+
+    private void overrideBlock(String str, boolean flag) {
+        if (flag)
+            addResourceOverride("textures", "blocks", str, "png");
+    }
+
+    private void overrideBlockModel(String str, boolean flag) {
+        if (flag)
+            addResourceOverride("models", "block", str, "json");
+    }
+
+    private void overrideItemModel(String str, boolean flag) {
+        if (flag)
+            addResourceOverride("models", "item", str, "json");
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockThatchStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockThatchStairs.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockThatchStairs.java	(date 1525606885000)
@@ -0,0 +1,22 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:56:21 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.Thatch;
+
+public class BlockThatchStairs extends BlockOverworldStairBase {
+
+    public BlockThatchStairs() {
+        super("thatch_stairs", Thatch.thatch.getDefaultState());
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockReedStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockReedStairs.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockReedStairs.java	(date 1525606886000)
@@ -0,0 +1,23 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:47:04 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.ReedBlock;
+
+public class BlockReedStairs extends BlockOverworldStairBase {
+
+    public BlockReedStairs() {
+        super("reed_block_stairs", ReedBlock.reed_block.getDefaultState());
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMidoriStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMidoriStairs.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockMidoriStairs.java	(date 1525606879000)
@@ -0,0 +1,22 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [29/06/2016, 18:28:06 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.features.MidoriBlocks;
+
+public class BlockMidoriStairs extends BlockOverworldStairBase {
+
+    public BlockMidoriStairs() {
+        super("midori_block_stairs", MidoriBlocks.midori_block.getDefaultState());
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/recipie/BlacklistOreIngredient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/recipie/BlacklistOreIngredient.java	(date 1523986189000)
+++ src/main/java/net/hdt/neutronia/recipie/BlacklistOreIngredient.java	(date 1523986189000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.recipie;
+
+import net.minecraft.item.ItemStack;
+import net.minecraftforge.oredict.OreIngredient;
+
+import java.util.function.Predicate;
+
+public class BlacklistOreIngredient extends OreIngredient {
+
+    final Predicate<ItemStack> blacklist;
+
+    public BlacklistOreIngredient(String key, Predicate<ItemStack> blacklist) {
+        super(key);
+        this.blacklist = blacklist;
+    }
+
+    @Override
+    public boolean apply(ItemStack input) {
+        return super.apply(input) && !blacklist.test(input);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Report.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Report.java	(date 1523988246000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Report.java	(date 1523988246000)
@@ -0,0 +1,19 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.hdt.neutronia.util.Reference;
+
+/* Console message reporter [key = value] */
+public class Report {
+
+    String result = "[" + Reference.NAME + " v" + Reference.VERSION + "]";
+
+    public Report add(String key, String value) {
+        result += "[" + key + " = " + value + "]";
+        return this;
+    }
+
+    public void print() {
+        System.out.println(result);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockFalling.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockFalling.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockFalling.java	(date 1525606878000)
@@ -0,0 +1,124 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.item.EntityFallingBlock;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import java.util.Random;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockFalling extends BlockMod {
+    public static boolean fallInstantly;
+
+    public BlockFalling(String name) {
+        super(Material.SAND, MOD_ID, name);
+        this.setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public BlockFalling(Material materialIn, String name) {
+        super(materialIn, MOD_ID, name);
+    }
+
+    public static boolean canFallThrough(IBlockState state) {
+        Block block = state.getBlock();
+        Material material = state.getMaterial();
+        return block == Blocks.FIRE || material == Material.AIR || material == Material.WATER || material == Material.LAVA;
+    }
+
+    /**
+     * Called after the block is set in the Chunk data, but before the Tile Entity is set
+     */
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        worldIn.scheduleUpdate(pos, this, this.tickRate(worldIn));
+    }
+
+    /**
+     * Called when a neighboring block was changed and marks that this state should perform any checks during a neighbor
+     * change. Cases may include when redstone power is updated, cactus blocks popping off due to a neighboring solid
+     * block, etc.
+     */
+    public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) {
+        worldIn.scheduleUpdate(pos, this, this.tickRate(worldIn));
+    }
+
+    public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
+        if (!worldIn.isRemote) {
+            this.checkFallable(worldIn, pos);
+        }
+    }
+
+    private void checkFallable(World worldIn, BlockPos pos) {
+        if ((worldIn.isAirBlock(pos.down()) || canFallThrough(worldIn.getBlockState(pos.down()))) && pos.getY() >= 0) {
+            int i = 32;
+
+            if (!fallInstantly && worldIn.isAreaLoaded(pos.add(-32, -32, -32), pos.add(32, 32, 32))) {
+                if (!worldIn.isRemote) {
+                    EntityFallingBlock entityfallingblock = new EntityFallingBlock(worldIn, (double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, worldIn.getBlockState(pos));
+                    this.onStartFalling(entityfallingblock);
+                    worldIn.spawnEntity(entityfallingblock);
+                }
+            } else {
+                IBlockState state = worldIn.getBlockState(pos);
+                worldIn.setBlockToAir(pos);
+                BlockPos blockpos;
+
+                for (blockpos = pos.down(); (worldIn.isAirBlock(blockpos) || canFallThrough(worldIn.getBlockState(blockpos))) && blockpos.getY() > 0; blockpos = blockpos.down()) {
+                }
+
+                if (blockpos.getY() > 0) {
+                    worldIn.setBlockState(blockpos.up(), state); //Forge: Fix loss of state information during world gen.
+                }
+            }
+        }
+    }
+
+    protected void onStartFalling(EntityFallingBlock fallingEntity) {
+    }
+
+    /**
+     * How many world ticks before ticking
+     */
+    public int tickRate(World worldIn) {
+        return 2;
+    }
+
+    public void onEndFalling(World worldIn, BlockPos pos, IBlockState p_176502_3_, IBlockState p_176502_4_) {
+    }
+
+    public void onBroken(World worldIn, BlockPos pos) {
+    }
+
+    /**
+     * Called periodically clientside on blocks near the player to show effects (like furnace fire particles). Note that
+     * this method is unrelated to @link #needsRandomTick}, and will always be called regardless
+     * of whether the block can receive random update ticks
+     */
+    @SideOnly(Side.CLIENT)
+    public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand) {
+        if (rand.nextInt(16) == 0) {
+            BlockPos blockpos = pos.down();
+
+            if (canFallThrough(worldIn.getBlockState(blockpos))) {
+                double d0 = (double) ((float) pos.getX() + rand.nextFloat());
+                double d1 = (double) pos.getY() - 0.05D;
+                double d2 = (double) ((float) pos.getZ() + rand.nextFloat());
+                worldIn.spawnParticle(EnumParticleTypes.FALLING_DUST, d0, d1, d2, 0.0D, 0.0D, 0.0D, Block.getStateId(stateIn));
+            }
+        }
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getDustColor(IBlockState state) {
+        return -16777216;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemLingeringPotionBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemLingeringPotionBase.java	(date 1523986173000)
+++ src/main/java/net/hdt/neutronia/items/ItemLingeringPotionBase.java	(date 1523986173000)
@@ -0,0 +1,55 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntityPotion;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemPotion;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionUtils;
+import net.minecraft.stats.StatList;
+import net.minecraft.util.ActionResult;
+import net.minecraft.util.EnumActionResult;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Objects;
+
+public class ItemLingeringPotionBase extends ItemPotion {
+
+    public String getItemStackDisplayName(ItemStack stack) {
+        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("lingering_potion.effect."));
+    }
+
+    /**
+     * allows items to add custom lines of information to the mouseover description
+     */
+    @SideOnly(Side.CLIENT)
+    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
+        PotionUtils.addPotionTooltip(stack, tooltip, 0.25F);
+    }
+
+    /**
+     * Called when the equipped item is right clicked.
+     */
+    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
+        ItemStack itemstack = playerIn.getHeldItem(handIn);
+        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
+        worldIn.playSound(null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_LINGERINGPOTION_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
+
+        if (!worldIn.isRemote) {
+            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
+            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
+            worldIn.spawnEntity(entitypotion);
+        }
+
+        playerIn.addStat(Objects.requireNonNull(StatList.getObjectUseStats(this)));
+        return new ActionResult<>(EnumActionResult.SUCCESS, itemstack);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/handlers/ConfigHandlerOld.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/ConfigHandlerOld.java	(date 1524839924000)
+++ src/main/java/net/hdt/neutronia/util/handlers/ConfigHandlerOld.java	(date 1524839924000)
@@ -0,0 +1,97 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraftforge.common.config.Config;
+import net.minecraftforge.common.config.ConfigManager;
+import net.minecraftforge.fml.client.event.ConfigChangedEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+@Config.LangKey("config.neutronia:title")
+@Config(modid = Reference.MOD_ID, name = "Neutronia/neutronia", category = "neutronia")
+public class ConfigHandlerOld {
+    private static final Logger LOGGER = LogManager.getLogger("Neutronia|ConfigHandlerOld");
+    @Config.Name("client")
+    @Config.LangKey("config.neutronia:client")
+    public static Client client = new Client();
+    @Config.Name("dimension")
+    @Config.LangKey("config.neutronia:dimension")
+    public static Dimension dimension = new Dimension();
+    @Config.Name("animation.animations.blocks")
+    @Config.LangKey("config.neutronia:animation.animations.blocks")
+    public static Block block = new Block();
+    @Config.Name("biome")
+    @Config.LangKey("config.neutronia:biome")
+    public static Biome biome = new Biome();
+
+    public static class Client {
+        @Config.Name("visual")
+        @Config.LangKey("config.neutronia:client.visual")
+        public Visual visual = new Visual();
+
+        public class Visual {
+            @Config.LangKey("config.neutronia:client.visual.disableNetherFog")
+            public boolean disableNetherFog = true;
+        }
+    }
+
+    public static class Dimension {
+        @Config.Name("nether")
+        @Config.LangKey("config.neutronia:dimension.nether")
+        public Nether nether = new Nether();
+
+        public class Nether {
+            @Config.LangKey("config.neutronia:dimension.nether.generateSoulSand")
+            public boolean generateSoulSand = false;
+
+            @Config.LangKey("config.neutronia:dimension.nether.generateGravel")
+            public boolean generateGravel = false;
+
+            @Config.LangKey("config.neutronia:dimension.nether.isLavaInfinite")
+            public boolean isLavaInfinite = false;
+        }
+    }
+
+    public static class Block {
+
+        @Config.Name("netherrack")
+        @Config.LangKey("config.neutronia:animation.animations.blocks.netherrack")
+        public Netherrack netherrack = new Netherrack();
+
+        @Config.Name("magma")
+        @Config.LangKey("config.neutronia:animation.animations.blocks.magma")
+        public Magma magma = new Magma();
+
+        public class Netherrack {
+            @Config.LangKey("config.neutronia:animation.animations.blocks.netherrack.allowAllShovelsToFlatten")
+            public boolean allowAllShovelsToFlatten = false;
+        }
+
+        public class Magma {
+            @Config.LangKey("config.neutronia:animation.animations.blocks.magma.turnIntoLava")
+            public boolean turnIntoLava = false;
+        }
+    }
+
+    public static class Biome {
+        @Config.Name("hell")
+        @Config.LangKey("config.neutronia:biome.hell")
+        public Hell hell = new Hell();
+
+        public class Hell {
+        }
+    }
+
+    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)
+    public static class ConfigSyncHandler {
+        @SubscribeEvent
+        public static void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent event) {
+            if (event.getModID().equals(Reference.MOD_ID)) {
+                ConfigManager.sync(Reference.MOD_ID, Config.Type.INSTANCE);
+                LOGGER.info("Configuration has been saved.");
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/api/config/IConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/api/config/IConfig.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/api/config/IConfig.java	(date 1525606882000)
@@ -0,0 +1,81 @@
+package net.hdt.neutronia.api.config;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.ResourceLocation;
+
+import java.util.List;
+import java.util.Map;
+
+public interface IConfig {
+    void parse(String jsonString);
+
+    JsonElement compose();
+
+    void add(String key, JsonElement element);
+
+    void addFallback(String key, JsonElement element);
+
+    void addSubConfig(String key, IConfig config);
+
+    boolean has(String key);
+
+    boolean hasFallback(String key);
+
+    boolean hasSubConfig(String key);
+
+    JsonElement get(String key);
+
+    JsonElement getFallback(String key);
+
+    Map<String, JsonElement> getElements();
+
+    void remove(String key);
+
+    String getString(String key, String fallbackValue);
+
+    int getInt(String key, int fallbackValue);
+
+    float getFloat(String key, float fallbackValue);
+
+    boolean getBoolean(String key, boolean fallbackValue);
+
+    <E extends Enum> E getEnum(String key, Class<? extends E> enumClass, E fallbackValue);
+
+    ResourceLocation getResource(String key, ResourceLocation fallbackValue);
+
+    IBlockState getBlock(String key, IBlockState fallbackValue);
+
+    ItemStack getItem(String key, ItemStack fallbackValue);
+
+    IConfig getSubConfig(String key, JsonObject defaultValue);
+
+    String getString(String key);
+
+    int getInt(String key);
+
+    float getFloat(String key);
+
+    boolean getBoolean(String key);
+
+    <E extends Enum> E getEnum(String key, Class<? extends E> enumClass);
+
+    ResourceLocation getResource(String key);
+
+    IBlockState getBlock(String key);
+
+    ItemStack getItem(String key);
+
+    IConfig getSubConfig(String key);
+
+    List<IConfig> getSubConfigs(String key, List<JsonObject> defaultValue);
+
+    List<IConfig> getSubConfigs(String key);
+
+    List<String> getStrings(String key, List<String> defaultValue);
+
+    List<String> getStrings(String key);
+
+}
Index: src/main/java/net/hdt/neutronia/util/WorldGenUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/WorldGenUtil.java	(date 1523986194000)
+++ src/main/java/net/hdt/neutronia/util/WorldGenUtil.java	(date 1523986194000)
@@ -0,0 +1,370 @@
+package net.hdt.neutronia.util;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockChest;
+import net.minecraft.block.BlockMobSpawner;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityList;
+import net.minecraft.init.Blocks;
+import net.minecraft.inventory.IInventory;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagDouble;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.tileentity.MobSpawnerBaseLogic;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Mirror;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.structure.StructureBoundingBox;
+import net.minecraft.world.gen.structure.template.BlockRotationProcessor;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraftforge.fml.relauncher.ReflectionHelper;
+
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Random;
+import java.util.UUID;
+
+@SuppressWarnings("ConstantConditions")
+public class WorldGenUtil {
+    private static final Field FIELD_BLOCKS = ReflectionHelper.findField(Template.class, "field_186270_a", "blocks");
+    private static final Field FIELD_ENTITIES = ReflectionHelper.findField(Template.class, "field_186271_b", "entities");
+
+    public static BlockPos getSuitableGroundPos(World world, BlockPos pos, BlockPos structureSize, float percentage) {
+        label_while:
+        while (pos.getY() > 32) {
+            float sizeX = structureSize.getX();
+            float sizeY = structureSize.getY();
+            float sizeZ = structureSize.getZ();
+
+            int topBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
+                    int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
+
+                    BlockPos newPos = pos.add(posX, 0, posZ);
+                    IBlockState state = world.getBlockState(newPos);
+
+                    if (!world.getBlockState(newPos).getMaterial().isReplaceable() && !world.getBlockState(newPos.down()).getMaterial().isReplaceable() && world.getBlockState(newPos.up()).getMaterial().isReplaceable()) {
+                        topBlocks++;
+                    } else if (state != Blocks.AIR.getDefaultState()) {
+                        pos = pos.down();
+                        continue label_while;
+                    }
+                }
+            }
+
+            int replaceableBlocks = 0;
+
+            if (topBlocks >= MathHelper.abs(sizeX * sizeZ) * percentage) {
+                for (int y = 1; y < sizeY; y++) {
+                    for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                        for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                            int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
+                            int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
+
+                            BlockPos newPos = pos.add(posX, y, posZ);
+                            IBlockState state = world.getBlockState(newPos);
+
+                            if (world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                                replaceableBlocks++;
+                            } else if (state != Blocks.AIR.getDefaultState()) {
+                                pos = pos.down();
+                                continue label_while;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (replaceableBlocks > MathHelper.abs(sizeX * sizeY * sizeZ) * 0.875F) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static BlockPos getSuitableWallPos(World world, BlockPos pos, BlockPos structureSize, float percentage) {
+        while (pos.getY() > 32) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int wallBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
+                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
+
+                        BlockPos newPos = pos.add(posX, y, posZ);
+
+                        if (!world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                            wallBlocks++;
+                        }
+                    }
+                }
+            }
+
+            if (wallBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ) * percentage) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static BlockPos getSuitableCeilingPos(World world, BlockPos pos, BlockPos structureSize) {
+        label_while:
+        while (pos.getY() < 128) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int ceilingBlocks = 0;
+            int replaceableBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
+                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
+
+                        BlockPos newPos = pos.add(posX, -y, posZ);
+
+                        if (y == 0) {
+                            if (world.getBlockState(newPos).isSideSolid(world, newPos, EnumFacing.DOWN)) {
+                                ceilingBlocks++;
+                            } else {
+                                pos = pos.up();
+                                continue label_while;
+                            }
+                        } else {
+                            if (world.getBlockState(newPos).getBlock().isReplaceable(world, newPos)) {
+                                replaceableBlocks++;
+                            } else {
+                                pos = pos.up();
+                                continue label_while;
+                            }
+
+                        }
+                    }
+                }
+            }
+
+            if (replaceableBlocks >= MathHelper.abs(sizeX * (sizeY - 1) * sizeZ) && ceilingBlocks >= MathHelper.abs(sizeX * sizeZ)) {
+                return pos.add(0, -sizeY, 0);
+            }
+
+            pos = pos.up();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static BlockPos getSuitableAirPos(World world, BlockPos pos, BlockPos structureSize) {
+        label_while:
+        while (pos.getY() > 32) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int replaceableBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
+                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
+
+                        BlockPos newPos = pos.add(posX, y, posZ);
+
+                        if (world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                            replaceableBlocks++;
+                        } else {
+                            pos = pos.down();
+                            continue label_while;
+                        }
+                    }
+                }
+            }
+
+            if (replaceableBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ)) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static void generateStructure(World world, BlockPos pos, Random rand, Template template, PlacementSettings placementSettings, List<ResourceLocation> lootTables, List<ResourceLocation> spawnerMobs) {
+        try {
+            List<Template.BlockInfo> blocks = (List<Template.BlockInfo>) FIELD_BLOCKS.get(template);
+            List<Template.EntityInfo> entities = (List<Template.EntityInfo>) FIELD_ENTITIES.get(template);
+
+            if ((!blocks.isEmpty() || !placementSettings.getIgnoreEntities() && !entities.isEmpty()) && template.getSize().getX() >= 1 && template.getSize().getY() >= 1 && template.getSize().getZ() >= 1) {
+                BlockRotationProcessor processor = new BlockRotationProcessor(pos, placementSettings);
+                Block block = placementSettings.getReplacedBlock();
+                StructureBoundingBox boundingBox = placementSettings.getBoundingBox();
+
+                for (Template.BlockInfo blockInfo : blocks) {
+                    BlockPos blockPos = Template.transformedBlockPos(placementSettings, blockInfo.pos).add(pos);
+                    Template.BlockInfo blockInfo1 = processor != null ? processor.processBlock(world, blockPos, blockInfo) : blockInfo;
+
+                    if (blockInfo1 != null) {
+                        Block block1 = blockInfo1.blockState.getBlock();
+
+                        if ((block == null || block != block1) && (!placementSettings.getIgnoreStructureBlock() || block1 != Blocks.STRUCTURE_BLOCK) && (boundingBox == null || boundingBox.isVecInside(blockPos))) {
+                            IBlockState state = blockInfo1.blockState.withMirror(placementSettings.getMirror()).withRotation(placementSettings.getRotation());
+
+                            if (blockInfo1.tileentityData != null) {
+                                TileEntity tileEntity = world.getTileEntity(blockPos);
+
+                                if (tileEntity != null) {
+                                    if (tileEntity instanceof IInventory) {
+                                        ((IInventory) tileEntity).clear();
+                                    }
+
+                                    world.setBlockState(blockPos, Blocks.BARRIER.getDefaultState(), 4);
+                                }
+                            }
+
+                            if (world.setBlockState(blockPos, state, 3) && blockInfo1.tileentityData != null) {
+                                TileEntity tileEntity = world.getTileEntity(blockPos);
+
+                                if (tileEntity != null) {
+                                    blockInfo1.tileentityData.setInteger("x", blockPos.getX());
+                                    blockInfo1.tileentityData.setInteger("y", blockPos.getY());
+                                    blockInfo1.tileentityData.setInteger("z", blockPos.getZ());
+                                    tileEntity.readFromNBT(blockInfo1.tileentityData);
+                                    tileEntity.mirror(placementSettings.getMirror());
+                                    tileEntity.rotate(placementSettings.getRotation());
+
+                                    if (state.getBlock() instanceof BlockChest) {
+                                        ((TileEntityChest) tileEntity).setLootTable(lootTables.get(rand.nextInt(lootTables.size())), rand.nextLong());
+
+                                    } else if (state.getBlock() instanceof BlockMobSpawner) {
+                                        MobSpawnerBaseLogic logic = ((TileEntityMobSpawner) tileEntity).getSpawnerBaseLogic();
+                                        NBTTagCompound compound = new NBTTagCompound();
+
+                                        logic.writeToNBT(compound);
+                                        compound.removeTag("SpawnPotentials");
+                                        logic.readFromNBT(compound);
+                                        logic.setEntityId(spawnerMobs.get(rand.nextInt(spawnerMobs.size())));
+                                        tileEntity.markDirty();
+
+                                        world.notifyBlockUpdate(pos, state, state, 3);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                for (Template.BlockInfo blockInfo2 : blocks) {
+                    if (block == null || block != blockInfo2.blockState.getBlock()) {
+                        BlockPos blockPos1 = Template.transformedBlockPos(placementSettings, blockInfo2.pos).add(pos);
+
+                        if (boundingBox == null || boundingBox.isVecInside(blockPos1)) {
+                            world.notifyNeighborsRespectDebug(blockPos1, blockInfo2.blockState.getBlock(), false);
+
+                            if (blockInfo2.tileentityData != null) {
+                                TileEntity tileEntity = world.getTileEntity(blockPos1);
+
+                                if (tileEntity != null) {
+                                    tileEntity.markDirty();
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (!placementSettings.getIgnoreEntities()) {
+                    addEntitiesToWorld(world, pos, placementSettings, entities, boundingBox);
+                }
+            }
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static void addEntitiesToWorld(World world, BlockPos pos, PlacementSettings placementSettings, List<Template.EntityInfo> entities, StructureBoundingBox boundingBox) {
+        for (Template.EntityInfo entityInfo : entities) {
+            BlockPos blockPos = Template.transformedBlockPos(placementSettings, entityInfo.blockPos).add(pos);
+
+            if (boundingBox == null || boundingBox.isVecInside(blockPos)) {
+                NBTTagCompound compound = entityInfo.entityData;
+                Vec3d vec3d = transformedVec3d(entityInfo.pos, placementSettings.getMirror(), placementSettings.getRotation());
+                Vec3d vec3d1 = vec3d.addVector((double) pos.getX(), (double) pos.getY(), (double) pos.getZ());
+                NBTTagList tagList = new NBTTagList();
+                tagList.appendTag(new NBTTagDouble(vec3d1.x));
+                tagList.appendTag(new NBTTagDouble(vec3d1.y));
+                tagList.appendTag(new NBTTagDouble(vec3d1.z));
+                compound.setTag("Pos", tagList);
+                compound.setUniqueId("UUID", UUID.randomUUID());
+                Entity entity;
+
+                try {
+                    entity = EntityList.createEntityFromNBT(compound, world);
+                } catch (Exception var15) {
+                    entity = null;
+                }
+
+                if (entity != null) {
+                    float f = entity.getMirroredYaw(placementSettings.getMirror());
+                    f = f + (entity.rotationYaw - entity.getRotatedYaw(placementSettings.getRotation()));
+                    entity.setLocationAndAngles(vec3d1.x, vec3d1.y, vec3d1.z, f, entity.rotationPitch);
+                    world.spawnEntity(entity);
+                }
+            }
+        }
+    }
+
+    private static Vec3d transformedVec3d(Vec3d vec, Mirror mirror, Rotation rotation) {
+        double xCoord = vec.x;
+        double yCoord = vec.y;
+        double zCoord = vec.z;
+        boolean flag = true;
+
+        switch (mirror) {
+            case LEFT_RIGHT:
+                zCoord = 1.0D - zCoord;
+                break;
+            case FRONT_BACK:
+                xCoord = 1.0D - xCoord;
+                break;
+            default:
+                flag = false;
+        }
+
+        switch (rotation) {
+            case COUNTERCLOCKWISE_90:
+                return new Vec3d(zCoord, yCoord, 1.0D - xCoord);
+            case CLOCKWISE_90:
+                return new Vec3d(1.0D - zCoord, yCoord, xCoord);
+            case CLOCKWISE_180:
+                return new Vec3d(1.0D - xCoord, yCoord, 1.0D - zCoord);
+            default:
+                return flag ? new Vec3d(xCoord, yCoord, zCoord) : vec;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenTreeHouse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenTreeHouse.java	(date 1523986199000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenTreeHouse.java	(date 1523986199000)
@@ -0,0 +1,50 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenTreeHouse extends WorldGenerator {
+
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (world.getBlockState(pos.down()).getBlock() == Blocks.DIRT) {
+            world.setBlockState(pos.add(-1, 0, -1), Blocks.PLANKS.getDefaultState());
+            world.setBlockState(pos.add(-1, 1, -1), Blocks.LOG.getDefaultState());
+            if (!world.getBlockState(pos.add(0, 1, -1)).getMaterial().isSolid()) {
+                world.setBlockState(pos.add(0, 1, -1), Blocks.LADDER.getDefaultState());
+            }
+
+            world.setBlockState(pos.up(2), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.up(3), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.up(4), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 4, 0), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 4, -1), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(0, 4, -1), Blocks.LADDER.getDefaultState());
+            world.setBlockState(pos.up(5), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(1, 5, -1), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(1, 5, 0), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(0, 5, -1), Blocks.LADDER.getDefaultState());
+            world.setBlockState(pos.add(0, 5, 1), Blocks.PLANKS.getDefaultState());
+            world.setBlockState(pos.add(0, 5, 2), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 5, -2), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 5, -1), Blocks.PLANKS.getDefaultState());
+            world.setBlockState(pos.add(-1, 5, 0), Blocks.PLANKS.getDefaultState());
+            world.setBlockState(pos.add(-1, 5, 1), Blocks.PLANKS.getDefaultState());
+            world.setBlockState(pos.add(-2, 5, 0), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.up(6), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(2, 6, -2), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 6, 1), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(-1, 6, 1), Blocks.CHEST.getDefaultState());
+
+
+            world.setBlockState(pos.up(7), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.add(0, 6, 1), Blocks.LOG.getDefaultState());
+            world.setBlockState(pos.up(8), Blocks.LEAVES.getDefaultState());
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderRedPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderRedPhantom.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderRedPhantom.java	(date 1523987836000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityRedPhantom;
+import net.hdt.neutronia.entity.render.model.ModelPhantom;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderRedPhantom extends RenderLiving<EntityRedPhantom> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/red_phantom.png");
+
+    public RenderRedPhantom(RenderManager manager) {
+        super(manager, new ModelPhantom(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityRedPhantom entity) {
+        return SCORP_TEXTURE;
+    }
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumCoralTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumCoralTypes.java	(date 1525019801000)
+++ src/main/java/net/hdt/neutronia/properties/EnumCoralTypes.java	(date 1525019801000)
@@ -0,0 +1,41 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumCoralTypes implements IStringSerializable {
+
+    BRAIN_CORAL(0, "brain_coral"),
+    ELEGANCE_CORAL(1, "elegance_coral"),
+    FIRE_CORAL(2, "fire_coral"),
+    SEA_GRASS(3, "sea_grass"),
+    LETTUCE_CORAL(4, "lettuce_coral"),
+    MIXED_CORAL_PLATES(5, "mixed_coral_plates"),
+    MIXED_CORAL_ROCKS(6, "mixed_coral_rocks"),
+    STAGHORN_CORAL(7, "staghorn_coral"),
+    LARGE_SEA_ANEMONE(8, "large_sea_anemone"),
+    SMALL_SEA_URCHIN(9, "small_sea_urchin"),
+    SMALL_SEA_ANEMONE(10, "small_sea_anemone"),
+    LARGE_SEA_URCHIN(11, "large_sea_urchin"),
+    BLADDERWRACK(12, "bladderwrack"),
+    GRACILARIA(13, "gracilaria"),
+    PYROPIA(14, "pyropia"),
+    SEA_URCHIN_TROPICAL(15, "sea_urchin_tropical");
+
+    private String name;
+    private int ID;
+
+    EnumCoralTypes(int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumGlowingNetherBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumGlowingNetherBlocks.java	(date 1524947218000)
+++ src/main/java/net/hdt/neutronia/properties/EnumGlowingNetherBlocks.java	(date 1524947218000)
@@ -0,0 +1,48 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumGlowingNetherBlocks implements IStringSerializable {
+
+    FIERY_STONE(0, "fiery_stone"),
+    VOLCANIC_GLOW_ROCK(1, "volcanic_glow_rock"),
+    VOLCANIC_ROCK(2, "volcanic_rock"),
+    HOT_COBBLESTONE(3, "hot_cobblestone");
+
+    private static final EnumGlowingNetherBlocks[] META_LOOKUP = new EnumGlowingNetherBlocks[values().length];
+
+    static {
+        for (EnumGlowingNetherBlocks blockstone$enumtype : values()) {
+            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumGlowingNetherBlocks(int p_i46384_3_, String p_i46384_5_) {
+        this.meta = p_i46384_3_;
+        this.name = p_i46384_5_;
+    }
+
+    public static EnumGlowingNetherBlocks byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumNetherPlantTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumNetherPlantTypes.java	(date 1524944099000)
+++ src/main/java/net/hdt/neutronia/properties/EnumNetherPlantTypes.java	(date 1524944099000)
@@ -0,0 +1,28 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumNetherPlantTypes implements IStringSerializable {
+
+    GRASS(0, "nether_grass"),
+    SOUL_SPROUTS(1, "soul_sprouts"),
+    NETHER_MUSHROOM(2, "nether_mushroom");
+
+    private String name;
+    private int ID;
+
+    EnumNetherPlantTypes(int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorScatter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorScatter.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorScatter.java	(date 1525606900000)
@@ -0,0 +1,128 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.common.base.Strings;
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.util.BlockUtil;
+import net.minecraft.block.BlockBush;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.Random;
+
+public class EnhancedGeneratorScatter extends EnhancedGenerator {
+    public static final EnhancedGeneratorScatter INSTANCE = new EnhancedGeneratorScatter(0, 0.0F, 0, 0, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), EnhancedGeneratorScatter.Placement.ON_GROUND);
+    private final IBlockState blockToSpawn;
+    private final IBlockState blockToTarget;
+    private final Placement placement;
+
+    private EnhancedGeneratorScatter(int generationAttempts, float generationProbability, int minHeight, int maxHeight, IBlockState blockToSpawnIn, IBlockState blockToTargetIn, Placement placementIn) {
+        super(generationAttempts, generationProbability, minHeight, maxHeight);
+
+        blockToSpawn = blockToSpawnIn;
+        blockToTarget = blockToTargetIn;
+        placement = placementIn;
+    }
+
+    @Override
+    public EnhancedGeneratorScatter deserializeConfig(JsonObject config) {
+        int generationAttempts = JsonUtils.getInt(config, "generationAttempts", 10);
+        float generationProbability = JsonUtils.getFloat(config, "generationProbability", 1.0F);
+        int minHeight = JsonUtils.getInt(config, "minHeight", 32);
+        int maxHeight = JsonUtils.getInt(config, "maxHeight", 128);
+
+        IBlockState blockToSpawn = null;
+        IBlockState blockToTarget = null;
+
+        JsonObject blockToSpawnJson = JsonUtils.getJsonObject(config, "blockToSpawn", new JsonObject());
+        JsonObject blockToTargetJson = JsonUtils.getJsonObject(config, "blockToTarget", new JsonObject());
+
+        if (blockToSpawnJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSpawnJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSpawn = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+        if (blockToTargetJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToTargetJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToTarget = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+
+        JsonObject blockToSpawnProperties = JsonUtils.getJsonObject(blockToSpawnJson, "properties", new JsonObject());
+        JsonObject blockToTargetProperties = JsonUtils.getJsonObject(blockToTargetJson, "properties", new JsonObject());
+
+        if (blockToSpawnProperties.entrySet().size() > 0) {
+            blockToSpawn = BlockUtil.getBlockWithProperties(blockToSpawn, JsonUtils.getJsonObject(blockToSpawnJson, "properties"));
+        }
+        if (blockToTargetProperties.entrySet().size() > 0) {
+            blockToTarget = BlockUtil.getBlockWithProperties(blockToTarget, JsonUtils.getJsonObject(blockToTargetJson, "properties"));
+        }
+
+        Placement placement = Placement.getFromString(JsonUtils.getString(config, "placement"));
+
+        if (blockToSpawn != null && blockToTarget != null) {
+            return new EnhancedGeneratorScatter(generationAttempts, generationProbability, minHeight, maxHeight, blockToSpawn, blockToTarget, placement);
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        for (int i = 0; i < 64; ++i) {
+            BlockPos newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(4) - rand.nextInt(4), rand.nextInt(8) - rand.nextInt(8));
+
+            if (world.isAirBlock(newPos) && world.getBlockState(newPos.down()) == blockToTarget) {
+                if (blockToSpawn instanceof BlockBush) {
+                    if (((BlockBush) blockToSpawn).canBlockStay(world, placement.offsetPos(pos), blockToSpawn)) {
+                        world.setBlockState(placement.offsetPos(newPos), blockToSpawn, 2);
+                    }
+                } else {
+                    world.setBlockState(placement.offsetPos(newPos), blockToSpawn, 2);
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public enum Placement {
+        ON_GROUND(null),
+        IN_GROUND(EnumFacing.DOWN);
+
+        EnumFacing offset;
+
+        Placement(EnumFacing offsetIn) {
+            offset = offsetIn;
+        }
+
+        public static Placement getFromString(String string) {
+            if (!Strings.isNullOrEmpty(string)) {
+                for (Placement placement : values()) {
+                    if (placement.name().replace("_", "").equalsIgnoreCase(string)) {
+                        return placement;
+                    }
+                }
+            }
+
+            return ON_GROUND;
+        }
+
+        public BlockPos offsetPos(BlockPos pos) {
+            if (offset != null) {
+                return pos.offset(offset);
+            } else {
+                return pos;
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemModHoe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemModHoe.java	(date 1523986170000)
+++ src/main/java/net/hdt/neutronia/items/ItemModHoe.java	(date 1523986170000)
@@ -0,0 +1,78 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemHoe;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.ResourceLocation;
+import net.thegaminghuskymc.huskylib2.interf.IVariantHolder;
+import net.thegaminghuskymc.huskylib2.items.ItemMod;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class ItemModHoe extends ItemHoe implements IVariantHolder {
+
+    private final String[] variants;
+    private final String bareName, modid;
+
+    public ItemModHoe(ToolMaterial material, String name, String modid, String... variants) {
+        super(material);
+
+        if (variants.length > 1)
+            setHasSubtypes(true);
+
+        if (variants.length == 0)
+            variants = new String[]{name};
+
+        bareName = name;
+        this.variants = variants;
+        this.modid = modid;
+        setUnlocalizedName(name, modid);
+        ItemMod.variantHolders.add(this);
+        this.toolMaterial = material;
+        this.maxStackSize = 1;
+        this.setCreativeTab(CreativeTabs.TOOLS);
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    public Item setUnlocalizedName(String name, String modid) {
+        super.setUnlocalizedName(name);
+        setRegistryName(new ResourceLocation(modid, name));
+        ProxyRegistry.register(this);
+
+        return this;
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack par1ItemStack) {
+        int dmg = par1ItemStack.getItemDamage();
+        String[] variants = getVariants();
+
+        String name;
+        if (dmg >= variants.length)
+            name = bareName;
+        else name = variants[dmg];
+
+        return "item." + getPrefix() + name;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/init/HMEntities.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMEntities.java	(date 1525364002000)
+++ src/main/java/net/hdt/neutronia/init/HMEntities.java	(date 1525364002000)
@@ -0,0 +1,103 @@
+package net.hdt.neutronia.init;
+
+import net.hdt.neutronia.entity.*;
+import net.hdt.neutronia.util.handlers.RenderHandler;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.entity.boss.EntityDragon;
+import net.minecraft.entity.boss.EntityWither;
+import net.minecraft.entity.monster.EntityIronGolem;
+import net.minecraft.entity.monster.EntitySnowman;
+import net.minecraft.entity.monster.EntityWitherSkeleton;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.biome.Biome;
+import net.minecraftforge.common.BiomeDictionary;
+import net.minecraftforge.event.RegistryEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import net.minecraftforge.fml.common.registry.*;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+@Mod.EventBusSubscriber(modid = MOD_ID)
+public class HMEntities {
+
+    private static int entityID = 0;
+
+    @SubscribeEvent
+    public static void RegisterEntitys(RegistryEvent.Register<EntityEntry> event) {
+        final EntityEntry[] entries = {
+                createBuilder("mummy").entity(EntityMummy.class).tracker(80, 3, true).egg(0xC9CE92, 0x444444).build(),
+                createBuilder("mummy_villager").entity(EntityMummyVillager.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
+                createBuilder("scorpion").entity(EntityScorp.class).tracker(30, 3, true).egg(0x65401, 0x6201209).build(),
+                createBuilder("phantom").entity(EntityPhantom.class).tracker(80, 3, true).egg(0x2d3f56, 0x958c79).build(),
+                createBuilder("red_phantom").entity(EntityRedPhantom.class).tracker(80, 3, true).egg(0x4A2929, 0x799591).build(),
+                createBuilder("ender_phantom").entity(EntityEnderPhantom.class).tracker(80, 3, true).egg(0x352D56, 0x8C9579).build(),
+                createBuilder("shadow_phantom").entity(EntityShadowPhantom.class).tracker(80, 3, true).egg(0x101010, 0x101010).build(),
+                createBuilder("hovering_inferno").entity(EntityHoveringInferno.class).tracker(80, 3, true).egg(0x864500, 0xd36d00).build(),
+                createBuilder("ravenous_killer_squid").entity(EntityMonsterOfTheOceanDepths.class).tracker(80, 3, true).egg(0x03002e, 0x060081).build(),
+                createBuilder("turtle").entity(EntitySeaTurtle.class).tracker(80, 3, true).egg(0xFFFFFF, 0x13232B).build(),
+                createBuilder("drowned").entity(EntityDrowned.class).tracker(80, 3, true).egg(0x86e2ca, 0x617d51).build(),
+                createBuilder("scuba_divers").entity(EntityScubaDivers.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
+                createBuilder("drowned_villager").entity(EntityDrownedVillager.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
+                createBuilder("great_hunger").entity(EntityGreatHunger.class).tracker(80, 3, true).egg(0x876949, 0xce9252).build(),
+                createBuilder("cod").entity(EntityCod.class).tracker(30, 3, true).egg(0xb89e70, 0x786749).build(),
+                createBuilder("salmon").entity(EntitySalmon.class).tracker(30, 3, true).egg(0xb89e70, 0x786749).build(),
+                createBuilder("tropical_fish").entity(EntityTropicalFish.class).tracker(30, 3, true).egg(0xb89e70, 0x786749).build(),
+                createBuilder("whale").entity(EntityWhale.class).tracker(30, 3, true).egg(0x603D8A, 0x261839).build(),
+                createBuilder("iron_golem").entity(EntityIronGolem.class).tracker(80, 3, true).egg(0xFFFFFF, 0xFF00FF).build(),
+                createBuilder("snow_golem").entity(EntitySnowman.class).tracker(80, 3, true).egg(0xFFFFFF, 0xFF00FF).build(),
+                createBuilder("wither").entity(EntityWither.class).tracker(80, 3, true).egg(0xFFFFFF, 0xFF00FF).build(),
+                createBuilder("wither_skeleton").entity(EntityWitherSkeleton.class).tracker(80, 3, true).egg(0xFFFFFF, 0xFF00FF).build(),
+                createBuilder("ender_dragon").entity(EntityDragon.class).tracker(80, 3, true).egg(0xFFFFFF, 0xFF00FF).build(),
+                createBuilder("anchored").entity(EntityAnchored.class).tracker(80, 3, true).egg(0x13271d, 0x88baad).build(),
+                createBuilder("lost_miner").entity(EntityLostMiner.class).tracker(80, 3, true).egg(0x13271d, 0x88baad).build()
+        };
+        event.getRegistry().registerAll(entries);
+        RenderHandler.registerEntityRenders();
+        addSpawns();
+    }
+
+    @SubscribeEvent
+    public static void registerNewVillagerProffesions(RegistryEvent.Register<VillagerRegistry.VillagerProfession> event) {
+        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "miner").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/miner").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/miner").toString()));
+        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "scuba_diver").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/scuba_diver").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/scuba_diver").toString()));
+        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "explorer").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/explorer").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/explorer").toString()));
+        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "magician").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/magician").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/magician").toString()));
+        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "guard").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/guard").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/guard").toString()));
+    }
+
+    private static void addSpawns() {
+        EntityRegistry.addSpawn(EntityMummy.class, 10, 1, 3, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
+        EntityRegistry.addSpawn(EntityScorp.class, 9, 2, 8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
+        EntityRegistry.addSpawn(EntityDrowned.class, 9, 2, 8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.OCEAN));
+        EntityRegistry.addSpawn(EntityHoveringInferno.class, 9, 2, 8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.NETHER));
+        EntityRegistry.addSpawn(EntityGreatHunger.class, 9, 2, 8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
+        EntityRegistry.addSpawn(EntitySeaTurtle.class, 9, 2, 8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.BEACH));
+        EntityRegistry.addSpawn(EntityMonsterOfTheOceanDepths.class, 10, 1, 3, EnumCreatureType.WATER_CREATURE, getBiomes(BiomeDictionary.Type.OCEAN));
+    }
+
+    private static <E extends Entity> EntityEntryBuilder<E> createBuilder(final String name) {
+        final EntityEntryBuilder<E> builder = EntityEntryBuilder.create();
+        final ResourceLocation registryName = new ResourceLocation(MOD_ID, name);
+        return builder.id(registryName, entityID++).name(registryName.toString());
+    }
+
+    private static Biome[] getBiomes(final BiomeDictionary.Type type) {
+        return BiomeDictionary.getBiomes(type).toArray(new Biome[0]);
+    }
+
+    //for use later...
+    private static void copySpawns(final Class<? extends EntityLiving> classToAdd, final EnumCreatureType creatureTypeToAdd, final Class<? extends EntityLiving> classToCopy, final EnumCreatureType creatureTypeToCopy) {
+        for (final Biome biome : ForgeRegistries.BIOMES) {
+            biome.getSpawnableList(creatureTypeToCopy).stream()
+                    .filter(entry -> entry.entityClass == classToCopy)
+                    .findFirst()
+                    .ifPresent(spawnListEntry ->
+                            biome.getSpawnableList(creatureTypeToAdd).add(new Biome.SpawnListEntry(classToAdd, spawnListEntry.itemWeight, spawnListEntry.minGroupCount, spawnListEntry.maxGroupCount))
+                    );
+        }
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockBarkStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockBarkStairs.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/stairs/BlockBarkStairs.java	(date 1525606887000)
@@ -0,0 +1,19 @@
+package net.hdt.neutronia.modules.building.blocks.stairs;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.blocks.BlockBark;
+import net.hdt.neutronia.modules.building.features.BarkBlocks;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockBarkStairs extends BlockOverworldStairBase implements IRecipeGrouped {
+
+    public BlockBarkStairs(BlockBark.Variants variant) {
+        super(variant.getName() + "_stairs", BarkBlocks.bark.getDefaultState().withProperty(BarkBlocks.bark.getVariantProp(), variant));
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "bark_stairs";
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumFrostedStoneVariants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumFrostedStoneVariants.java	(date 1525343870000)
+++ src/main/java/net/hdt/neutronia/properties/EnumFrostedStoneVariants.java	(date 1525343870000)
@@ -0,0 +1,49 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumFrostedStoneVariants implements IStringSerializable {
+
+    STONE(0, "frosted_stone"),
+    COBBLESTONE(1, "frosted_cobblestone"),
+    GRANITE(2, "frosted_granite"),
+    DIORITE(3, "frosted_diorite"),
+    ANDESITE(4, "frosted_andesite"),
+    HARDENED_CLAY(5, "hardened_frosted_clay");
+
+    private static final EnumFrostedStoneVariants[] META_LOOKUP = new EnumFrostedStoneVariants[values().length];
+
+    static {
+        for (EnumFrostedStoneVariants enumdyecolor : values()) {
+            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumFrostedStoneVariants(int metaIn, String nameIn) {
+        this.meta = metaIn;
+        this.name = nameIn;
+    }
+
+    public static EnumFrostedStoneVariants byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/spruce_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/spruce_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/spruce_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,22 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 1
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:spruce_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/properties/EnumNewStoneVariants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumNewStoneVariants.java	(date 1525310389000)
+++ src/main/java/net/hdt/neutronia/properties/EnumNewStoneVariants.java	(date 1525310389000)
@@ -0,0 +1,74 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumNewStoneVariants implements IStringSerializable {
+
+    GRANITE_BRICKS(0, "granite_bricks"),
+    GRANITE_COBBLE(1, "granite_cobble"),
+    DIORITE_BRICKS(2, "diorite_bricks"),
+    DIORITE_COBBLE(3, "diorite_cobble"),
+    ANDESITE_BRICKS(4, "andesite_bricks"),
+    ANDESITE_COBBLE(5, "andesite_cobble"),
+    BASALT(6, "raw_basalt"),
+    BASALT_SMOOTH(7, "smooth_basalt"),
+    BASALT_CHISELED(8, "chiseled_basalt"),
+    BASALT_BRICKS(9, "basalt_bricks"),
+    BASALT_COBBLE(10, "basalt_cobble"),
+    BASALT_CRACKED_BRICKS(11, "cracked_basalt_bricks"),
+    BASALT_SMALL_BRICKS(12, "small_basalt_bricks"),
+    MARBLE(13, "raw_marble"),
+    MARBLE_SMOOTH(14, "smooth_marble"),
+    MARBLE_CHISELED(15, "chiseled_marble"),
+    MARBLE_BRICKS(16, "marble_bricks"),
+    MARBLE_COBBLE(17, "marble_cobble"),
+    MARBLE_CRACKED_BRICKS(18, "cracked_marble_bricks"),
+    MARBLE_SMALL_BRICKS(19, "small_marble_bricks"),
+    LIMESTONE(20, "raw_limestone"),
+    LIMESTONE_SMOOTH(21, "smooth_limestone"),
+    LIMESTONE_CHISELED(22, "chiseled_limestone"),
+    LIMESTONE_BRICKS(23, "limestone_bricks"),
+    LIMESTONE_COBBLE(24, "limestone_cobble"),
+    LIMESTONE_CRACKED_BRICKS(25, "cracked_limestone_bricks"),
+    LIMESTONE_SMALL_BRICKS(26, "small_limestone_bricks"),
+    METEORITE(27, "raw_meteorite"),
+    METEORITE_BRICKS(28, "meteorite_bricks"),
+    METEORITE_SMOOTH(29, "smooth_meteorite");
+
+    private static final EnumNewStoneVariants[] META_LOOKUP = new EnumNewStoneVariants[values().length];
+
+    static {
+        for (EnumNewStoneVariants blockstone$enumtype : values()) {
+            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumNewStoneVariants(int p_i46384_3_, String p_i46384_5_) {
+        this.meta = p_i46384_3_;
+        this.name = p_i46384_5_;
+    }
+
+    public static EnumNewStoneVariants byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+}
Index: src/main/resources/assets/neutronia/recipes/red_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/red_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/red_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 1
+    }
+  ],
+  "result": {
+    "item": "neutronia:red_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/silver_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/silver_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/silver_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 7
+    }
+  ],
+  "result": {
+    "item": "neutronia:silver_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/dungeons/generator/RoomStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/dungeons/generator/RoomStructure.java	(date 1523988240000)
+++ src/main/java/net/hdt/neutronia/world/dungeons/generator/RoomStructure.java	(date 1523988240000)
@@ -0,0 +1,47 @@
+package net.hdt.neutronia.world.dungeons.generator;
+
+import net.hdt.neutronia.util.Reference;
+import net.hdt.neutronia.util.interfaces.IStructure;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.gen.structure.template.TemplateManager;
+
+import java.util.Random;
+
+public class RoomStructure extends WorldGenerator implements IStructure {
+
+    private static String structureName;
+
+    public RoomStructure(String name) {
+        structureName = name;
+    }
+
+    private static void generateStructure(World world, BlockPos pos) {
+        MinecraftServer mcServer = world.getMinecraftServer();
+        TemplateManager manager = worldServer.getStructureTemplateManager();
+        ResourceLocation location = new ResourceLocation(Reference.MOD_ID, structureName);
+        Template template = manager.get(mcServer, location);
+
+        if (template != null) {
+            IBlockState state = world.getBlockState(pos);
+            world.notifyBlockUpdate(pos, state, state, 3);
+            template.addBlocksToWorldChunk(world, pos, settings);
+        }
+
+        if (template == null) {
+            System.out.println("NO STRUCTURE");
+        }
+
+    }
+
+    @Override
+    public boolean generate(World worldIn, Random rand, BlockPos position) {
+        generateStructure(worldIn, position);
+        return true;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/andesite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/andesite_bricks.json	(date 1525350113000)
+++ src/main/resources/assets/neutronia/recipes/andesite_bricks.json	(date 1525350113000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "stones",
+  "pattern": [
+    "AA",
+    "AA"
+  ],
+  "key": {
+    "A": {
+      "item": "minecraft:stone",
+      "data": 6
+    }
+  },
+  "result": {
+    "item": "neutronia:andesite_bricks",
+    "count": 4
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpTarget.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpTarget.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpTarget.java	(date 1523987836000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.entity.ai;
+
+import net.hdt.neutronia.entity.EntityScorp;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
+
+public class EntityAIScorpTarget<T extends EntityLivingBase> extends EntityAINearestAttackableTarget<T> {
+    public EntityAIScorpTarget(EntityScorp scorp, Class<T> classTarget) {
+        super(scorp, classTarget, true);
+    }
+
+    public boolean shouldExecute() {
+        return super.shouldExecute();
+    }
+}
Index: src/main/resources/assets/neutronia/recipes/white_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/white_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/white_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 15
+    }
+  ],
+  "result": {
+    "item": "neutronia:white_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/purple_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/purple_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/purple_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 5
+    }
+  ],
+  "result": {
+    "item": "neutronia:purple_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/jungle_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/jungle_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/jungle_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,22 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 3
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:jungle_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/yellow_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/yellow_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/yellow_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 11
+    }
+  ],
+  "result": {
+    "item": "neutronia:yellow_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/lime_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/lime_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/lime_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 10
+    }
+  ],
+  "result": {
+    "item": "neutronia:lime_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/black_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/black_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/black_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 0
+    }
+  ],
+  "result": {
+    "item": "neutronia:black_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/dark_oak_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/dark_oak_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/dark_oak_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 5
+    }
+  },
+  "result": {
+    "item": "neutronia:dark_oak_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherPlantBase.java	(date 1524919933000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherPlantBase.java	(date 1524919933000)
@@ -0,0 +1,31 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public class BlockNetherPlantBase extends BlockModBush {
+
+    public BlockNetherPlantBase(String name) {
+        super(Material.PLANTS, name, Reference.MOD_ID);
+        this.setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/recipes/acacia_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/acacia_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/acacia_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,22 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 4
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:acacia_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/properties/Type.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/Type.java	(date 1523986195000)
+++ src/main/java/net/hdt/neutronia/properties/Type.java	(date 1523986195000)
@@ -0,0 +1,90 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum Type implements IStringSerializable {
+
+    RAW(0, "raw"),
+    PAVER(1, "paver"),
+    BRICKS(2, "bricks"),
+    CHISELED(3, "chiseled"),
+    BRICK_SMALL(4, "brick_small"),
+    TILE(5, "tile"),
+    PILLAR(6, "pillar"),
+    ARCH(7, "arch"),
+    ENGRAVED(8, "engraved"),
+    RUNED(9, "runed"),
+    PILLAR_TOP(10, "pillar_top"),
+    PILLAR_BOTTOM(11, "pillar_bottom"),
+    PILLAR_MIDDLE(12, "pillar_middle");
+
+    private static final Type[] METADATA_LOOKUP = new Type[values().length];
+
+    static {
+        for (Type type : values()) {
+            METADATA_LOOKUP[type.getMetadata()] = type;
+        }
+    }
+
+    private final int metadata;
+    private final String name;
+    private final int light;
+    private final float hardness;
+    private final float resistance;
+
+    Type(int metadata, String name, int light, float hardness, float resistance) {
+
+        this.metadata = metadata;
+        this.name = name;
+        this.light = light;
+        this.hardness = hardness;
+        this.resistance = resistance;
+    }
+
+    Type(int metadata, String name, float hardness, float resistance) {
+        this(metadata, name, 0, hardness, resistance);
+    }
+
+    Type(int metadata, String name, int light) {
+
+        this(metadata, name, light, 5.0F, 6.0F);
+    }
+
+    Type(int metadata, String name) {
+
+        this(metadata, name, 0, 5.0F, 6.0F);
+    }
+
+    public static Type byMetadata(int metadata) {
+
+        if (metadata < 0 || metadata >= METADATA_LOOKUP.length) {
+            metadata = 0;
+        }
+        return METADATA_LOOKUP[metadata];
+    }
+
+    public int getMetadata() {
+        return this.metadata;
+    }
+
+    @Override
+    public String getName() {
+
+        return this.name;
+    }
+
+    public int getLight() {
+
+        return this.light;
+    }
+
+    public float getHardness() {
+
+        return this.hardness;
+    }
+
+    public float getResistance() {
+
+        return this.resistance;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/gray_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/gray_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/gray_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 8
+    }
+  ],
+  "result": {
+    "item": "neutronia:gray_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityTropicalFish.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityTropicalFish.java	(date 1523986179000)
+++ src/main/java/net/hdt/neutronia/entity/EntityTropicalFish.java	(date 1523986179000)
@@ -0,0 +1,242 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.MoverType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBase;
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+
+public class EntityTropicalFish extends EntityWaterMob {
+
+    public float squidPitch;
+    public float prevSquidPitch;
+    public float squidYaw;
+    public float prevSquidYaw;
+    /**
+     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
+     */
+    public float squidRotation;
+    /**
+     * previous squidRotation in radians
+     */
+    public float prevSquidRotation;
+    /**
+     * angle of the tentacles in radians
+     */
+    public float tentacleAngle;
+    /**
+     * the last calculated angle of the tentacles in radians
+     */
+    public float lastTentacleAngle;
+    private float randomMotionSpeed;
+    /**
+     * change in squidRotation in radians.
+     */
+    private float rotationVelocity;
+    private float rotateSpeed;
+    private float randomMotionVecX;
+    private float randomMotionVecY;
+    private float randomMotionVecZ;
+
+    public EntityTropicalFish(World worldIn) {
+        super(worldIn);
+        this.setSize(0.5F, 0.3F);
+        this.rand.setSeed((long) (1 + this.getEntityId()));
+        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityTropicalFish.AIMoveRandom(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
+    }
+
+    public float getEyeHeight() {
+        return this.height;
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SQUID_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SQUID_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SQUID_DEATH;
+    }
+
+    /**
+     * Returns the volume for the sounds this mob makes.
+     */
+    protected float getSoundVolume() {
+        return 0.4F;
+    }
+
+    /**
+     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
+     * prevent them from trampling crops
+     */
+    protected boolean canTriggerWalking() {
+        return false;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_SQUID;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+        this.prevSquidPitch = this.squidPitch;
+        this.prevSquidYaw = this.squidYaw;
+        this.prevSquidRotation = this.squidRotation;
+        this.lastTentacleAngle = this.tentacleAngle;
+        this.squidRotation += this.rotationVelocity;
+
+        if ((double) this.squidRotation > (Math.PI * 2D)) {
+            if (this.world.isRemote) {
+                this.squidRotation = ((float) Math.PI * 2F);
+            } else {
+                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
+
+                if (this.rand.nextInt(10) == 0) {
+                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+                }
+
+                this.world.setEntityState(this, (byte) 19);
+            }
+        }
+
+        if (this.inWater) {
+            if (this.squidRotation < (float) Math.PI) {
+                float f = this.squidRotation / (float) Math.PI;
+                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
+
+                if ((double) f > 0.75D) {
+                    this.randomMotionSpeed = 1.0F;
+                    this.rotateSpeed = 1.0F;
+                } else {
+                    this.rotateSpeed *= 0.8F;
+                }
+            } else {
+                this.tentacleAngle = 0.0F;
+                this.randomMotionSpeed *= 0.9F;
+                this.rotateSpeed *= 0.99F;
+            }
+
+            if (!this.world.isRemote) {
+                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
+                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
+                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
+            }
+
+            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
+            this.rotationYaw = this.renderYawOffset;
+            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
+            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
+        } else {
+            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
+
+            if (!this.world.isRemote) {
+                this.motionX = 0.0D;
+                this.motionZ = 0.0D;
+
+                if (this.isPotionActive(MobEffects.LEVITATION)) {
+                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
+                } else if (!this.hasNoGravity()) {
+                    this.motionY -= 0.08D;
+                }
+
+                this.motionY *= 0.9800000190734863D;
+            }
+
+            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
+        }
+    }
+
+    public void travel(float strafe, float vertical, float forward) {
+        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+    }
+
+    /**
+     * Checks if the entity's current position is a valid location to spawn this entity.
+     */
+    public boolean getCanSpawnHere() {
+        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
+    }
+
+    /**
+     * Handler for {@link World#setEntityState}
+     */
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 19) {
+            this.squidRotation = 0.0F;
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
+        this.randomMotionVecX = randomMotionVecXIn;
+        this.randomMotionVecY = randomMotionVecYIn;
+        this.randomMotionVecZ = randomMotionVecZIn;
+    }
+
+    public boolean hasMovementVector() {
+        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
+    }
+
+    static class AIMoveRandom extends EntityAIBase {
+        private final EntityTropicalFish squid;
+
+        public AIMoveRandom(EntityTropicalFish p_i45859_1_) {
+            this.squid = p_i45859_1_;
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            return true;
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            int i = this.squid.getIdleTime();
+
+            if (i > 100) {
+                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
+            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
+                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
+                float f1 = MathHelper.cos(f) * 0.2F;
+                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
+                float f3 = MathHelper.sin(f) * 0.2F;
+                this.squid.setMovementVector(f1, f2, f3);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/cyan_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/cyan_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/cyan_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 6
+    }
+  ],
+  "result": {
+    "item": "neutronia:cyan_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/oak_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/oak_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/oak_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,21 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks"
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:oak_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/green_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/green_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/green_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 2
+    }
+  ],
+  "result": {
+    "item": "neutronia:green_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/jungle_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/jungle_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/jungle_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 3
+    }
+  },
+  "result": {
+    "item": "neutronia:jungle_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Posture.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Posture.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Posture.java	(date 1525606900000)
@@ -0,0 +1,231 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.minecraft.block.Block;
+import net.minecraft.util.math.BlockPos;
+
+/* Reflects information about cuboid stereometric state in the world. */
+class Posture {
+
+    private int posX, posY, posZ;
+    private int rotateX, rotateY, rotateZ;
+    private boolean flipX, flipY, flipZ;
+    private int width, height, length;
+    private int sizeX, sizeY, sizeZ;
+    private int endX, endY, endZ;
+
+    Posture(int posX, int posY, int posZ,
+            int rotateX, int rotateY, int rotateZ,
+            boolean flipX, boolean flipY, boolean flipZ,
+            int width, int height, int length) {
+        this.posX = posX;
+        this.posY = posY;
+        this.posZ = posZ;
+        this.rotateX = (rotateX % 4 + 4) % 4;
+        this.rotateY = (rotateY % 4 + 4) % 4;
+        this.rotateZ = (rotateZ % 4 + 4) % 4;
+        this.flipX = flipX;
+        this.flipY = flipY;
+        this.flipZ = flipZ;
+        this.width = width;
+        this.height = height;
+        this.length = length;
+        update();
+    }
+
+    void shift(int dx, int dy, int dz) {
+        this.posX += dx;
+        this.posY += dy;
+        this.posZ += dz;
+        update();
+    }
+
+    private void update() {
+        this.sizeX = width;
+        this.sizeY = height;
+        this.sizeZ = length;
+        if (rotateX % 2 > 0) {
+            int tmp = sizeY;
+            sizeY = sizeZ;
+            sizeZ = tmp;
+        }
+        if (rotateY % 2 > 0) {
+            int tmp = sizeX;
+            sizeX = sizeZ;
+            sizeZ = tmp;
+        }
+        if (rotateZ % 2 > 0) {
+            int tmp = sizeX;
+            sizeX = sizeY;
+            sizeY = tmp;
+        }
+        this.endX = posX + sizeX;
+        this.endY = posY + sizeY;
+        this.endZ = posZ + sizeZ;
+    }
+
+    /* Get world position of structure index(x,y,z) block */
+    BlockPos getWorldPos(int x, int y, int z) {
+        int wx = flipX ? width - x - 1 : x;
+        int wy = flipY ? height - y - 1 : y;
+        int wz = flipZ ? length - z - 1 : z;
+        int w = width, h = height, l = length;
+        /* ADD X rotations */
+        /* ADD Z rotations */
+        for (int i = 0; i < rotateY; ++i) {
+            int tmp = wz;
+            wz = w - wx - 1;
+            wx = tmp;
+            tmp = w;
+            w = l;
+            l = tmp;
+        }
+        return new BlockPos(wx + posX, wy + posY, wz + posZ);
+    }
+
+    /* Get world metadata of block with metadata */
+    int getWorldMeta(Block block, byte meta) {
+        Directions.BlockType blockType = Directions.getBlockType(block, meta);
+        int mask = Directions.getMask(blockType);
+        int overlap = (meta & mask) ^ meta;
+        int direction = Directions.getDirection(meta & mask, blockType);
+        /* Rotation counter-clockwise */
+        int[] rotationsY = {Directions.EAST, Directions.NORTH, Directions.WEST, Directions.SOUTH};
+        /* ADD X rotations */
+        /* ADD Z rotations */
+        /* ADD Y flip */
+        int rotY = rotateY;
+        boolean zAxis = (direction == Directions.SOUTH || direction == Directions.NORTH);
+        boolean xAxis = (direction == Directions.WEST || direction == Directions.EAST);
+        if (Directions.isDoubleDirected(blockType)) {
+            /* Always should be directed clockwise */
+            if (flipX && flipZ) {
+                rotY += 2;
+            } else {
+                rotY += flipX ? zAxis ? 1 : -1 : 0;
+                rotY += flipZ ? xAxis ? 1 : -1 : 0;
+            }
+        } else {
+            rotY += (flipX && xAxis) ? 2 : 0;
+            rotY += (flipZ && zAxis) ? 2 : 0;
+        }
+        rotY = (4 + rotY % 4) % 4;
+        if (direction == Directions.EAST) {
+            return Directions.getMeta(meta, rotationsY[rotY % 4], blockType) | overlap;
+        }
+        if (direction == Directions.NORTH) {
+            return Directions.getMeta(meta, rotationsY[(1 + rotY) % 4], blockType) | overlap;
+        }
+        if (direction == Directions.WEST) {
+            return Directions.getMeta(meta, rotationsY[(2 + rotY) % 4], blockType) | overlap;
+        }
+        if (direction == Directions.SOUTH) {
+            return Directions.getMeta(meta, rotationsY[(3 + rotY) % 4], blockType) | overlap;
+        }
+        return meta | overlap;
+    }
+
+    int getPosX() {
+        return posX;
+    }
+
+    int getPosY() {
+        return posY;
+    }
+
+    int getPosZ() {
+        return posZ;
+    }
+
+    int getRotateX() {
+        return rotateX;
+    }
+
+    int getRotateY() {
+        return rotateY;
+    }
+
+    int getRotateZ() {
+        return rotateZ;
+    }
+
+    boolean isFlipX() {
+        return flipX;
+    }
+
+    boolean isFlipY() {
+        return flipY;
+    }
+
+    boolean isFlipZ() {
+        return flipZ;
+    }
+
+    int getWidth() {
+        return width;
+    }
+
+    int getHeight() {
+        return height;
+    }
+
+    int getLength() {
+        return length;
+    }
+
+    int getSizeX() {
+        return sizeX;
+    }
+
+    int getSizeY() {
+        return sizeY;
+    }
+
+    int getSizeZ() {
+        return sizeZ;
+    }
+
+    int getEndX() {
+        return endX;
+    }
+
+    int getEndY() {
+        return endY;
+    }
+
+    int getEndZ() {
+        return endZ;
+    }
+
+    int getIndex(int x, int y, int z) {
+        return x + y * width * length + z * width;
+    }
+
+    int getX(int index) {
+        return index % width;
+    }
+
+    int getY(int index) {
+        return index / (width * length);
+    }
+
+    int getZ(int index) {
+        return (index / width) % length;
+    }
+
+    int getStartChunkX() {
+        return posX / 16 + (posX < 0 ? -1 : 0);
+    }
+
+    int getStartChunkZ() {
+        return posZ / 16 + (posZ < 0 ? -1 : 0);
+    }
+
+    int getEndChunkX() {
+        return getEndX() / 16 + (getEndX() < 0 ? -1 : 0);
+    }
+
+    int getEndChunkZ() {
+        return getEndZ() / 16 + (getEndZ() < 0 ? -1 : 0);
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/acacia_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/acacia_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/acacia_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 4
+    }
+  },
+  "result": {
+    "item": "neutronia:acacia_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/handlers/EventHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/EventHandler.java	(date 1524839924000)
+++ src/main/java/net/hdt/neutronia/util/handlers/EventHandler.java	(date 1524839924000)
@@ -0,0 +1,98 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.init.HMItems;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.enchantment.EnchantmentHelper;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.monster.EntityWitherSkeleton;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Enchantments;
+import net.minecraft.init.Items;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DimensionType;
+import net.minecraft.world.World;
+import net.minecraftforge.common.util.FakePlayer;
+import net.minecraftforge.event.entity.living.LivingDropsEvent;
+import net.minecraftforge.event.world.BlockEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.Event;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.util.ListIterator;
+import java.util.Random;
+
+@SuppressWarnings("ConstantConditions")
+@Mod.EventBusSubscriber(modid = Reference.MOD_ID)
+public class EventHandler {
+
+    @SubscribeEvent
+    public static void onBlockBreak(BlockEvent.BreakEvent event) {
+        World world = event.getWorld();
+        BlockPos pos = event.getPos();
+        IBlockState state = event.getState();
+
+        if (!(event.getPlayer() instanceof FakePlayer)) {
+            EntityPlayer player = event.getPlayer();
+
+            if (state.getBlock() == Blocks.MAGMA) {
+                if (ConfigHandler.blockConfig.magma.turnIntoLava) {
+                    if (EnchantmentHelper.getEnchantmentLevel(Enchantments.SILK_TOUCH, player.getHeldItemMainhand()) == 0) {
+                        world.setBlockState(pos, Blocks.LAVA.getDefaultState(), 3);
+                        player.getHeldItemMainhand().damageItem(1, player);
+                        event.setCanceled(true);
+                    }
+                }
+            }
+        }
+    }
+
+    @SubscribeEvent
+    public static void onBlockPlaced(BlockEvent.PlaceEvent event) {
+        BlockPos pos = event.getPos();
+        IBlockState state = event.getState();
+        EntityPlayer player = event.getPlayer();
+
+        if (state.getBlock() == Blocks.BEDROCK) {
+            if (player.dimension != DimensionType.NETHER.getId() || pos.getY() < 120) {
+                event.setCanceled(true);
+            }
+        }
+    }
+
+    @SubscribeEvent
+    public static void onCreateFluidSource(BlockEvent.CreateFluidSourceEvent event) {
+        World world = event.getWorld();
+        BlockPos pos = event.getPos();
+        IBlockState state = event.getState();
+
+        if (world.provider.getDimension() == DimensionType.NETHER.getId()) {
+            if (state.getBlock() == Blocks.LAVA || state.getBlock() == Blocks.FLOWING_LAVA) {
+                event.setResult(ConfigHandler.dimensionConfig.nether.isLavaInfinite ? Event.Result.ALLOW : Event.Result.DEFAULT);
+            }
+        }
+    }
+
+    @SubscribeEvent
+    public static void onLivingDrops(LivingDropsEvent event) {
+        Random rand = new Random();
+        BlockPos deathPoint = event.getEntity().getPosition();
+
+        if (event.getEntity() instanceof EntityWitherSkeleton) {
+            ListIterator<EntityItem> iter = event.getDrops().listIterator();
+
+            while (iter.hasNext()) {
+                EntityItem entityItem = iter.next();
+                ItemStack stack = entityItem.getItem();
+
+                if (stack.getItem() == Items.BONE || stack.getItem() == Items.COAL) {
+                    iter.remove();
+                }
+            }
+
+            event.getDrops().add(new EntityItem(event.getEntity().world, deathPoint.getX(), deathPoint.getY(), deathPoint.getZ(), new ItemStack(HMItems.witherBone, rand.nextInt(3), 0)));
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/birch_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/birch_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/birch_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,22 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 2
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:birch_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/light_blue_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/light_blue_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/light_blue_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 12
+    }
+  ],
+  "result": {
+    "item": "neutronia:light_blue_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/oak_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/oak_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/oak_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks"
+    }
+  },
+  "result": {
+    "item": "neutronia:oak_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Distributor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Distributor.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Distributor.java	(date 1525606901000)
@@ -0,0 +1,89 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/* Assign array of clusters to biome map and distribute relative spawn chance */
+class Distributor {
+
+    private HashMap<Integer, ArrayList<Cluster>> biomesClusters = new HashMap<Integer, ArrayList<Cluster>>();
+
+    /* Constructs distributor using chaotic cluster array */
+    Distributor(ArrayList<Cluster> clusters) {
+
+        /* Assign config ratios */
+        double A = Decorator.ratioA;
+        double B = Decorator.ratioB;
+        boolean strictly = Decorator.strictMode;
+
+        /* Put all clusters appropriate biome entry */
+        int common_bid = Biome.Style.COMMON.value;
+        for (Cluster cluster : clusters) {
+            HashMap<Integer, Integer> biomeStyles = new HashMap<Integer, Integer>();
+            for (Structure structure : cluster.getStructures()) {
+                int bid = structure.flags.getInteger("Biome");
+                biomeStyles.put(bid, biomeStyles.getOrDefault(bid, 0) + 1);
+                if (!strictly && structure.flags.getString("Method").equalsIgnoreCase("Floating")) {
+                    biomeStyles.put(common_bid, biomeStyles.getOrDefault(common_bid, 0) + 1);
+                }
+            }
+            /* Put cluster to biomes that have maximal similarity. May be one, two or more */
+            int maxValue = Collections.max(biomeStyles.values());
+            for (Map.Entry<Integer, Integer> entry : biomeStyles.entrySet()) {
+                if (entry.getValue() == maxValue) {
+                    int bid = entry.getKey();
+                    final Cluster clusterCopy = new Cluster(cluster);
+                    if (biomesClusters.containsKey(bid)) {
+                        biomesClusters.get(bid).add(clusterCopy);
+                    } else {
+                        biomesClusters.put(bid, new ArrayList<Cluster>() {{
+                            add(clusterCopy);
+                        }});
+                    }
+                }
+            }
+        }
+
+        /* Distribute and normalize clusters weight deviations of average value */
+        for (ArrayList<Cluster> biomeClusters : biomesClusters.values()) {
+            long blocksTotal = 0;
+            for (Cluster cluster : biomeClusters) {
+                for (Structure structure : cluster.getStructures()) {
+                    int width = structure.flags.getShort("Width");
+                    int height = structure.flags.getShort("Height");
+                    int length = structure.flags.getShort("Length");
+                    blocksTotal += width * height * length;
+                }
+            }
+            double averageBlocks = blocksTotal / biomeClusters.size();
+            double chancesSum = 0;
+            for (Cluster cluster : biomeClusters) {
+                long weight = 0;
+                for (Structure structure : cluster.getStructures()) {
+                    int width = structure.flags.getShort("Width");
+                    int height = structure.flags.getShort("Height");
+                    int length = structure.flags.getShort("Length");
+                    weight += width * height * length;
+                }
+                /* Logistic smooth saturation function  */
+                /* f(x) = 2 / (1 + e ^ (-A * x ^ B)) - 1, default A = 1, B = 0.5 */
+                double saturation = 2.0 / (1.0 + Math.exp(-A * Math.pow(weight / averageBlocks, B))) - 1.0;
+                double chance = 1.0 - saturation;
+                cluster.setChance(chance);
+                chancesSum += chance;
+            }
+            /* Make sum of all chances = 1 : (a+b+c)/(a+b+c) = 1 */
+            for (Cluster cluster : biomeClusters) {
+                cluster.setChance(cluster.getChance() / chancesSum);
+            }
+        }
+    }
+
+    /* Get all clusters that can be spawned in given biome type */
+    ArrayList<Cluster> getClusters(Biome.Style biome) {
+        return biomesClusters.getOrDefault(biome.value, new ArrayList<Cluster>());
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/blue_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/blue_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/blue_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 4
+    }
+  ],
+  "result": {
+    "item": "neutronia:blue_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/utils/WorldGenUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/WorldGenUtils.java	(date 1523986190000)
+++ src/main/java/net/hdt/neutronia/world/utils/WorldGenUtils.java	(date 1523986190000)
@@ -0,0 +1,65 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.structure.template.Template;
+
+public class WorldGenUtils {
+
+    public static int calculateGenerationHeight(World world, int x, int z, Block topBlock) {
+        int y = world.getHeight();
+        boolean foundGround = false;
+
+        while (!foundGround && y-- >= 0) {
+            Block block = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = block == topBlock;
+        }
+
+        return y;
+    }
+
+    public static int getGroundFromAbove(World world, int x, int z) {
+        int y = 255;
+        boolean foundGround = false;
+        while (!foundGround && y-- >= 31) {
+            Block blockAt = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = blockAt == Blocks.WATER || blockAt == Blocks.FLOWING_WATER || blockAt == Blocks.GRASS || blockAt == Blocks.SAND || blockAt == Blocks.SNOW || blockAt == Blocks.SNOW_LAYER || blockAt == Blocks.GLASS || blockAt == Blocks.MYCELIUM;
+        }
+
+        return y;
+    }
+
+    public static int getLakeFromAbove(World world, int x, int z) {
+        int y = 255;
+        boolean foundGround = false;
+        while (!foundGround && y-- >= 31) {
+            Block blockAt = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+            foundGround = blockAt == Blocks.WATER || blockAt == Blocks.FLOWING_WATER;
+        }
+
+        return y;
+    }
+
+    public static boolean canSpawnHere(Template template, World world, BlockPos posAboveGround) {
+        int zwidth = template.getSize().getZ();
+        int xwidth = template.getSize().getX();
+
+        // check all the corners to see which ones are replaceable
+        boolean corner1 = isCornerValid(world, posAboveGround);
+        boolean corner2 = isCornerValid(world, posAboveGround.add(xwidth, 0, zwidth));
+
+        // if Y > 20 and all corners pass the test, it's okay to spawn the structure
+        return posAboveGround.getY() > 31 && corner1 && corner2;
+    }
+
+    public static boolean isCornerValid(World world, BlockPos pos) {
+        int variation = 3;
+        int highestBlock = getGroundFromAbove(world, pos.getX(), pos.getZ());
+
+        return highestBlock > pos.getY() - variation && highestBlock < pos.getY() + variation;
+
+    }
+
+}
Index: src/main/resources/assets/neutronia/recipes/birch_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/birch_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/birch_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 2
+    }
+  },
+  "result": {
+    "item": "neutronia:birch_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/dark_oak_bookshelf.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/dark_oak_bookshelf.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/dark_oak_bookshelf.json	(date 1525345853000)
@@ -0,0 +1,22 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "bookshelves",
+  "pattern": [
+    "WWW",
+    "BBB",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 5
+    },
+    "B": {
+      "item": "minecraft:book"
+    }
+  },
+  "result": {
+    "item": "neutronia:dark_oak_bookshelf"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/brown_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/brown_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/brown_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 3
+    }
+  ],
+  "result": {
+    "item": "neutronia:brown_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/orange_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/orange_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/orange_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 14
+    }
+  ],
+  "result": {
+    "item": "neutronia:orange_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockDesertPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockDesertPlantBase.java	(date 1523987841000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockDesertPlantBase.java	(date 1523987841000)
@@ -0,0 +1,31 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public class BlockDesertPlantBase extends BlockModBush {
+
+    public BlockDesertPlantBase(String name) {
+        super(Material.PLANTS, name, Reference.MOD_ID);
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockVerticalSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockVerticalSlab.java	(date 1525606888000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockVerticalSlab.java	(date 1525606888000)
@@ -0,0 +1,288 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockSlab;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyDirection;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Mirror;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.common.ForgeModContainer;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlockSlab;
+import net.thegaminghuskymc.huskylib2.recipie.RecipeHandler;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import java.util.HashMap;
+import java.util.Random;
+
+public class BlockVerticalSlab extends Block implements IModBlock {
+
+    public static final PropertyEnum<BlockSlab.EnumBlockHalf> HALF = PropertyEnum.create("half", BlockSlab.EnumBlockHalf.class);
+    public static final PropertyDirection PROPERTYFACING = PropertyDirection.create("facing", EnumFacing.Plane.HORIZONTAL);
+    protected static final AxisAlignedBB AABB_NORTH = new AxisAlignedBB(0.0D, 0.0D, 0.5D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_SOUTH = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 0.5D);
+    protected static final AxisAlignedBB AABB_EAST = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.5D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_WEST = new AxisAlignedBB(0.5D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D);
+    public static HashMap<BlockVerticalSlab, BlockVerticalSlab> halfSlabs = new HashMap<>();
+    public static HashMap<BlockVerticalSlab, BlockVerticalSlab> fullSlabs = new HashMap<>();
+    static boolean tempDoubleSlab;
+    private final String[] variants;
+    private final String bareName, modid;
+    boolean doubleSlab;
+
+    public BlockVerticalSlab(String name, String modid, Material materialIn, boolean doubleSlab) {
+        super(hacky(materialIn, doubleSlab));
+        this.doubleSlab = doubleSlab;
+        if (doubleSlab)
+            name += "_double";
+
+        variants = new String[]{name};
+        bareName = name;
+        this.modid = modid;
+
+        setUnlocalizedName(name);
+        if (!doubleSlab) {
+            useNeighborBrightness = true;
+            setDefaultState(blockState.getBaseState().withProperty(PROPERTYFACING, EnumFacing.NORTH).withProperty(HALF, BlockSlab.EnumBlockHalf.BOTTOM));
+        }
+    }
+
+    public static Material hacky(Material m, boolean doubleSlab) {
+        tempDoubleSlab = doubleSlab;
+        return m;
+    }
+
+    public static void initSlab(Block base, int meta, BlockVerticalSlab half, BlockVerticalSlab full) {
+        fullSlabs.put(half, full);
+        fullSlabs.put(full, full);
+        halfSlabs.put(half, half);
+        halfSlabs.put(full, half);
+
+        half.register();
+        full.register();
+
+        RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(half, 6),
+                "BBB",
+                'B', ProxyRegistry.newStack(base, 1, meta));
+    }
+
+    protected boolean canSilkHarvest() {
+        return false;
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        if (isDouble())
+            return FULL_BLOCK_AABB;
+        if (state.getValue(PROPERTYFACING) == EnumFacing.NORTH)
+            return AABB_NORTH;
+        if (state.getValue(PROPERTYFACING) == EnumFacing.SOUTH)
+            return AABB_SOUTH;
+        if (state.getValue(PROPERTYFACING) == EnumFacing.EAST)
+            return AABB_EAST;
+        if (state.getValue(PROPERTYFACING) == EnumFacing.WEST)
+            return AABB_WEST;
+        else
+            return FULL_BLOCK_AABB;
+    }
+
+    public boolean isTopSolid(IBlockState state) {
+        return isDouble();
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return isDouble();
+    }
+
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        if (ForgeModContainer.disableStairSlabCulling)
+            return super.doesSideBlockRendering(state, world, pos, face);
+        if (state.isOpaqueCube()) {
+            return true;
+        } else {
+            EnumFacing facing = state.getValue(PROPERTYFACING);
+            return facing == EnumFacing.NORTH && face == EnumFacing.SOUTH || facing == EnumFacing.SOUTH && face == EnumFacing.NORTH || facing == EnumFacing.EAST && face == EnumFacing.WEST || facing == EnumFacing.WEST && face == EnumFacing.EAST;
+        }
+    }
+
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta,
+                                            EntityLivingBase placer) {
+        if (placer.getHorizontalFacing() == EnumFacing.NORTH) {
+            if (facing == EnumFacing.SOUTH)
+                return getDefaultState().withProperty(PROPERTYFACING, facing);
+            if ((double) hitZ < 0.5D && !isDouble())
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.SOUTH);
+            else
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.NORTH);
+        }
+        if (placer.getHorizontalFacing() == EnumFacing.SOUTH) {
+            if (facing == EnumFacing.NORTH)
+                return getDefaultState().withProperty(PROPERTYFACING, facing);
+            if ((double) hitZ < 0.5D || isDouble())
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.SOUTH);
+            else
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.NORTH);
+        }
+        if (placer.getHorizontalFacing() == EnumFacing.EAST) {
+            if (facing == EnumFacing.WEST)
+                return getDefaultState().withProperty(PROPERTYFACING, facing);
+            if ((double) hitX < 0.5D || isDouble())
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.EAST);
+            else
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.WEST);
+        }
+        if (placer.getHorizontalFacing() == EnumFacing.WEST) {
+            if (facing == EnumFacing.EAST)
+                return getDefaultState().withProperty(PROPERTYFACING, facing);
+            if ((double) hitX < 0.5D && !isDouble())
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.EAST);
+            else
+                return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.WEST);
+        } else {
+            return getDefaultState().withProperty(PROPERTYFACING, EnumFacing.NORTH);
+        }
+    }
+
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        return state.withProperty(PROPERTYFACING, rot.rotate(state.getValue(PROPERTYFACING)));
+    }
+
+    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {
+        return state.withRotation(mirrorIn.toRotation(state.getValue(PROPERTYFACING)));
+    }
+
+    public int quantityDropped(Random random) {
+        return isDouble() ? 2 : 1;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return isDouble();
+    }
+
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        if (isDouble())
+            return super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+        else
+            return true;
+    }
+
+    @Override
+    public BlockStateContainer createBlockState() {
+        return tempDoubleSlab ? new BlockStateContainer(this, PROPERTYFACING, getVariantProp()) : new BlockStateContainer(this, PROPERTYFACING, getVariantProp());
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        return getDefaultState();
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        return 0;
+    }
+
+    public BlockVerticalSlab getFullBlock() {
+        return fullSlabs.get(this);
+    }
+
+    public BlockVerticalSlab getSingleBlock() {
+        return halfSlabs.get(this);
+    }
+
+    @Override
+    public ItemStack getPickBlock(IBlockState state, RayTraceResult target, World world, BlockPos pos, EntityPlayer player) {
+        return new ItemStack(getSingleBlock());
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState p_149650_1_, Random p_149650_2_, int p_149650_3_) {
+        return Item.getItemFromBlock(getSingleBlock());
+    }
+
+    @Override
+    public int quantityDropped(IBlockState state, int fortune, Random random) {
+        return super.quantityDropped(state, fortune, random);
+    }
+
+    public void register() {
+        setRegistryName(getPrefix(), bareName);
+        ProxyRegistry.register(this);
+        if (!isDouble())
+            ProxyRegistry.register(new ItemModBlockSlab(this, new ResourceLocation(getPrefix(), bareName)));
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[0];
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    public boolean isDouble() {
+        return doubleSlab;
+    }
+
+    @Override
+    public boolean isFullBlock(IBlockState state) {
+        return isDouble();
+    }
+
+    @Override
+    public boolean isSideSolid(IBlockState base_state, IBlockAccess world, BlockPos pos, EnumFacing side) {
+        IBlockState state = getActualState(base_state, world, pos);
+        return isDouble()
+                || (state.getValue(BlockSlab.HALF) == BlockSlab.EnumBlockHalf.TOP && side == EnumFacing.UP)
+                || (state.getValue(BlockSlab.HALF) == BlockSlab.EnumBlockHalf.BOTTOM && side == EnumFacing.DOWN);
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+}
Index: src/main/resources/assets/neutronia/recipes/pink_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/pink_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/pink_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 9
+    }
+  ],
+  "result": {
+    "item": "neutronia:pink_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/magenta_colored_vase.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/magenta_colored_vase.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/magenta_colored_vase.json	(date 1525345853000)
@@ -0,0 +1,18 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shapeless",
+  "group": "colored_vases",
+  "ingredients": [
+    {
+      "item": "minecraft:flower_pot",
+      "data": 0
+    },
+    {
+      "item": "minecraft:dye",
+      "data": 13
+    }
+  ],
+  "result": {
+    "item": "neutronia:magenta_colored_vase"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/spruce_trapdoor.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/spruce_trapdoor.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/recipes/spruce_trapdoor.json	(date 1525345853000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "wooden_trapdoors",
+  "pattern": [
+    "WWW",
+    "WWW"
+  ],
+  "key": {
+    "W": {
+      "item": "minecraft:planks",
+      "data": 1
+    }
+  },
+  "result": {
+    "item": "neutronia:spruce_trapdoor",
+    "count": 6
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/granite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/granite_bricks.json	(date 1525350113000)
+++ src/main/resources/assets/neutronia/recipes/granite_bricks.json	(date 1525350113000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "stones",
+  "pattern": [
+    "GG",
+    "GG"
+  ],
+  "key": {
+    "G": {
+      "item": "minecraft:stone",
+      "data": 2
+    }
+  },
+  "result": {
+    "item": "neutronia:granite_bricks",
+    "count": 4
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntitySalmon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntitySalmon.java	(date 1523986191000)
+++ src/main/java/net/hdt/neutronia/entity/EntitySalmon.java	(date 1523986191000)
@@ -0,0 +1,242 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.MoverType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBase;
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+
+public class EntitySalmon extends EntityWaterMob {
+
+    public float squidPitch;
+    public float prevSquidPitch;
+    public float squidYaw;
+    public float prevSquidYaw;
+    /**
+     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
+     */
+    public float squidRotation;
+    /**
+     * previous squidRotation in radians
+     */
+    public float prevSquidRotation;
+    /**
+     * angle of the tentacles in radians
+     */
+    public float tentacleAngle;
+    /**
+     * the last calculated angle of the tentacles in radians
+     */
+    public float lastTentacleAngle;
+    private float randomMotionSpeed;
+    /**
+     * change in squidRotation in radians.
+     */
+    private float rotationVelocity;
+    private float rotateSpeed;
+    private float randomMotionVecX;
+    private float randomMotionVecY;
+    private float randomMotionVecZ;
+
+    public EntitySalmon(World worldIn) {
+        super(worldIn);
+        this.setSize(0.5F, 0.3F);
+        this.rand.setSeed((long) (1 + this.getEntityId()));
+        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntitySalmon.AIMoveRandom(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
+    }
+
+    public float getEyeHeight() {
+        return this.height;
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SQUID_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SQUID_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SQUID_DEATH;
+    }
+
+    /**
+     * Returns the volume for the sounds this mob makes.
+     */
+    protected float getSoundVolume() {
+        return 0.4F;
+    }
+
+    /**
+     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
+     * prevent them from trampling crops
+     */
+    protected boolean canTriggerWalking() {
+        return false;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_SQUID;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+        this.prevSquidPitch = this.squidPitch;
+        this.prevSquidYaw = this.squidYaw;
+        this.prevSquidRotation = this.squidRotation;
+        this.lastTentacleAngle = this.tentacleAngle;
+        this.squidRotation += this.rotationVelocity;
+
+        if ((double) this.squidRotation > (Math.PI * 2D)) {
+            if (this.world.isRemote) {
+                this.squidRotation = ((float) Math.PI * 2F);
+            } else {
+                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
+
+                if (this.rand.nextInt(10) == 0) {
+                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+                }
+
+                this.world.setEntityState(this, (byte) 19);
+            }
+        }
+
+        if (this.inWater) {
+            if (this.squidRotation < (float) Math.PI) {
+                float f = this.squidRotation / (float) Math.PI;
+                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
+
+                if ((double) f > 0.75D) {
+                    this.randomMotionSpeed = 1.0F;
+                    this.rotateSpeed = 1.0F;
+                } else {
+                    this.rotateSpeed *= 0.8F;
+                }
+            } else {
+                this.tentacleAngle = 0.0F;
+                this.randomMotionSpeed *= 0.9F;
+                this.rotateSpeed *= 0.99F;
+            }
+
+            if (!this.world.isRemote) {
+                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
+                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
+                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
+            }
+
+            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
+            this.rotationYaw = this.renderYawOffset;
+            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
+            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
+        } else {
+            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
+
+            if (!this.world.isRemote) {
+                this.motionX = 0.0D;
+                this.motionZ = 0.0D;
+
+                if (this.isPotionActive(MobEffects.LEVITATION)) {
+                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
+                } else if (!this.hasNoGravity()) {
+                    this.motionY -= 0.08D;
+                }
+
+                this.motionY *= 0.9800000190734863D;
+            }
+
+            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
+        }
+    }
+
+    public void travel(float strafe, float vertical, float forward) {
+        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+    }
+
+    /**
+     * Checks if the entity's current position is a valid location to spawn this entity.
+     */
+    public boolean getCanSpawnHere() {
+        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
+    }
+
+    /**
+     * Handler for {@link World#setEntityState}
+     */
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 19) {
+            this.squidRotation = 0.0F;
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
+        this.randomMotionVecX = randomMotionVecXIn;
+        this.randomMotionVecY = randomMotionVecYIn;
+        this.randomMotionVecZ = randomMotionVecZIn;
+    }
+
+    public boolean hasMovementVector() {
+        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
+    }
+
+    static class AIMoveRandom extends EntityAIBase {
+        private final EntitySalmon squid;
+
+        public AIMoveRandom(EntitySalmon p_i45859_1_) {
+            this.squid = p_i45859_1_;
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            return true;
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            int i = this.squid.getIdleTime();
+
+            if (i > 100) {
+                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
+            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
+                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
+                float f1 = MathHelper.cos(f) * 0.2F;
+                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
+                float f3 = MathHelper.sin(f) * 0.2F;
+                this.squid.setMovementVector(f1, f2, f3);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderAnchored.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderAnchored.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderAnchored.java	(date 1523987836000)
@@ -0,0 +1,32 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityAnchored;
+import net.hdt.neutronia.entity.render.layer.LayerDiverSuit;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class RenderAnchored extends RenderBiped<EntityAnchored> {
+
+    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation("neutronia:textures/entity/diver/diver.png");
+
+    public RenderAnchored(RenderManager rendermanagerIn) {
+        super(rendermanagerIn, new ModelZombie(), 0.5F);
+        this.addLayer(new LayerDiverSuit(this));
+    }
+
+    @Override
+    protected boolean setBrightness(EntityAnchored entitylivingbaseIn, float partialTicks, boolean combineTextures) {
+        return true;
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityAnchored entity) {
+        return MUMMY_TEXTURE;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/ItemAnimaniaFoodRaw.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemAnimaniaFoodRaw.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/items/ItemAnimaniaFoodRaw.java	(date 1525606881000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.init.MobEffects;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.world.World;
+
+import java.util.List;
+
+public class ItemAnimaniaFoodRaw extends ItemAnimaniaFood {
+
+    public ItemAnimaniaFoodRaw(String name) {
+        super(1, 1f, name, new PotionEffect(MobEffects.NAUSEA, 200, 3, false, false));
+    }
+
+    @Override
+    public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
+
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/recipes/diorite_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/recipes/diorite_bricks.json	(date 1525350113000)
+++ src/main/resources/assets/neutronia/recipes/diorite_bricks.json	(date 1525350113000)
@@ -0,0 +1,19 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "type": "forge:ore_shaped",
+  "group": "stones",
+  "pattern": [
+    "DD",
+    "DD"
+  ],
+  "key": {
+    "D": {
+      "item": "minecraft:stone",
+      "data": 4
+    }
+  },
+  "result": {
+    "item": "neutronia:diorite_bricks",
+    "count": 4
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/GenerationStage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/GenerationStage.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/world/gen/GenerationStage.java	(date 1525606898000)
@@ -0,0 +1,57 @@
+package net.hdt.neutronia.world.gen;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import net.hdt.neutronia.world.gen.feature.EnhancedGenerator;
+import net.minecraft.world.biome.Biome;
+
+import java.util.List;
+import java.util.Map;
+
+public enum GenerationStage {
+    PRE_POPULATE,
+    POPULATE,
+    POST_POPULATE,
+    PRE_DECORATE,
+    DECORATE,
+    POST_DECORATE,
+    PRE_ORE,
+    ORE,
+    POST_ORE,
+    LAVA_FALL,
+    FIRE,
+    GLOWSTONE,
+    MUSHROOM,
+    QUARTZ,
+    MAGMA,
+    LAVA_TRAP;
+
+    private final Map<Biome, List<EnhancedGenerator>> biomeGenerators = Maps.newHashMap();
+
+    public static GenerationStage getFromString(String string) {
+        if (!Strings.isNullOrEmpty(string)) {
+            for (GenerationStage generationStage : values()) {
+                if (generationStage.name().replace("_", "").equalsIgnoreCase(string)) {
+                    return generationStage;
+                }
+            }
+        }
+
+        return POST_DECORATE;
+    }
+
+    public void addGenerator(Biome biome, EnhancedGenerator feature) {
+        biomeGenerators.computeIfAbsent(biome, k -> Lists.newArrayList()).add(feature);
+    }
+
+    public void clearGeneratorList(Biome biome) {
+        biomeGenerators.remove(biome);
+    }
+
+    public Map<Biome, List<EnhancedGenerator>> getBiomeGeneratorMap() {
+        return ImmutableMap.copyOf(biomeGenerators);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModWall.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModWall.java	(date 1523987841000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModWall.java	(date 1523987841000)
@@ -0,0 +1,144 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockFenceGate;
+import net.minecraft.block.BlockWall;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyBool;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.recipie.RecipeHandler;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import javax.annotation.Nullable;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockModWall extends BlockMod implements IModBlock {
+
+    public static final PropertyBool UP = PropertyBool.create("up");
+    public static final PropertyBool NORTH = PropertyBool.create("north");
+    public static final PropertyBool EAST = PropertyBool.create("east");
+    public static final PropertyBool SOUTH = PropertyBool.create("south");
+    public static final PropertyBool WEST = PropertyBool.create("west");
+
+    protected static final AxisAlignedBB[] AABB_BY_INDEX = new AxisAlignedBB[]{new AxisAlignedBB(0.25D, 0.0D, 0.25D, 0.75D, 1.0D, 0.75D), new AxisAlignedBB(0.25D, 0.0D, 0.25D, 0.75D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.25D, 0.75D, 1.0D, 0.75D), new AxisAlignedBB(0.0D, 0.0D, 0.25D, 0.75D, 1.0D, 1.0D), new AxisAlignedBB(0.25D, 0.0D, 0.0D, 0.75D, 1.0D, 0.75D), new AxisAlignedBB(0.3125D, 0.0D, 0.0D, 0.6875D, 0.875D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.75D, 1.0D, 0.75D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.75D, 1.0D, 1.0D), new AxisAlignedBB(0.25D, 0.0D, 0.25D, 1.0D, 1.0D, 0.75D), new AxisAlignedBB(0.25D, 0.0D, 0.25D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.3125D, 1.0D, 0.875D, 0.6875D), new AxisAlignedBB(0.0D, 0.0D, 0.25D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.25D, 0.0D, 0.0D, 1.0D, 1.0D, 0.75D), new AxisAlignedBB(0.25D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 0.75D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D)};
+    protected static final AxisAlignedBB[] CLIP_AABB_BY_INDEX = new AxisAlignedBB[]{AABB_BY_INDEX[0].setMaxY(1.5D), AABB_BY_INDEX[1].setMaxY(1.5D), AABB_BY_INDEX[2].setMaxY(1.5D), AABB_BY_INDEX[3].setMaxY(1.5D), AABB_BY_INDEX[4].setMaxY(1.5D), AABB_BY_INDEX[5].setMaxY(1.5D), AABB_BY_INDEX[6].setMaxY(1.5D), AABB_BY_INDEX[7].setMaxY(1.5D), AABB_BY_INDEX[8].setMaxY(1.5D), AABB_BY_INDEX[9].setMaxY(1.5D), AABB_BY_INDEX[10].setMaxY(1.5D), AABB_BY_INDEX[11].setMaxY(1.5D), AABB_BY_INDEX[12].setMaxY(1.5D), AABB_BY_INDEX[13].setMaxY(1.5D), AABB_BY_INDEX[14].setMaxY(1.5D), AABB_BY_INDEX[15].setMaxY(1.5D)};
+
+    public BlockModWall(String name, IBlockState state) {
+        super(state.getMaterial(), MOD_ID, name);
+
+        setHardness(state.getBlockHardness(null, new BlockPos(0, 0, 0)));
+        setResistance(state.getBlock().getExplosionResistance(null) * 5F / 3F);
+        setSoundType(state.getBlock().getSoundType());
+        setDefaultState(blockState.getBaseState().withProperty(UP, Boolean.FALSE).withProperty(NORTH, Boolean.FALSE).withProperty(EAST, Boolean.FALSE).withProperty(SOUTH, Boolean.FALSE).withProperty(WEST, Boolean.valueOf(false)));
+        setCreativeTab(CreativeTabs.DECORATIONS);
+    }
+
+    private static int getAABBIndex(IBlockState state) {
+        int i = 0;
+
+        if (state.getValue(NORTH))
+            i |= 1 << EnumFacing.NORTH.getHorizontalIndex();
+
+        if (state.getValue(EAST))
+            i |= 1 << EnumFacing.EAST.getHorizontalIndex();
+
+        if (state.getValue(SOUTH))
+            i |= 1 << EnumFacing.SOUTH.getHorizontalIndex();
+
+        if (state.getValue(WEST))
+            i |= 1 << EnumFacing.WEST.getHorizontalIndex();
+
+        return i;
+    }
+
+    public static void initWall(Block base, int meta, Block block) {
+        RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(block, 6),
+                "BBB", "BBB",
+                'B', ProxyRegistry.newStack(base, 1, meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        return 0;
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        state = this.getActualState(state, source, pos);
+        return AABB_BY_INDEX[getAABBIndex(state)];
+    }
+
+    @Override
+    @Nullable
+    public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos) {
+        blockState = this.getActualState(blockState, worldIn, pos);
+        return CLIP_AABB_BY_INDEX[getAABBIndex(blockState)];
+    }
+
+    @Override
+    public boolean canPlaceTorchOnTop(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return true;
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    public boolean isPassable(IBlockAccess worldIn, BlockPos pos) {
+        return false;
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    private boolean canConnectTo(IBlockAccess worldIn, BlockPos pos) {
+        IBlockState iblockstate = worldIn.getBlockState(pos);
+        Block block = iblockstate.getBlock();
+        Material material = iblockstate.getMaterial();
+        return block != Blocks.BARRIER && (block == this || block instanceof BlockFenceGate || (material.isOpaque() && iblockstate.isFullCube() ? material != Material.GOURD : block instanceof BlockModWall || block instanceof BlockWall));
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        return side != EnumFacing.DOWN || super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+    }
+
+    @Override
+    public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos) {
+        boolean flag = canConnectTo(worldIn, pos.north());
+        boolean flag1 = canConnectTo(worldIn, pos.east());
+        boolean flag2 = canConnectTo(worldIn, pos.south());
+        boolean flag3 = canConnectTo(worldIn, pos.west());
+        boolean flag4 = flag && !flag1 && flag2 && !flag3 || !flag && flag1 && !flag2 && flag3;
+        return state.withProperty(UP, Boolean.valueOf(!flag4 || !worldIn.isAirBlock(pos.up()))).withProperty(NORTH, Boolean.valueOf(flag)).withProperty(EAST, Boolean.valueOf(flag1)).withProperty(SOUTH, Boolean.valueOf(flag2)).withProperty(WEST, Boolean.valueOf(flag3));
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, UP, NORTH, EAST, WEST, SOUTH);
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{UP, NORTH, EAST, WEST, SOUTH};
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderLostMiner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderLostMiner.java	(date 1525366055000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderLostMiner.java	(date 1525366055000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityLostMiner;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class RenderLostMiner extends RenderBiped<EntityLostMiner> {
+
+    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation("neutronia:textures/entity/miner/lost_miner.png");
+
+    public RenderLostMiner(RenderManager rendermanagerIn) {
+        super(rendermanagerIn, new ModelZombie(), 0.5F);
+    }
+
+    @Override
+    protected boolean setBrightness(EntityLostMiner entitylivingbaseIn, float partialTicks, boolean combineTextures) {
+        return true;
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityLostMiner entity) {
+        return MUMMY_TEXTURE;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_lime_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_lime_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_lime_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_lime_terracotta",
+    "side": "neutronia:blocks/frosted_lime_terracotta",
+    "top": "neutronia:blocks/frosted_lime_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityAnchored.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityAnchored.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/EntityAnchored.java	(date 1523987836000)
@@ -0,0 +1,265 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.init.HMItems;
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EnumCreatureAttribute;
+import net.minecraft.entity.IEntityLivingData;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBreakDoor;
+import net.minecraft.entity.ai.EntityAIHurtByTarget;
+import net.minecraft.entity.ai.attributes.AttributeModifier;
+import net.minecraft.entity.monster.EntityCreeper;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNavigateGround;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Calendar;
+
+public class EntityAnchored extends EntityUndeadBase {
+
+    public static final DataParameter<Boolean> ARMS_RAISED = EntityDataManager.createKey(EntityAnchored.class, DataSerializers.BOOLEAN);
+    private final EntityAIBreakDoor breakDoor = new EntityAIBreakDoor(this);
+    private boolean isBreakDoorsTaskSet;
+
+    private float mummyWidth = -1.0F;
+    private float mummyHeight;
+
+    public EntityAnchored(World worldIn) {
+        super(worldIn);
+        this.setSize(0.6F, 1.95F);
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.applyEntityAI();
+    }
+
+    protected void applyEntityAI() {
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+    }
+
+    @Override
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
+        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(2.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(10.0D);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.getDataManager().register(ARMS_RAISED, Boolean.FALSE);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean isArmsRaised() {
+        return this.getDataManager().get(ARMS_RAISED);
+    }
+
+    public void setArmsRaised(boolean armsRaised) {
+        this.getDataManager().set(ARMS_RAISED, armsRaised);
+    }
+
+    public boolean isBreakDoorsTaskSet() {
+        return this.isBreakDoorsTaskSet;
+    }
+
+    public void setBreakDoorAItask(boolean enabled) {
+        if (this.isBreakDoorsTaskSet != enabled) {
+            this.isBreakDoorsTaskSet = enabled;
+            ((PathNavigateGround) this.getNavigator()).setBreakDoors(enabled);
+
+            if (enabled)
+                this.tasks.addTask(1, this.breakDoor);
+            else
+                this.tasks.removeTask(this.breakDoor);
+        }
+    }
+
+    @Override
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        return super.attackEntityFrom(source, amount);
+    }
+
+    @Override
+    public boolean attackEntityAsMob(Entity entityIn) {
+        boolean flag = super.attackEntityAsMob(entityIn);
+
+        if (flag) {
+            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
+
+            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
+                entityIn.setFire(2 * (int) f);
+        }
+        return flag;
+    }
+
+    /**
+     * TODO: Change Sounds...
+     */
+    @Override
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_ZOMBIE_AMBIENT;
+    }
+
+    @Override
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_ZOMBIE_HURT;
+    }
+
+    @Override
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_ZOMBIE_DEATH;
+    }
+
+    // TODO ^
+
+    protected SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_STEP;
+    }
+
+    @Override
+    protected void playStepSound(BlockPos pos, Block blockIn) {
+        this.playSound(this.getStepSound(), 0.15F, 1.0F);
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.UNDEAD;
+    }
+
+    @Nullable
+    @Override
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.MUMMY;
+    }
+
+    @Override
+    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
+        super.setEquipmentBasedOnDifficulty(difficulty);
+
+        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
+            int i = this.rand.nextInt(3);
+
+            if (i == 0)
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(HMItems.ancientSword));
+            else
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(Item.getItemFromBlock(Blocks.SAND)));
+        }
+    }
+
+    @Override
+    public float getEyeHeight() {
+        float f = 1.74F;
+        if (this.isChild())
+            f = (float) ((double) f - 0.81D);
+        return f;
+    }
+
+    @Override
+    protected boolean canEquipItem(ItemStack stack) {
+        return stack.getItem() == HMItems.anchor;
+    }
+
+    @Override
+    public boolean getCanSpawnHere() {
+        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        if (!getCanSpawnHere())
+            despawnEntity();
+        else {
+            livingdata = super.onInitialSpawn(difficulty, livingdata);
+            float f = difficulty.getClampedAdditionalDifficulty();
+            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
+            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
+                Calendar calendar = this.world.getCurrentDate();
+                if (calendar.get(Calendar.MONTH) + 1 == 10 && calendar.get(Calendar.DATE) == 31 && this.rand.nextFloat() < 0.25F) {
+                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
+                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
+                }
+            }
+            this.setBreakDoorAItask(this.rand.nextFloat() < f * 0.1F);
+            this.setEquipmentBasedOnDifficulty(difficulty);
+            this.setEnchantmentBasedOnDifficulty(difficulty);
+
+            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
+            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
+
+            if (d0 > 1.0D)
+                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random mummy-spawn bonus", d0, 2));
+
+            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader mummy bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
+                this.setBreakDoorAItask(true);
+            }
+        }
+        return livingdata;
+    }
+
+    @Override
+    protected final void setSize(float width, float height) {
+        boolean flag = this.mummyWidth > 0.0F && this.mummyHeight > 0.0F;
+        this.mummyWidth = width;
+        this.mummyHeight = height;
+
+        if (!flag)
+            this.multiplySize(1.0f);
+    }
+
+    protected final void multiplySize(float size) {
+        super.setSize(this.mummyWidth * size, this.mummyHeight * size);
+    }
+
+    public double getYOffset() {
+        return this.isChild() ? 0.0D : -0.45D;
+    }
+
+    @Override
+    public void onDeath(DamageSource cause) {
+        super.onDeath(cause);
+
+        if (cause.getTrueSource() instanceof EntityCreeper) {
+            EntityCreeper entityCreeper = (EntityCreeper) cause.getTrueSource();
+
+            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
+                entityCreeper.incrementDroppedSkulls();
+                ItemStack itemStack = this.getSkullDrop();
+
+                if (!itemStack.isEmpty())
+                    this.entityDropItem(itemStack, 0.0F);
+            }
+        }
+    }
+
+    protected ItemStack getSkullDrop() {
+        return new ItemStack(Items.SKULL, 1, 2);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/BarkBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/BarkBlocks.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/BarkBlocks.java	(date 1525606886000)
@@ -0,0 +1,70 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [24/03/2016, 15:24:42 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockBark;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockBarkSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockBarkStairs;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class BarkBlocks extends Feature {
+
+    public static BlockMod bark;
+
+    boolean enableWalls, enableStairsAndSlabs, use2x2;
+
+    @Override
+    public void setupConfig() {
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        use2x2 = loadPropBool("Use 2x2 Recipe", "Set this to true to use a 2x2 recipe instead of 3x3.", false);
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        bark = new BlockBark();
+
+		/*for(int i = 0; i < 6; i++) {
+			ItemStack log = ProxyRegistry.newStack(i > 3 ? Blocks.LOG2 : Blocks.LOG, 1, i % 4);
+
+			if(!use2x2)
+				RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(bark, 9, i),
+						"WWW", "WWW", "WWW",
+						'W', log);
+			else RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(bark, 4, i),
+					"WW", "WW",
+					'W', log);
+			RecipeHandler.addShapelessOreDictRecipe(log, ProxyRegistry.newStack(bark, 1, i));
+		}*/
+
+        for (BlockBark.Variants variant : BlockBark.Variants.class.getEnumConstants()) {
+            bark.getDefaultState().withProperty(bark.getVariantProp(), variant);
+            String name = variant.getName();
+//			VanillaWalls.add(name, bark, variant.ordinal(), enableWalls);
+
+            if (enableStairsAndSlabs) {
+                BlockModStairs.initStairs(bark, variant.ordinal(), new BlockBarkStairs(variant));
+                BlockModSlab.initSlab(bark, variant.ordinal(), new BlockBarkSlab(variant, false), new BlockBarkSlab(variant, true));
+            }
+        }
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/block/half_frosted_green_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_green_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_green_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_green_terracotta",
+    "side": "neutronia:blocks/frosted_green_terracotta",
+    "top": "neutronia:blocks/frosted_green_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_red_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_red_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_red_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_red_terracotta",
+    "side": "neutronia:blocks/frosted_red_terracotta",
+    "top": "neutronia:blocks/frosted_red_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/commands/TPBiomeCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/commands/TPBiomeCommand.java	(date 1525534700000)
+++ src/main/java/net/hdt/neutronia/commands/TPBiomeCommand.java	(date 1525534700000)
@@ -0,0 +1,69 @@
+package net.hdt.neutronia.commands;
+
+import com.google.common.collect.Lists;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.Minecraft;
+import net.minecraft.command.CommandBase;
+import net.minecraft.command.CommandException;
+import net.minecraft.command.ICommandSender;
+import net.minecraft.command.WrongUsageException;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.TextComponentString;
+import net.minecraft.util.text.TextComponentUtils;
+import net.minecraft.world.biome.Biome;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.List;
+
+public class TPBiomeCommand extends CommandBase {
+
+    private final List<String> aliases = Lists.newArrayList(Reference.MOD_ID, "f", "fn", "findbio", "findbiome", "find");
+
+    @Override
+    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException {
+
+        if (args.length != 1) {
+            throw new WrongUsageException("findbiome <name>");
+        } else {
+            String s = args[0];
+            final SearchResult result = BiomeUtils.searchForBiome(server.getWorld(0), Biome.REGISTRY.getObject(new ResourceLocation(s)), sender.getPosition());
+            if (result.found()) {
+                sender.sendMessage(TextComponentUtils.processComponent(sender, new TextComponentString(String.format("We found a biome at X: %d Z: %d with the name %s", result.getX(), result.getZ(), s)), Minecraft.getMinecraft().player));
+            } else {
+                sender.sendMessage(new TextComponentString(String.format("We did not find any biomes with the name %s", s)));
+            }
+        }
+
+    }
+
+    @Override
+    public String getName() {
+        return "findbiome";
+    }
+
+    @Override
+    public String getUsage(ICommandSender sender) {
+        return "findbiome <name>";
+    }
+
+    @Override
+    public List<String> getAliases() {
+        return aliases;
+    }
+
+    @Override
+    public boolean checkPermission(MinecraftServer server, ICommandSender sender) {
+        return true;
+    }
+
+    /**
+     * Get a list of options for when the user presses the TAB key
+     */
+    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos) {
+        return args.length == 1 ? getListOfStringsMatchingLastWord(args, "forest", "desert", "red_desert", "black_desert", "deep_ocean", "ocean", "swamp", "mesa") : Collections.emptyList();
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/CharredNetherBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/CharredNetherBricks.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/CharredNetherBricks.java	(date 1525606881000)
@@ -0,0 +1,41 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockCharredNetherBricks;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockCharredNetherBrickSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockCharredNetherBrickStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class CharredNetherBricks extends Feature {
+
+    public static Block charred_nether_bricks;
+
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        charred_nether_bricks = new BlockCharredNetherBricks();
+
+//		RecipeHandler.addShapelessOreDictRecipe(ProxyRegistry.newStack(charred_nether_bricks, 3), ProxyRegistry.newStack(Blocks.NETHER_BRICK), ProxyRegistry.newStack(Blocks.NETHER_BRICK), ProxyRegistry.newStack(Blocks.NETHER_BRICK), ProxyRegistry.newStack(Items.FIRE_CHARGE));
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(charred_nether_bricks, 0, new BlockCharredNetherBrickStairs());
+            BlockModSlab.initSlab(charred_nether_bricks, 0, new BlockCharredNetherBrickSlab(false), new BlockCharredNetherBrickSlab(true));
+        }
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesStairs.java	(date 1525537565000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesStairs.java	(date 1525537565000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedClayTiles;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedClayTilesStairs extends BlockOverworldStairBase implements IRecipeGrouped {
+
+    public BlockStainedClayTilesStairs(BlockStainedClayTiles.Variants variant) {
+        super(variant.getName() + "_stairs", HMBlocks.stained_clay_tiles.getDefaultState().withProperty(HMBlocks.stained_clay_tiles.getVariantProp(), variant));
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_clay_tiles_stairs";
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_purple_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_purple_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_purple_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_purple_terracotta",
+    "side": "neutronia:blocks/frosted_purple_terracotta",
+    "top": "neutronia:blocks/frosted_purple_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/CarvedWood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/CarvedWood.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/CarvedWood.java	(date 1525606878000)
@@ -0,0 +1,37 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/03/2016, 18:42:41 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockCarvedWood;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+
+public class CarvedWood extends Feature {
+
+    public static BlockMod carvedWood;
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        carvedWood = new BlockCarvedWood();
+
+		/*for(int i = 0; i < 6; i++)
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(carvedWood, 2, i),
+					"WW", "WW",
+					'W', ProxyRegistry.newStack(Blocks.WOODEN_SLAB, 1, i));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/block/half_frosted_black_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_black_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_black_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_black_terracotta",
+    "side": "neutronia:blocks/frosted_black_terracotta",
+    "top": "neutronia:blocks/frosted_black_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/base/tools/BaseShovel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/tools/BaseShovel.java	(date 1523988243000)
+++ src/main/java/net/hdt/neutronia/items/base/tools/BaseShovel.java	(date 1523988243000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.items.base.tools;
+
+import net.hdt.neutronia.util.Reference;
+import net.thegaminghuskymc.huskylib2.items.ItemModSpade;
+
+public class BaseShovel extends ItemModSpade {
+
+    public BaseShovel(String name, ToolMaterial material) {
+        super(material, name, Reference.MOD_ID);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/StructureHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/StructureHelper.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/util/StructureHelper.java	(date 1525606898000)
@@ -0,0 +1,149 @@
+package net.hdt.neutronia.util;
+
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+
+public class StructureHelper {
+    public static BlockPos getGroundedPos(World world, BlockPos pos, BlockPos structureSize, float clearancePercentage) {
+        while (pos.getY() > 0) {
+            float sizeX = structureSize.getX();
+            float sizeY = structureSize.getY();
+            float sizeZ = structureSize.getZ();
+
+            int surfaceBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    BlockPos newPos = pos.add(x, 0, z);
+
+                    if (!world.getBlockState(newPos).getMaterial().isReplaceable() && world.getBlockState(newPos.up()).getMaterial().isReplaceable()) {
+                        surfaceBlocks++;
+                    }
+                }
+            }
+
+            int replaceableBlocks = 0;
+
+            if (surfaceBlocks >= MathHelper.abs(sizeX * sizeZ) * clearancePercentage) {
+                for (int y = 1; y < sizeY; y++) {
+                    for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                        for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                            BlockPos newPos = pos.add(x, y, z);
+
+                            if (world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                                replaceableBlocks++;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (replaceableBlocks > MathHelper.abs(sizeX * sizeY * sizeZ) * 0.875F) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return null;
+    }
+
+    public static BlockPos getFloatingPos(World world, BlockPos pos, BlockPos structureSize, float clearancePercentage) {
+        while (pos.getY() > 32) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int replaceableBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        BlockPos newPos = pos.add(x, y, z);
+
+                        if (world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                            replaceableBlocks++;
+                        }
+                    }
+                }
+            }
+
+            if (replaceableBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ) * clearancePercentage) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static BlockPos getHangingPos(World world, BlockPos pos, BlockPos structureSize, float clearancePercentage) {
+        while (pos.getY() < 128) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int ceilingBlocks = 0;
+            int replaceableBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        BlockPos newPos = pos.add(x, -y, z);
+
+                        if (y == 0) {
+                            if (world.getBlockState(newPos).isSideSolid(world, newPos, EnumFacing.DOWN)) {
+                                ceilingBlocks++;
+                            }
+                        } else {
+                            if (world.getBlockState(newPos).getBlock().isReplaceable(world, newPos)) {
+                                replaceableBlocks++;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (ceilingBlocks + replaceableBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ) * clearancePercentage) {
+                return pos.add(0, -sizeY, 0);
+            }
+
+            pos = pos.up();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+
+    public static BlockPos getBuriedPos(World world, BlockPos pos, BlockPos structureSize, float clearancePercentage) {
+        while (pos.getY() > 32) {
+            float sizeX = structureSize.getX();
+            float sizeZ = structureSize.getZ();
+            float sizeY = structureSize.getY();
+
+            int nonReplaceableBlocks = 0;
+
+            for (int x = 0; x <= MathHelper.abs(sizeX); x++) {
+                for (int z = 0; z <= MathHelper.abs(sizeZ); z++) {
+                    for (int y = 0; y <= sizeY; y++) {
+                        BlockPos newPos = pos.add(x, y, z);
+
+                        if (!world.getBlockState(newPos).getMaterial().isReplaceable()) {
+                            nonReplaceableBlocks++;
+                        }
+                    }
+                }
+            }
+
+            if (nonReplaceableBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ) * clearancePercentage) {
+                return pos;
+            }
+
+            pos = pos.down();
+        }
+
+        return BlockPos.ORIGIN;
+    }
+}
Index: src/main/resources/assets/neutronia/models/block/half_frosted_cyan_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_cyan_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_cyan_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_cyan_terracotta",
+    "side": "neutronia:blocks/frosted_cyan_terracotta",
+    "top": "neutronia:blocks/frosted_cyan_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_orange_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_orange_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_orange_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_orange_terracotta",
+    "side": "neutronia:blocks/frosted_orange_terracotta",
+    "top": "neutronia:blocks/frosted_orange_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_light_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_light_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_light_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_light_blue_terracotta",
+    "side": "neutronia:blocks/frosted_light_blue_terracotta",
+    "top": "neutronia:blocks/frosted_light_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityRedPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityRedPhantom.java	(date 1523986195000)
+++ src/main/java/net/hdt/neutronia/entity/EntityRedPhantom.java	(date 1523986195000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.world.World;
+
+public class EntityRedPhantom extends EntityLiving {
+
+    public EntityRedPhantom(World worldIn) {
+        super(worldIn);
+        this.setHealth(this.getMaxHealth());
+        setSize(0.5F, 0.5F);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_silver_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_silver_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_silver_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_silver_terracotta",
+    "side": "neutronia:blocks/frosted_silver_terracotta",
+    "top": "neutronia:blocks/frosted_silver_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_cyan_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_cyan_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_cyan_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_cyan_terracotta",
+    "side": "neutronia:blocks/frosted_cyan_terracotta",
+    "top": "neutronia:blocks/frosted_cyan_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelSeaTurtle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelSeaTurtle.java	(date 1523986184000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelSeaTurtle.java	(date 1523986184000)
@@ -0,0 +1,74 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+/**
+ * SeaTurtle - TheGamingHuskyMC
+ * Created using Tabula 7.0.0
+ */
+public class ModelSeaTurtle extends ModelBase {
+
+    public ModelRenderer head;
+    public ModelRenderer shellRing;
+    public ModelRenderer frontRightFin;
+    public ModelRenderer shell;
+    public ModelRenderer backLeftFin;
+    public ModelRenderer frontLeftFin;
+    public ModelRenderer body;
+    public ModelRenderer backRightFin;
+
+    public ModelSeaTurtle() {
+        this.textureWidth = 128;
+        this.textureHeight = 64;
+        this.frontLeftFin = new ModelRenderer(this, 18, 22);
+        this.frontLeftFin.setRotationPoint(-4.0F, 0.0F, 4.0F);
+        this.frontLeftFin.addBox(-1.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
+        this.backRightFin = new ModelRenderer(this, 18, 22);
+        this.backRightFin.setRotationPoint(4.0F, 0.0F, -4.0F);
+        this.backRightFin.addBox(0.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
+        this.body = new ModelRenderer(this, 0, 0);
+        this.body.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.body.addBox(-4.0F, -1.5F, -6.0F, 8, 3, 12, 0.0F);
+        this.backLeftFin = new ModelRenderer(this, 18, 22);
+        this.backLeftFin.setRotationPoint(-4.0F, 0.0F, -4.0F);
+        this.backLeftFin.addBox(-1.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
+        this.shellRing = new ModelRenderer(this, 0, 48);
+        this.shellRing.mirror = true;
+        this.shellRing.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.shellRing.addBox(-5.0F, -2.5F, -7.0F, 10, 2, 14, 0.0F);
+        this.head = new ModelRenderer(this, 0, 23);
+        this.head.mirror = true;
+        this.head.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.head.addBox(-2.0F, -2.5F, 6.0F, 4, 3, 5, 0.0F);
+        this.shell = new ModelRenderer(this, 0, 31);
+        this.shell.mirror = true;
+        this.shell.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.shell.addBox(-4.5F, -4.0F, -6.5F, 9, 2, 13, 0.0F);
+        this.frontRightFin = new ModelRenderer(this, 18, 22);
+        this.frontRightFin.setRotationPoint(4.0F, 0.0F, 4.0F);
+        this.frontRightFin.addBox(0.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.frontLeftFin.render(f5);
+        this.shellRing.render(f5);
+        this.shell.render(f5);
+        this.backRightFin.render(f5);
+        this.frontRightFin.render(f5);
+        this.body.render(f5);
+        this.backLeftFin.render(f5);
+        this.head.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+}
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_white_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_white_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_white_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_white_terracotta",
+    "side": "neutronia:blocks/frosted_white_terracotta",
+    "top": "neutronia:blocks/frosted_white_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_yellow_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_yellow_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_yellow_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_yellow_terracotta",
+    "side": "neutronia:blocks/frosted_yellow_terracotta",
+    "top": "neutronia:blocks/frosted_yellow_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/BlockArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/BlockArray.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/world/BlockArray.java	(date 1525606899000)
@@ -0,0 +1,391 @@
+// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
+// Jad home page: http://www.kpdus.com/jad.html
+// Decompiler options: packimports(3) 
+// Source File Name:   BlockArray.java
+
+package net.hdt.neutronia.world;
+
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import javax.vecmath.Vector3d;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+
+public class BlockArray
+        implements Serializable {
+    private static final long serialVersionUID = 0xcc0860L;
+    public transient List blocks;
+    public List blocksSnaps;
+    public transient BlockPos CenterOffset;
+    public Vector3d CntOff;
+    public boolean allowSlopes;
+    public boolean isSlope;
+    public Vector3d ObjSize;
+    public boolean allowHex;
+    public boolean allowRect;
+    public boolean isFloorObject;
+    public boolean isWallObject;
+    public boolean isCeilingObject;
+    public boolean cantTouchWall;
+    public Vector3d FloorDist;
+    public Vector3d CeilingDist;
+    public transient World wrld;
+
+    public BlockArray() {
+        CenterOffset = new BlockPos(0, 0, 0);
+        CntOff = new Vector3d(0.0D, 0.0D, 0.0D);
+        allowSlopes = true;
+        isSlope = false;
+        ObjSize = new Vector3d(0.0D, 0.0D, 0.0D);
+        allowHex = true;
+        allowRect = true;
+        isFloorObject = true;
+        isWallObject = false;
+        isCeilingObject = false;
+        cantTouchWall = false;
+        FloorDist = new Vector3d(-1D, -1D, -1D);
+        CeilingDist = new Vector3d(-1D, -1D, -1D);
+        wrld = null;
+        blocks = new ArrayList();
+        blocks.add(new ArrayList());
+        ((List) blocks.get(0)).add(new ArrayList());
+        blocksSnaps = new ArrayList();
+        blocksSnaps.add(new ArrayList());
+        ((List) blocksSnaps.get(0)).add(new ArrayList());
+    }
+
+    public BlockArray(BlockArray BA) {
+        CenterOffset = new BlockPos(0, 0, 0);
+        CntOff = new Vector3d(0.0D, 0.0D, 0.0D);
+        allowSlopes = true;
+        isSlope = false;
+        ObjSize = new Vector3d(0.0D, 0.0D, 0.0D);
+        allowHex = true;
+        allowRect = true;
+        isFloorObject = true;
+        isWallObject = false;
+        isCeilingObject = false;
+        cantTouchWall = false;
+        FloorDist = new Vector3d(-1D, -1D, -1D);
+        CeilingDist = new Vector3d(-1D, -1D, -1D);
+        wrld = null;
+        blocks = new ArrayList();
+        blocks.add(new ArrayList());
+        ((List) blocks.get(0)).add(new ArrayList());
+        blocksSnaps = new ArrayList();
+        blocksSnaps.add(new ArrayList());
+        ((List) blocksSnaps.get(0)).add(new ArrayList());
+        CenterOffset = new BlockPos(BA.CenterOffset);
+        CntOff = new Vector3d(BA.CntOff);
+        allowSlopes = BA.allowSlopes;
+        isSlope = BA.isSlope;
+        ObjSize = new Vector3d(BA.ObjSize);
+        allowHex = BA.allowHex;
+        allowRect = BA.allowRect;
+        isFloorObject = BA.isFloorObject;
+        isWallObject = BA.isWallObject;
+        isCeilingObject = BA.isCeilingObject;
+        cantTouchWall = BA.cantTouchWall;
+        FloorDist = new Vector3d(BA.FloorDist);
+        CeilingDist = new Vector3d(BA.CeilingDist);
+        wrld = BA.wrld;
+    }
+
+    public void init() {
+        blocks = new ArrayList();
+        blocks.add(new ArrayList());
+        ((List) blocks.get(0)).add(new ArrayList());
+        CenterOffset = new BlockPos(0, 0, 0);
+    }
+
+    public IBlockState getBlock(int x, int y, int z) {
+        List lstY = blocks;
+        if (lstY.size() >= y + 1) {
+            List lstX = (List) lstY.get(y);
+            if (lstX.size() >= x + 1) {
+                List lstZ = (List) lstX.get(x);
+                if (lstZ.size() >= z + 1)
+                    return (IBlockState) lstZ.get(z);
+            }
+        }
+        return null;
+    }
+
+    public void setBlock(int x, int y, int z, IBlockState block) {
+        List lstY;
+        for (lstY = blocks; lstY.size() < y + 1; lstY.add(new ArrayList())) ;
+        List lstX;
+        for (lstX = (List) lstY.get(y); lstX.size() < x + 1; lstX.add(new ArrayList())) ;
+        List lstZ;
+        for (lstZ = (List) lstX.get(x); lstZ.size() < z + 1; lstZ.add(null)) ;
+        lstZ.set(z, block);
+    }
+
+    public void clear() {
+        List lstY = blocks;
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                lstZ.clear();
+            }
+
+            lstX.clear();
+        }
+
+        lstY.clear();
+    }
+
+    public Vector3d GetBounds() {
+        int maxX = 0;
+        int maxY = 0;
+        int maxZ = 0;
+        List lstY = blocks;
+        maxY = lstY.size();
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            if (lstX.size() > maxX)
+                maxX = lstX.size();
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                if (lstZ.size() > maxZ)
+                    maxZ = lstZ.size();
+            }
+
+        }
+
+        return new Vector3d(maxX, maxY, maxZ);
+    }
+
+    public BlockArray Rotate(int deg) {
+        Vector3d Bounds = GetBounds();
+        BlockArray newBar = new BlockArray(this);
+        switch (deg) {
+            case 90: // 'Z'
+                newBar.CenterOffset = new BlockPos(Bounds.z - (double) CenterOffset.getZ() - 1.0D, CenterOffset.getY(), CenterOffset.getX());
+                break;
+
+            case 180:
+                newBar.CenterOffset = new BlockPos(Bounds.x - (double) CenterOffset.getX() - 1.0D, CenterOffset.getY(), Bounds.z - (double) CenterOffset.getZ() - 1.0D);
+                break;
+
+            case 270:
+                newBar.CenterOffset = new BlockPos(CenterOffset.getZ(), CenterOffset.getY(), Bounds.x - (double) CenterOffset.getX() - 1.0D);
+                break;
+        }
+        newBar.CntOff = new Vector3d(newBar.CenterOffset.getX(), newBar.CenterOffset.getY(), newBar.CenterOffset.getZ());
+        List lstY = blocks;
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                for (int k = 0; k < lstZ.size(); k++) {
+                    IBlockState IBS = (IBlockState) lstZ.get(k);
+                    if (IBS != null) {
+                        PropertyEnum FACING = null;
+                        try {
+                            EnumFacing ef = null;
+                            Collection col = IBS.getPropertyKeys();
+                            Iterator it = col.iterator();
+                            do {
+                                if (!it.hasNext())
+                                    break;
+                                IProperty prop = (IProperty) it.next();
+                                if (prop.toString().contains("PropertyDirection")) {
+                                    FACING = (PropertyEnum) prop;
+                                    ef = (EnumFacing) IBS.getValue(FACING);
+                                    if (ef.getAxis() != net.minecraft.util.EnumFacing.Axis.Y) {
+                                        int rot = 0;
+                                        while (rot < deg / 90) {
+                                            ef = ef.rotateY();
+                                            IBS = IBS.withProperty(FACING, ef);
+                                            rot++;
+                                        }
+                                    }
+                                }
+                            } while (true);
+                        } catch (IllegalArgumentException illegalargumentexception) {
+                        }
+                    }
+                    switch (deg) {
+                        case 90: // 'Z'
+                            newBar.setBlock((int) Bounds.z - (k + 1), i, j, IBS);
+                            break;
+
+                        case 180:
+                            newBar.setBlock((int) Bounds.x - (j + 1), i, (int) Bounds.z - (k + 1), IBS);
+                            break;
+
+                        case 270:
+                            newBar.setBlock(k, i, (int) Bounds.x - (j + 1), IBS);
+                            break;
+
+                        default:
+                            newBar.setBlock(j, i, k, IBS);
+                            break;
+                    }
+                }
+
+            }
+
+        }
+
+        return newBar;
+    }
+
+    public BlockArray Mirror() {
+        Vector3d Bounds = GetBounds();
+        BlockArray newBar = new BlockArray(this);
+        newBar.CntOff = new Vector3d(newBar.CenterOffset.getX(), newBar.CenterOffset.getY(), newBar.CenterOffset.getZ());
+        List lstY = blocks;
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                for (int k = 0; k < lstZ.size(); k++) {
+                    IBlockState IBS = (IBlockState) lstZ.get(k);
+                    if (IBS == null)
+                        continue;
+                    PropertyEnum FACING = null;
+                    try {
+                        EnumFacing ef = null;
+                        Collection col = IBS.getPropertyKeys();
+                        Iterator it = col.iterator();
+                        do {
+                            if (!it.hasNext())
+                                break;
+                            IProperty prop = (IProperty) it.next();
+                            if (prop.toString().contains("PropertyDirection")) {
+                                FACING = (PropertyEnum) prop;
+                                ef = (EnumFacing) IBS.getValue(FACING);
+                                if (ef.getAxis() == net.minecraft.util.EnumFacing.Axis.X) {
+                                    int rot = 0;
+                                    while (rot < 2) {
+                                        ef = ef.rotateY();
+                                        IBS = IBS.withProperty(FACING, ef);
+                                        rot++;
+                                    }
+                                }
+                            }
+                        } while (true);
+                    } catch (IllegalArgumentException illegalargumentexception) {
+                    }
+                    newBar.setBlock((int) Bounds.x - (j + 1), i, k, IBS);
+                }
+
+            }
+
+        }
+
+        return newBar;
+    }
+
+    public void PrepareSave() {
+        CntOff = new Vector3d(CenterOffset.getX(), CenterOffset.getY(), CenterOffset.getZ());
+        clearSnaps();
+        if (wrld != null) {
+            List lstY = blocks;
+            for (int i = 0; i < lstY.size(); i++) {
+                List lstX = (List) lstY.get(i);
+                for (int j = 0; j < lstX.size(); j++) {
+                    List lstZ = (List) lstX.get(j);
+                    for (int k = 0; k < lstZ.size(); k++)
+                        if (lstZ.get(k) != null) {
+                            ZedBlockSnapshot bs = new ZedBlockSnapshot((IBlockState) lstZ.get(k));
+                            setBlockSnap(j, i, k, bs);
+                        } else {
+                            setBlockSnap(j, i, k, null);
+                        }
+
+                }
+
+            }
+
+        }
+    }
+
+    public void LoadFromSave() {
+        if (blocks == null)
+            init();
+        clear();
+        CenterOffset = ZedUtil.newBlPos(CntOff);
+        List lstY = blocksSnaps;
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                for (int k = 0; k < lstZ.size(); k++)
+                    if (lstZ.get(k) != null) {
+                        IBlockState bs = ((ZedBlockSnapshot) lstZ.get(k)).getReplacedBlock();
+                        setBlock(j, i, k, bs);
+                    } else {
+                        setBlockSnap(j, i, k, null);
+                    }
+
+            }
+
+        }
+
+    }
+
+    public void setBlockSnap(int x, int y, int z, ZedBlockSnapshot block) {
+        List lstY;
+        for (lstY = blocksSnaps; lstY.size() < y + 1; lstY.add(new ArrayList())) ;
+        List lstX;
+        for (lstX = (List) lstY.get(y); lstX.size() < x + 1; lstX.add(new ArrayList())) ;
+        List lstZ;
+        for (lstZ = (List) lstX.get(x); lstZ.size() < z + 1; lstZ.add(null)) ;
+        lstZ.set(z, block);
+    }
+
+    public void clearSnaps() {
+        List lstY = blocksSnaps;
+        for (int i = 0; i < lstY.size(); i++) {
+            List lstX = (List) lstY.get(i);
+            for (int j = 0; j < lstX.size(); j++) {
+                List lstZ = (List) lstX.get(j);
+                lstZ.clear();
+            }
+
+            lstX.clear();
+        }
+
+        lstY.clear();
+    }
+
+    public class ZedBlockSnapshot
+            implements Serializable {
+
+        final BlockArray this$0;
+        private transient IBlockState replacedBlock;
+        private transient ResourceLocation registryName;
+        private String domain;
+        private String path;
+        private int meta;
+
+        public ZedBlockSnapshot(IBlockState state) {
+            super();
+            this.this$0 = BlockArray.this;
+            registryName = state.getBlock().getRegistryName();
+            domain = registryName.getResourceDomain();
+            path = registryName.getResourcePath();
+            meta = state.getBlock().getMetaFromState(state);
+        }
+
+        public IBlockState getReplacedBlock() {
+            if (replacedBlock == null)
+                replacedBlock = ForgeRegistries.BLOCKS.getValue(new ResourceLocation(domain, path)).getStateFromMeta(meta);
+            return replacedBlock;
+        }
+    }
+}
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_green_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_green_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_green_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_green_terracotta",
+    "side": "neutronia:blocks/frosted_green_terracotta",
+    "top": "neutronia:blocks/frosted_green_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_brown_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_brown_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_brown_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_brown_terracotta",
+    "side": "neutronia:blocks/frosted_brown_terracotta",
+    "top": "neutronia:blocks/frosted_brown_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_blue_terracotta",
+    "side": "neutronia:blocks/frosted_blue_terracotta",
+    "top": "neutronia:blocks/frosted_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/models/ModelPlayer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/models/ModelPlayer.java	(date 1523986194000)
+++ src/main/java/net/hdt/neutronia/items/models/ModelPlayer.java	(date 1523986194000)
@@ -0,0 +1,72 @@
+package net.hdt.neutronia.items.models;
+
+import net.minecraft.client.model.ModelBiped;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+/**
+ * ModelPlayer - Either Mojang or a mod author
+ * Created using Tabula 7.0.0
+ */
+public class ModelPlayer extends ModelBiped {
+
+    public ModelRenderer bipedRightArm;
+    public ModelRenderer bipedLeftArm;
+    public ModelRenderer bipedBody;
+    public ModelRenderer bipedHead;
+    public ModelRenderer bipedRightLeg;
+    public ModelRenderer bipedLeftLeg;
+    public ModelRenderer shape15;
+    public ModelRenderer shape15_1;
+
+    public ModelPlayer() {
+        this.textureWidth = 64;
+        this.textureHeight = 64;
+        this.bipedRightLeg = new ModelRenderer(this, 0, 16);
+        this.bipedRightLeg.setRotationPoint(-1.9F, 12.0F, 0.0F);
+        this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, 0.0F);
+        this.bipedLeftLeg = new ModelRenderer(this, 16, 48);
+        this.bipedLeftLeg.setRotationPoint(1.9F, 12.0F, 0.0F);
+        this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, 0.0F);
+        this.shape15 = new ModelRenderer(this, 25, 0);
+        this.shape15.setRotationPoint(3.5F, -0.5F, 1.5F);
+        this.shape15.addBox(0.0F, 0.0F, -4.0F, 5, 5, 5, 0.0F);
+        this.bipedHead = new ModelRenderer(this, 0, 2);
+        this.bipedHead.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.bipedHead.addBox(-4.0F, -8.0F, -4.0F, 8, 8, 8, 0.0F);
+        this.shape15_1 = new ModelRenderer(this, 25, 0);
+        this.shape15_1.setRotationPoint(-8.5F, -0.5F, -2.5F);
+        this.shape15_1.addBox(0.0F, 0.0F, 0.0F, 5, 5, 5, 0.0F);
+        this.bipedLeftArm = new ModelRenderer(this, 32, 48);
+        this.bipedLeftArm.setRotationPoint(5.0F, 2.0F, 0.0F);
+        this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, 0.0F);
+        this.bipedRightArm = new ModelRenderer(this, 40, 16);
+        this.bipedRightArm.setRotationPoint(-5.0F, 2.0F, 0.0F);
+        this.bipedRightArm.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, 0.0F);
+        this.bipedBody = new ModelRenderer(this, 16, 16);
+        this.bipedBody.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.bipedBody.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, 0.0F);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.bipedRightLeg.render(f5);
+        this.bipedLeftLeg.render(f5);
+        this.shape15.render(f5);
+        this.bipedHead.render(f5);
+        this.shape15_1.render(f5);
+        this.bipedLeftArm.render(f5);
+        this.bipedRightArm.render(f5);
+        this.bipedBody.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_gray_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_gray_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_gray_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_gray_terracotta",
+    "side": "neutronia:blocks/frosted_gray_terracotta",
+    "top": "neutronia:blocks/frosted_gray_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderShadowPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderShadowPhantom.java	(date 1523987842000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderShadowPhantom.java	(date 1523987842000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityShadowPhantom;
+import net.hdt.neutronia.entity.render.model.ModelPhantom;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderShadowPhantom extends RenderLiving<EntityShadowPhantom> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/shadow_phantom.png");
+
+    public RenderShadowPhantom(RenderManager manager) {
+        super(manager, new ModelPhantom(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityShadowPhantom entity) {
+        return SCORP_TEXTURE;
+    }
+}
Index: src/main/resources/assets/neutronia/models/block/half_frosted_white_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_white_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_white_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_white_terracotta",
+    "side": "neutronia:blocks/frosted_white_terracotta",
+    "top": "neutronia:blocks/frosted_white_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_light_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_light_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_light_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_light_blue_terracotta",
+    "side": "neutronia:blocks/frosted_light_blue_terracotta",
+    "top": "neutronia:blocks/frosted_light_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_pink_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_pink_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_pink_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_pink_terracotta",
+    "side": "neutronia:blocks/frosted_pink_terracotta",
+    "top": "neutronia:blocks/frosted_pink_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_lime_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_lime_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_lime_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_lime_terracotta",
+    "side": "neutronia:blocks/frosted_lime_terracotta",
+    "top": "neutronia:blocks/frosted_lime_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_magenta_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_magenta_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_magenta_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_magenta_terracotta",
+    "side": "neutronia:blocks/frosted_magenta_terracotta",
+    "top": "neutronia:blocks/frosted_magenta_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/utils/StructureTFStrongholdStones.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/StructureTFStrongholdStones.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/world/utils/StructureTFStrongholdStones.java	(date 1525606898000)
@@ -0,0 +1,31 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.BlockSilverfish;
+import net.minecraft.block.BlockStoneBrick;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.gen.structure.StructureComponent;
+
+import java.util.Random;
+
+public class StructureTFStrongholdStones extends StructureComponent.BlockSelector {
+
+    @Override
+    public void selectBlocks(Random par1Random, int par2, int par3, int par4, boolean par5) {
+        if (!par5) {
+            blockstate = Blocks.AIR.getDefaultState();
+        } else {
+            float var6 = par1Random.nextFloat();
+
+            if (var6 < 0.2F) {
+                blockstate = Blocks.STONEBRICK.getDefaultState().withProperty(BlockStoneBrick.VARIANT, BlockStoneBrick.EnumType.CRACKED);
+            } else if (var6 < 0.5F) {
+                blockstate = Blocks.STONEBRICK.getDefaultState().withProperty(BlockStoneBrick.VARIANT, BlockStoneBrick.EnumType.MOSSY);
+            } else if (var6 < 0.55F) {
+                blockstate = Blocks.MONSTER_EGG.getDefaultState().withProperty(BlockSilverfish.VARIANT, BlockSilverfish.EnumType.STONEBRICK);
+            } else {
+                blockstate = Blocks.STONEBRICK.getDefaultState();
+            }
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/events/OreGenEvents.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/events/OreGenEvents.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/world/events/OreGenEvents.java	(date 1525606896000)
@@ -0,0 +1,98 @@
+package net.hdt.neutronia.world.events;
+
+import net.hdt.neutronia.world.gen.generators.StoneInfoBasedGenerator;
+import net.hdt.neutronia.world.utils.StoneInfo;
+import net.hdt.neutronia.world.utils.handlers.BiomeTypeConfigHandler;
+import net.minecraft.block.BlockStone;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraftforge.event.terraingen.OreGenEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.fml.common.eventhandler.Event;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static net.minecraftforge.common.BiomeDictionary.Type;
+
+public class OreGenEvents {
+
+    private static StoneInfo graniteInfo,
+            dioriteInfo,
+            andesiteInfo;
+    private static List<StoneInfoBasedGenerator> generators;
+
+    public OreGenEvents(FMLPreInitializationEvent event) {
+        setupConfig();
+        preInit(event);
+    }
+
+    private static void setupConfig() {
+        int defSize = 14;
+        int defRarity = 15;
+        int defUpper = 80;
+        int defLower = 20;
+
+        graniteInfo = loadStoneInfo("granite", defSize, defRarity, defUpper, defLower, true, Type.MOUNTAIN, Type.HILLS);
+        dioriteInfo = loadStoneInfo("diorite", defSize, defRarity, defUpper, defLower, true, Type.SANDY, Type.SAVANNA, Type.WASTELAND, Type.MUSHROOM);
+        andesiteInfo = loadStoneInfo("andesite", defSize, defRarity, defUpper, defLower, true, Type.FOREST);
+    }
+
+    private static StoneInfo loadStoneInfo(String name, int clusterSize, int clusterRarity, int upperBound, int lowerBound, boolean enabled, Type... biomes) {
+        return loadStoneInfo(name, clusterSize, clusterRarity, upperBound, lowerBound, enabled, "0", biomes);
+    }
+
+    private static StoneInfo loadStoneInfo(String name, int clusterSize, int clusterRarity, int upperBound, int lowerBound, boolean enabled, String dims, Type... biomes) {
+        String category = "worldGen." + name;
+        return new StoneInfo(category, clusterSize, clusterRarity, upperBound, lowerBound, enabled, dims, biomes);
+    }
+
+    public static void preInit(FMLPreInitializationEvent event) {
+        IBlockState graniteState = Blocks.STONE.getDefaultState().withProperty(BlockStone.VARIANT, BlockStone.EnumType.GRANITE);
+        IBlockState dioriteState = Blocks.STONE.getDefaultState().withProperty(BlockStone.VARIANT, BlockStone.EnumType.DIORITE);
+        IBlockState andesiteState = Blocks.STONE.getDefaultState().withProperty(BlockStone.VARIANT, BlockStone.EnumType.ANDESITE);
+
+        generators = new ArrayList<>();
+
+        generators.add(new StoneInfoBasedGenerator(() -> graniteInfo, graniteState, "granite"));
+        generators.add(new StoneInfoBasedGenerator(() -> dioriteInfo, dioriteState, "diorite"));
+        generators.add(new StoneInfoBasedGenerator(() -> andesiteInfo, andesiteState, "andesite"));
+
+        BiomeTypeConfigHandler.debugStoneGeneration(generators);
+    }
+
+    @SubscribeEvent
+    public void onOreGenerate(OreGenEvent.GenerateMinable event) {
+        switch (event.getType()) {
+            case GRANITE:
+                if (graniteInfo.enabled)
+                    event.setResult(Event.Result.DENY);
+                break;
+            case DIORITE:
+                if (dioriteInfo.enabled)
+                    event.setResult(Event.Result.DENY);
+                break;
+            case ANDESITE:
+                if (andesiteInfo.enabled)
+                    event.setResult(Event.Result.DENY);
+
+                generateNewStones(event);
+                break;
+            default:
+        }
+    }
+
+    private void generateNewStones(OreGenEvent.GenerateMinable event) {
+        World world = event.getWorld();
+        BlockPos pos = event.getPos();
+        Chunk chunk = world.getChunkFromBlockCoords(pos);
+
+        for (StoneInfoBasedGenerator gen : generators)
+            gen.generate(chunk.x, chunk.z, world);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/MossyCobbleTemplateProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/MossyCobbleTemplateProcessor.java	(date 1524594998000)
+++ src/main/java/net/hdt/neutronia/world/utils/MossyCobbleTemplateProcessor.java	(date 1524594998000)
@@ -0,0 +1,38 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockWall;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraft.world.gen.structure.template.Template;
+
+import javax.annotation.Nullable;
+
+public class MossyCobbleTemplateProcessor extends RandomizedTemplateProcessor {
+
+    public MossyCobbleTemplateProcessor(BlockPos pos, PlacementSettings settings) {
+        super(pos, settings);
+    }
+
+    @Nullable
+    @Override
+    public Template.BlockInfo processBlock(World worldIn, BlockPos pos, Template.BlockInfo blockInfo) {
+        if (shouldPlaceBlock()) {
+            IBlockState state = blockInfo.blockState;
+            Block block = state.getBlock();
+
+            if (block == Blocks.COBBLESTONE)
+                return random.nextBoolean() ? blockInfo : new Template.BlockInfo(pos, Blocks.MOSSY_COBBLESTONE.getDefaultState(), null);
+
+            if (block == Blocks.COBBLESTONE_WALL)
+                return random.nextBoolean() ? blockInfo : new Template.BlockInfo(pos, state.withProperty(BlockWall.VARIANT, BlockWall.EnumType.MOSSY), null);
+
+            return blockInfo;
+        }
+
+        return null;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_blue_terracotta",
+    "side": "neutronia:blocks/frosted_blue_terracotta",
+    "top": "neutronia:blocks/frosted_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndStone.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndStone.java	(date 1524853001000)
@@ -0,0 +1,81 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockEndStone extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockEndStone()
+    {
+        super("end_stone", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/properties/EnumWoodType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumWoodType.java	(date 1525012657000)
+++ src/main/java/net/hdt/neutronia/properties/EnumWoodType.java	(date 1525012657000)
@@ -0,0 +1,73 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.block.material.MapColor;
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumWoodType implements IStringSerializable {
+    SPRUCE(0, "spruce", MapColor.OBSIDIAN),
+    BIRCH(1, "birch", MapColor.SAND),
+    JUNGLE(2, "jungle", MapColor.DIRT),
+    ACACIA(3, "acacia", MapColor.ADOBE),
+    DARK_OAK(4, "dark_oak", "big_oak", MapColor.BROWN),
+    REDWOOD(5, "redwood", MapColor.RED),
+    PALM(6, "palm", MapColor.DIRT),
+    CHERRY(7, "cherry", MapColor.PINK);
+
+    private static final EnumWoodType[] META_LOOKUP = new EnumWoodType[values().length];
+
+    static {
+        for (EnumWoodType blockplanks$enumtype : values()) {
+            META_LOOKUP[blockplanks$enumtype.getMetadata()] = blockplanks$enumtype;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+    private final String unlocalizedName;
+    /**
+     * The color that represents this entry on a map.
+     */
+    private final MapColor mapColor;
+
+    EnumWoodType(int metaIn, String nameIn, MapColor mapColorIn) {
+        this(metaIn, nameIn, nameIn, mapColorIn);
+    }
+
+    EnumWoodType(int metaIn, String nameIn, String unlocalizedNameIn, MapColor mapColorIn) {
+        this.meta = metaIn;
+        this.name = nameIn;
+        this.unlocalizedName = unlocalizedNameIn;
+        this.mapColor = mapColorIn;
+    }
+
+    public static EnumWoodType byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    /**
+     * The color which represents this entry on a map.
+     */
+    public MapColor getMapColor() {
+        return this.mapColor;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public String getUnlocalizedName() {
+        return this.unlocalizedName;
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_black_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_black_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_black_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_black_terracotta",
+    "side": "neutronia:blocks/frosted_black_terracotta",
+    "top": "neutronia:blocks/frosted_black_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_red_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_red_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_red_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_red_terracotta",
+    "side": "neutronia:blocks/frosted_red_terracotta",
+    "top": "neutronia:blocks/frosted_red_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_orange_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_orange_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_orange_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_orange_terracotta",
+    "side": "neutronia:blocks/frosted_orange_terracotta",
+    "top": "neutronia:blocks/frosted_orange_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_purple_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_purple_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_purple_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_purple_terracotta",
+    "side": "neutronia:blocks/frosted_purple_terracotta",
+    "top": "neutronia:blocks/frosted_purple_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_gray_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_gray_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_gray_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_gray_terracotta",
+    "side": "neutronia:blocks/frosted_gray_terracotta",
+    "top": "neutronia:blocks/frosted_gray_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemBandage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemBandage.java	(date 1523988245000)
+++ src/main/java/net/hdt/neutronia/items/ItemBandage.java	(date 1523988245000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.ActionResult;
+import net.minecraft.util.EnumActionResult;
+import net.minecraft.util.EnumHand;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.items.ItemMod;
+
+public class ItemBandage extends ItemMod {
+
+    public ItemBandage() {
+        super("bandage", Reference.MOD_ID);
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    @Override
+    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
+        if (playerIn.getHealth() < playerIn.getMaxHealth() && worldIn.isRemote && playerIn.getHeldItem(handIn).getItem() == this) {
+            float f = playerIn.getHealth();
+            playerIn.setHealth(f + 1.0F);
+            playerIn.getHeldItem(handIn).shrink(1);
+            return new ActionResult<>(EnumActionResult.SUCCESS, playerIn.getHeldItem(handIn));
+        }
+        return new ActionResult<>(EnumActionResult.PASS, playerIn.getHeldItem(handIn));
+    }
+}
Index: src/main/java/net/hdt/neutronia/util/helpers/EnumHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/helpers/EnumHelper.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/util/helpers/EnumHelper.java	(date 1525606896000)
@@ -0,0 +1,92 @@
+package net.hdt.neutronia.util.helpers;
+
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+
+public class EnumHelper {
+
+    public static EnumFacing rotateRight(EnumFacing facing) {
+        EnumFacing CACHE = null;
+        switch (facing) {
+            case DOWN:
+                CACHE = facing;
+                break;
+            case EAST:
+                CACHE = EnumFacing.NORTH;
+                break;
+            case NORTH:
+                CACHE = EnumFacing.WEST;
+                break;
+            case SOUTH:
+                CACHE = EnumFacing.EAST;
+                break;
+            case UP:
+                CACHE = facing;
+                break;
+            case WEST:
+                CACHE = EnumFacing.SOUTH;
+                break;
+        }
+
+        return CACHE != null ? CACHE : facing;
+    }
+
+    public static EnumFacing rotateLeft(EnumFacing facing) {
+        EnumFacing CACHE = null;
+        switch (facing) {
+            case DOWN:
+                CACHE = facing;
+                break;
+            case EAST:
+                CACHE = EnumFacing.SOUTH;
+                break;
+            case NORTH:
+                CACHE = EnumFacing.EAST;
+                break;
+            case SOUTH:
+                CACHE = EnumFacing.WEST;
+                break;
+            case UP:
+                CACHE = facing;
+                break;
+            case WEST:
+                CACHE = EnumFacing.NORTH;
+                break;
+        }
+
+        return CACHE != null ? CACHE : facing;
+    }
+
+    public static EnumFacing getOffsetFacingWithProperty(EnumFacing offset, EnumFacing property) {
+        EnumFacing CACHE = null;
+        switch (property) {
+            case DOWN:
+                CACHE = offset;
+                break;
+            case EAST:
+                CACHE = rotateLeft(offset);
+                break;
+            case NORTH:
+                CACHE = offset;
+                break;
+            case SOUTH:
+                CACHE = rotateLeft(rotateLeft(offset));
+                break;
+            case UP:
+                CACHE = offset;
+                break;
+            case WEST:
+                CACHE = rotateRight(offset);
+                break;
+        }
+
+        return CACHE != null ? CACHE : offset;
+    }
+
+    public static EnumFacing getFacingFromOffset(BlockPos pos1, BlockPos pos2) {
+        return pos1.getY() == pos2.getY()
+                ? (pos1.getZ() == pos2.getZ() ? (pos1.getX() < pos2.getZ() ? EnumFacing.WEST : EnumFacing.EAST)
+                : (pos1.getZ() < pos2.getZ() ? EnumFacing.NORTH : EnumFacing.SOUTH))
+                : (pos1.getY() < pos2.getY() ? EnumFacing.UP : EnumFacing.DOWN);
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_yellow_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_yellow_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_yellow_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_yellow_terracotta",
+    "side": "neutronia:blocks/frosted_yellow_terracotta",
+    "top": "neutronia:blocks/frosted_yellow_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_pink_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_pink_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_pink_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_pink_terracotta",
+    "side": "neutronia:blocks/frosted_pink_terracotta",
+    "top": "neutronia:blocks/frosted_pink_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/upper_frosted_brown_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/upper_frosted_brown_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/upper_frosted_brown_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_brown_terracotta",
+    "side": "neutronia:blocks/frosted_brown_terracotta",
+    "top": "neutronia:blocks/frosted_brown_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/api/IPistonCallback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/api/IPistonCallback.java	(date 1523986186000)
+++ src/main/java/net/hdt/neutronia/api/IPistonCallback.java	(date 1523986186000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.api;
+
+/**
+ * Implement on a TileEntity to add a callback to when it's moved by a piston.
+ */
+public interface IPistonCallback {
+
+    void onPistonMovementStarted();
+
+    void onPistonMovementFinished();
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherDoublePlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherDoublePlantBase.java	(date 1524944098000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherDoublePlantBase.java	(date 1524944098000)
@@ -0,0 +1,174 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+import java.util.Random;
+
+public class BlockNetherDoublePlantBase extends BlockModBush {
+
+    public static final PropertyEnum<BlockNetherDoublePlantBase.EnumBlockHalf> HALF = PropertyEnum.create("half", BlockNetherDoublePlantBase.EnumBlockHalf.class);
+    public static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
+
+    public BlockNetherDoublePlantBase(String name) {
+        super(Material.PLANTS, name, Reference.MOD_ID);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.LOWER).withProperty(FACING, EnumFacing.NORTH));
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return FULL_BLOCK_AABB;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos) {
+        return true;
+    }
+
+    protected void checkAndDropBlock(World worldIn, BlockPos pos, IBlockState state) {
+        if (!this.canBlockStay(worldIn, pos, state)) {
+            boolean flag = state.getValue(HALF) == BlockNetherDoublePlantBase.EnumBlockHalf.UPPER;
+            BlockPos blockpos = flag ? pos : pos.up();
+            BlockPos blockpos1 = flag ? pos.down() : pos;
+            Block block = (flag ? this : worldIn.getBlockState(blockpos).getBlock());
+            Block block1 = (flag ? worldIn.getBlockState(blockpos1).getBlock() : this);
+
+            if (!flag) this.dropBlockAsItem(worldIn, pos, state, 0); //Forge move above the setting to air.
+
+            if (block == this) {
+                worldIn.setBlockState(blockpos, Blocks.AIR.getDefaultState(), 2);
+            }
+
+            if (block1 == this) {
+                worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 3);
+            }
+        }
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        if (state.getBlock() != this)
+            return super.canBlockStay(worldIn, pos, state); //Forge: This function is called during world gen and placement, before this animation.animations.blocks is set, so if we are not 'here' then assume it's the pre-check.
+        if (state.getValue(HALF) == BlockNetherDoublePlantBase.EnumBlockHalf.UPPER) {
+            return worldIn.getBlockState(pos.down()).getBlock() == this;
+        } else {
+            IBlockState iblockstate = worldIn.getBlockState(pos.up());
+            return iblockstate.getBlock() == this && super.canBlockStay(worldIn, pos, iblockstate);
+        }
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        if (state.getValue(HALF) == BlockNetherDoublePlantBase.EnumBlockHalf.UPPER) {
+            return Items.AIR;
+        } else {
+            return super.getItemDropped(state, rand, fortune);
+        }
+    }
+
+    public void placeAt(World worldIn, BlockPos lowerPos, int flags) {
+        worldIn.setBlockState(lowerPos, this.getDefaultState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.LOWER), flags);
+        worldIn.setBlockState(lowerPos.up(), this.getDefaultState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.UPPER), flags);
+    }
+
+    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
+        worldIn.setBlockState(pos.up(), this.getDefaultState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.UPPER), 2);
+    }
+
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack) {
+        {
+            super.harvestBlock(worldIn, player, pos, state, te, stack);
+        }
+    }
+
+    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        if (state.getValue(HALF) == BlockNetherDoublePlantBase.EnumBlockHalf.UPPER) {
+            if (worldIn.getBlockState(pos.down()).getBlock() == this) {
+                if (player.capabilities.isCreativeMode) {
+                    worldIn.setBlockToAir(pos.down());
+                } else {
+                    IBlockState iblockstate = worldIn.getBlockState(pos.down());
+
+                    if (worldIn.isRemote) {
+                        worldIn.setBlockToAir(pos.down());
+                    } else if (!player.getHeldItemMainhand().isEmpty() && player.getHeldItemMainhand().getItem() == Items.SHEARS) {
+                        this.onHarvest(worldIn, pos, iblockstate, player);
+                        worldIn.setBlockToAir(pos.down());
+                    } else {
+                        worldIn.destroyBlock(pos.down(), true);
+                    }
+                }
+            }
+        } else if (worldIn.getBlockState(pos.up()).getBlock() == this) {
+            worldIn.setBlockState(pos.up(), Blocks.AIR.getDefaultState(), 2);
+        }
+
+        super.onBlockHarvested(worldIn, pos, state, player);
+    }
+
+    private boolean onHarvest(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        player.addStat(Objects.requireNonNull(StatList.getBlockStats(this)));
+        return true;
+    }
+
+    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
+        return new ItemStack(this, 1);
+    }
+
+    public IBlockState getStateFromMeta(int meta) {
+        return (meta & 8) > 0 ? this.getDefaultState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.UPPER) : this.getDefaultState().withProperty(HALF, BlockNetherDoublePlantBase.EnumBlockHalf.LOWER);
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(HALF) == BlockNetherDoublePlantBase.EnumBlockHalf.UPPER ? 8 : (state.getValue(FACING)).getHorizontalIndex();
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, HALF, FACING);
+    }
+
+    public EnumOffsetType getOffsetType() {
+        return EnumOffsetType.XZ;
+    }
+
+    public enum EnumBlockHalf implements IStringSerializable {
+        UPPER,
+        LOWER;
+
+        public String toString() {
+            return this.getName();
+        }
+
+        public String getName() {
+            return this == UPPER ? "upper" : "lower";
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/Reference.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/Reference.java	(date 1525373004000)
+++ src/main/java/net/hdt/neutronia/util/Reference.java	(date 1525373004000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.util;
+
+public class Reference {
+    public static final String MOD_ID = "neutronia";
+    public static final String NAME = "Neutronia";
+    public static final String VERSION = "0.0.1";
+    public static final String DEPENDENCIES = "required-before:hl2;required-after:chisel;";
+
+    public static final String CLIENT_PROXY = "net.hdt.neutronia.proxy.ClientProxy";
+    public static final String SERVER_PROXY = "net.hdt.neutronia.proxy.CommonProxy";
+    public static final String NETWORK_CHANNEL_NAME = MOD_ID;
+
+}
Index: src/main/java/net/hdt/neutronia/util/handlers/EntityEventHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/EntityEventHandler.java	(date 1523988245000)
+++ src/main/java/net/hdt/neutronia/util/handlers/EntityEventHandler.java	(date 1523988245000)
@@ -0,0 +1,61 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.entity.EntityMummy;
+import net.hdt.neutronia.entity.EntityMummyVillager;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.monster.EntitySpider;
+import net.minecraft.entity.monster.EntityZombie;
+import net.minecraft.entity.passive.EntitySquid;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.MobEffects;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraftforge.event.entity.living.LivingDeathEvent;
+import net.minecraftforge.event.entity.living.LivingHurtEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.util.List;
+
+@Mod.EventBusSubscriber(modid = Reference.MOD_ID)
+public class EntityEventHandler {
+
+    @SubscribeEvent
+    public static void onLivingDeath(LivingDeathEvent event) {
+        if (event.getEntity() instanceof EntityVillager || event.getEntity() instanceof EntityZombie) {
+            World world = event.getEntity().world;
+            BlockPos pos = event.getEntity().getPosition();
+            if (event.getEntity().getEntityWorld().getBiome(new BlockPos(pos)) == Biomes.DESERT && !world.isRemote) {
+                if (event.getEntity() instanceof EntitySpider || event.getEntity() instanceof EntityMummy)
+                    return;
+
+                EntityMummyVillager mummy = new EntityMummyVillager(world);
+                if (mummy.isAIDisabled())
+                    mummy.setNoAI(false);
+                mummy.setPositionAndRotation(pos.getX() + 1D, pos.getY() + 0.5D, pos.getZ() + 1D, mummy.rotationYaw, mummy.cameraPitch);
+                mummy.onInitialSpawn(world.getDifficultyForLocation(new BlockPos(mummy)), null);
+                world.spawnEntity(mummy);
+            }
+        }
+    }
+
+    @SubscribeEvent
+    public void onHurt(LivingHurtEvent event) {
+        Entity e = event.getEntity();
+        if (e instanceof EntitySquid && !e.world.isRemote) {
+            List<EntityPlayer> players = e.world.getEntitiesWithinAABB(EntityPlayer.class, e.getEntityBoundingBox().grow(4, 4, 4));
+            for (EntityPlayer player : players)
+                player.addPotionEffect(new PotionEffect(MobEffects.BLINDNESS, 80, 0));
+
+            WorldServer ws = (WorldServer) e.world;
+            ws.spawnParticle(EnumParticleTypes.SMOKE_LARGE, e.posX + e.width / 2, e.posY + e.height / 2, e.posZ + e.width / 2, 100, 0, 0, 0, 0.02);
+        }
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/block/half_frosted_magenta_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_magenta_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_magenta_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_magenta_terracotta",
+    "side": "neutronia:blocks/frosted_magenta_terracotta",
+    "top": "neutronia:blocks/frosted_magenta_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/block/half_frosted_silver_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/block/half_frosted_silver_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/block/half_frosted_silver_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,9 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/slab",
+  "textures": {
+    "bottom": "neutronia:blocks/frosted_silver_terracotta",
+    "side": "neutronia:blocks/frosted_silver_terracotta",
+    "top": "neutronia:blocks/frosted_silver_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/models/ModelCustomArmor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/models/ModelCustomArmor.java	(date 1523986186000)
+++ src/main/java/net/hdt/neutronia/items/models/ModelCustomArmor.java	(date 1523986186000)
@@ -0,0 +1,65 @@
+package net.hdt.neutronia.items.models;
+
+import net.minecraft.client.model.ModelBiped;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+public class ModelCustomArmor extends ModelBiped {
+    ModelRenderer basehorn;
+    ModelRenderer horn1;
+    ModelRenderer rightshoulder;
+    ModelRenderer leftshoulder;
+
+    public ModelCustomArmor(float expand) {
+
+        super(expand, 0, 64, 64);
+
+        basehorn = new ModelRenderer(this, 38, 0);
+        basehorn.addBox(-1F, -9F, -4.5F, 2, 2, 2, expand);
+        basehorn.setRotationPoint(0F, 0F, 0F);
+        basehorn.setTextureSize(64, 32);
+        basehorn.mirror = true;
+        setRotation(basehorn, 0F, 0F, 0F);
+
+        horn1 = new ModelRenderer(this, 33, 0);
+        horn1.addBox(-0.5F, -14.5F, 0.7666667F, 1, 5, 1, expand / 3);
+        horn1.setRotationPoint(0F, 0F, 0F);
+        horn1.setTextureSize(64, 32);
+        horn1.mirror = true;
+        setRotation(horn1, 0.5576792F, 0F, 0F);
+
+        rightshoulder = new ModelRenderer(this, 0, 33);
+        rightshoulder.addBox(-3.5F, -3F, -2.5F, 5, 5, 5, expand / 1.2F);
+        rightshoulder.setRotationPoint(0F, 0F, 0F);
+        rightshoulder.setTextureSize(64, 32);
+        rightshoulder.mirror = true;
+        setRotation(rightshoulder, 0F, 0F, 0F);
+
+        leftshoulder = new ModelRenderer(this, 0, 33);
+        leftshoulder.addBox(-1.5F, -3F, -2.5F, 5, 5, 5, expand / 1.2F);
+        leftshoulder.setRotationPoint(0F, 0F, 0F);
+        leftshoulder.setTextureSize(64, 32);
+        leftshoulder.mirror = true;
+        setRotation(leftshoulder, 0F, 0F, 0F);
+
+        basehorn.addChild(horn1);
+        this.bipedHead.addChild(basehorn);
+
+        this.bipedRightArm.addChild(rightshoulder);
+        this.bipedLeftArm.addChild(leftshoulder);
+
+    }
+
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        super.render(entity, f, f1, f2, f3, f4, f5);
+        setRotationAngles(f, f1, f2, f3, f4, f5, entity);
+    }
+
+    private void setRotation(ModelRenderer model, float x, float y, float z) {
+        model.rotateAngleX = x;
+        model.rotateAngleY = y;
+        model.rotateAngleZ = z;
+    }
+
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_white_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_white_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_white_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_white_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_white_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_white_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_white_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_white_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/events/EventHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/events/EventHandler.java	(date 1524662234000)
+++ src/main/java/net/hdt/neutronia/events/EventHandler.java	(date 1524662234000)
@@ -0,0 +1,290 @@
+package net.hdt.neutronia.events;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.Minecraft;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.monster.EntityBlaze;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.gen.feature.WorldGenBigMushroom;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.common.DungeonHooks;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.entity.living.LivingSpawnEvent;
+import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
+import net.minecraftforge.event.terraingen.PopulateChunkEvent;
+import net.minecraftforge.fml.client.FMLClientHandler;
+import net.minecraftforge.fml.common.Loader;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.Event;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.lang.reflect.Constructor;
+import java.util.*;
+
+@Mod.EventBusSubscriber
+public class EventHandler {
+
+    private List<String> allowedBlocks;
+
+    // This is mostly copied from the EntityRenderer#getMouseOver() method
+    private static RayTraceResult getMouseOverExtended(float dist) {
+        Minecraft mc = FMLClientHandler.instance().getClient();
+        Entity theRenderViewEntity = mc.getRenderViewEntity();
+        AxisAlignedBB theViewBoundingBox = new AxisAlignedBB(
+                Objects.requireNonNull(theRenderViewEntity).posX - 0.5D,
+                theRenderViewEntity.posY - 0.0D,
+                theRenderViewEntity.posZ - 0.5D,
+                theRenderViewEntity.posX + 0.5D,
+                theRenderViewEntity.posY + 1.5D,
+                theRenderViewEntity.posZ + 0.5D
+        );
+        RayTraceResult returnMOP = null;
+        if (mc.world != null) {
+            double var2 = dist;
+            returnMOP = theRenderViewEntity.rayTrace(var2, 0);
+            double calcdist = var2;
+            Vec3d pos = theRenderViewEntity.getPositionEyes(0);
+            var2 = calcdist;
+            if (returnMOP != null) {
+                calcdist = returnMOP.hitVec.distanceTo(pos);
+            }
+
+            Vec3d lookvec = theRenderViewEntity.getLook(0);
+            Vec3d var8 = pos.addVector(lookvec.x * var2,
+                    lookvec.y * var2,
+                    lookvec.z * var2);
+            Entity pointedEntity = null;
+            float var9 = 1.0F;
+            @SuppressWarnings("unchecked")
+            List<Entity> list = mc.world.getEntitiesWithinAABBExcludingEntity(
+                    theRenderViewEntity,
+                    theViewBoundingBox.grow(
+                            lookvec.x * var2,
+                            lookvec.y * var2,
+                            lookvec.z * var2).expand(var9, var9, var9));
+            double d = calcdist;
+
+            for (Entity entity : list) {
+                if (entity.canBeCollidedWith()) {
+                    float bordersize = entity.getCollisionBorderSize();
+                    AxisAlignedBB aabb = new AxisAlignedBB(
+                            entity.posX - entity.width / 2,
+                            entity.posY,
+                            entity.posZ - entity.width / 2,
+                            entity.posX + entity.width / 2,
+                            entity.posY + entity.height,
+                            entity.posZ + entity.width / 2);
+                    aabb.expand(bordersize, bordersize, bordersize);
+                    RayTraceResult mop0 = aabb.calculateIntercept(pos, var8);
+
+                    if (aabb.contains(pos)) {
+                        if (0.0D < d || d == 0.0D) {
+                            pointedEntity = entity;
+                            d = 0.0D;
+                        }
+                    } else if (mop0 != null) {
+                        double d1 = pos.distanceTo(mop0.hitVec);
+
+                        if (d1 < d || d == 0.0D) {
+                            pointedEntity = entity;
+                            d = d1;
+                        }
+                    }
+                }
+            }
+
+            if (pointedEntity != null && (d < calcdist || returnMOP == null)) {
+                returnMOP = new RayTraceResult(pointedEntity);
+            }
+        }
+        return returnMOP;
+    }
+
+    @SubscribeEvent
+    public void onSpawn(LivingSpawnEvent.CheckSpawn event) {
+        allowedBlocks = Arrays.asList(Objects.requireNonNull(Blocks.NETHERRACK.getRegistryName()).toString(),
+                Objects.requireNonNull(Blocks.SOUL_SAND.getRegistryName()).toString(),
+                Objects.requireNonNull(Blocks.MAGMA.getRegistryName()).toString());
+        if (!event.isSpawner() && event.getEntityLiving() instanceof EntityBlaze && event.getResult() != Event.Result.DENY && event.getEntityLiving().world instanceof WorldServer) {
+            EntityBlaze blaze = (EntityBlaze) event.getEntityLiving();
+            WorldServer world = (WorldServer) blaze.world;
+            BlockPos pos = blaze.getPosition();
+            Block block = world.getBlockState(pos.down()).getBlock();
+            ResourceLocation res = block.getRegistryName();
+            if (res != null) {
+                boolean allowedBlock = allowedBlocks.contains(res.toString());
+                boolean fortress = world.getChunkProvider().isInsideStructure(world, "Fortress", pos);
+                if (!fortress && !allowedBlock)
+                    event.setResult(Event.Result.DENY);
+            }
+        }
+    }
+
+    @SubscribeEvent
+    public void decorate(DecorateBiomeEvent.Decorate event) {
+        World world = event.getWorld();
+        Biome biome = world.getBiome(event.getPos());
+        Random rand = event.getRand();
+        double bigMushroomsPerChunk = 0.5;
+        WorldGenerator bigMushroomGen = new WorldGenBigMushroom();
+
+        if ((biome == Biomes.SWAMPLAND || biome == Biomes.MUTATED_SWAMPLAND) && event.getType() == DecorateBiomeEvent.Decorate.EventType.BIG_SHROOM) {
+            if (rand.nextDouble() > bigMushroomsPerChunk)
+                return;
+
+            int amount = (int) Math.max(1, bigMushroomsPerChunk);
+            for (int i = 0; i < amount; i++) {
+                int x = rand.nextInt(16) + 8;
+                int y = rand.nextInt(16) + 8;
+                bigMushroomGen.generate(world, rand, world.getHeight(event.getPos().add(x, 0, y)));
+            }
+
+            event.setResult(Event.Result.DENY);
+        }
+    }
+
+    @SubscribeEvent
+    public void onDungeonSpawn(PopulateChunkEvent.Populate event) {
+        if (event.getType() != PopulateChunkEvent.Populate.EventType.DUNGEON)
+            return;
+
+        int i = event.getChunkX() * 16;
+        int j = event.getChunkZ() * 16;
+
+        BlockPos blockpos = new BlockPos(i, 0, j);
+        World world = event.getWorld();
+        Random rand = event.getRand();
+
+        int x = rand.nextInt(16) + 8;
+        int y = rand.nextInt(256);
+        int z = rand.nextInt(16) + 8;
+        BlockPos generatePos = blockpos.add(x, y, z);
+        if (couldDungeonGenerate(world, rand, generatePos) && world instanceof WorldServer) {
+            placeDungeonAt((WorldServer) world, rand, generatePos);
+            event.setResult(Event.Result.DENY);
+        }
+    }
+
+    private boolean couldDungeonGenerate(World worldIn, Random rand, BlockPos position) {
+        int j = rand.nextInt(2) + 2;
+        int k = -j - 1;
+        int l = j + 1;
+        int k1 = rand.nextInt(2) + 2;
+        int l1 = -k1 - 1;
+        int i2 = k1 + 1;
+        int j2 = 0;
+
+        for (int k2 = k; k2 <= l; ++k2) {
+            for (int l2 = -1; l2 <= 4; ++l2) {
+                for (int i3 = l1; i3 <= i2; ++i3) {
+                    BlockPos blockpos = position.add(k2, l2, i3);
+                    Material material = worldIn.getBlockState(blockpos).getMaterial();
+                    boolean flag = material.isSolid();
+
+                    if (l2 == -1 && !flag)
+                        return false;
+
+                    if (l2 == 4 && !flag)
+                        return false;
+
+                    if ((k2 == k || k2 == l || i3 == l1 || i3 == i2) && l2 == 0 && worldIn.isAirBlock(blockpos) && worldIn.isAirBlock(blockpos.up()))
+                        ++j2;
+                }
+            }
+        }
+
+        return j2 >= 1 && j2 <= 5;
+    }
+
+    private void placeDungeonAt(WorldServer world, Random rand, BlockPos position) {
+        int dungeonType = rand.nextInt(10);
+
+        MinecraftServer server = world.getMinecraftServer();
+        Template template = world.getStructureTemplateManager().getTemplate(server, new ResourceLocation(Reference.MOD_ID, "dungeon_" + dungeonType));
+        PlacementSettings settings = new PlacementSettings();
+        settings.setRotation(Rotation.values()[rand.nextInt(Rotation.values().length)]);
+
+        BlockPos size = template.getSize();
+        for (int x = 0; x < size.getX(); x++)
+            for (int y = 0; y < size.getY(); y++)
+                for (int z = 0; z < size.getZ(); z++) {
+                    BlockPos checkPos = position.add(Template.transformedBlockPos(settings, new BlockPos(x, y, z)));
+                    IBlockState checkState = world.getBlockState(checkPos);
+                    if (checkState.getBlock().getBlockHardness(checkState, world, checkPos) == -1 || world.canBlockSeeSky(checkPos))
+                        return; // Obstructed or exposed, can't generate here
+                }
+
+        template.addBlocksToWorld(world, position, settings);
+
+        int spawners = 0;
+        List<BlockPos> chests = new ArrayList<>();
+        Map<BlockPos, String> dataBlocks = template.getDataBlocks(position, settings);
+
+        for (Map.Entry<BlockPos, String> entry : dataBlocks.entrySet()) {
+            BlockPos pos = entry.getKey();
+            String data = entry.getValue();
+
+            if (data.equals("spawner")) {
+                spawners++;
+                world.setBlockState(pos, Blocks.MOB_SPAWNER.getDefaultState(), 2);
+                TileEntity tile = world.getTileEntity(pos);
+
+                if (tile instanceof TileEntityMobSpawner) {
+                    if (Loader.isModLoaded("dungeontweaks")) {
+                        try {
+                            Constructor<? extends Event> constructor = (Constructor<? extends Event>) Class.forName("com.EvilNotch.dungeontweeks.main.Events.EventDungeon$Post").getConstructor(TileEntity.class, BlockPos.class, Random.class, ResourceLocation.class, World.class);
+                            Event event = constructor.newInstance(tile, tile.getPos(), world.rand, new ResourceLocation(Reference.MOD_ID, "dungeon"), world);
+                            MinecraftForge.EVENT_BUS.post(event);
+                        } catch (Throwable t) {
+                            t.printStackTrace();
+                        }
+                    } else
+                        ((TileEntityMobSpawner) tile).getSpawnerBaseLogic().setEntityId(DungeonHooks.getRandomDungeonMob(rand));
+                }
+            } else if (data.equals("chests"))
+                chests.add(pos);
+        }
+
+        int maxChests = spawners * 2 + rand.nextInt(spawners + 2);
+        while (chests.size() > maxChests) {
+            int i = rand.nextInt(chests.size());
+            BlockPos chestPos = chests.get(i);
+            chests.remove(i);
+            world.setBlockToAir(chestPos);
+        }
+
+        for (BlockPos pos : chests) {
+            world.setBlockState(pos, Blocks.CHEST.correctFacing(world, pos, Blocks.CHEST.getDefaultState()), 2);
+            TileEntity tile = world.getTileEntity(pos);
+            String lootTableStr = "";
+            ResourceLocation lootTable = lootTableStr.isEmpty() ? null : new ResourceLocation(lootTableStr);
+
+            if (tile instanceof TileEntityChest) {
+                if (lootTable == null)
+                    ((TileEntityChest) tile).setLootTable(LootTableList.CHESTS_SIMPLE_DUNGEON, rand.nextLong());
+                else ((TileEntityChest) tile).setLootTable(lootTable, rand.nextLong());
+            }
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/natural_smooth_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/natural_smooth_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/natural_smooth_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/natural_smooth_aquamarine"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_silver_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/cracked_limestone_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/cracked_limestone_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/cracked_limestone_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/cracked_limestone_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/small_marble_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/small_marble_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/small_marble_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/small_marble_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredDoubleWaterPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredDoubleWaterPlantBase.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredDoubleWaterPlantBase.java	(date 1525606881000)
@@ -0,0 +1,224 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.properties.EnumCoralColor;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+import java.util.Random;
+
+import static net.minecraft.block.BlockLiquid.LEVEL;
+
+public class BlockColoredDoubleWaterPlantBase extends BlockModBush {
+
+    public static final PropertyEnum<BlockColoredDoubleWaterPlantBase.EnumBlockHalf> HALF = PropertyEnum.create("half", BlockColoredDoubleWaterPlantBase.EnumBlockHalf.class);
+    public static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
+
+    public BlockColoredDoubleWaterPlantBase(EnumCoralColor coralColor, String name) {
+        super(Material.WATER, coralColor + "_" + name, Reference.MOD_ID);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.LOWER).withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return FULL_BLOCK_AABB;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        switch (face) {
+            case DOWN:
+                return false;
+            case UP:
+                return isWater(world, pos.add(0, 1, 0));
+            case NORTH:
+                return isWater(world, pos.add(0, 0, -1));
+            case SOUTH:
+                return isWater(world, pos.add(0, 0, 1));
+            case EAST:
+                return isWater(world, pos.add(1, 0, 0));
+            case WEST:
+                return isWater(world, pos.add(-1, 0, 0));
+        }
+        return false;
+    }
+
+    private boolean isWater(IBlockAccess world, BlockPos pos) {
+        return world.getBlockState(pos).getMaterial() == Material.WATER;
+    }
+
+    @Override
+    public boolean isTranslucent(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEVEL};
+    }
+
+    protected void checkAndDropBlock(World worldIn, BlockPos pos, IBlockState state) {
+        if (!this.canBlockStay(worldIn, pos, state)) {
+            boolean flag = state.getValue(HALF) == BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER;
+            BlockPos blockpos = flag ? pos : pos.up();
+            BlockPos blockpos1 = flag ? pos.down() : pos;
+            Block block = (flag ? this : worldIn.getBlockState(blockpos).getBlock());
+            Block block1 = (flag ? worldIn.getBlockState(blockpos1).getBlock() : this);
+
+            if (!flag) this.dropBlockAsItem(worldIn, pos, state, 0); //Forge move above the setting to air.
+
+            if (block == this) {
+                worldIn.setBlockState(blockpos, Blocks.AIR.getDefaultState(), 2);
+            }
+
+            if (block1 == this) {
+                worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 3);
+            }
+        }
+    }
+
+    public void placeAt(World worldIn, BlockPos lowerPos, int flags) {
+        worldIn.setBlockState(lowerPos, this.getDefaultState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.LOWER), flags);
+        worldIn.setBlockState(lowerPos.up(), this.getDefaultState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER), flags);
+    }
+
+    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
+        worldIn.setBlockState(pos.up(), this.getDefaultState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER), 2);
+    }
+
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack) {
+        {
+            super.harvestBlock(worldIn, player, pos, state, te, stack);
+        }
+    }
+
+    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        if (state.getValue(HALF) == BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER) {
+            if (worldIn.getBlockState(pos.down()).getBlock() == this) {
+                if (player.capabilities.isCreativeMode) {
+                    worldIn.setBlockToAir(pos.down());
+                } else {
+                    IBlockState iblockstate = worldIn.getBlockState(pos.down());
+
+                    if (worldIn.isRemote) {
+                        worldIn.setBlockToAir(pos.down());
+                    } else if (!player.getHeldItemMainhand().isEmpty() && player.getHeldItemMainhand().getItem() == Items.SHEARS) {
+                        this.onHarvest(worldIn, pos, iblockstate, player);
+                        worldIn.setBlockToAir(pos.down());
+                    } else {
+                        worldIn.destroyBlock(pos.down(), true);
+                    }
+                }
+            }
+        } else if (worldIn.getBlockState(pos.up()).getBlock() == this) {
+            worldIn.setBlockState(pos.up(), Blocks.AIR.getDefaultState(), 2);
+        }
+
+        super.onBlockHarvested(worldIn, pos, state, player);
+    }
+
+    private boolean onHarvest(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        player.addStat(Objects.requireNonNull(StatList.getBlockStats(this)));
+        return true;
+    }
+
+    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
+        return new ItemStack(this, 1);
+    }
+
+    public IBlockState getStateFromMeta(int meta) {
+        return (meta & 8) > 0 ? this.getDefaultState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER) : this.getDefaultState().withProperty(HALF, BlockColoredDoubleWaterPlantBase.EnumBlockHalf.LOWER);
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(HALF) == BlockColoredDoubleWaterPlantBase.EnumBlockHalf.UPPER ? 8 : (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, HALF, FACING, LEVEL);
+    }
+
+    public EnumOffsetType getOffsetType() {
+        return EnumOffsetType.XZ;
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canBlockStay(IBlockAccess worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        Block ground = worldIn.getBlockState(pos.add(0, -1, 0)).getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL && worldIn.getBlockState(pos.add(0, 2, 0)).getBlock() != Blocks.AIR;
+    }
+
+    public boolean isReplaceable(IBlockAccess access, BlockPos pos) {
+        return access.getBlockState(pos).getBlock() == Blocks.WATER && canBlockStay(access, pos, getDefaultState()) && access.getBlockState(pos.add(0, 1, 0)).getBlock() != Blocks.AIR;
+    }
+
+    protected boolean canSustainBush(IBlockState state) {
+        Block ground = state.getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL;
+    }
+
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        checkAndDropBlock(worldIn, pos, state);
+        super.onBlockAdded(worldIn, pos, state);
+    }
+
+    public boolean isReplaceable(World worldIn, BlockPos pos) {
+        return false;
+    }
+
+    public enum EnumBlockHalf implements IStringSerializable {
+        UPPER,
+        LOWER;
+
+        public String toString() {
+            return this.getName();
+        }
+
+        public String getName() {
+            return this == UPPER ? "upper" : "lower";
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelWhale.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelWhale.java	(date 1523986187000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelWhale.java	(date 1523986187000)
@@ -0,0 +1,68 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+public class ModelWhale extends ModelBase {
+    public ModelRenderer body1;
+    public ModelRenderer body2;
+    public ModelRenderer tail1;
+    public ModelRenderer tail2;
+    public ModelRenderer tail3;
+    public ModelRenderer fin1;
+    public ModelRenderer fin2;
+
+    public ModelWhale() {
+        this.textureWidth = 64;
+        this.textureHeight = 32;
+        this.tail1 = new ModelRenderer(this, 0, 21);
+        this.tail1.mirror = true;
+        this.tail1.setRotationPoint(0.0F, 20.0F, 3.0F);
+        this.tail1.addBox(-2.5F, -1.0F, 8.0F, 5, 2, 6, 0.0F);
+        this.fin2 = new ModelRenderer(this, 35, 21);
+        this.fin2.mirror = true;
+        this.fin2.setRotationPoint(-3.0F, 20.0F, 0.0F);
+        this.fin2.addBox(-2.0F, 1.0F, 0.0F, 2, 1, 5, 0.0F);
+        this.tail2 = new ModelRenderer(this, 18, 21);
+        this.tail2.mirror = true;
+        this.tail2.setRotationPoint(0.0F, 20.0F, 3.0F);
+        this.tail2.addBox(-5.0F, 0.0F, 13.0F, 3, 1, 5, 0.0F);
+        this.body2 = new ModelRenderer(this, 28, 0);
+        this.body2.mirror = true;
+        this.body2.setRotationPoint(0.0F, 20.0F, 3.0F);
+        this.body2.addBox(-2.5F, -2.5F, 0.0F, 5, 5, 9, 0.0F);
+        this.fin1 = new ModelRenderer(this, 35, 21);
+        this.fin1.mirror = true;
+        this.fin1.setRotationPoint(3.0F, 20.0F, 0.0F);
+        this.fin1.addBox(0.0F, 1.0F, 0.0F, 2, 1, 5, 0.0F);
+        this.body1 = new ModelRenderer(this, 0, 0);
+        this.body1.mirror = true;
+        this.body1.setRotationPoint(0.0F, 19.0F, -4.0F);
+        this.body1.addBox(-3.5F, -2.5F, -7.0F, 7, 7, 14, 0.0F);
+        this.tail3 = new ModelRenderer(this, 18, 21);
+        this.tail3.mirror = true;
+        this.tail3.setRotationPoint(0.0F, 20.0F, 3.0F);
+        this.tail3.addBox(2.0F, 0.0F, 13.0F, 3, 1, 5, 0.0F);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.tail1.render(f5);
+        this.fin2.render(f5);
+        this.tail2.render(f5);
+        this.body2.render(f5);
+        this.fin1.render(f5);
+        this.body1.render(f5);
+        this.tail3.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+}
Index: src/main/resources/assets/neutronia/models/item/marble_cobble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/marble_cobble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/marble_cobble.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/marble_cobble"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_red_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_red_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_red_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_red_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/natural_chiseled_aquamarine.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/natural_chiseled_aquamarine.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/natural_chiseled_aquamarine.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/natural_chiseled_aquamarine"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_yellow_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/api/world/gen/feature/IFeature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/api/world/gen/feature/IFeature.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/api/world/gen/feature/IFeature.java	(date 1525606884000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.api.world.gen.feature;
+
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public interface IFeature {
+    boolean generate(World world, Random rand, BlockPos pos);
+
+    int getGenAttempts();
+
+    int getGenAttempts(Random rand);
+
+    float getGenProbability();
+
+    boolean randomizeGenAttempts();
+
+    int getMinHeight();
+
+    int getMaxHeight();
+}
Index: src/main/resources/assets/neutronia/models/item/natural_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/natural_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/natural_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/natural_aquamarine_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_green_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_green_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_green_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_green_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/aquamarine_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_pink_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/chiseled_limestone.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/chiseled_limestone.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/chiseled_limestone.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/chiseled_limestone"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_brown_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_cyan_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_orange_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_light_blue_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityMonsterOfTheOceanDepths.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityMonsterOfTheOceanDepths.java	(date 1523986178000)
+++ src/main/java/net/hdt/neutronia/entity/EntityMonsterOfTheOceanDepths.java	(date 1523986178000)
@@ -0,0 +1,248 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.MoverType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBase;
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+
+public class EntityMonsterOfTheOceanDepths extends EntityWaterMob {
+
+    public float squidPitch;
+    public float prevSquidPitch;
+    public float squidYaw;
+    public float prevSquidYaw;
+    /**
+     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
+     */
+    public float squidRotation;
+    /**
+     * previous squidRotation in radians
+     */
+    public float prevSquidRotation;
+    /**
+     * angle of the tentacles in radians
+     */
+    public float tentacleAngle;
+    /**
+     * the last calculated angle of the tentacles in radians
+     */
+    public float lastTentacleAngle;
+    private float randomMotionSpeed;
+    /**
+     * change in squidRotation in radians.
+     */
+    private float rotationVelocity;
+    private float rotateSpeed;
+    private float randomMotionVecX;
+    private float randomMotionVecY;
+    private float randomMotionVecZ;
+
+    public EntityMonsterOfTheOceanDepths(World worldIn) {
+        super(worldIn);
+        this.setSize(0.8F, 0.8F);
+        this.rand.setSeed((long) (1 + this.getEntityId()));
+        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+    }
+
+    public static void registerFixesSquid(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityMonsterOfTheOceanDepths.class);
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityMonsterOfTheOceanDepths.AIMoveRandom(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
+    }
+
+    public float getEyeHeight() {
+        return this.height * 0.5F;
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SQUID_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SQUID_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SQUID_DEATH;
+    }
+
+    /**
+     * Returns the volume for the sounds this mob makes.
+     */
+    protected float getSoundVolume() {
+        return 0.4F;
+    }
+
+    /**
+     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
+     * prevent them from trampling crops
+     */
+    protected boolean canTriggerWalking() {
+        return false;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_SQUID;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+        this.prevSquidPitch = this.squidPitch;
+        this.prevSquidYaw = this.squidYaw;
+        this.prevSquidRotation = this.squidRotation;
+        this.lastTentacleAngle = this.tentacleAngle;
+        this.squidRotation += this.rotationVelocity;
+
+        if ((double) this.squidRotation > (Math.PI * 2D)) {
+            if (this.world.isRemote) {
+                this.squidRotation = ((float) Math.PI * 2F);
+            } else {
+                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
+
+                if (this.rand.nextInt(10) == 0) {
+                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+                }
+
+                this.world.setEntityState(this, (byte) 19);
+            }
+        }
+
+        if (this.inWater) {
+            if (this.squidRotation < (float) Math.PI) {
+                float f = this.squidRotation / (float) Math.PI;
+                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
+
+                if ((double) f > 0.75D) {
+                    this.randomMotionSpeed = 1.0F;
+                    this.rotateSpeed = 1.0F;
+                } else {
+                    this.rotateSpeed *= 0.8F;
+                }
+            } else {
+                this.tentacleAngle = 0.0F;
+                this.randomMotionSpeed *= 0.9F;
+                this.rotateSpeed *= 0.99F;
+            }
+
+            if (!this.world.isRemote) {
+                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
+                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
+                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
+            }
+
+            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
+            this.rotationYaw = this.renderYawOffset;
+            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
+            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
+        } else {
+            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
+
+            if (!this.world.isRemote) {
+                this.motionX = 0.0D;
+                this.motionZ = 0.0D;
+
+                if (this.isPotionActive(MobEffects.LEVITATION)) {
+                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
+                } else if (!this.hasNoGravity()) {
+                    this.motionY -= 0.08D;
+                }
+
+                this.motionY *= 0.9800000190734863D;
+            }
+
+            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
+        }
+    }
+
+    public void travel(float strafe, float vertical, float forward) {
+        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+    }
+
+    /**
+     * Checks if the entity's current position is a valid location to spawn this entity.
+     */
+    public boolean getCanSpawnHere() {
+        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
+    }
+
+    /**
+     * Handler for {@link World#setEntityState}
+     */
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 19) {
+            this.squidRotation = 0.0F;
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
+        this.randomMotionVecX = randomMotionVecXIn;
+        this.randomMotionVecY = randomMotionVecYIn;
+        this.randomMotionVecZ = randomMotionVecZIn;
+    }
+
+    public boolean hasMovementVector() {
+        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
+    }
+
+    static class AIMoveRandom extends EntityAIBase {
+        private final EntityMonsterOfTheOceanDepths squid;
+
+        public AIMoveRandom(EntityMonsterOfTheOceanDepths p_i45859_1_) {
+            this.squid = p_i45859_1_;
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            return true;
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            int i = this.squid.getIdleTime();
+
+            if (i > 100) {
+                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
+            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
+                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
+                float f1 = MathHelper.cos(f) * 0.2F;
+                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
+                float f3 = MathHelper.sin(f) * 0.2F;
+                this.squid.setMovementVector(f1, f2, f3);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_gray_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterPlantBase.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterPlantBase.java	(date 1525606879000)
@@ -0,0 +1,167 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.properties.EnumCoralColor;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+import static net.minecraft.block.BlockLiquid.LEVEL;
+
+public class BlockColoredWaterPlantBase extends BlockModBush {
+
+    private static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
+    private final EnumCoralColor color;
+
+    public BlockColoredWaterPlantBase(EnumCoralColor coralColor, String name) {
+        super(Material.WATER, coralColor + "_" + name, Reference.MOD_ID);
+        this.color = coralColor;
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
+    }
+
+    @SideOnly(Side.CLIENT)
+    public static EnumCoralColor getColorFromItem(Item itemIn) {
+        return getColorFromBlock(Block.getBlockFromItem(itemIn));
+    }
+
+    @SideOnly(Side.CLIENT)
+    private static EnumCoralColor getColorFromBlock(Block blockIn) {
+        return blockIn instanceof BlockColoredWaterPlantBase ? ((BlockColoredWaterPlantBase) blockIn).getColor() : EnumCoralColor.BLUE;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEVEL};
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public boolean canPlaceBlockOnSide(World worldIn, BlockPos pos, EnumFacing side) {
+        if (this == Block.getBlockFromName("neutronia:" + color.getName() + "_coral_fan")) {
+            return side != EnumFacing.DOWN && side != EnumFacing.UP;
+        } else {
+            return true;
+        }
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        switch (face) {
+            case DOWN:
+                return false;
+            case UP:
+                return isWater(world, pos.add(0, 1, 0));
+            case NORTH:
+                return isWater(world, pos.add(0, 0, -1));
+            case SOUTH:
+                return isWater(world, pos.add(0, 0, 1));
+            case EAST:
+                return isWater(world, pos.add(1, 0, 0));
+            case WEST:
+                return isWater(world, pos.add(-1, 0, 0));
+        }
+        return false;
+    }
+
+    private boolean isWater(IBlockAccess world, BlockPos pos) {
+        return world.getBlockState(pos).getMaterial() == Material.WATER;
+    }
+
+    @Override
+    public boolean isTranslucent(IBlockState state) {
+        return true;
+    }
+
+    @SideOnly(Side.CLIENT)
+    private EnumCoralColor getColor() {
+        return this.color;
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand) {
+        IBlockState state = super.getStateForPlacement(world, pos, facing, hitX, hitY, hitZ, meta, placer, hand);
+        return state.withProperty(FACING, placer.getHorizontalFacing());
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(FACING, EnumFacing.getHorizontal(meta));
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING, LEVEL);
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canBlockStay(IBlockAccess worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        Block ground = worldIn.getBlockState(pos.add(0, -1, 0)).getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL && worldIn.getBlockState(pos.add(0, 2, 0)).getBlock() != Blocks.AIR;
+    }
+
+    public boolean isReplaceable(IBlockAccess access, BlockPos pos) {
+        return access.getBlockState(pos).getBlock() == Blocks.WATER && canBlockStay(access, pos, getDefaultState()) && access.getBlockState(pos.add(0, 1, 0)).getBlock() != Blocks.AIR;
+    }
+
+    protected boolean canSustainBush(IBlockState state) {
+        Block ground = state.getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL;
+    }
+
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        checkAndDropBlock(worldIn, pos, state);
+        super.onBlockAdded(worldIn, pos, state);
+    }
+
+    public boolean isReplaceable(World worldIn, BlockPos pos) {
+        return false;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_gray_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_gray_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/client/container/ContainerWorkbench.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/client/container/ContainerWorkbench.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/client/container/ContainerWorkbench.java	(date 1525606887000)
@@ -0,0 +1,34 @@
+package net.hdt.neutronia.client.container;
+
+import net.hdt.neutronia.tileentity.TileEntityCraftingTable;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.InventoryPlayer;
+import net.minecraft.inventory.Container;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.items.ItemStackHandler;
+
+public class ContainerWorkbench extends net.minecraft.inventory.ContainerWorkbench {
+
+    private TileEntityCraftingTable TE = new TileEntityCraftingTable();
+
+    public ContainerWorkbench(InventoryPlayer playerInventory, World worldIn, BlockPos posIn) {
+        super(playerInventory, worldIn, posIn);
+
+        ItemStackHandler inv = TE.INVENTORY;
+        for (int index = 0; index < 9; index++) {
+            craftMatrix.setInventorySlotContents(index, inv.extractItem(index, inv.getStackInSlot(index).getCount(), false));
+        }
+
+    }
+
+    public void onContainerClosed(EntityPlayer playerIn) {
+        Container c = this;
+        c.onContainerClosed(playerIn);
+        ItemStackHandler inv = TE.INVENTORY;
+        for (int index = 0; index < 9; index++) {
+            inv.insertItem(index, craftMatrix.getStackInSlot(index), true);
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/small_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/small_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/small_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/small_aquamarine_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/cracked_basalt_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/cracked_basalt_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/cracked_basalt_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/cracked_basalt_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_magenta_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemPotionBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemPotionBase.java	(date 1523986170000)
+++ src/main/java/net/hdt/neutronia/items/ItemPotionBase.java	(date 1523986170000)
@@ -0,0 +1,55 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntityPotion;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemPotion;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionUtils;
+import net.minecraft.stats.StatList;
+import net.minecraft.util.ActionResult;
+import net.minecraft.util.EnumActionResult;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.List;
+
+public class ItemPotionBase extends ItemPotion {
+
+    public String getItemStackDisplayName(ItemStack stack) {
+        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("potion.effect."));
+    }
+
+    /**
+     * allows items to add custom lines of information to the mouseover description
+     */
+    @SideOnly(Side.CLIENT)
+    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
+        PotionUtils.addPotionTooltip(stack, tooltip, 0.25F);
+    }
+
+    /**
+     * Called when the equipped item is right clicked.
+     */
+    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
+        ItemStack itemstack = playerIn.getHeldItem(handIn);
+        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
+        worldIn.playSound(null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_LINGERINGPOTION_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
+
+        if (!worldIn.isRemote) {
+            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
+            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
+            worldIn.spawnEntity(entitypotion);
+        }
+
+        playerIn.addStat(StatList.getObjectUseStats(this));
+        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, itemstack);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockSoulStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockSoulStone.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockSoulStone.java	(date 1525606880000)
@@ -0,0 +1,38 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import javax.annotation.Nullable;
+
+public class BlockSoulStone extends BlockMod {
+
+    private static final AxisAlignedBB SOUL_SAND_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.875D, 1.0D);
+
+    public BlockSoulStone(String name) {
+        super(Material.SAND, Reference.MOD_ID, name);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+    @Nullable
+    public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos) {
+        return SOUL_SAND_AABB;
+    }
+
+    /**
+     * Called When an Entity Collided with the Block
+     */
+    public void onEntityCollidedWithBlock(World worldIn, BlockPos pos, IBlockState state, Entity entityIn) {
+        entityIn.motionX *= 0.4D;
+        entityIn.motionZ *= 0.4D;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/commands/TeleportUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/commands/TeleportUtil.java	(date 1523986176000)
+++ src/main/java/net/hdt/neutronia/commands/TeleportUtil.java	(date 1523986176000)
@@ -0,0 +1,80 @@
+package net.hdt.neutronia.commands;
+
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.Teleporter;
+import net.minecraft.world.WorldServer;
+
+import javax.annotation.Nonnull;
+
+public class TeleportUtil {
+
+    public static void teleportToDimension(EntityPlayer player, int dimension, double x, double y, double z) {
+        if (!(player instanceof EntityPlayerMP)) return;
+        int oldDimension = player.world.provider.getDimension();
+        EntityPlayerMP entityPlayerMP = (EntityPlayerMP) player;
+        MinecraftServer server = ((EntityPlayerMP) player).world.getMinecraftServer();
+        if (server == null) return;
+        WorldServer worldServer = server.getWorld(dimension);
+        player.addExperienceLevel(0);
+
+        if (worldServer.getMinecraftServer() == null) return;
+
+        worldServer.getMinecraftServer().getPlayerList().transferPlayerToDimension(entityPlayerMP, dimension, new CustomTeleporter(worldServer, x, y, z));
+        player.setPositionAndUpdate(x, y, z);
+        if (oldDimension == 1) {
+            // For some reason teleporting out of the end does weird things.
+            player.setPositionAndUpdate(x, y, z);
+            worldServer.spawnEntity(player);
+            worldServer.updateEntityWithOptionalForce(player, false);
+        }
+    }
+
+    public static void blink(EntityLivingBase entity, double dist) {
+        if (entity == null) return;
+        Vec3d look = entity.getLookVec();
+
+        double x = entity.posX += look.x * dist;
+        double y = entity.posY += Math.max(0, look.y * dist);
+        double z = entity.posZ += look.z * dist;
+
+        if (entity instanceof EntityPlayerMP) {
+            EntityPlayerMP mp = (EntityPlayerMP) entity;
+            mp.connection.setPlayerLocation(x, y, z, entity.rotationYaw, entity.rotationPitch);
+        } else entity.setPosition(x, y, z);
+    }
+
+
+    public static class CustomTeleporter extends Teleporter {
+        private final WorldServer worldServer;
+
+        private final double x;
+        private final double y;
+        private final double z;
+
+
+        public CustomTeleporter(WorldServer world, double x, double y, double z) {
+            super(world);
+            worldServer = world;
+            this.x = x;
+            this.y = y;
+            this.z = z;
+
+        }
+
+        @Override
+        public void placeInPortal(@Nonnull Entity entity, float rotationYaw) {
+            worldServer.getBlockState(new BlockPos((int) x, (int) y, (int) z));
+
+            entity.setPosition(x, y, z);
+            entity.motionX = 0.0f;
+            entity.motionY = 0.0f;
+            entity.motionZ = 0.0f;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_blue_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_blue_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_silver_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_silver_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_black_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_black_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_black_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_black_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/small_basalt_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/small_basalt_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/small_basalt_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/small_basalt_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/chiseled_marble.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/chiseled_marble.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/chiseled_marble.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/chiseled_marble"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_red_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_red_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_red_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_red_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_light_blue_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_light_blue_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_lime_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/small_natural_aquamarine_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/small_natural_aquamarine_bricks.json	(date 1525194030000)
+++ src/main/resources/assets/neutronia/models/item/small_natural_aquamarine_bricks.json	(date 1525194030000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/small_natural_aquamarine_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_purple_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_purple_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_purple_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_orange_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_orange_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_green_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_green_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_green_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_green_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_yellow_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_yellow_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityDrowned.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityDrowned.java	(date 1523987840000)
+++ src/main/java/net/hdt/neutronia/entity/EntityDrowned.java	(date 1523987840000)
@@ -0,0 +1,242 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.init.HMItems;
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.*;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.ai.attributes.AttributeModifier;
+import net.minecraft.entity.monster.EntityCreeper;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.World;
+
+import javax.annotation.Nullable;
+import java.util.Calendar;
+
+public class EntityDrowned extends EntityMob {
+
+    private float mummyWidth = 0.6F;
+    private float mummyHeight = 1.95F;
+
+    public EntityDrowned(World worldIn) {
+        super(worldIn);
+        this.setSize(mummyWidth, mummyHeight);
+    }
+
+    public static void registerFixesDrowned(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityDrowned.class);
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityAISwimming(this));
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 7.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+        this.applyEntityAI();
+    }
+
+    protected void applyEntityAI() {
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+    }
+
+    @Override
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(30.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(1.5D);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+    }
+
+    @Override
+    protected int getExperiencePoints(EntityPlayer player) {
+        return super.getExperiencePoints(player);
+    }
+
+    @Override
+    public void notifyDataManagerChange(DataParameter<?> key) {
+        super.notifyDataManagerChange(key);
+    }
+
+    @Override
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+    }
+
+    @Override
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        return super.attackEntityFrom(source, amount);
+    }
+
+    @Override
+    public boolean attackEntityAsMob(Entity entityIn) {
+        boolean flag = super.attackEntityAsMob(entityIn);
+
+        if (flag) {
+            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
+
+            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
+                entityIn.setFire(2 * (int) f);
+        }
+        return flag;
+    }
+
+    /**
+     * TODO: Change Sounds...
+     */
+    @Override
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_BAT_AMBIENT;
+    }
+
+    @Override
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.BLOCK_ANVIL_USE;
+    }
+
+    @Override
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_DONKEY_DEATH;
+    }
+
+    // TODO ^
+
+    protected SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_STEP;
+    }
+
+    @Override
+    protected void playStepSound(BlockPos pos, Block blockIn) {
+        this.playSound(this.getStepSound(), 0.15F, 1.0F);
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.UNDEAD;
+    }
+
+    @Nullable
+    @Override
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.DROWNED;
+    }
+
+    @Override
+    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
+        super.setEquipmentBasedOnDifficulty(difficulty);
+
+        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
+            int i = this.rand.nextInt(3);
+
+            if (i == 0)
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(HMItems.trident));
+            else
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, ItemStack.EMPTY);
+        }
+    }
+
+    @Override
+    public void writeEntityToNBT(NBTTagCompound compound) {
+        super.writeEntityToNBT(compound);
+    }
+
+    @Override
+    public void readEntityFromNBT(NBTTagCompound compound) {
+        super.readEntityFromNBT(compound);
+    }
+
+    @Override
+    public float getEyeHeight() {
+        return 1.74F;
+    }
+
+    @Override
+    protected boolean canEquipItem(ItemStack stack) {
+        return stack.getItem() == HMItems.trident;
+    }
+
+    @Override
+    public boolean getCanSpawnHere() {
+        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        if (!getCanSpawnHere())
+            despawnEntity();
+        else {
+            livingdata = super.onInitialSpawn(difficulty, livingdata);
+            float f = difficulty.getClampedAdditionalDifficulty();
+            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
+            this.setEquipmentBasedOnDifficulty(difficulty);
+            this.setEnchantmentBasedOnDifficulty(difficulty);
+
+            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
+                Calendar calendar = this.world.getCurrentDate();
+                if (calendar.get(Calendar.MONTH) + 1 == 10 && calendar.get(Calendar.DATE) == 31 && this.rand.nextFloat() < 0.25F) {
+                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
+                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
+                }
+            }
+
+            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
+            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
+
+            if (d0 > 1.0D)
+                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random drowned-spawn bonus", d0, 2));
+
+            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader drowned bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
+            }
+        }
+        return livingdata;
+    }
+
+    public double getYOffset() {
+        return -0.45D;
+    }
+
+    @Override
+    public void onDeath(DamageSource cause) {
+        super.onDeath(cause);
+
+        if (cause.getTrueSource() instanceof EntityCreeper) {
+            EntityCreeper entityCreeper = (EntityCreeper) cause.getTrueSource();
+
+            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
+                entityCreeper.incrementDroppedSkulls();
+                ItemStack itemStack = this.getSkullDrop();
+
+                if (!itemStack.isEmpty())
+                    this.entityDropItem(itemStack, 0.0F);
+            }
+        }
+    }
+
+    protected ItemStack getSkullDrop() {
+        return new ItemStack(Items.SKULL, 1, 2);
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_lime_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_lime_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelHoveringInferno.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelHoveringInferno.java	(date 1523986195000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelHoveringInferno.java	(date 1523986195000)
@@ -0,0 +1,119 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+/**
+ * ModelHoveringInferno - Created By: Dion/Trikzon
+ * Created using Tabula 7.0.0
+ */
+public class ModelHoveringInferno extends ModelBase {
+    public ModelRenderer head;
+    public ModelRenderer rod;
+    public ModelRenderer helmetFront1;
+    public ModelRenderer helmetFront2;
+    public ModelRenderer helmetFront3;
+    public ModelRenderer helmetFront4;
+    public ModelRenderer helmetFront5;
+    public ModelRenderer helmetFront6;
+    public ModelRenderer helmetFront7;
+    public ModelRenderer helmetLeft1;
+    public ModelRenderer helmetRight1;
+    public ModelRenderer helmetBack1;
+    public ModelRenderer helmetFrontGold;
+    public ModelRenderer shield1;
+    public ModelRenderer shield2;
+    public ModelRenderer shield3;
+    public ModelRenderer shield4;
+
+    public ModelHoveringInferno() {
+        this.textureWidth = 128;
+        this.textureHeight = 64;
+        this.helmetFrontGold = new ModelRenderer(this, 27, 6);
+        this.helmetFrontGold.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFrontGold.addBox(-1.0F, -7.5F, -4.5F, 2, 2, 1, 0.0F);
+        this.helmetRight1 = new ModelRenderer(this, 1, 14);
+        this.helmetRight1.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetRight1.addBox(-4.0F, -8.0F, -3.0F, 1, 8, 6, 0.0F);
+        this.helmetFront3 = new ModelRenderer(this, 35, 23);
+        this.helmetFront3.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront3.addBox(2.0F, -4.0F, -4.0F, 2, 4, 1, 0.0F);
+        this.shield2 = new ModelRenderer(this, 16, 44);
+        this.shield2.setRotationPoint(6.0F, 0.0F, -6.0F);
+        this.shield2.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
+        this.setRotateAngle(shield2, -0.2617993877991494F, -0.7853981633974483F, 0.0F);
+        this.helmetLeft1 = new ModelRenderer(this, 45, 14);
+        this.helmetLeft1.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetLeft1.addBox(3.0F, -8.0F, -3.0F, 1, 8, 6, 0.0F);
+        this.helmetFront2 = new ModelRenderer(this, 18, 17);
+        this.helmetFront2.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront2.addBox(-4.0F, -8.0F, -4.0F, 1, 4, 1, 0.0F);
+        this.helmetBack1 = new ModelRenderer(this, 21, 29);
+        this.helmetBack1.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetBack1.addBox(-4.0F, -8.0F, 3.0F, 8, 8, 1, 0.0F);
+        this.helmetFront4 = new ModelRenderer(this, 38, 17);
+        this.helmetFront4.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront4.addBox(3.0F, -8.0F, -4.0F, 1, 4, 1, 0.0F);
+        this.head = new ModelRenderer(this, 46, 50);
+        this.head.setRotationPoint(0.0F, -2.0F, 0.0F);
+        this.head.addBox(-3.0F, -8.0F, -3.0F, 6, 8, 6, 0.0F);
+        this.helmetFront7 = new ModelRenderer(this, 27, 10);
+        this.helmetFront7.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront7.addBox(-1.0F, -9.0F, -4.0F, 2, 1, 1, 0.0F);
+        this.rod = new ModelRenderer(this, 0, 38);
+        this.rod.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.rod.addBox(-2.0F, 0.0F, -2.0F, 4, 22, 4, 0.0F);
+        this.shield4 = new ModelRenderer(this, 16, 44);
+        this.shield4.setRotationPoint(-6.0F, 0.0F, 6.0F);
+        this.shield4.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
+        this.setRotateAngle(shield4, 0.2617993877991494F, -0.7853981633974483F, 0.0F);
+        this.helmetFront6 = new ModelRenderer(this, 25, 13);
+        this.helmetFront6.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront6.addBox(-2.0F, -8.0F, -4.0F, 4, 1, 1, 0.0F);
+        this.shield1 = new ModelRenderer(this, 16, 44);
+        this.shield1.setRotationPoint(-6.0F, 0.0F, -6.0F);
+        this.shield1.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
+        this.setRotateAngle(shield1, -0.2617993877991494F, 0.7853981633974483F, 0.0F);
+        this.shield3 = new ModelRenderer(this, 16, 44);
+        this.shield3.setRotationPoint(6.0F, 0.0F, 6.0F);
+        this.shield3.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
+        this.setRotateAngle(shield3, 0.2617993877991494F, 0.7853981633974483F, 0.0F);
+        this.helmetFront1 = new ModelRenderer(this, 19, 23);
+        this.helmetFront1.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront1.addBox(-4.0F, -4.0F, -4.0F, 2, 4, 1, 0.0F);
+        this.helmetFront5 = new ModelRenderer(this, 23, 16);
+        this.helmetFront5.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.helmetFront5.addBox(-3.0F, -7.0F, -4.0F, 6, 2, 1, 0.0F);
+        this.head.addChild(this.helmetFrontGold);
+        this.head.addChild(this.helmetRight1);
+        this.head.addChild(this.helmetFront3);
+        this.rod.addChild(this.shield2);
+        this.head.addChild(this.helmetLeft1);
+        this.head.addChild(this.helmetFront2);
+        this.head.addChild(this.helmetBack1);
+        this.head.addChild(this.helmetFront4);
+        this.head.addChild(this.helmetFront7);
+        this.rod.addChild(this.shield4);
+        this.head.addChild(this.helmetFront6);
+        this.rod.addChild(this.shield1);
+        this.rod.addChild(this.shield3);
+        this.head.addChild(this.helmetFront1);
+        this.head.addChild(this.helmetFront5);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.head.render(f5);
+        this.rod.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+}
Index: src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_cyan_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_cyan_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/small_limestone_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/small_limestone_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/small_limestone_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/small_limestone_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_brown_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_brown_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/cracked_marble_bricks.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/cracked_marble_bricks.json	(date 1525345853000)
+++ src/main/resources/assets/neutronia/models/item/cracked_marble_bricks.json	(date 1525345853000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v3.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/cracked_marble_bricks"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_black_terracotta_slab.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_black_terracotta_slab.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_black_terracotta_slab.json	(date 1525306811000)
@@ -0,0 +1,4 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "neutronia:block/half_frosted_black_terracotta_slab"
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockCoralPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockCoralPlantBase.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockCoralPlantBase.java	(date 1525606885000)
@@ -0,0 +1,94 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+import static net.minecraft.block.BlockLiquid.LEVEL;
+
+public class BlockCoralPlantBase extends BlockModBush {
+
+    public BlockCoralPlantBase(String name) {
+        super(Material.WATER, name, Reference.MOD_ID);
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(LEVEL, 15));
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEVEL};
+    }
+
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(LEVEL);
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, LEVEL);
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canBlockStay(IBlockAccess worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        Block ground = worldIn.getBlockState(pos.add(0, -1, 0)).getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL && worldIn.getBlockState(pos.add(0, 2, 0)).getBlock() != Blocks.AIR;
+    }
+
+    public boolean isReplaceable(IBlockAccess access, BlockPos pos) {
+        return access.getBlockState(pos).getBlock() == Blocks.WATER && canBlockStay(access, pos, getDefaultState()) && access.getBlockState(pos.add(0, 1, 0)).getBlock() != Blocks.AIR;
+    }
+
+    protected boolean canSustainBush(IBlockState state) {
+        Block ground = state.getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL;
+    }
+
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        checkAndDropBlock(worldIn, pos, state);
+        super.onBlockAdded(worldIn, pos, state);
+    }
+
+    public boolean isReplaceable(World worldIn, BlockPos pos) {
+        return false;
+    }
+
+}
Index: src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_pink_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_pink_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta.json	(date 1525306811000)
+++ src/main/resources/assets/neutronia/models/item/frosted_magenta_terracotta.json	(date 1525306811000)
@@ -0,0 +1,7 @@
+{
+  "_comment": "Generated using Husky's JSON Generator v2.",
+  "parent": "block/cube_all",
+  "textures": {
+    "all": "neutronia:blocks/frosted_magenta_terracotta"
+  }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelCod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelCod.java	(date 1523986196000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelCod.java	(date 1523986196000)
@@ -0,0 +1,91 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.entity.Entity;
+
+public class ModelCod extends ModelBase {
+
+    public ModelRenderer head0;
+    public ModelRenderer head1;
+    public ModelRenderer leftFin;
+    public ModelRenderer rightFin;
+    public ModelRenderer tailFin;
+    public ModelRenderer waist;
+    public ModelRenderer body0;
+    public ModelRenderer body1;
+
+    public ModelCod() {
+        this.textureWidth = 32;
+        this.textureHeight = 32;
+        this.leftFin = new ModelRenderer(this, 24, 4);
+        this.leftFin.setRotationPoint(0.0F, 3.0F, -3.0F);
+        this.leftFin.addBox(1.0F, 0.0F, 0.0F, 2, 1, 2, 0.0F);
+        this.setRotateAngle(leftFin, -0.045553093477052F, 0.0F, 0.0F);
+        this.body0 = new ModelRenderer(this, 0, 0);
+        this.body0.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.body0.addBox(-1.0F, 0.0F, -1.0F, 2, 4, 7, 0.0F);
+        this.head1 = new ModelRenderer(this, 11, 0);
+        this.head1.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.head1.addBox(-1.0F, 0.0F, -4.0F, 2, 4, 3, 0.0F);
+        this.head0 = new ModelRenderer(this, 0, 0);
+        this.head0.setRotationPoint(0.0F, -1.0F, 0.0F);
+        this.head0.addBox(-1.0F, 1.0F, -5.0F, 2, 3, 1, 0.0F);
+        this.tailFin = new ModelRenderer(this, 20, 1);
+        this.tailFin.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.tailFin.addBox(0.0F, 0.0F, 6.0F, 0, 4, 6, 0.0F);
+        this.waist = new ModelRenderer(this, 0, 0);
+        this.waist.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.waist.addBox(0.0F, 0.0F, 0.0F, 0, 0, 0, 0.0F);
+        this.body1 = new ModelRenderer(this, 20, -6);
+        this.body1.setRotationPoint(0.0F, -4.0F, 0.0F);
+        this.body1.addBox(-0.6F, 4.0F, -2.0F, 0, 0, 6, 0.5F);
+        this.rightFin = new ModelRenderer(this, 24, 1);
+        this.rightFin.setRotationPoint(0.0F, 3.0F, -3.0F);
+        this.rightFin.addBox(-3.0F, 0.0F, 0.0F, 2, 1, 2, 0.0F);
+    }
+
+    @Override
+    public void render(Entity entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
+        GlStateManager.pushMatrix();
+        GlStateManager.translate(this.leftFin.offsetX, this.leftFin.offsetY, this.leftFin.offsetZ);
+        GlStateManager.translate(this.leftFin.rotationPointX * scale, this.leftFin.rotationPointY * scale, this.leftFin.rotationPointZ * scale);
+        GlStateManager.scale(1.0D, 0.0D, 1.0D);
+        GlStateManager.translate(-this.leftFin.offsetX, -this.leftFin.offsetY, -this.leftFin.offsetZ);
+        GlStateManager.translate(-this.leftFin.rotationPointX * scale, -this.leftFin.rotationPointY * scale, -this.leftFin.rotationPointZ * scale);
+        this.leftFin.render(scale);
+        GlStateManager.popMatrix();
+        this.body0.render(scale);
+        this.head1.render(scale);
+        this.head0.render(scale);
+        this.tailFin.render(scale);
+        this.waist.render(scale);
+        GlStateManager.pushMatrix();
+        GlStateManager.translate(this.body1.offsetX, this.body1.offsetY, this.body1.offsetZ);
+        GlStateManager.translate(this.body1.rotationPointX * scale, this.body1.rotationPointY * scale, this.body1.rotationPointZ * scale);
+        GlStateManager.scale(0.0D, 0.9D, 1.0D);
+        GlStateManager.translate(-this.body1.offsetX, -this.body1.offsetY, -this.body1.offsetZ);
+        GlStateManager.translate(-this.body1.rotationPointX * scale, -this.body1.rotationPointY * scale, -this.body1.rotationPointZ * scale);
+        this.body1.render(scale);
+        GlStateManager.popMatrix();
+        GlStateManager.pushMatrix();
+        GlStateManager.translate(this.rightFin.offsetX, this.rightFin.offsetY, this.rightFin.offsetZ);
+        GlStateManager.translate(this.rightFin.rotationPointX * scale, this.rightFin.rotationPointY * scale, this.rightFin.rotationPointZ * scale);
+        GlStateManager.scale(1.0D, 0.0D, 1.0D);
+        GlStateManager.translate(-this.rightFin.offsetX, -this.rightFin.offsetY, -this.rightFin.offsetZ);
+        GlStateManager.translate(-this.rightFin.rotationPointX * scale, -this.rightFin.rotationPointY * scale, -this.rightFin.rotationPointZ * scale);
+        this.rightFin.render(scale);
+        GlStateManager.popMatrix();
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/tileentity/TileEntityCraftingTable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/tileentity/TileEntityCraftingTable.java	(date 1525599325000)
+++ src/main/java/net/hdt/neutronia/tileentity/TileEntityCraftingTable.java	(date 1525599325000)
@@ -0,0 +1,41 @@
+package net.hdt.neutronia.tileentity;
+
+import net.minecraft.nbt.NBTBase;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraftforge.common.capabilities.Capability;
+import net.minecraftforge.items.CapabilityItemHandler;
+import net.minecraftforge.items.IItemHandler;
+import net.minecraftforge.items.ItemStackHandler;
+
+import javax.annotation.Nullable;
+
+public class TileEntityCraftingTable extends TileEntity {
+
+    public Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = CapabilityItemHandler.ITEM_HANDLER_CAPABILITY;
+    public ItemStackHandler INVENTORY = new ItemStackHandler(9);
+
+    @Override
+    public void readFromNBT(NBTTagCompound compound) {
+        ITEM_HANDLER_CAPABILITY.readNBT(INVENTORY, null, compound.getTag("inventory"));
+    }
+
+    @Override
+    public NBTTagCompound writeToNBT(NBTTagCompound compound) {
+        NBTBase INVENTORY = ITEM_HANDLER_CAPABILITY.writeNBT(this.INVENTORY, null);
+        compound.setTag("inventory", INVENTORY);
+        return compound;
+    }
+
+    @Override
+    public boolean hasCapability(Capability<?> capability, @Nullable EnumFacing facing) {
+        return capability == ITEM_HANDLER_CAPABILITY;
+    }
+
+    @Nullable
+    @Override
+    public <T> T getCapability(Capability<T> capability, @Nullable EnumFacing facing) {
+        return capability == ITEM_HANDLER_CAPABILITY ? (T) INVENTORY : null;
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredRedstoneLamp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredRedstoneLamp.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredRedstoneLamp.java	(date 1523987839000)
@@ -0,0 +1,86 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.blocks.base.BlockColoredAlt;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.gui.GuiScreen;
+import net.minecraft.client.renderer.color.IBlockColor;
+import net.minecraft.client.renderer.color.IItemColor;
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.text.TextFormatting;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.interf.IBlockColorProvider;
+import org.apache.commons.lang3.text.WordUtils;
+
+import javax.annotation.Nullable;
+import java.util.List;
+
+public class BlockColoredRedstoneLamp extends BlockColoredAlt implements IBlockColorProvider {
+
+    public final EnumDyeColor color;
+
+    public BlockColoredRedstoneLamp(EnumDyeColor color) {
+        super(Reference.MOD_ID, "colored_redstone_lamp", color);
+        this.color = color;
+    }
+
+    private static TextFormatting getFromColor(EnumDyeColor color) {
+        switch (color) {
+            case ORANGE:
+                return TextFormatting.GOLD;
+            case MAGENTA:
+                return TextFormatting.LIGHT_PURPLE;
+            case LIGHT_BLUE:
+                return TextFormatting.BLUE;
+            case YELLOW:
+                return TextFormatting.YELLOW;
+            case LIME:
+                return TextFormatting.GREEN;
+            case PINK:
+                return TextFormatting.LIGHT_PURPLE;
+            case GRAY:
+                return TextFormatting.DARK_GRAY;
+            case SILVER:
+                return TextFormatting.GRAY;
+            case CYAN:
+                return TextFormatting.DARK_AQUA;
+            case PURPLE:
+                return TextFormatting.DARK_PURPLE;
+            case BLUE:
+                return TextFormatting.DARK_BLUE;
+            case BROWN:
+                return TextFormatting.GOLD;
+            case GREEN:
+                return TextFormatting.DARK_GREEN;
+            case RED:
+                return TextFormatting.DARK_RED;
+            case BLACK:
+                return TextFormatting.BLACK;
+            default:
+                return TextFormatting.WHITE;
+        }
+    }
+
+    @Override
+    public void addInformation(ItemStack stack, @Nullable World player, List<String> tooltip, ITooltipFlag advanced) {
+        if (!GuiScreen.isShiftKeyDown()) {
+            tooltip.add("Hold " + TextFormatting.BOLD + getFromColor(color) + "SHIFT " + TextFormatting.GRAY + "for more information");
+        } else {
+            String colorName = color.getName().replace("_", " ");
+            colorName = WordUtils.capitalize(colorName);
+            tooltip.add("Color: " + TextFormatting.BOLD.toString() + getFromColor(color).toString() + colorName);
+        }
+    }
+
+    @Override
+    public IBlockColor getBlockColor() {
+        return (state, worldIn, pos, tintIndex) -> EnumDyeColor.values()[tintIndex].getColorValue();
+    }
+
+    @Override
+    public IItemColor getItemColor() {
+        return (stack, tintIndex) -> EnumDyeColor.values()[tintIndex].getColorValue();
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockChiseledEndStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockChiseledEndStoneBricks.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockChiseledEndStoneBricks.java	(date 1524853001000)
@@ -0,0 +1,82 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockChiseledEndStoneBricks extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockChiseledEndStoneBricks()
+    {
+        super("end_stone_bricks_chiseled", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/commands/TPDimensionCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/commands/TPDimensionCommand.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/commands/TPDimensionCommand.java	(date 1523987837000)
@@ -0,0 +1,62 @@
+package net.hdt.neutronia.commands;
+
+import com.google.common.collect.Lists;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.command.CommandBase;
+import net.minecraft.command.ICommandSender;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.TextComponentString;
+import net.minecraft.util.text.TextFormatting;
+
+import java.util.Collections;
+import java.util.List;
+
+public class TPDimensionCommand extends CommandBase {
+    private final List<String> aliases = Lists.newArrayList(Reference.MOD_ID, "TP", "tp", "tpdim", "tpdimension", "teleport");
+
+    @Override
+    public void execute(MinecraftServer server, ICommandSender sender, String[] args) {
+        if (args.length < 1) return;
+
+        String s = args[0];
+        int dimension;
+
+        try {
+            dimension = Integer.parseInt(s);
+        } catch (NumberFormatException e) {
+            sender.sendMessage(new TextComponentString(TextFormatting.RED + "Dimension not found"));
+            return;
+        }
+
+        if (sender instanceof EntityPlayer) {
+            TeleportUtil.teleportToDimension((EntityPlayer) sender, dimension, 0, 100, 0);
+        }
+    }
+
+    @Override
+    public String getName() {
+        return "tpdimension";
+    }
+
+    @Override
+    public String getUsage(ICommandSender sender) {
+        return "tpdimension <id>";
+    }
+
+    @Override
+    public List<String> getAliases() {
+        return aliases;
+    }
+
+    @Override
+    public boolean checkPermission(MinecraftServer server, ICommandSender sender) {
+        return true;
+    }
+
+    @Override
+    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos targetPos) {
+        return Collections.emptyList();
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockWorkbench.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockWorkbench.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockWorkbench.java	(date 1525606887000)
@@ -0,0 +1,90 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.client.container.ContainerWorkbench;
+import net.hdt.neutronia.tileentity.TileEntityCraftingTable;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.InventoryPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.inventory.Container;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.ITextComponent;
+import net.minecraft.util.text.TextComponentTranslation;
+import net.minecraft.world.IInteractionObject;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import javax.annotation.Nullable;
+
+public class BlockWorkbench extends BlockMod {
+
+    public BlockWorkbench() {
+        super(Material.WOOD, "minecraft", "crafting_table");
+        this.setCreativeTab(CreativeTabs.DECORATIONS);
+        setUnlocalizedName("workbench");
+    }
+
+    @Nullable
+    @Override
+    public TileEntity createTileEntity(World world, IBlockState state) {
+        return new TileEntityCraftingTable();
+    }
+
+    /**
+     * Called when the block is right clicked by a player.
+     */
+    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
+        if (worldIn.isRemote) {
+            return true;
+        } else {
+            playerIn.displayGui(new BlockWorkbench.InterfaceCraftingTable(worldIn, pos));
+            playerIn.addStat(StatList.CRAFTING_TABLE_INTERACTION);
+            return true;
+        }
+    }
+
+    public static class InterfaceCraftingTable implements IInteractionObject {
+        private final World world;
+        private final BlockPos position;
+
+        public InterfaceCraftingTable(World worldIn, BlockPos pos) {
+            this.world = worldIn;
+            this.position = pos;
+        }
+
+        /**
+         * Get the name of this object. For players this returns their username
+         */
+        public String getName() {
+            return "crafting_table";
+        }
+
+        /**
+         * Returns true if this thing is named
+         */
+        public boolean hasCustomName() {
+            return false;
+        }
+
+        /**
+         * Get the formatted ChatComponent that will be used for the sender's username in chat
+         */
+        public ITextComponent getDisplayName() {
+            return new TextComponentTranslation(Blocks.CRAFTING_TABLE.getUnlocalizedName() + ".name");
+        }
+
+        public Container createContainer(InventoryPlayer playerInventory, EntityPlayer playerIn) {
+            return new ContainerWorkbench(playerInventory, this.world, this.position);
+        }
+
+        public String getGuiID() {
+            return "minecraft:crafting_table";
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockTestBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockTestBase.java	(date 1524472351000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockTestBase.java	(date 1524472351000)
@@ -0,0 +1,11 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.Material;
+
+public class BlockTestBase extends BlockMod {
+
+    public BlockTestBase(String modid, String name, String textureName) {
+        super(Material.ROCK, modid, name, textureName);
+    }
+
+}
Index: src/main/resources/assets/neutronia/lang/colored_blocks.lang
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/lang/colored_blocks.lang	(date 1525413697000)
+++ src/main/resources/assets/neutronia/lang/colored_blocks.lang	(date 1525413697000)
@@ -0,0 +1,80 @@
+tile.frosted_white_terracotta.name=Frosted White Terracotta
+tile.frosted_white_terracotta_slab.name=Frosted White Terracotta Slab
+tile.frosted_white_terracotta_slab_double.name=Frosted White Terracotta Slab Double
+tile.frosted_white_terracotta_stairs.name=Frosted White Terracotta Stairs
+tile.white_colored_vase.name=White Colored Vase
+tile.frosted_orange_terracotta.name=Frosted Orange Terracotta
+tile.frosted_orange_terracotta_slab.name=Frosted Orange Terracotta Slab
+tile.frosted_orange_terracotta_slab_double.name=Frosted Orange Terracotta Slab Double
+tile.frosted_orange_terracotta_stairs.name=Frosted Orange Terracotta Stairs
+tile.orange_colored_vase.name=Orange Colored Vase
+tile.frosted_magenta_terracotta.name=Frosted Magenta Terracotta
+tile.frosted_magenta_terracotta_slab.name=Frosted Magenta Terracotta Slab
+tile.frosted_magenta_terracotta_slab_double.name=Frosted Magenta Terracotta Slab Double
+tile.frosted_magenta_terracotta_stairs.name=Frosted Magenta Terracotta Stairs
+tile.magenta_colored_vase.name=Magenta Colored Vase
+tile.frosted_light_blue_terracotta.name=Frosted Light Blue Terracotta
+tile.frosted_light_blue_terracotta_slab.name=Frosted Light Blue Terracotta Slab
+tile.frosted_light_blue_terracotta_slab_double.name=Frosted Light Blue Terracotta Slab Double
+tile.frosted_light_blue_terracotta_stairs.name=Frosted Light Blue Terracotta Stairs
+tile.light_blue_colored_vase.name=Light Blue Colored Vase
+tile.frosted_yellow_terracotta.name=Frosted Yellow Terracotta
+tile.frosted_yellow_terracotta_slab.name=Frosted Yellow Terracotta Slab
+tile.frosted_yellow_terracotta_slab_double.name=Frosted Yellow Terracotta Slab Double
+tile.frosted_yellow_terracotta_stairs.name=Frosted Yellow Terracotta Stairs
+tile.yellow_colored_vase.name=Yellow Colored Vase
+tile.frosted_lime_terracotta.name=Frosted Lime Terracotta
+tile.frosted_lime_terracotta_slab.name=Frosted Lime Terracotta Slab
+tile.frosted_lime_terracotta_slab_double.name=Frosted Lime Terracotta Slab Double
+tile.frosted_lime_terracotta_stairs.name=Frosted Lime Terracotta Stairs
+tile.lime_colored_vase.name=Lime Colored Vase
+tile.frosted_pink_terracotta.name=Frosted Pink Terracotta
+tile.frosted_pink_terracotta_slab.name=Frosted Pink Terracotta Slab
+tile.frosted_pink_terracotta_slab_double.name=Frosted Pink Terracotta Slab Double
+tile.frosted_pink_terracotta_stairs.name=Frosted Pink Terracotta Stairs
+tile.pink_colored_vase.name=Pink Colored Vase
+tile.frosted_gray_terracotta.name=Frosted Gray Terracotta
+tile.frosted_gray_terracotta_slab.name=Frosted Gray Terracotta Slab
+tile.frosted_gray_terracotta_slab_double.name=Frosted Gray Terracotta Slab Double
+tile.frosted_gray_terracotta_stairs.name=Frosted Gray Terracotta Stairs
+tile.gray_colored_vase.name=Gray Colored Vase
+tile.frosted_silver_terracotta.name=Frosted Silver Terracotta
+tile.frosted_silver_terracotta_slab.name=Frosted Silver Terracotta Slab
+tile.frosted_silver_terracotta_slab_double.name=Frosted Silver Terracotta Slab Double
+tile.frosted_silver_terracotta_stairs.name=Frosted Silver Terracotta Stairs
+tile.silver_colored_vase.name=Silver Colored Vase
+tile.frosted_cyan_terracotta.name=Frosted Cyan Terracotta
+tile.frosted_cyan_terracotta_slab.name=Frosted Cyan Terracotta Slab
+tile.frosted_cyan_terracotta_slab_double.name=Frosted Cyan Terracotta Slab Double
+tile.frosted_cyan_terracotta_stairs.name=Frosted Cyan Terracotta Stairs
+tile.cyan_colored_vase.name=Cyan Colored Vase
+tile.frosted_purple_terracotta.name=Frosted Purple Terracotta
+tile.frosted_purple_terracotta_slab.name=Frosted Purple Terracotta Slab
+tile.frosted_purple_terracotta_slab_double.name=Frosted Purple Terracotta Slab Double
+tile.frosted_purple_terracotta_stairs.name=Frosted Purple Terracotta Stairs
+tile.purple_colored_vase.name=Purple Colored Vase
+tile.frosted_blue_terracotta.name=Frosted Blue Terracotta
+tile.frosted_blue_terracotta_slab.name=Frosted Blue Terracotta Slab
+tile.frosted_blue_terracotta_slab_double.name=Frosted Blue Terracotta Slab Double
+tile.frosted_blue_terracotta_stairs.name=Frosted Blue Terracotta Stairs
+tile.blue_colored_vase.name=Blue Colored Vase
+tile.frosted_brown_terracotta.name=Frosted Brown Terracotta
+tile.frosted_brown_terracotta_slab.name=Frosted Brown Terracotta Slab
+tile.frosted_brown_terracotta_slab_double.name=Frosted Brown Terracotta Slab Double
+tile.frosted_brown_terracotta_stairs.name=Frosted Brown Terracotta Stairs
+tile.brown_colored_vase.name=Brown Colored Vase
+tile.frosted_green_terracotta.name=Frosted Green Terracotta
+tile.frosted_green_terracotta_slab.name=Frosted Green Terracotta Slab
+tile.frosted_green_terracotta_slab_double.name=Frosted Green Terracotta Slab Double
+tile.frosted_green_terracotta_stairs.name=Frosted Green Terracotta Stairs
+tile.green_colored_vase.name=Green Colored Vase
+tile.frosted_red_terracotta.name=Frosted Red Terracotta
+tile.frosted_red_terracotta_slab.name=Frosted Red Terracotta Slab
+tile.frosted_red_terracotta_slab_double.name=Frosted Red Terracotta Slab Double
+tile.frosted_red_terracotta_stairs.name=Frosted Red Terracotta Stairs
+tile.red_colored_vase.name=Red Colored Vase
+tile.frosted_black_terracotta.name=Frosted Black Terracotta
+tile.frosted_black_terracotta_slab.name=Frosted Black Terracotta Slab
+tile.frosted_black_terracotta_slab_double.name=Frosted Black Terracotta Slab Double
+tile.frosted_black_terracotta_stairs.name=Frosted Black Terracotta Stairs
+tile.black_colored_vase.name=Black Colored Vase
Index: src/main/java/net/hdt/neutronia/init/HMItems.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMItems.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/init/HMItems.java	(date 1525606878000)
@@ -0,0 +1,326 @@
+package net.hdt.neutronia.init;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.items.*;
+import net.hdt.neutronia.items.base.tools.*;
+import net.hdt.neutronia.properties.FishType;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemArmor;
+import net.minecraft.potion.PotionEffect;
+import net.minecraftforge.common.util.EnumHelper;
+import net.minecraftforge.event.RegistryEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+@Mod.EventBusSubscriber(modid = MOD_ID)
+public class HMItems {
+    public static final Item.ToolMaterial CAXE = EnumHelper.addToolMaterial("caxe", 3, 350, 7.0F, 4.0F, 12);
+    public static final Item.ToolMaterial CPICK = EnumHelper.addToolMaterial("cpick", 3, 350, 7.0F, 4.0F, 12);
+    public static final Item.ToolMaterial CHOE = EnumHelper.addToolMaterial("choe", 3, 325, 7.0F, 4.0F, 12);
+    public static final Item.ToolMaterial CSHOVEL = EnumHelper.addToolMaterial("cshovel", 3, 325, 7.0F, 4.0F, 12);
+    public static final Item.ToolMaterial CSWORD = EnumHelper.addToolMaterial("csword", 3, 325, 7.0F, 8.0F, 12);
+    public static final ItemArmor.ArmorMaterial TEST = EnumHelper.addArmorMaterial("test", "test", 100, new int[]{10, 10, 10, 10}, 10, SoundEvents.ITEM_ARMOR_EQUIP_LEATHER, 3F);
+
+    public static final Item ancientSword, bandage, witherBone, witherBonemeal, driedKelp, stinger, chitin, nautilusShell, heartOfTheSea, heartOfTheNether, heartOfTheEnd, scute;
+
+    public static final Item AXE_CHITIN;
+    public static final Item PICKAXE_CHITIN;
+    public static final Item HOE_CHITIN;
+    public static final Item SHOVEL_CHITIN;
+    public static final Item SWORD_CHITIN;
+
+    /*public static final ArmorTM helmet;
+    public static final ArmorTM chestplate;
+    public static final ArmorTM leggings;
+    public static final ArmorTM boots;*/
+
+    public static final Item easter_egg;
+
+    public static final ItemSpear woodSpear;
+    public static final ItemSpear stoneSpear;
+    public static final ItemSpear ironSpear;
+    public static final ItemSpear goldSpear;
+    public static final ItemSpear diamondSpear;
+
+    public static final ItemSpear trident;
+    public static final ItemSpear anchor;
+
+    // Items
+    public static Item hamsterFood;
+    public static Item truffle;
+    public static Item brownEgg;
+    public static Item carvingKnife;
+    public static Item cheeseMold;
+    public static Item hamsterBallClear;
+    public static Item hamsterBallColored;
+    public static Item peacockEggBlue;
+    public static Item peacockEggWhite;
+    public static Item salt;
+    public static Item peacockFeatherBlue;
+    public static Item peacockFeatherWhite;
+    public static Item peacockFeatherCharcoal;
+    public static Item peacockFeatherOpal;
+    public static Item peacockFeatherPeach;
+    public static Item peacockFeatherPurple;
+    public static Item peacockFeatherTaupe;
+    public static Item ridingCrop;
+    public static Item wheel;
+    public static Item milkBottle;
+
+    // Beef
+    public static Item rawHerefordBeef;
+    public static Item rawLonghornBeef;
+    public static Item rawAngusBeef;
+    public static Item rawHerefordSteak;
+    public static Item rawLonghornSteak;
+    public static Item rawAngusSteak;
+    public static Item cookedHerefordRoast;
+    public static Item cookedLonghornRoast;
+    public static Item cookedAngusRoast;
+    public static Item cookedHerefordSteak;
+    public static Item cookedLonghornSteak;
+    public static Item cookedAngusSteak;
+
+    public static Item rawPrimeSteak;
+    public static Item rawPrimeBeef;
+    public static Item cookedPrimeSteak;
+    public static Item cookedPrimeBeef;
+
+    // Horse
+    public static Item rawHorse;
+    public static Item cookedHorse;
+
+    // Pork
+    public static Item rawLargeBlackPork;
+    public static Item rawDurocPork;
+    public static Item rawOldSpotPork;
+    public static Item rawHampshirePork;
+    public static Item rawLargeBlackBacon;
+    public static Item rawDurocBacon;
+    public static Item rawOldSpotBacon;
+    public static Item rawHampshireBacon;
+    public static Item cookedLargeBlackRoast;
+    public static Item cookedDurocRoast;
+    public static Item cookedOldSpotRoast;
+    public static Item cookedHampshireRoast;
+    public static Item cookedLargeBlackBacon;
+    public static Item cookedDurocBacon;
+    public static Item cookedOldSpotBacon;
+    public static Item cookedHampshireBacon;
+
+    public static Item rawPrimePork;
+    public static Item rawPrimeBacon;
+    public static Item cookedPrimePork;
+    public static Item cookedPrimeBacon;
+
+    // Chicken
+    public static Item rawOrpingtonChicken;
+    public static Item rawPlymouthRockChicken;
+    public static Item rawWyandotteChicken;
+    public static Item rawRhodeIslandRedChicken;
+    public static Item cookedOrpingtonChicken;
+    public static Item cookedPlymouthRockChicken;
+    public static Item cookedWyandotteChicken;
+    public static Item cookedRhodeIslandRedChicken;
+
+    public static Item rawPrimeChicken;
+    public static Item cookedPrimeChicken;
+
+    // Frogs
+    public static Item rawFrogLegs;
+    public static Item cookedFrogLegs;
+
+    // Goats
+    public static Item rawChevon;
+    public static Item cookedChevon;
+    public static Item rawPrimeChevon;
+    public static Item cookedPrimeChevon;
+
+    // Sheep
+    public static Item rawMutton;
+    public static Item cookedMutton;
+
+    // Rabbit
+    public static Item rawRabbit;
+    public static Item cookedRabbit;
+
+    // Other Foods
+    public static Item plainOmelette;
+    public static Item cheeseOmelette;
+    public static Item baconOmelette;
+    public static Item truffleOmelette;
+    public static Item ultimateOmelette;
+    public static Item cheeseWheelFriesian;
+    public static Item cheeseWedgeFriesian;
+    public static Item cheeseWheelHolstein;
+    public static Item cheeseWedgeHolstein;
+    public static Item cheeseWheelJersey;
+    public static Item cheeseWedgeJersey;
+    public static Item cheeseWheelGoat;
+    public static Item cheeseWedgeGoat;
+    public static Item cheeseWheelSheep;
+    public static Item cheeseWedgeSheep;
+    public static Item truffleSoup;
+    public static Item chocolateTruffle;
+
+    public static Item newFishesRaw, newFishesCooked;
+
+    static {
+        ancientSword = new ItemAncientSword();
+        bandage = new ItemBandage();
+        witherBone = new ItemBase("wither_bone", Main.ITEM_EXPANSION_TAB);
+        witherBonemeal = new ItemBase("wither_bonemeal", Main.ITEM_EXPANSION_TAB);
+        driedKelp = new ItemFood("dried_kelp", Main.ITEM_EXPANSION_TAB, 1, false);
+        stinger = new ItemBase("stinger", Main.ITEM_EXPANSION_TAB);
+        chitin = new ItemBase("chitin", Main.ITEM_EXPANSION_TAB);
+        nautilusShell = new ItemBase("nautilus_shell", Main.ITEM_EXPANSION_TAB);
+        heartOfTheSea = new ItemBase("heart_of_the_sea", Main.ITEM_EXPANSION_TAB);
+        heartOfTheNether = new ItemBase("heart_of_the_nether", Main.ITEM_EXPANSION_TAB);
+        heartOfTheEnd = new ItemBase("heart_of_the_end", Main.ITEM_EXPANSION_TAB);
+        scute = new ItemBase("scute", Main.ITEM_EXPANSION_TAB);
+
+        AXE_CHITIN = new BaseAxe("axe_chitin", CAXE);
+        PICKAXE_CHITIN = new BasePickaxe("pickaxe_chitin", CPICK);
+        HOE_CHITIN = new BaseHoe("hoe_chitin", CHOE);
+        SHOVEL_CHITIN = new BaseShovel("shovel_chitin", CSHOVEL);
+        SWORD_CHITIN = new BaseSword("sword_chitin", CSWORD);
+        /*helmet = new ArmorTM("test_helmet", TEST, 0, EntityEquipmentSlot.HEAD);
+        chestplate = new ArmorTM("test_chestplate", TEST, 0, EntityEquipmentSlot.CHEST);
+        leggings = new ArmorTM("test_leggings", TEST, 0, EntityEquipmentSlot.LEGS);
+        boots = new ArmorTM("test_boots", TEST, 0, EntityEquipmentSlot.FEET);*/
+        easter_egg = new ItemEasterEgg();
+
+        woodSpear = new ItemSpear("wood_spear", Item.ToolMaterial.WOOD);
+        stoneSpear = new ItemSpear("stone_spear", Item.ToolMaterial.STONE);
+        ironSpear = new ItemSpear("iron_spear", Item.ToolMaterial.IRON);
+        goldSpear = new ItemSpear("gold_spear", Item.ToolMaterial.GOLD);
+        diamondSpear = new ItemSpear("diamond_spear", Item.ToolMaterial.DIAMOND);
+        trident = new ItemSpear("trident", Item.ToolMaterial.DIAMOND);
+        anchor = new ItemSpear("anchor", Item.ToolMaterial.IRON);
+
+        for (FishType fishType : FishType.values()) {
+            newFishesRaw = new ItemFishFood("raw_", Main.FOOD_EXPANSION_TAB, fishType, false);
+            newFishesCooked = new ItemFishFood("cooked_", Main.FOOD_EXPANSION_TAB, fishType, true);
+        }
+
+        // Items for Animals
+        hamsterFood = new AnimaniaItem("hamster_food");
+        truffle = new AnimaniaItem("truffle");
+        salt = new AnimaniaItem("salt");
+        peacockFeatherBlue = new AnimaniaItem("blue_peacock_feather");
+        peacockFeatherWhite = new AnimaniaItem("white_peacock_feather");
+        peacockFeatherCharcoal = new AnimaniaItem("charcoal_peacock_feather");
+        peacockFeatherOpal = new AnimaniaItem("opal_peacock_feather");
+        peacockFeatherPeach = new AnimaniaItem("peach_peacock_feather");
+        peacockFeatherPurple = new AnimaniaItem("purple_peacock_feather");
+        peacockFeatherTaupe = new AnimaniaItem("taupe_peacock_feather");
+
+        // Other foods
+        ultimateOmelette = new ItemAnimaniaFood(5, 2f, "super_omelette", new PotionEffect(MobEffects.REGENERATION, 600, 1, false, false), new PotionEffect(MobEffects.STRENGTH, 600, 0, false, false), new PotionEffect(MobEffects.RESISTANCE, 600, 1, false, false));
+        truffleOmelette = new ItemAnimaniaFood(5, 2f, "truffle_omelette", new PotionEffect(MobEffects.REGENERATION, 600, 1, false, false));
+        baconOmelette = new ItemAnimaniaFood(5, 2f, "bacon_omelette", new PotionEffect(MobEffects.STRENGTH, 600, 0, false, false));
+        cheeseOmelette = new ItemAnimaniaFood(5, 2f, "cheese_omelette", new PotionEffect(MobEffects.INSTANT_HEALTH, 2, 2, false, false));
+        plainOmelette = new ItemAnimaniaFood(5, 2f, "plain_omelette");
+        chocolateTruffle = new ItemAnimaniaFood(6, 2f, "chocolate_truffle", new PotionEffect(MobEffects.SPEED, 1200, 3, false, false));
+
+        // ITEMS produced by Animals
+        // COW ITEMS
+        rawHerefordBeef = new ItemAnimaniaFoodRaw("raw_hereford_beef");
+        rawLonghornBeef = new ItemAnimaniaFoodRaw("raw_longhorn_beef");
+        rawAngusBeef = new ItemAnimaniaFoodRaw("raw_angus_beef");
+
+        rawLonghornSteak = new ItemAnimaniaFoodRaw("raw_longhorn_steak");
+        rawHerefordSteak = new ItemAnimaniaFoodRaw("raw_hereford_steak");
+        rawAngusSteak = new ItemAnimaniaFoodRaw("raw_angus_steak");
+
+        cookedLonghornRoast = new ItemAnimaniaFood(10, 1f, "cooked_longhorn_roast", new PotionEffect(MobEffects.INSTANT_HEALTH, 6, 1, false, false));
+        cookedHerefordRoast = new ItemAnimaniaFood(12, 1f, "cooked_hereford_roast", new PotionEffect(MobEffects.INSTANT_HEALTH, 4, 1, false, false));
+        cookedAngusRoast = new ItemAnimaniaFood(20, 1f, "cooked_angus_roast", new PotionEffect(MobEffects.INSTANT_HEALTH, 10, 1, false, false));
+
+        cookedLonghornSteak = new ItemAnimaniaFood(5, 1f, "cooked_longhorn_steak", new PotionEffect(MobEffects.INSTANT_HEALTH, 3, 1, false, false));
+        cookedHerefordSteak = new ItemAnimaniaFood(6, 1f, "cooked_hereford_steak", new PotionEffect(MobEffects.INSTANT_HEALTH, 2, 1, false, false));
+        cookedAngusSteak = new ItemAnimaniaFood(10, 1f, "cooked_angus_steak", new PotionEffect(MobEffects.INSTANT_HEALTH, 5, 1, false, false));
+
+        rawPrimeBeef = new ItemAnimaniaFoodRaw("raw_prime_beef");
+        cookedPrimeBeef = new ItemAnimaniaFood(20, 1f, "cooked_prime_beef", new PotionEffect(MobEffects.INSTANT_HEALTH, 10, 1, false, false));
+        rawPrimeSteak = new ItemAnimaniaFoodRaw("raw_prime_steak");
+        cookedPrimeSteak = new ItemAnimaniaFood(10, 1f, "cooked_prime_steak", new PotionEffect(MobEffects.INSTANT_HEALTH, 5, 1, false, false));
+
+        // PIG ITEMS
+        rawLargeBlackPork = new ItemAnimaniaFoodRaw("raw_large_black_pork");
+        rawDurocPork = new ItemAnimaniaFoodRaw("raw_duroc_pork");
+        rawOldSpotPork = new ItemAnimaniaFoodRaw("raw_old_spot_pork");
+        rawHampshirePork = new ItemAnimaniaFoodRaw("raw_hampshire_pork");
+        cookedLargeBlackRoast = new ItemAnimaniaFood(16, 1f, "cooked_large_black_roast", new PotionEffect(MobEffects.ABSORPTION, 1800, 2, false, false));
+        cookedDurocRoast = new ItemAnimaniaFood(12, 1f, "cooked_duroc_roast", new PotionEffect(MobEffects.ABSORPTION, 1800, 1, false, false));
+        cookedOldSpotRoast = new ItemAnimaniaFood(10, 1f, "cooked_old_spot_roast", new PotionEffect(MobEffects.ABSORPTION, 1800, 1, false, false));
+        cookedHampshireRoast = new ItemAnimaniaFood(8, 1f, "cooked_hampshire_roast", new PotionEffect(MobEffects.ABSORPTION, 1800, 1, false, false));
+        cookedLargeBlackBacon = new ItemAnimaniaFood(8, 1f, "cooked_large_black_bacon", new PotionEffect(MobEffects.ABSORPTION, 1200, 2, false, false));
+        cookedDurocBacon = new ItemAnimaniaFood(6, 1f, "cooked_duroc_bacon", new PotionEffect(MobEffects.ABSORPTION, 1200, 0, false, false));
+        cookedOldSpotBacon = new ItemAnimaniaFood(5, 1f, "cooked_old_spot_bacon", new PotionEffect(MobEffects.ABSORPTION, 1200, 0, false, false));
+        cookedHampshireBacon = new ItemAnimaniaFood(4, 1f, "cooked_hampshire_bacon", new PotionEffect(MobEffects.ABSORPTION, 1200, 0, false, false));
+        rawPrimePork = new ItemAnimaniaFoodRaw("raw_prime_pork");
+        cookedPrimePork = new ItemAnimaniaFood(12, 1f, "cooked_prime_pork", new PotionEffect(MobEffects.ABSORPTION, 3000, 0, false, false));
+
+        rawPrimeBacon = new ItemAnimaniaFoodRaw("raw_prime_bacon");
+        cookedPrimeBacon = new ItemAnimaniaFood(12, 1f, "cooked_prime_bacon", new PotionEffect(MobEffects.ABSORPTION, 1800, 0, false, false));
+
+        // CHICKEN ITEMS
+        rawOrpingtonChicken = new ItemAnimaniaFoodRaw("raw_orpington_chicken");
+        rawPlymouthRockChicken = new ItemAnimaniaFoodRaw("raw_plymouth_rock_chicken");
+        rawWyandotteChicken = new ItemAnimaniaFoodRaw("raw_wyandotte_chicken");
+        rawRhodeIslandRedChicken = new ItemAnimaniaFoodRaw("raw_rhode_island_red_chicken");
+        cookedOrpingtonChicken = new ItemAnimaniaFood(12, 1f, "cooked_orpington_chicken", new PotionEffect(MobEffects.HASTE, 3000, 0, false, false));
+        cookedPlymouthRockChicken = new ItemAnimaniaFood(10, 1f, "cooked_plymouth_rock_chicken", new PotionEffect(MobEffects.HASTE, 2400, 0, false, false));
+        cookedWyandotteChicken = new ItemAnimaniaFood(6, 1f, "cooked_wyandotte_chicken", new PotionEffect(MobEffects.HASTE, 1800, 0, false, false));
+        cookedRhodeIslandRedChicken = new ItemAnimaniaFood(8, 1f, "cooked_rhode_island_red_chicken", new PotionEffect(MobEffects.HASTE, 1200, 0, false, false));
+        rawPrimeChicken = new ItemAnimaniaFoodRaw("raw_prime_chicken");
+        cookedPrimeChicken = new ItemAnimaniaFood(12, 1f, "cooked_prime_chicken", new PotionEffect(MobEffects.HASTE, 3000, 0, false, false));
+        peacockEggBlue = new AnimaniaItem("peacock_egg_blue").setMaxStackSize(16);
+        peacockEggWhite = new AnimaniaItem("peacock_egg_white").setMaxStackSize(16);
+        rawLargeBlackBacon = new ItemAnimaniaFoodRaw("raw_large_black_bacon");
+        rawDurocBacon = new ItemAnimaniaFoodRaw("raw_duroc_bacon");
+        rawOldSpotBacon = new ItemAnimaniaFoodRaw("raw_old_spot_bacon");
+        rawHampshireBacon = new ItemAnimaniaFoodRaw("raw_hampshire_bacon");
+
+        // SHEEP ITEMS
+        rawMutton = new ItemAnimaniaFoodRaw("raw_prime_mutton");
+        cookedMutton = new ItemAnimaniaFood(3, 1f, "cooked_prime_mutton", new PotionEffect(MobEffects.INSTANT_HEALTH, 5, 1, false, false));
+
+
+        // RABBIT ITEMS
+        rawRabbit = new ItemAnimaniaFoodRaw("raw_prime_rabbit");
+        cookedRabbit = new ItemAnimaniaFood(4, 1f, "cooked_prime_rabbit", new PotionEffect(MobEffects.JUMP_BOOST, 600, 3, false, false));
+
+        // FROG ITEMS
+        rawFrogLegs = new ItemAnimaniaFoodRaw("raw_frog_legs");
+        cookedFrogLegs = new ItemAnimaniaFood(3, 1f, "cooked_frog_legs", new PotionEffect(MobEffects.JUMP_BOOST, 1200, 2, false, false));
+
+        // HORSE ITEMS
+        rawHorse = new ItemAnimaniaFoodRaw("raw_horse");
+        cookedHorse = new ItemAnimaniaFood(20, 1f, "cooked_horse", new PotionEffect(MobEffects.STRENGTH, 600, 0, false, false));
+
+        // GOAT ITEMS
+        rawChevon = new ItemAnimaniaFoodRaw("raw_chevon");
+        cookedChevon = new ItemAnimaniaFood(3, 1f, "cooked_chevon", new PotionEffect(MobEffects.RESISTANCE, 600, 0, false, false));
+        rawPrimeChevon = new ItemAnimaniaFoodRaw("raw_prime_chevon");
+        cookedPrimeChevon = new ItemAnimaniaFood(3, 1f, "cooked_prime_chevon", new PotionEffect(MobEffects.RESISTANCE, 1200, 1, false, false));
+
+        // CHEESE
+        cheeseWedgeFriesian = new ItemAnimaniaFood(2, 2f, "friesian_cheese_wedge", new PotionEffect(MobEffects.INSTANT_HEALTH, 6, 2, false, false));
+        cheeseWedgeHolstein = new ItemAnimaniaFood(2, 2f, "holstein_cheese_wedge", new PotionEffect(MobEffects.INSTANT_HEALTH, 12, 2, false, false));
+        cheeseWedgeJersey = new ItemAnimaniaFood(2, 2f, "jersey_cheese_wedge", new PotionEffect(MobEffects.INSTANT_HEALTH, 10, 2, false, false));
+        cheeseWedgeGoat = new ItemAnimaniaFood(2, 2f, "goat_cheese_wedge", new PotionEffect(MobEffects.RESISTANCE, 1200, 0, false, false));
+        cheeseWedgeSheep = new ItemAnimaniaFood(2, 2f, "sheep_cheese_wedge", new PotionEffect(MobEffects.INSTANT_HEALTH, 10, 0, false, false));
+    }
+
+    @SubscribeEvent
+    public static void registerItems(RegistryEvent.Register<Item> event) {
+
+    }
+
+}
Index: src/main/resources/assets/neutronia/lang/stones.lang
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/lang/stones.lang	(date 1525413697000)
+++ src/main/resources/assets/neutronia/lang/stones.lang	(date 1525413697000)
@@ -0,0 +1,120 @@
+tile.granite_bricks.name=Granite Bricks
+tile.granite_bricks_slab.name=Granite Bricks Slab
+tile.granite_bricks_slab_double.name=Granite Bricks Slab Double
+tile.granite_bricks_stairs.name=Granite Bricks Stairs
+tile.granite_cobble.name=Granite Cobble
+tile.granite_cobble_slab.name=Granite Cobble Slab
+tile.granite_cobble_slab_double.name=Granite Cobble Slab Double
+tile.granite_cobble_stairs.name=Granite Cobble Stairs
+tile.diorite_bricks.name=Diorite Bricks
+tile.diorite_bricks_slab.name=Diorite Bricks Slab
+tile.diorite_bricks_slab_double.name=Diorite Bricks Slab Double
+tile.diorite_bricks_stairs.name=Diorite Bricks Stairs
+tile.diorite_cobble.name=Diorite Cobble
+tile.diorite_cobble_slab.name=Diorite Cobble Slab
+tile.diorite_cobble_slab_double.name=Diorite Cobble Slab Double
+tile.diorite_cobble_stairs.name=Diorite Cobble Stairs
+tile.andesite_bricks.name=Andesite Bricks
+tile.andesite_bricks_slab.name=Andesite Bricks Slab
+tile.andesite_bricks_slab_double.name=Andesite Bricks Slab Double
+tile.andesite_bricks_stairs.name=Andesite Bricks Stairs
+tile.andesite_cobble.name=Andesite Cobble
+tile.andesite_cobble_slab.name=Andesite Cobble Slab
+tile.andesite_cobble_slab_double.name=Andesite Cobble Slab Double
+tile.andesite_cobble_stairs.name=Andesite Cobble Stairs
+tile.raw_basalt.name=Raw Basalt
+tile.raw_basalt_slab.name=Raw Basalt Slab
+tile.raw_basalt_slab_double.name=Raw Basalt Slab Double
+tile.raw_basalt_stairs.name=Raw Basalt Stairs
+tile.smooth_basalt.name=Smooth Basalt
+tile.smooth_basalt_slab.name=Smooth Basalt Slab
+tile.smooth_basalt_slab_double.name=Smooth Basalt Slab Double
+tile.smooth_basalt_stairs.name=Smooth Basalt Stairs
+tile.chiseled_basalt.name=Chiseled Basalt
+tile.chiseled_basalt_slab.name=Chiseled Basalt Slab
+tile.chiseled_basalt_slab_double.name=Chiseled Basalt Slab Double
+tile.chiseled_basalt_stairs.name=Chiseled Basalt Stairs
+tile.basalt_bricks.name=Basalt Bricks
+tile.basalt_bricks_slab.name=Basalt Bricks Slab
+tile.basalt_bricks_slab_double.name=Basalt Bricks Slab Double
+tile.basalt_bricks_stairs.name=Basalt Bricks Stairs
+tile.basalt_cobble.name=Basalt Cobble
+tile.basalt_cobble_slab.name=Basalt Cobble Slab
+tile.basalt_cobble_slab_double.name=Basalt Cobble Slab Double
+tile.basalt_cobble_stairs.name=Basalt Cobble Stairs
+tile.cracked_basalt_bricks.name=Cracked Basalt Bricks
+tile.cracked_basalt_bricks_slab.name=Cracked Basalt Bricks Slab
+tile.cracked_basalt_bricks_slab_double.name=Cracked Basalt Bricks Slab Double
+tile.cracked_basalt_bricks_stairs.name=Cracked Basalt Bricks Stairs
+tile.small_basalt_bricks.name=Small Basalt Bricks
+tile.small_basalt_bricks_slab.name=Small Basalt Bricks Slab
+tile.small_basalt_bricks_slab_double.name=Small Basalt Bricks Slab Double
+tile.small_basalt_bricks_stairs.name=Small Basalt Bricks Stairs
+tile.raw_marble.name=Raw Marble
+tile.raw_marble_slab.name=Raw Marble Slab
+tile.raw_marble_slab_double.name=Raw Marble Slab Double
+tile.raw_marble_stairs.name=Raw Marble Stairs
+tile.smooth_marble.name=Smooth Marble
+tile.smooth_marble_slab.name=Smooth Marble Slab
+tile.smooth_marble_slab_double.name=Smooth Marble Slab Double
+tile.smooth_marble_stairs.name=Smooth Marble Stairs
+tile.chiseled_marble.name=Chiseled Marble
+tile.chiseled_marble_slab.name=Chiseled Marble Slab
+tile.chiseled_marble_slab_double.name=Chiseled Marble Slab Double
+tile.chiseled_marble_stairs.name=Chiseled Marble Stairs
+tile.marble_bricks.name=Marble Bricks
+tile.marble_bricks_slab.name=Marble Bricks Slab
+tile.marble_bricks_slab_double.name=Marble Bricks Slab Double
+tile.marble_bricks_stairs.name=Marble Bricks Stairs
+tile.marble_cobble.name=Marble Cobble
+tile.marble_cobble_slab.name=Marble Cobble Slab
+tile.marble_cobble_slab_double.name=Marble Cobble Slab Double
+tile.marble_cobble_stairs.name=Marble Cobble Stairs
+tile.cracked_marble_bricks.name=Cracked Marble Bricks
+tile.cracked_marble_bricks_slab.name=Cracked Marble Bricks Slab
+tile.cracked_marble_bricks_slab_double.name=Cracked Marble Bricks Slab Double
+tile.cracked_marble_bricks_stairs.name=Cracked Marble Bricks Stairs
+tile.small_marble_bricks.name=Small Marble Bricks
+tile.small_marble_bricks_slab.name=Small Marble Bricks Slab
+tile.small_marble_bricks_slab_double.name=Small Marble Bricks Slab Double
+tile.small_marble_bricks_stairs.name=Small Marble Bricks Stairs
+tile.raw_limestone.name=Raw Limestone
+tile.raw_limestone_slab.name=Raw Limestone Slab
+tile.raw_limestone_slab_double.name=Raw Limestone Slab Double
+tile.raw_limestone_stairs.name=Raw Limestone Stairs
+tile.smooth_limestone.name=Smooth Limestone
+tile.smooth_limestone_slab.name=Smooth Limestone Slab
+tile.smooth_limestone_slab_double.name=Smooth Limestone Slab Double
+tile.smooth_limestone_stairs.name=Smooth Limestone Stairs
+tile.chiseled_limestone.name=Chiseled Limestone
+tile.chiseled_limestone_slab.name=Chiseled Limestone Slab
+tile.chiseled_limestone_slab_double.name=Chiseled Limestone Slab Double
+tile.chiseled_limestone_stairs.name=Chiseled Limestone Stairs
+tile.limestone_bricks.name=Limestone Bricks
+tile.limestone_bricks_slab.name=Limestone Bricks Slab
+tile.limestone_bricks_slab_double.name=Limestone Bricks Slab Double
+tile.limestone_bricks_stairs.name=Limestone Bricks Stairs
+tile.limestone_cobble.name=Limestone Cobble
+tile.limestone_cobble_slab.name=Limestone Cobble Slab
+tile.limestone_cobble_slab_double.name=Limestone Cobble Slab Double
+tile.limestone_cobble_stairs.name=Limestone Cobble Stairs
+tile.cracked_limestone_bricks.name=Cracked Limestone Bricks
+tile.cracked_limestone_bricks_slab.name=Cracked Limestone Bricks Slab
+tile.cracked_limestone_bricks_slab_double.name=Cracked Limestone Bricks Slab Double
+tile.cracked_limestone_bricks_stairs.name=Cracked Limestone Bricks Stairs
+tile.small_limestone_bricks.name=Small Limestone Bricks
+tile.small_limestone_bricks_slab.name=Small Limestone Bricks Slab
+tile.small_limestone_bricks_slab_double.name=Small Limestone Bricks Slab Double
+tile.small_limestone_bricks_stairs.name=Small Limestone Bricks Stairs
+tile.raw_meteorite.name=Raw Meteorite
+tile.raw_meteorite_slab.name=Raw Meteorite Slab
+tile.raw_meteorite_slab_double.name=Raw Meteorite Slab Double
+tile.raw_meteorite_stairs.name=Raw Meteorite Stairs
+tile.meteorite_bricks.name=Meteorite Bricks
+tile.meteorite_bricks_slab.name=Meteorite Bricks Slab
+tile.meteorite_bricks_slab_double.name=Meteorite Bricks Slab Double
+tile.meteorite_bricks_stairs.name=Meteorite Bricks Stairs
+tile.smooth_meteorite.name=Smooth Meteorite
+tile.smooth_meteorite_slab.name=Smooth Meteorite Slab
+tile.smooth_meteorite_slab_double.name=Smooth Meteorite Slab Double
+tile.smooth_meteorite_stairs.name=Smooth Meteorite Stairs
Index: src/main/java/net/hdt/neutronia/entity/EntityUndeadBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityUndeadBase.java	(date 1523986177000)
+++ src/main/java/net/hdt/neutronia/entity/EntityUndeadBase.java	(date 1523986177000)
@@ -0,0 +1,40 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EnumCreatureAttribute;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+
+public class EntityUndeadBase extends EntityMob {
+
+    public EntityUndeadBase(World world) {
+        super(world);
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityAISwimming(this));
+        this.tasks.addTask(2, new EntityAIMoveTowardsRestriction(this, 1.0D));
+        this.tasks.addTask(2, new EntityAIWander(this, 1.0D));
+        this.tasks.addTask(3, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
+        this.tasks.addTask(3, new EntityAILookIdle(this));
+        this.targetTasks.addTask(1, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.UNDEAD;
+    }
+
+    @Override
+    public boolean getCanSpawnHere() {
+        int i = MathHelper.floor(this.getEntityBoundingBox().minY);
+        if (i <= 62) {
+            return false;
+        } else {
+            return super.getCanSpawnHere();
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/idk/StringParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/StringParser.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/util/idk/StringParser.java	(date 1525606896000)
@@ -0,0 +1,118 @@
+package net.hdt.neutronia.util.idk;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.JsonToNBT;
+import net.minecraft.nbt.NBTException;
+import net.minecraft.nbt.NBTTagCompound;
+
+import javax.annotation.Nullable;
+
+
+public class StringParser {
+
+    @Nullable
+    public static Block getBlock(String string) {
+        NBTTagCompound tag = getTagCompound(string);
+        if (tag != null)
+            string = string.replace(tag.toString(), "");
+
+        if (string.contains("#"))
+            string = string.replace(string.substring(string.indexOf("#")), "");
+
+        Block block = Block.getBlockFromName(string);
+        if (block == null)
+            new InvalidConfigException("Block Parsing Error. Invalid Name: " + string).printException();
+
+        return block;
+    }
+
+    public static int getMeta(String string) {
+        NBTTagCompound tag = getTagCompound(string);
+        if (tag != null)
+            string = string.replace(tag.toString(), "");
+
+        if (string.contains("#")) {
+            int meta = 0;
+            try {
+                meta = Integer.parseInt(string.substring(string.indexOf("#")).replace("#", ""));
+            } catch (Exception e) {
+                new InvalidConfigException("Meta Parsing Error at: " + string + " : " + e.getMessage()).printException();
+            }
+
+            return meta;
+        }
+        return 0;
+    }
+
+    @Nullable
+    public static IBlockState getBlockState(String string) {
+        NBTTagCompound tag = getTagCompound(string);
+        if (tag != null)
+            string = string.replace(tag.toString(), "");
+
+        int meta = getMeta(string);
+        if (meta == 0) {
+            Block block = getBlock(string);
+            if (block != null)
+                return block.getDefaultState();
+        }
+        try {
+            return getBlock(string).getStateFromMeta(meta);
+        } catch (Exception e) {
+            new InvalidConfigException("Blockstate parsing Exception at: " + string + " : " + e.getMessage()).printException();
+            return null;
+        }
+    }
+
+    @Nullable
+    public static Item getItem(String string) {
+        NBTTagCompound tag = getTagCompound(string);
+        if (tag != null)
+            string = string.replace(tag.toString(), "");
+
+        if (string.contains("#"))
+            string = string.replace(string.substring(string.indexOf("#")), "");
+
+        return Item.getByNameOrId(string);
+    }
+
+    public static ItemStack getItemStack(String string) {
+        Item item = getItem(string);
+
+        if (item == null)
+            return ItemStack.EMPTY;
+
+        ItemStack stack = new ItemStack(item, 1, getMeta(string));
+        NBTTagCompound tag = getTagCompound(string);
+        if (tag != null)
+            stack.setTagCompound(tag);
+
+        return stack;
+    }
+
+    @Nullable
+    public static NBTTagCompound getTagCompound(String string) {
+        NBTTagCompound tag = null;
+        if (string.contains("{")) {
+            if (!string.contains("}"))
+                new InvalidConfigException("Missing } at  : " + string).printException();
+
+            String nbt = string.substring(string.indexOf("{"));
+            string = string.replace(nbt, "");
+            try {
+                tag = JsonToNBT.getTagFromJson(nbt);
+            } catch (NBTException e) {
+                new InvalidConfigException("Error while parsing NBT: " + e.getMessage()).printException();
+                return null;
+            }
+
+        } else if (string.contains("}"))
+            new InvalidConfigException("Missing { at  : " + string).printException();
+
+        return tag;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorCluster.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorCluster.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorCluster.java	(date 1525606902000)
@@ -0,0 +1,107 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.util.BlockUtil;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.Random;
+
+public class EnhancedGeneratorCluster extends EnhancedGenerator {
+    public static final EnhancedGeneratorCluster INSTANCE = new EnhancedGeneratorCluster(0, 0.0F, 0, 0, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState());
+    private IBlockState blockToSpawn;
+    private IBlockState blockToHangFrom;
+
+    private EnhancedGeneratorCluster(int generationAttempts, float generationProbability, int minHeight, int maxHeight, IBlockState blockToSpawnIn, IBlockState blockToHangFromIn) {
+        super(generationAttempts, generationProbability, minHeight, maxHeight);
+
+        blockToSpawn = blockToSpawnIn;
+        blockToHangFrom = blockToHangFromIn;
+    }
+
+    @Override
+    public EnhancedGeneratorCluster deserializeConfig(JsonObject config) {
+        int generationAttempts = JsonUtils.getInt(config, "generationAttempts", 10);
+        float generationProbability = JsonUtils.getFloat(config, "generationProbability", 1.0F);
+        int minHeight = JsonUtils.getInt(config, "minHeight", 32);
+        int maxHeight = JsonUtils.getInt(config, "maxHeight", 128);
+
+        IBlockState blockToSpawn = null;
+        IBlockState blockToHangFrom = null;
+
+        JsonObject blockToSpawnJson = JsonUtils.getJsonObject(config, "blockToSpawn", new JsonObject());
+        JsonObject blockToHangFromJson = JsonUtils.getJsonObject(config, "blockToHangFrom", new JsonObject());
+
+        if (blockToSpawnJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSpawnJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSpawn = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+        if (blockToHangFromJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToHangFromJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToHangFrom = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+
+        JsonObject blockToSpawnProperties = JsonUtils.getJsonObject(blockToSpawnJson, "properties", new JsonObject());
+        JsonObject blockToHangFromProperties = JsonUtils.getJsonObject(blockToHangFromJson, "properties", new JsonObject());
+
+        if (blockToSpawnProperties.entrySet().size() > 0) {
+            blockToSpawn = BlockUtil.getBlockWithProperties(blockToSpawn, JsonUtils.getJsonObject(blockToSpawnJson, "properties"));
+        }
+        if (blockToHangFromProperties.entrySet().size() > 0) {
+            blockToHangFrom = BlockUtil.getBlockWithProperties(blockToHangFrom, JsonUtils.getJsonObject(blockToHangFromJson, "properties"));
+        }
+
+        if (blockToSpawn != null && blockToHangFrom != null) {
+            return new EnhancedGeneratorCluster(generationAttempts, generationProbability, minHeight, maxHeight, blockToSpawn, blockToHangFrom);
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (!world.isAirBlock(pos)) {
+            return false;
+        } else if (world.getBlockState(pos.up()) != blockToHangFrom) {
+            return false;
+        } else {
+            world.setBlockState(pos, blockToSpawn, 3);
+
+            for (int i = 0; i < 1500; ++i) {
+                BlockPos newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), -rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8));
+
+                if (world.isAirBlock(newPos)) {
+                    int j = 0;
+
+                    for (EnumFacing facing : EnumFacing.values()) {
+                        if (world.getBlockState(newPos.offset(facing)).getBlock() == blockToSpawn.getBlock()) {
+                            ++j;
+                        }
+
+                        if (j > 1) {
+                            break;
+                        }
+                    }
+
+                    if (j == 1) {
+                        world.setBlockState(newPos, blockToSpawn, 3);
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockPolishedNetherrackBricksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockPolishedNetherrackBricksSlab.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockPolishedNetherrackBricksSlab.java	(date 1525606887000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockPolishedNetherrackBricksSlab extends BlockOverworldSlabBase {
+
+    public BlockPolishedNetherrackBricksSlab(boolean doubleSlab) {
+        super("polished_netherrack_bricks_slab", Material.ROCK, doubleSlab);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/ItemSpear.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemSpear.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/items/ItemSpear.java	(date 1523987836000)
@@ -0,0 +1,16 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.items.base.tools.BaseSword;
+
+public class ItemSpear extends BaseSword implements IExtendedReach {
+
+    public ItemSpear(String name, ToolMaterial material) {
+        super(name, material);
+    }
+
+    @Override
+    public float getReach() {
+        return 7.0F;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/RayCastUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/RayCastUtil.java	(date 1523986179000)
+++ src/main/java/net/hdt/neutronia/util/RayCastUtil.java	(date 1523986179000)
@@ -0,0 +1,125 @@
+// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
+// Jad home page: http://www.kpdus.com/jad.html
+// Decompiler options: packimports(3) 
+// Source File Name:   RayCastUtil.java
+
+package net.hdt.neutronia.util;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+
+public class RayCastUtil {
+
+    public RayCastUtil() {
+    }
+
+    public static RayTraceResult rayTraceBlocks(World world, Vec3d vec31, Vec3d vec32, boolean stopOnLiquid, boolean ignoreBlockWithoutBoundingBox, boolean returnLastUncollidableBlock, boolean allowNonfullCube) {
+        if (!Double.isNaN(vec31.x) && !Double.isNaN(vec31.y) && !Double.isNaN(vec31.z)) {
+            if (!Double.isNaN(vec32.x) && !Double.isNaN(vec32.y) && !Double.isNaN(vec32.z)) {
+                int i = MathHelper.floor(vec32.x);
+                int j = MathHelper.floor(vec32.y);
+                int k = MathHelper.floor(vec32.z);
+                int l = MathHelper.floor(vec31.x);
+                int i1 = MathHelper.floor(vec31.y);
+                int j1 = MathHelper.floor(vec31.z);
+                BlockPos blockpos = new BlockPos(l, i1, j1);
+                IBlockState iblockstate = world.getBlockState(blockpos);
+                Block block = iblockstate.getBlock();
+                if (iblockstate.getCollisionBoundingBox(world, blockpos) != Block.NULL_AABB && (iblockstate.isFullCube() || allowNonfullCube) && block.canCollideCheck(iblockstate, stopOnLiquid)) {
+                    RayTraceResult raytraceresult = iblockstate.collisionRayTrace(world, blockpos, vec31, vec32);
+                    if (raytraceresult != null)
+                        return raytraceresult;
+                }
+                RayTraceResult raytraceresult2 = null;
+                int k1 = 200;
+                do {
+                    if (k1-- < 0)
+                        break;
+                    if (Double.isNaN(vec31.x) || Double.isNaN(vec31.y) || Double.isNaN(vec31.z))
+                        return null;
+                    if (l == i && i1 == j && j1 == k)
+                        return returnLastUncollidableBlock ? raytraceresult2 : null;
+                    boolean flag2 = true;
+                    boolean flag = true;
+                    boolean flag1 = true;
+                    double d0 = 999D;
+                    double d1 = 999D;
+                    double d2 = 999D;
+                    if (i > l)
+                        d0 = (double) l + 1.0D;
+                    else if (i < l)
+                        d0 = (double) l + 0.0D;
+                    else
+                        flag2 = false;
+                    if (j > i1)
+                        d1 = (double) i1 + 1.0D;
+                    else if (j < i1)
+                        d1 = (double) i1 + 0.0D;
+                    else
+                        flag = false;
+                    if (k > j1)
+                        d2 = (double) j1 + 1.0D;
+                    else if (k < j1)
+                        d2 = (double) j1 + 0.0D;
+                    else
+                        flag1 = false;
+                    double d3 = 999D;
+                    double d4 = 999D;
+                    double d5 = 999D;
+                    double d6 = vec32.x - vec31.x;
+                    double d7 = vec32.y - vec31.y;
+                    double d8 = vec32.z - vec31.z;
+                    if (flag2)
+                        d3 = (d0 - vec31.x) / d6;
+                    if (flag)
+                        d4 = (d1 - vec31.y) / d7;
+                    if (flag1)
+                        d5 = (d2 - vec31.z) / d8;
+                    if (d3 == -0D)
+                        d3 = -0.0001D;
+                    if (d4 == -0D)
+                        d4 = -0.0001D;
+                    if (d5 == -0D)
+                        d5 = -0.0001D;
+                    EnumFacing enumfacing;
+                    if (d3 < d4 && d3 < d5) {
+                        enumfacing = i <= l ? EnumFacing.EAST : EnumFacing.WEST;
+                        vec31 = new Vec3d(d0, vec31.y + d7 * d3, vec31.z + d8 * d3);
+                    } else if (d4 < d5) {
+                        enumfacing = j <= i1 ? EnumFacing.UP : EnumFacing.DOWN;
+                        vec31 = new Vec3d(vec31.x + d6 * d4, d1, vec31.z + d8 * d4);
+                    } else {
+                        enumfacing = k <= j1 ? EnumFacing.SOUTH : EnumFacing.NORTH;
+                        vec31 = new Vec3d(vec31.x + d6 * d5, vec31.y + d7 * d5, d2);
+                    }
+                    l = MathHelper.floor(vec31.x) - (enumfacing != EnumFacing.EAST ? 0 : 1);
+                    i1 = MathHelper.floor(vec31.y) - (enumfacing != EnumFacing.UP ? 0 : 1);
+                    j1 = MathHelper.floor(vec31.z) - (enumfacing != EnumFacing.SOUTH ? 0 : 1);
+                    blockpos = new BlockPos(l, i1, j1);
+                    IBlockState iblockstate1 = world.getBlockState(blockpos);
+                    Block block1 = iblockstate1.getBlock();
+                    if (iblockstate1.getMaterial() == Material.PORTAL || iblockstate1.getCollisionBoundingBox(world, blockpos) != Block.NULL_AABB)
+                        if (block1.canCollideCheck(iblockstate1, stopOnLiquid) && (iblockstate.isFullCube() || allowNonfullCube)) {
+                            RayTraceResult raytraceresult1 = iblockstate1.collisionRayTrace(world, blockpos, vec31, vec32);
+                            if (raytraceresult1 != null)
+                                return raytraceresult1;
+                        } else {
+                            raytraceresult2 = new RayTraceResult(RayTraceResult.Type.MISS, vec31, enumfacing, blockpos);
+                        }
+                } while (true);
+                return returnLastUncollidableBlock ? raytraceresult2 : null;
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/util/BlockUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/BlockUtil.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/util/BlockUtil.java	(date 1525606899000)
@@ -0,0 +1,220 @@
+package net.hdt.neutronia.util;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.minecraft.block.Block;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.Minecraft;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemStack;
+import net.minecraft.network.play.client.CPacketPlayerDigging;
+import net.minecraft.network.play.server.SPacketBlockChange;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.world.DimensionType;
+import net.minecraft.world.World;
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.oredict.OreDictionary;
+
+import java.util.Map;
+
+public class BlockUtil {
+
+    public static Block getBlock(String blockId, String fallback) {
+        return Block.getBlockFromName(blockId == null || blockId.isEmpty() || Block.getBlockFromName(blockId) == null ? fallback : blockId);
+    }
+
+    public static boolean mine3x3(World world, ItemStack stack, BlockPos pos, EntityPlayer player) {
+        RayTraceResult traceResult = WorldUtil.rayTraceFromEntity(world, player, false, 4.5D);
+
+        if (traceResult == null) {
+            return true;
+        }
+
+        EnumFacing sideHit = traceResult.sideHit;
+
+        BlockPos startPos;
+        BlockPos endPos;
+
+        if (sideHit.getAxis() == EnumFacing.Axis.X) {
+            startPos = new BlockPos(0, 1, 1);
+            endPos = new BlockPos(0, -1, -1);
+        } else if (sideHit.getAxis() == EnumFacing.Axis.Y) {
+            startPos = new BlockPos(1, 0, 1);
+            endPos = new BlockPos(-1, 0, -1);
+        } else {
+            startPos = new BlockPos(1, 1, 0);
+            endPos = new BlockPos(-1, -1, 0);
+        }
+
+        Iterable<BlockPos> posIter = BlockPos.getAllInBox(startPos, endPos);
+        IBlockState originalState = world.getBlockState(pos);
+        float originalStrength = ForgeHooks.blockStrength(originalState, player, world, pos);
+
+        boolean canHarvestBedrock = false;
+
+        if (originalState.getBlock() == Blocks.BEDROCK) {
+            if (player.dimension == DimensionType.NETHER.getId() && pos.getY() >= 120) {
+                canHarvestBedrock = true;
+            }
+        }
+
+        for (BlockPos testPos : posIter) {
+            testPos = testPos.add(pos);
+
+            if (testPos.equals(pos)) {
+                continue;
+            }
+
+            IBlockState testState = world.getBlockState(testPos);
+            float testStrength = ForgeHooks.blockStrength(testState, player, world, testPos);
+            boolean canBeHarvested = ForgeHooks.canHarvestBlock(testState.getBlock(), player, world, testPos);
+
+            if (originalState.getMaterial() == testState.getMaterial() && testStrength > 0.0F && (originalStrength / testStrength) <= 10.0F || canHarvestBedrock) {
+                if (canBeHarvested && stack.canHarvestBlock(originalState) || canBeHarvested) {
+                    BlockUtil.tryToHarvest(world, testState, testPos, player, sideHit);
+                }
+            }
+        }
+
+        if (canHarvestBedrock) {
+            BlockUtil.tryToHarvest(world, originalState, pos, player, sideHit);
+        }
+
+        return false;
+    }
+
+    /**
+     * A method that harvests animations.blocks when they aren't able to normally
+     * <p>
+     * Written by VapourDrive here:
+     * https://github.com/VapourDrive/Hammerz/blob/55d31b8f8fd463d127110de04b2562605604e85c/src/main/java/vapourdrive/hammerz/utils/BlockUtils.java#L21
+     *
+     * @author VapourDrive
+     */
+    public static boolean tryToHarvest(World world, IBlockState state, BlockPos pos, EntityPlayer player, EnumFacing side) {
+        Block block = state.getBlock();
+
+        if (world.isAirBlock(pos)) {
+            return false;
+        }
+
+        EntityPlayerMP playerMP = null;
+
+        if (player instanceof EntityPlayerMP) {
+            playerMP = (EntityPlayerMP) player;
+        }
+
+        ItemStack stack = player.getHeldItemMainhand();
+
+        if (!(stack.getItem().getToolClasses(stack).contains(block.getHarvestTool(state)) || stack.getItem().getDestroySpeed(stack, state) > 1.0F)) {
+            return false;
+        }
+        if (!ForgeHooks.canHarvestBlock(block, player, world, pos)) {
+
+            return false;
+        }
+
+        int event = 0;
+
+        if (playerMP != null) {
+            event = ForgeHooks.onBlockBreakEvent(world, world.getWorldInfo().getGameType(), playerMP, pos);
+
+            if (event == -1) {
+                return false;
+            }
+        }
+
+        world.playEvent(playerMP, 2001, pos, Block.getStateId(state));
+
+
+        if (player.capabilities.isCreativeMode) {
+            if (!world.isRemote) {
+                block.onBlockHarvested(world, pos, state, player);
+            }
+            if (block.removedByPlayer(state, world, pos, player, false)) {
+                block.onBlockDestroyedByPlayer(world, pos, state);
+            }
+            if (!world.isRemote) {
+                playerMP.connection.sendPacket(new SPacketBlockChange(world, pos));
+            } else {
+                Minecraft.getMinecraft().getConnection().sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, side));
+            }
+            return true;
+        }
+        if (!world.isRemote) {
+            block.onBlockHarvested(world, pos, state, player);
+
+            if (block.removedByPlayer(state, world, pos, player, true)) {
+                block.onBlockDestroyedByPlayer(world, pos, state);
+                block.harvestBlock(world, player, pos, state, null, stack);
+                block.dropXpOnBlockBreak(world, pos, event);
+            }
+
+            playerMP.connection.sendPacket(new SPacketBlockChange(world, pos));
+        } else {
+            if (block.removedByPlayer(state, world, pos, player, true)) {
+                block.onBlockDestroyedByPlayer(world, pos, state);
+            }
+
+            Minecraft.getMinecraft().getConnection().sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, side));
+        }
+        return true;
+    }
+
+
+    public static boolean isOreDict(String id, Block block) {
+        for (ItemStack stack : OreDictionary.getOres(id)) {
+            if (stack.getItem() instanceof ItemBlock) {
+                if (((ItemBlock) stack.getItem()).getBlock() == block) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    private static IProperty getProperty(IBlockState state, String propertyName) {
+        for (IProperty property : state.getProperties().keySet()) {
+            if (property.getName().equalsIgnoreCase(propertyName)) {
+                return property;
+            }
+        }
+
+        return null;
+    }
+
+    private static Comparable getPropertyValue(IProperty property, String propertyValue) {
+        for (Comparable value : (ImmutableSet<Comparable>) property.getAllowedValues()) {
+            if (value.toString().equalsIgnoreCase(propertyValue)) {
+                return value;
+            }
+        }
+
+        return null;
+    }
+
+    public static IBlockState getBlockWithProperties(IBlockState state, JsonObject json) {
+        for (Map.Entry<String, JsonElement> entry : json.entrySet()) {
+            IProperty property = getProperty(state, entry.getKey());
+
+            if (property != null) {
+                Comparable value = getPropertyValue(property, entry.getValue().getAsString());
+
+                if (value != null) {
+                    return state.withProperty(property, value);
+                }
+            }
+        }
+
+        return state;
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/lang/natural_aquamarine.lang
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/lang/natural_aquamarine.lang	(date 1525459183000)
+++ src/main/resources/assets/neutronia/lang/natural_aquamarine.lang	(date 1525459183000)
@@ -0,0 +1,55 @@
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
+tile.natural_aquamarine_bricks.name=Natural Aquamarine Bricks
+tile.natural_chiseled_aquamarine.name=Natural Chiseled Aquamarine
+tile.raw_natural_aquamarine.name=Raw Natural Aquamarine
+tile.small_natural_aquamarine_bricks.name=Small Natural Aquamarine Bricks
+tile.natural_smooth_aquamarine.name=Natural Smooth Aquamarine
Index: src/main/java/net/hdt/neutronia/commands/BiomeUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/commands/BiomeUtils.java	(date 1523986182000)
+++ src/main/java/net/hdt/neutronia/commands/BiomeUtils.java	(date 1523986182000)
@@ -0,0 +1,103 @@
+package net.hdt.neutronia.commands;
+
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.BiomeProvider;
+import net.minecraft.world.gen.ChunkGeneratorSettings;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class BiomeUtils {
+
+    public static List<Biome> getAllowedBiomes() {
+        final List<Biome> biomes = new ArrayList<>();
+        for (Biome biome : Biome.REGISTRY) {
+            if (biome != null) {
+                biomes.add(biome);
+            }
+        }
+
+        return biomes;
+    }
+
+    public static SearchResult searchForBiome(World world, Biome biome, BlockPos startPos) {
+        final int sampleSpace = 16 * getBiomeSize(world);
+        final int maxDistance = 250000 * getBiomeSize(world);
+        if (maxDistance <= 0 || sampleSpace <= 0) {
+            return new SearchResult(0, 0, maxDistance, 0, false);
+        }
+
+        final BiomeProvider biomeProvider = world.getBiomeProvider();
+        int direction = -1;
+        int samples = 0;
+        int nextLength = sampleSpace;
+        int x = startPos.getX();
+        int z = startPos.getZ();
+        while (nextLength / 2 <= maxDistance && samples <= 100000) {
+            final int fixedDirection = direction == -1 ? -1 : direction % 4;
+            for (int i = 0; i < nextLength; i += sampleSpace) {
+                if (fixedDirection == 0) {
+                    x += sampleSpace;
+                } else if (fixedDirection == 1) {
+                    z -= sampleSpace;
+                } else if (fixedDirection == 2) {
+                    x -= sampleSpace;
+                } else if (fixedDirection == 3) {
+                    z += sampleSpace;
+                }
+
+                final Biome[] biomes = biomeProvider.getBiomes(null, x, z, 1, 1, false);
+                if (biomes[0] == biome) {
+                    return new SearchResult(x, z, nextLength / 2, samples, true);
+                }
+
+                samples++;
+            }
+
+            if (direction >= 0) {
+                nextLength += sampleSpace;
+            }
+            direction++;
+        }
+
+        return new SearchResult(0, 0, nextLength / 2, samples, false);
+    }
+
+    public static int getBiomeSize(World world) {
+        final String settings = world.getWorldInfo().getGeneratorOptions();
+        return ChunkGeneratorSettings.Factory.jsonToFactory(settings).build().biomeSize;
+    }
+
+    public static int getDistanceToBiome(EntityPlayer player, int x, int z) {
+        return (int) player.getDistance(x, player.posY, z);
+    }
+
+    public static String getBiomeName(Biome biome) {
+        if (biome != null) {
+            final String original = biome.getBiomeName();
+            StringBuilder fixed = new StringBuilder();
+            char pre = ' ';
+            for (int i = 0; i < original.length(); i++) {
+                final char c = original.charAt(i);
+                if (Character.isUpperCase(c) && Character.isLowerCase(pre) && Character.isAlphabetic(pre)) {
+                    fixed.append(" ");
+                }
+                fixed.append(String.valueOf(c));
+                pre = c;
+            }
+
+            return fixed.toString();
+
+        }
+
+        return "";
+    }
+
+    public static String getBiomeName(int biomeID) {
+        return getBiomeName(Biome.getBiomeForId(biomeID));
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityScubaDivers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityScubaDivers.java	(date 1523986198000)
+++ src/main/java/net/hdt/neutronia/entity/EntityScubaDivers.java	(date 1523986198000)
@@ -0,0 +1,277 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntitySmallFireball;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNodeType;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+
+public class EntityScubaDivers extends EntityMob {
+
+    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityScubaDivers.class, DataSerializers.BYTE);
+    /**
+     * Random offset used in floating behaviour
+     */
+    private float heightOffset = 0.5F;
+    /**
+     * ticks until heightOffset is randomized
+     */
+    private int heightOffsetUpdateTime;
+
+    public EntityScubaDivers(World worldIn) {
+        super(worldIn);
+        this.setPathPriority(PathNodeType.WATER, -1.0F);
+        this.setPathPriority(PathNodeType.LAVA, 8.0F);
+        this.setPathPriority(PathNodeType.DANGER_FIRE, 0.0F);
+        this.setPathPriority(PathNodeType.DAMAGE_FIRE, 0.0F);
+        this.isImmuneToFire = true;
+        this.experienceValue = 10;
+    }
+
+    public static void registerFixesBlaze(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityScubaDivers.class);
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(4, new EntityScubaDivers.AIFireballAttack(this));
+        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
+        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(ON_FIRE, (byte) 0);
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_BLAZE_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_BLAZE_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_BLAZE_DEATH;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getBrightnessForRender() {
+        return 15728880;
+    }
+
+    /**
+     * Gets how bright this entity is.
+     */
+    public float getBrightness() {
+        return 1.0F;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        if (!this.onGround && this.motionY < 0.0D) {
+            this.motionY *= 0.6D;
+        }
+
+        if (this.world.isRemote) {
+            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
+                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
+            }
+
+            for (int i = 0; i < 2; ++i) {
+                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
+            }
+        }
+
+        super.onLivingUpdate();
+    }
+
+    protected void updateAITasks() {
+        if (this.isWet()) {
+            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
+        }
+
+        --this.heightOffsetUpdateTime;
+
+        if (this.heightOffsetUpdateTime <= 0) {
+            this.heightOffsetUpdateTime = 100;
+            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
+        }
+
+        EntityLivingBase entitylivingbase = this.getAttackTarget();
+
+        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
+            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
+            this.isAirBorne = true;
+        }
+
+        super.updateAITasks();
+    }
+
+    public void fall(float distance, float damageMultiplier) {
+    }
+
+    /**
+     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
+     */
+    public boolean isBurning() {
+        return this.isCharged();
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_BLAZE;
+    }
+
+    private boolean isCharged() {
+        return (this.dataManager.get(ON_FIRE) & 1) != 0;
+    }
+
+    private void setOnFire(boolean onFire) {
+        byte b0 = this.dataManager.get(ON_FIRE);
+
+        if (onFire) {
+            b0 = (byte) (b0 | 1);
+        } else {
+            b0 = (byte) (b0 & -2);
+        }
+
+        this.dataManager.set(ON_FIRE, b0);
+    }
+
+    /**
+     * Checks to make sure the light is not too bright where the mob is spawning
+     */
+    protected boolean isValidLightLevel() {
+        return true;
+    }
+
+    static class AIFireballAttack extends EntityAIBase {
+        private final EntityScubaDivers blaze;
+        private int attackStep;
+        private int attackTime;
+
+        AIFireballAttack(EntityScubaDivers blazeIn) {
+            this.blaze = blazeIn;
+            this.setMutexBits(3);
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            return entitylivingbase != null && entitylivingbase.isEntityAlive();
+        }
+
+        /**
+         * Execute a one shot task or start executing a continuous task
+         */
+        public void startExecuting() {
+            this.attackStep = 0;
+        }
+
+        /**
+         * Reset the task's internal state. Called when this task is interrupted by another one
+         */
+        public void resetTask() {
+            this.blaze.setOnFire(false);
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            --this.attackTime;
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
+
+            if (d0 < 4.0D) {
+                if (this.attackTime <= 0) {
+                    this.attackTime = 20;
+                    this.blaze.attackEntityAsMob(entitylivingbase);
+                }
+
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
+                double d1 = entitylivingbase.posX - this.blaze.posX;
+                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
+                double d3 = entitylivingbase.posZ - this.blaze.posZ;
+
+                if (this.attackTime <= 0) {
+                    ++this.attackStep;
+
+                    if (this.attackStep == 1) {
+                        this.attackTime = 60;
+                        this.blaze.setOnFire(true);
+                    } else if (this.attackStep <= 4) {
+                        this.attackTime = 6;
+                    } else {
+                        this.attackTime = 100;
+                        this.attackStep = 0;
+                        this.blaze.setOnFire(false);
+                    }
+
+                    if (this.attackStep > 1) {
+                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
+                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
+
+                        for (int i = 0; i < 1; ++i) {
+                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
+                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
+                            this.blaze.world.spawnEntity(entitysmallfireball);
+                        }
+                    }
+                }
+
+                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
+            } else {
+                this.blaze.getNavigator().clearPath();
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            }
+
+            super.updateTask();
+        }
+
+        private double getFollowDistance() {
+            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
+            return iattributeinstance.getAttributeValue();
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSponge.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSponge.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSponge.java	(date 1525606883000)
@@ -0,0 +1,181 @@
+package net.hdt.neutronia.blocks.nether;
+
+import com.google.common.collect.Lists;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyBool;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.Tuple;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.List;
+import java.util.Queue;
+import java.util.Random;
+
+public class BlockNetherSponge extends BlockNetherBase {
+    public static final PropertyBool WET = PropertyBool.create("wet");
+
+    public BlockNetherSponge() {
+        super(Material.SPONGE, "nether_sponge");
+        this.setDefaultState(this.blockState.getBaseState().withProperty(WET, Boolean.FALSE));
+    }
+
+    /**
+     * Gets the localized name of this block. Used for the statistics page.
+     */
+    public String getLocalizedName() {
+        return I18n.translateToLocal(this.getUnlocalizedName() + "_dry.name");
+    }
+
+    /**
+     * Gets the metadata of the item this Block can drop. This method is called when the block gets destroyed. It
+     * returns the metadata of the dropped item based on the old metadata of the block.
+     */
+    public int damageDropped(IBlockState state) {
+        return state.getValue(WET) ? 1 : 0;
+    }
+
+    /**
+     * Called after the block is set in the Chunk data, but before the Tile Entity is set
+     */
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        this.tryAbsorb(worldIn, pos, state);
+    }
+
+    /**
+     * Called when a neighboring block was changed and marks that this state should perform any checks during a neighbor
+     * change. Cases may include when redstone power is updated, cactus blocks popping off due to a neighboring solid
+     * block, etc.
+     */
+    public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) {
+        this.tryAbsorb(worldIn, pos, state);
+        super.neighborChanged(state, worldIn, pos, blockIn, fromPos);
+    }
+
+    protected void tryAbsorb(World worldIn, BlockPos pos, IBlockState state) {
+        if (!state.getValue(WET) && this.absorb(worldIn, pos)) {
+            worldIn.setBlockState(pos, state.withProperty(WET, Boolean.TRUE), 2);
+            worldIn.playEvent(2001, pos, Block.getIdFromBlock(Blocks.WATER));
+        }
+    }
+
+    private boolean absorb(World worldIn, BlockPos pos) {
+        Queue<Tuple<BlockPos, Integer>> queue = Lists.newLinkedList();
+        List<BlockPos> list = Lists.newArrayList();
+        queue.add(new Tuple<>(pos, 0));
+        int i = 0;
+
+        while (!queue.isEmpty()) {
+            Tuple<BlockPos, Integer> tuple = queue.poll();
+            BlockPos blockpos = tuple.getFirst();
+            int j = tuple.getSecond();
+
+            for (EnumFacing enumfacing : EnumFacing.values()) {
+                BlockPos blockpos1 = blockpos.offset(enumfacing);
+
+                if (worldIn.getBlockState(blockpos1).getMaterial() == Material.WATER) {
+                    worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 2);
+                    list.add(blockpos1);
+                    ++i;
+
+                    if (j < 6) {
+                        queue.add(new Tuple<>(blockpos1, j + 1));
+                    }
+                }
+            }
+
+            if (i > 64) {
+                break;
+            }
+        }
+
+        for (BlockPos blockpos2 : list) {
+            worldIn.notifyNeighborsOfStateChange(blockpos2, Blocks.AIR, false);
+        }
+
+        return i > 0;
+    }
+
+    /**
+     * returns a list of blocks with the same ID, but different meta (eg: wood returns 4 blocks)
+     */
+    public void getSubBlocks(CreativeTabs itemIn, NonNullList<ItemStack> items) {
+        items.add(new ItemStack(this, 1, 0));
+        items.add(new ItemStack(this, 1, 1));
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(WET, Boolean.valueOf((meta & 1) == 1));
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(WET).booleanValue() ? 1 : 0;
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, WET);
+    }
+
+    /**
+     * Called periodically clientside on blocks near the player to show effects (like furnace fire particles). Note that
+     * this method is unrelated to {{@link #needsRandomTick}, and will always be called regardless
+     * of whether the block can receive random update ticks
+     */
+    @SideOnly(Side.CLIENT)
+    public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand) {
+        if (stateIn.getValue(WET)) {
+            EnumFacing enumfacing = EnumFacing.random(rand);
+
+            if (enumfacing != EnumFacing.UP && !worldIn.getBlockState(pos.offset(enumfacing)).isTopSolid()) {
+                double d0 = (double) pos.getX();
+                double d1 = (double) pos.getY();
+                double d2 = (double) pos.getZ();
+
+                if (enumfacing == EnumFacing.DOWN) {
+                    d1 = d1 - 0.05D;
+                    d0 += rand.nextDouble();
+                    d2 += rand.nextDouble();
+                } else {
+                    d1 = d1 + rand.nextDouble() * 0.8D;
+
+                    if (enumfacing.getAxis() == EnumFacing.Axis.X) {
+                        d2 += rand.nextDouble();
+
+                        if (enumfacing == EnumFacing.EAST) {
+                            ++d0;
+                        } else {
+                            d0 += 0.05D;
+                        }
+                    } else {
+                        d0 += rand.nextDouble();
+
+                        if (enumfacing == EnumFacing.SOUTH) {
+                            ++d2;
+                        } else {
+                            d2 += 0.05D;
+                        }
+                    }
+                }
+
+                worldIn.spawnParticle(EnumParticleTypes.DRIP_LAVA, d0, d1, d2, 0.0D, 0.0D, 0.0D);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockCharredNetherBrickSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockCharredNetherBrickSlab.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockCharredNetherBrickSlab.java	(date 1525606879000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockCharredNetherBrickSlab extends BlockNetherSlabBase {
+
+    public BlockCharredNetherBrickSlab(boolean doubleSlab) {
+        super("charred_nether_brick_slab", doubleSlab);
+        setHardness(2.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+
+}
Index: src/main/resources/assets/neutronia/lang/aquamarine.lang
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/lang/aquamarine.lang	(date 1525459183000)
+++ src/main/resources/assets/neutronia/lang/aquamarine.lang	(date 1525459183000)
@@ -0,0 +1,55 @@
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
+tile.aquamarine_bricks.name=Aquamarine Bricks
+tile.chiseled_aquamarine.name=Chiseled Aquamarine
+tile.raw_aquamarine.name=Raw Aquamarine
+tile.small_aquamarine_bricks.name=Small Aquamarine Bricks
+tile.smooth_aquamarine.name=Smooth Aquamarine
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureOre.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureOre.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureOre.java	(date 1525606895000)
@@ -0,0 +1,82 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.block.state.pattern.BlockMatcher;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public class FeatureOre extends Feature {
+    private IBlockState blockToSpawn;
+    private IBlockState blockToReplace;
+    private int veinSize;
+
+    public FeatureOre(IConfig config) {
+        super(config);
+        blockToSpawn = config.getBlock("blockToSpawn", Blocks.BARRIER.getDefaultState());
+        blockToReplace = config.getBlock("blockToReplace", Blocks.BARRIER.getDefaultState());
+        veinSize = config.getInt("veinSize", 8);
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (blockToSpawn.getBlock() == Blocks.BARRIER || blockToReplace.getBlock() == Blocks.BARRIER) {
+            return false;
+        }
+
+        float f = rand.nextFloat() * (float) Math.PI;
+        double d0 = (double) ((float) pos.getX() + MathHelper.sin(f) * (float) veinSize / 8.0F);
+        double d1 = (double) ((float) pos.getX() - MathHelper.sin(f) * (float) veinSize / 8.0F);
+        double d2 = (double) ((float) pos.getZ() + MathHelper.cos(f) * (float) veinSize / 8.0F);
+        double d3 = (double) ((float) pos.getZ() - MathHelper.cos(f) * (float) veinSize / 8.0F);
+        double d4 = (double) (pos.getY() + rand.nextInt(3) - 2);
+        double d5 = (double) (pos.getY() + rand.nextInt(3) - 2);
+
+        for (int i = 0; i < veinSize; ++i) {
+            float f1 = (float) i / (float) veinSize;
+            double d6 = d0 + (d1 - d0) * (double) f1;
+            double d7 = d4 + (d5 - d4) * (double) f1;
+            double d8 = d2 + (d3 - d2) * (double) f1;
+            double d9 = rand.nextDouble() * (double) veinSize / 16.0D;
+            double d10 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
+            double d11 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
+            int j = MathHelper.floor(d6 - d10 / 2.0D);
+            int k = MathHelper.floor(d7 - d11 / 2.0D);
+            int l = MathHelper.floor(d8 - d10 / 2.0D);
+            int i1 = MathHelper.floor(d6 + d10 / 2.0D);
+            int j1 = MathHelper.floor(d7 + d11 / 2.0D);
+            int k1 = MathHelper.floor(d8 + d10 / 2.0D);
+
+            for (int l1 = j; l1 <= i1; ++l1) {
+                double d12 = ((double) l1 + 0.5D - d6) / (d10 / 2.0D);
+
+                if (d12 * d12 < 1.0D) {
+                    for (int i2 = k; i2 <= j1; ++i2) {
+                        double d13 = ((double) i2 + 0.5D - d7) / (d11 / 2.0D);
+
+                        if (d12 * d12 + d13 * d13 < 1.0D) {
+                            for (int j2 = l; j2 <= k1; ++j2) {
+                                double d14 = ((double) j2 + 0.5D - d8) / (d10 / 2.0D);
+
+                                if (d12 * d12 + d13 * d13 + d14 * d14 < 1.0D) {
+                                    BlockPos newPos = new BlockPos(l1, i2, j2);
+                                    IBlockState state = world.getBlockState(newPos);
+
+                                    if (state.getBlock().isReplaceableOreGen(state, world, newPos, BlockMatcher.forBlock(blockToReplace.getBlock())) && state == blockToReplace) {
+                                        world.setBlockState(newPos, blockToSpawn, 2);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorFluid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorFluid.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorFluid.java	(date 1525606896000)
@@ -0,0 +1,135 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.util.BlockUtil;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.Random;
+
+public class EnhancedGeneratorFluid extends EnhancedGenerator {
+    public static final EnhancedGeneratorFluid INSTANCE = new EnhancedGeneratorFluid(0, 0.0F, 0, 0, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
+    private IBlockState blockToSpawn;
+    private IBlockState blockToTarget;
+    private boolean hidden;
+
+    private EnhancedGeneratorFluid(int generationAttempts, float generationProbability, int minHeight, int maxHeight, IBlockState blockToSpawnIn, IBlockState blockToTargetIn, boolean hiddenIn) {
+        super(generationAttempts, generationProbability, minHeight, maxHeight);
+
+        blockToSpawn = blockToSpawnIn;
+        blockToTarget = blockToTargetIn;
+        hidden = hiddenIn;
+    }
+
+    @Override
+    public EnhancedGeneratorFluid deserializeConfig(JsonObject config) {
+        int generationAttempts = JsonUtils.getInt(config, "generationAttempts", 10);
+        float generationProbability = JsonUtils.getFloat(config, "generationProbability", 1.0F);
+        int minHeight = JsonUtils.getInt(config, "minHeight", 32);
+        int maxHeight = JsonUtils.getInt(config, "maxHeight", 128);
+
+        IBlockState blockToSpawn = null;
+        IBlockState blockToTarget = null;
+
+        JsonObject blockToSpawnJson = JsonUtils.getJsonObject(config, "blockToSpawn", new JsonObject());
+        JsonObject blockToTargetJson = JsonUtils.getJsonObject(config, "blockToTarget", new JsonObject());
+
+        if (blockToSpawnJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSpawnJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSpawn = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+        if (blockToTargetJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToTargetJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToTarget = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+
+        JsonObject blockToSpawnProperties = JsonUtils.getJsonObject(blockToSpawnJson, "properties", new JsonObject());
+        JsonObject blockToTargetProperties = JsonUtils.getJsonObject(blockToTargetJson, "properties", new JsonObject());
+
+        if (blockToSpawnProperties.entrySet().size() > 0) {
+            blockToSpawn = BlockUtil.getBlockWithProperties(blockToSpawn, JsonUtils.getJsonObject(blockToSpawnJson, "properties"));
+        }
+        if (blockToTargetProperties.entrySet().size() > 0) {
+            blockToTarget = BlockUtil.getBlockWithProperties(blockToTarget, JsonUtils.getJsonObject(blockToTargetJson, "properties"));
+        }
+
+        boolean hidden = JsonUtils.getBoolean(config, "hidden", false);
+
+        if (blockToSpawn != null && blockToTarget != null) {
+            return new EnhancedGeneratorFluid(generationAttempts, generationProbability, minHeight, maxHeight, blockToSpawn, blockToTarget, hidden);
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (world.getBlockState(pos.up()) != blockToTarget) {
+            return false;
+        } else if (!world.isAirBlock(pos) && world.getBlockState(pos) != blockToTarget) {
+            return false;
+        } else {
+            int i = 0;
+
+            if (world.getBlockState(pos.west()) == blockToTarget) {
+                ++i;
+            }
+
+            if (world.getBlockState(pos.east()) == blockToTarget) {
+                ++i;
+            }
+
+            if (world.getBlockState(pos.north()) == blockToTarget) {
+                ++i;
+            }
+
+            if (world.getBlockState(pos.south()) == blockToTarget) {
+                ++i;
+            }
+
+            if (world.getBlockState(pos.down()) == blockToTarget) {
+                ++i;
+            }
+
+            int j = 0;
+
+            if (world.isAirBlock(pos.west())) {
+                ++j;
+            }
+
+            if (world.isAirBlock(pos.east())) {
+                ++j;
+            }
+
+            if (world.isAirBlock(pos.north())) {
+                ++j;
+            }
+
+            if (world.isAirBlock(pos.south())) {
+                ++j;
+            }
+
+            if (world.isAirBlock(pos.down())) {
+                ++j;
+            }
+
+            if (!hidden && i == 4 && j == 1 || i == 5) {
+                world.setBlockState(pos, blockToSpawn, 2);
+                world.immediateBlockTick(pos, blockToSpawn, rand);
+            }
+
+            return true;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/biome/BiomeProviderBOPHell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/BiomeProviderBOPHell.java	(date 1524916603000)
+++ src/main/java/net/hdt/neutronia/world/biome/BiomeProviderBOPHell.java	(date 1524916603000)
@@ -0,0 +1,127 @@
+/*******************************************************************************
+ * Copyright 2014-2017, the Biomes O' Plenty Team
+ *
+ * This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License.
+ *
+ * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.
+ ******************************************************************************//*
+
+package net.hdt.neutronia.world.biome;
+
+import net.minecraft.crash.CrashReport;
+import net.minecraft.crash.CrashReportCategory;
+import net.minecraft.init.Biomes;
+import net.minecraft.util.ReportedException;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldType;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.BiomeProvider;
+import net.minecraft.world.gen.layer.*;
+
+public class BiomeProviderBOPHell extends BiomeProvider {
+
+    public BiomeProviderBOPHell(long seed, WorldType worldType, String chunkProviderSettings)
+    {
+        super();
+
+        // load the settings object
+        // note on the client side, chunkProviderSettings is an empty string
+        // I'm not sure if this is a bug or deliberate, but it might have some consequences when the biomes/genlayers are different between client and server
+        // The same thing happens in vanilla minecraft
+        System.out.println("settings for hell world: "+chunkProviderSettings);
+        BOPWorldSettings settings = new BOPWorldSettings(chunkProviderSettings);
+
+        // set up all the gen layers
+        GenLayer[] genlayers = setupBOPGenLayers(seed, settings);
+        this.genBiomes = genlayers[0];
+        this.biomeIndexLayer = genlayers[1];
+    }
+
+    @Override
+    public Biome[] getBiomesForGeneration(Biome[] biomes, int x, int z, int width, int height)
+    {
+        IntCache.resetIntCache();
+
+        if (biomes == null || biomes.length < width * height)
+        {
+            biomes = new Biome[width * height];
+        }
+
+        int[] aint = this.genBiomes.getInts(x, z, width, height);
+
+        try
+        {
+            for (int i = 0; i < width * height; ++i)
+            {
+                biomes[i] = Biome.getBiome(aint[i], Biomes.HELL);
+            }
+
+            return biomes;
+        }
+        catch (Throwable throwable)
+        {
+            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Invalid Biome id");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("RawBiomeBlock");
+            crashreportcategory.addCrashSection("biomes[] size", biomes.length);
+            crashreportcategory.addCrashSection("x", x);
+            crashreportcategory.addCrashSection("z", z);
+            crashreportcategory.addCrashSection("w", width);
+            crashreportcategory.addCrashSection("h", height);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public BiomeProviderBOPHell(World world)
+    {
+        this(world.getSeed(), world.getWorldInfo().getTerrainType(), world.getWorldInfo().getGeneratorOptions());
+    }
+
+    public static GenLayer allocateBiomes(long worldSeed, BOPWorldSettings settings, GenLayer subBiomesInit)
+    {
+        // allocate the basic biomes
+        GenLayer biomesLayer = new GenLayerBiomeBOPHell(200L, settings);
+
+        // magnify everything (using the same seed)
+        biomesLayer = new GenLayerZoom(1000L, biomesLayer);
+        subBiomesInit = new GenLayerZoom(1000L, subBiomesInit);
+
+        // magnify everything again (using the same seed)
+        biomesLayer = new GenLayerZoom(1000L, biomesLayer);
+        subBiomesInit = new GenLayerZoom(1000L, subBiomesInit);
+
+        // add sub-biomes (like hills or rare mutated variants) seeded with subBiomesInit
+        biomesLayer = new GenLayerSubBiomesBOPHell(1000L, biomesLayer, subBiomesInit);
+
+        return biomesLayer;
+    }
+
+
+    public static GenLayer[] setupBOPGenLayers(long worldSeed, BOPWorldSettings settings)
+    {
+        int biomeSize = 3;
+
+        // the nether doesn't have oceans, so make it all land
+        GenLayer mainBranch = new GenLayerIslandBOP(1L, 1);
+
+        // fork off a new branch as a seed for sub biomes (normally for rivers too, but they're not applicable here)
+        GenLayer riversAndSubBiomesInit = new GenLayerRiverInit(100L, mainBranch);
+
+        // allocate the biomes
+        mainBranch = allocateBiomes(worldSeed, settings, riversAndSubBiomesInit);
+
+        // do a bit more zooming, depending on biomeSize
+        for (int i = 0; i < biomeSize; ++i)
+        {
+            mainBranch = new GenLayerZoom((long)(1000 + i), mainBranch);
+            if (i == 0) {mainBranch = new GenLayerRaggedEdges(3L, mainBranch);}
+        }
+        mainBranch = new GenLayerSmooth(1000L, mainBranch);
+
+        // finish biomes with Voronoi zoom
+        GenLayer biomesFinal = new GenLayerVoronoiZoom(10L, mainBranch);
+
+        mainBranch.initWorldGenSeed(worldSeed);
+        biomesFinal.initWorldGenSeed(worldSeed);
+        return new GenLayer[] {mainBranch, biomesFinal};
+    }
+}*/
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockHardenedClayTilesSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockHardenedClayTilesSlab.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockHardenedClayTilesSlab.java	(date 1525606878000)
@@ -0,0 +1,37 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 16:37:01 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+
+public class BlockHardenedClayTilesSlab extends BlockOverworldSlabBase {
+
+    public BlockHardenedClayTilesSlab(boolean doubleSlab) {
+        super("hardened_clay_tiles_slab", Material.ROCK, doubleSlab);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumBerriesType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumBerriesType.java	(date 1525164075000)
+++ src/main/java/net/hdt/neutronia/properties/EnumBerriesType.java	(date 1525164075000)
@@ -0,0 +1,84 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumBerriesType implements IStringSerializable {
+
+    STRAWBERRY(0, "strawberry", "strawberry", 0.5, 0.5, 1),
+    BLACKBERRY(1, "blackberry", "blackberry", 0.5, 0.5, 1),
+    BLUEBERRY(2, "blueberry", "blueberry", 0.5, 0.5, 1),
+    CHERRIES(3, "cherries", "cherries", 0.5, 0.5, 1),
+    RASPBERRY_BLUE(4, "raspberry_blue", "raspberry_blue", 0.5, 0.5, 1),
+    RASPBERRY_RED(5, "raspberry_red", "raspberry_red", 0.5, 0.5, 1);
+
+    private String name, texture;
+    private int ID, eatTime, saturation, health;
+
+    EnumBerriesType(int ID, String name, String texture, double eatTime, double saturation, double health) {
+        this.name = name;
+        this.texture = texture;
+        this.ID = ID;
+        this.eatTime = (int) eatTime;
+        this.saturation = (int) saturation;
+        this.health = (int) health;
+    }
+
+    EnumBerriesType(int ID, String name, String texture, int eatTime, int saturation, int health) {
+        this.name = name;
+        this.texture = texture;
+        this.ID = ID;
+        this.eatTime = eatTime;
+        this.saturation = saturation;
+        this.health = health;
+    }
+
+    public String getTexture() {
+        return texture;
+    }
+
+    public void setTexture(String texture) {
+        this.texture = texture;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    public void setID(int ID) {
+        this.ID = ID;
+    }
+
+    public int getEatTime() {
+        return eatTime;
+    }
+
+    public void setEatTime(int eatTime) {
+        this.eatTime = eatTime;
+    }
+
+    public int getSaturation() {
+        return saturation;
+    }
+
+    public void setSaturation(int saturation) {
+        this.saturation = saturation;
+    }
+
+    public int getHealth() {
+        return health;
+    }
+
+    public void setHealth(int health) {
+        this.health = health;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedClayTilesSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedClayTilesSlab.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedClayTilesSlab.java	(date 1525606882000)
@@ -0,0 +1,44 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 18:31:18 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedClayTiles;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedClayTilesSlab extends BlockOverworldSlabBase implements IRecipeGrouped {
+
+    public BlockStainedClayTilesSlab(BlockStainedClayTiles.Variants variant, boolean doubleSlab) {
+        super(variant.getName() + "_slab", Material.ROCK, doubleSlab);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_clay_tiles_slab";
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityPhantom.java	(date 1523986196000)
+++ src/main/java/net/hdt/neutronia/entity/EntityPhantom.java	(date 1523986196000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.world.World;
+
+public class EntityPhantom extends EntityLiving {
+
+    public EntityPhantom(World worldIn) {
+        super(worldIn);
+        this.setHealth(this.getMaxHealth());
+        setSize(0.5F, 0.5F);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSoulSandstoneSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSoulSandstoneSlab.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSoulSandstoneSlab.java	(date 1525606885000)
@@ -0,0 +1,14 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherSlabBase;
+import net.minecraft.block.SoundType;
+
+public class BlockSoulSandstoneSlab extends BlockNetherSlabBase {
+
+    public BlockSoulSandstoneSlab(boolean doubleSlab) {
+        super("soul_sandstone_slab", doubleSlab);
+        setHardness(1F);
+        setSoundType(SoundType.STONE);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/WastelandWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/WastelandWorldData.java	(date 1523986181000)
+++ src/main/java/net/hdt/neutronia/world/utils/WastelandWorldData.java	(date 1523986181000)
@@ -0,0 +1,118 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.nbt.CompressedStreamTools;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.util.math.BlockPos;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class WastelandWorldData {
+    private File file;
+
+    public WastelandWorldData(String filename) {
+        this.file = new File(filename);
+    }
+
+    public WastelandWorldData() {
+        this.file = null;
+    }
+
+    public void setFile(String filename) {
+        this.file = new File(filename);
+    }
+
+    public boolean checkIfExists() {
+        return this.file.exists();
+    }
+
+    public void createFile() {
+        NBTTagCompound playerTags = new NBTTagCompound();
+        NBTTagCompound spawnTag = new NBTTagCompound();
+        NBTTagCompound wastelandData = new NBTTagCompound();
+        wastelandData.setTag("PlayerTags", playerTags);
+        wastelandData.setTag("SpawnTag", spawnTag);
+
+        try {
+            this.file.createNewFile();
+            FileOutputStream e = new FileOutputStream(this.file);
+            CompressedStreamTools.writeCompressed(wastelandData, e);
+        } catch (IOException var5) {
+            var5.printStackTrace();
+        }
+
+    }
+
+    public List getPlayerNames() {
+        ArrayList names = new ArrayList();
+
+        try {
+            FileInputStream e = new FileInputStream(this.file);
+            NBTTagCompound wastelandData = CompressedStreamTools.readCompressed(e);
+            names.addAll(wastelandData.getCompoundTag("PlayerTags").getKeySet());
+        } catch (Exception var4) {
+            var4.printStackTrace();
+        }
+
+        return names.isEmpty() ? null : names;
+    }
+
+    public void savePlayerNames(List names) {
+        try {
+            FileInputStream e = new FileInputStream(this.file);
+            NBTTagCompound wastelandData = CompressedStreamTools.readCompressed(e);
+            NBTTagCompound playerTags = wastelandData.getCompoundTag("PlayerTags");
+
+            for (int fileStreamOut = 0; fileStreamOut < names.size(); ++fileStreamOut) {
+                playerTags.setString((String) names.get(fileStreamOut), "NA");
+            }
+
+            FileOutputStream var7 = new FileOutputStream(this.file);
+            CompressedStreamTools.writeCompressed(wastelandData, var7);
+        } catch (Exception var6) {
+            var6.printStackTrace();
+        }
+
+    }
+
+    public void savePlayerName(String name) {
+        ArrayList names = new ArrayList();
+        names.add(name);
+        this.savePlayerNames(names);
+    }
+
+    public void saveSpawnLoc(BlockPos spawn) {
+        try {
+            FileInputStream e = new FileInputStream(this.file);
+            NBTTagCompound wastelandData = CompressedStreamTools.readCompressed(e);
+            NBTTagCompound spawnTag = wastelandData.getCompoundTag("spawnTag");
+            spawnTag.setInteger("spawnX", spawn.getX());
+            spawnTag.setInteger("spawnY", spawn.getY());
+            spawnTag.setInteger("spawnZ", spawn.getZ());
+            FileOutputStream fileStreamOut = new FileOutputStream(this.file);
+            CompressedStreamTools.writeCompressed(wastelandData, fileStreamOut);
+        } catch (Exception var6) {
+            var6.printStackTrace();
+        }
+
+    }
+
+    public BlockPos loadSpawnLoc() {
+        BlockPos spawn = null;
+
+        try {
+            FileInputStream e = new FileInputStream(this.file);
+            NBTTagCompound wastelandData = CompressedStreamTools.readCompressed(e);
+            NBTTagCompound spawnTag = wastelandData.getCompoundTag("spawnTag");
+            spawn = new BlockPos(spawnTag.getInteger("spawnX"), spawnTag.getInteger("spawnY"), spawnTag.getInteger("spawnZ"));
+        } catch (Exception var5) {
+            var5.printStackTrace();
+        }
+
+        return spawn;
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedPlanksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedPlanksSlab.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockStainedPlanksSlab.java	(date 1525606882000)
@@ -0,0 +1,35 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 18:31:18 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedPlanks;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedPlanksSlab extends BlockOverworldSlabBase implements IRecipeGrouped {
+
+    public BlockStainedPlanksSlab(BlockStainedPlanks.Variants variant, boolean doubleSlab) {
+        super(variant.getName() + "_slab", Material.WOOD, doubleSlab);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_planks_slab";
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/config/AnimaniaConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/config/AnimaniaConfig.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/config/AnimaniaConfig.java	(date 1525606884000)
@@ -0,0 +1,80 @@
+package net.hdt.neutronia.config;
+
+import net.hdt.neutronia.util.idk.ReflectionUtil;
+import net.minecraftforge.common.config.Config;
+import net.minecraftforge.common.config.ConfigManager;
+import net.minecraftforge.common.config.Configuration;
+import net.minecraftforge.fml.client.config.IConfigElement;
+import net.minecraftforge.fml.client.event.ConfigChangedEvent;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.io.File;
+import java.lang.invoke.MethodHandle;
+import java.util.Map;
+import java.util.Optional;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+@Config(modid = MOD_ID)
+public class AnimaniaConfig {
+    @Config.LangKey("Neutronia")
+
+    public static CommonConfig.GameRules gameRules = new CommonConfig.GameRules();
+    public static CommonConfig.Drops drops = new CommonConfig.Drops();
+    public static CommonConfig.Spawn spawn = new CommonConfig.Spawn();
+    public static CommonConfig.CareAndFeeding careAndFeeding = new CommonConfig.CareAndFeeding();
+    public static CommonConfig.FoodValues foodValues = new CommonConfig.FoodValues();
+
+    @Mod.EventBusSubscriber(modid = MOD_ID)
+    public static class EventHandler {
+
+        /**
+         * The {@link ConfigManager#CONFIGS} getter.
+         */
+        private static final MethodHandle CONFIGS_GETTER = ReflectionUtil.findFieldGetter(ConfigManager.class, "CONFIGS");
+
+        /**
+         * The {@link Configuration} instance.
+         */
+        private static Configuration configuration;
+
+        /**
+         * Get the {@link Configuration} instance from {@link ConfigManager}.
+         * <p>
+         * TODO: Use a less hackish method of getting the
+         * {@link Configuration}/{@link IConfigElement}s when possible.
+         *
+         * @return The Configuration instance
+         */
+        public static Configuration getConfiguration() {
+            if (EventHandler.configuration == null)
+                try {
+                    final String fileName = MOD_ID + ".cfg";
+
+                    @SuppressWarnings("unchecked") final Map<String, Configuration> configsMap = (Map<String, Configuration>) EventHandler.CONFIGS_GETTER.invokeExact();
+
+                    final Optional<Map.Entry<String, Configuration>> entryOptional = configsMap.entrySet().stream()
+                            .filter(entry -> fileName.equals(new File(entry.getKey()).getName())).findFirst();
+
+                    entryOptional.ifPresent(stringConfigurationEntry -> EventHandler.configuration = stringConfigurationEntry.getValue());
+                } catch (Throwable throwable) {
+                    throwable.printStackTrace();
+                }
+
+            return EventHandler.configuration;
+        }
+
+        /**
+         * Inject the new values and save to the config file when the config has
+         * been changed from the GUI.
+         *
+         * @param event The event
+         */
+        @SubscribeEvent
+        public static void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent event) {
+            if (event.getModID().equals(MOD_ID))
+                ConfigManager.load(MOD_ID, Config.Type.INSTANCE);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSandyBricksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSandyBricksSlab.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSandyBricksSlab.java	(date 1525606879000)
@@ -0,0 +1,28 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:02:02 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockSandyBricksSlab extends BlockOverworldSlabBase {
+
+    public BlockSandyBricksSlab(boolean doubleSlab) {
+        super("sandy_bricks_slab", Material.ROCK, doubleSlab);
+        setHardness(2.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityScorp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityScorp.java	(date 1523987841000)
+++ src/main/java/net/hdt/neutronia/entity/EntityScorp.java	(date 1523987841000)
@@ -0,0 +1,243 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.entity.ai.EntityAIScorpAttack;
+import net.hdt.neutronia.entity.ai.EntityAIScorpTarget;
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.*;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.monster.EntitySpider;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNavigate;
+import net.minecraft.pathfinding.PathNavigateClimber;
+import net.minecraft.potion.Potion;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Objects;
+
+/*
+ *TODO:Optimize Mob, Add Custom Sounds, Add Animations
+ */
+
+public class EntityScorp extends EntitySpider {
+
+    public static final DataParameter<Boolean> TAIL_OUT = EntityDataManager.createKey(EntityScorp.class, DataSerializers.BOOLEAN);
+    private static final DataParameter<Byte> CLIMBING = EntityDataManager.createKey(EntityScorp.class, DataSerializers.BYTE);
+    private static final DataParameter<Integer> VARIANTS = EntityDataManager.createKey(EntityScorp.class, DataSerializers.VARINT);
+    private static final String[] HORSE_TEXTURES = new String[]{
+            "neutronia:textures/entity/scorpion/scorpion_ender.png",
+            "neutronia:textures/entity/scorpion/scorpion_grey.png",
+            "neutronia:textures/entity/scorpion/scorpion_nether.png",
+            "neutronia:textures/entity/scorpion/scorpion_sand.png"
+    };
+    private static final String[] HORSE_TEXTURES_ABBR = new String[]{"sce", "scg", "scn", "scs"};
+    private final String[] horseTexturesArray = new String[3];
+    private String texturePrefix;
+
+    public EntityScorp(World worldIn) {
+        super(worldIn);
+    }
+
+    public static void registerFixesScorp(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityScorp.class);
+    }
+
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.SCORPION;
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntityAISwimming(this));
+        this.tasks.addTask(2, new EntityAIScorpAttack(this, 1.0D, false));
+        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 0.8D));
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 7.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+        this.targetTasks.addTask(2, new EntityAIScorpTarget<>(this, EntityPlayer.class));
+        applyEntityAI();
+    }
+
+    protected PathNavigate createNavigator(World worldIn) {
+        return new PathNavigateClimber(this, worldIn);
+    }
+
+    private void applyEntityAI() {
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+        this.targetTasks.addTask(3, new EntityAINearestAttackableTarget<>(this, EntityVillager.class, true));
+    }
+
+    /**
+     * (abstract) Protected helper method to write subclass entity data to NBT.
+     */
+    public void writeEntityToNBT(NBTTagCompound compound) {
+        super.writeEntityToNBT(compound);
+        compound.setInteger("variant", this.getHorseVariant());
+    }
+
+    /**
+     * (abstract) Protected helper method to read subclass entity data from NBT.
+     */
+    public void readEntityFromNBT(NBTTagCompound compound) {
+        super.readEntityFromNBT(compound);
+        this.setHorseVariant(compound.getInteger("variant"));
+    }
+
+    public void onUpdate() {
+        super.onUpdate();
+
+        if (!this.world.isRemote) {
+            this.setBesideClimbableBlock(this.collidedHorizontally);
+        }
+    }
+
+    public void setBesideClimbableBlock(boolean climbing) {
+        byte b0 = this.dataManager.get(CLIMBING);
+
+        if (climbing) {
+            b0 = (byte) (b0 | 1);
+        } else {
+            b0 = (byte) (b0 & -2);
+        }
+
+        this.dataManager.set(CLIMBING, b0);
+    }
+
+    public float getEyeHeight() {
+        return 0.65F;
+    }
+
+    @Override
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(30.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(1.5D);
+        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(TAIL_OUT, false);
+        this.dataManager.register(CLIMBING, (byte) 0);
+        this.dataManager.register(VARIANTS, 0);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean isTailOut() {
+        return this.getDataManager().get(TAIL_OUT);
+    }
+
+    public void setTailOut(boolean tailOut) {
+        this.getDataManager().set(TAIL_OUT, tailOut);
+    }
+
+    @Override
+    protected int getExperiencePoints(EntityPlayer player) {
+        return super.getExperiencePoints(player);
+    }
+
+    @Override
+    public void notifyDataManagerChange(DataParameter<?> key) {
+        super.notifyDataManagerChange(key);
+    }
+
+    @Override
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+    }
+
+    @Override
+    public boolean attackEntityAsMob(Entity entityIn) {
+        if (super.attackEntityAsMob(entityIn)) {
+            if (entityIn instanceof EntityLivingBase) {
+                ((EntityLivingBase) entityIn).addPotionEffect(new PotionEffect(Objects.requireNonNull(Potion.getPotionById(19)), 12 * 20, 0));
+            }
+            return true;
+        } else
+            return false;
+    }
+
+    @Override
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SPIDER_AMBIENT;
+    }
+
+    @Override
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SPIDER_HURT;
+    }
+
+    @Override
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SPIDER_DEATH;
+    }
+
+    protected SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_SPIDER_STEP;
+    }
+
+    @Override
+    protected void playStepSound(BlockPos pos, Block blockIn) {
+        this.playSound(this.getStepSound(), 0.15F, 1.0F);
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.ARTHROPOD;
+    }
+
+
+    @Override
+    public boolean getCanSpawnHere() {
+        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
+    }
+
+    public int getHorseVariant() {
+        return this.dataManager.get(VARIANTS);
+    }
+
+    public void setHorseVariant(int variant) {
+        this.dataManager.set(VARIANTS, variant);
+        this.resetTexturePrefix();
+    }
+
+    private void resetTexturePrefix() {
+        this.texturePrefix = null;
+    }
+
+    @SideOnly(Side.CLIENT)
+    private void setHorseTexturePaths() {
+        int i = this.getHorseVariant();
+        int j = (i & 255) % 7;
+        this.horseTexturesArray[0] = HORSE_TEXTURES[j];
+        this.texturePrefix = "scorpion/" + HORSE_TEXTURES_ABBR[j];
+    }
+
+    @SideOnly(Side.CLIENT)
+    public String getHorseTexture() {
+        if (this.texturePrefix == null) {
+            this.setHorseTexturePaths();
+        }
+
+        return this.texturePrefix;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMagmaBricksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMagmaBricksSlab.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMagmaBricksSlab.java	(date 1525606879000)
@@ -0,0 +1,36 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public class BlockMagmaBricksSlab extends BlockOverworldSlabBase {
+
+    public BlockMagmaBricksSlab(boolean doubleSlab) {
+        super("magma_bricks_slab", Material.ROCK, doubleSlab);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+        setLightLevel(0.2F);
+    }
+
+    @Override
+    public boolean isFireSource(World world, BlockPos pos, EnumFacing side) {
+        return isSideSolid(world.getBlockState(pos), world, pos, side);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntitySeaTurtle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntitySeaTurtle.java	(date 1523986184000)
+++ src/main/java/net/hdt/neutronia/entity/EntitySeaTurtle.java	(date 1523986184000)
@@ -0,0 +1,242 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.MoverType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBase;
+import net.minecraft.entity.passive.EntityWaterMob;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+
+public class EntitySeaTurtle extends EntityWaterMob {
+
+    public float squidPitch;
+    public float prevSquidPitch;
+    public float squidYaw;
+    public float prevSquidYaw;
+    /**
+     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
+     */
+    public float squidRotation;
+    /**
+     * previous squidRotation in radians
+     */
+    public float prevSquidRotation;
+    /**
+     * angle of the tentacles in radians
+     */
+    public float tentacleAngle;
+    /**
+     * the last calculated angle of the tentacles in radians
+     */
+    public float lastTentacleAngle;
+    private float randomMotionSpeed;
+    /**
+     * change in squidRotation in radians.
+     */
+    private float rotationVelocity;
+    private float rotateSpeed;
+    private float randomMotionVecX;
+    private float randomMotionVecY;
+    private float randomMotionVecZ;
+
+    public EntitySeaTurtle(World worldIn) {
+        super(worldIn);
+        setSize(0.5F, 0.5F);
+        this.rand.setSeed((long) (1 + this.getEntityId()));
+        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(0, new EntitySeaTurtle.AIMoveRandom(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
+    }
+
+    public float getEyeHeight() {
+        return this.height;
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SQUID_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SQUID_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SQUID_DEATH;
+    }
+
+    /**
+     * Returns the volume for the sounds this mob makes.
+     */
+    protected float getSoundVolume() {
+        return 0.4F;
+    }
+
+    /**
+     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
+     * prevent them from trampling crops
+     */
+    protected boolean canTriggerWalking() {
+        return false;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_SQUID;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+        this.prevSquidPitch = this.squidPitch;
+        this.prevSquidYaw = this.squidYaw;
+        this.prevSquidRotation = this.squidRotation;
+        this.lastTentacleAngle = this.tentacleAngle;
+        this.squidRotation += this.rotationVelocity;
+
+        if ((double) this.squidRotation > (Math.PI * 2D)) {
+            if (this.world.isRemote) {
+                this.squidRotation = ((float) Math.PI * 2F);
+            } else {
+                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
+
+                if (this.rand.nextInt(10) == 0) {
+                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
+                }
+
+                this.world.setEntityState(this, (byte) 19);
+            }
+        }
+
+        if (this.inWater) {
+            if (this.squidRotation < (float) Math.PI) {
+                float f = this.squidRotation / (float) Math.PI;
+                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
+
+                if ((double) f > 0.75D) {
+                    this.randomMotionSpeed = 1.0F;
+                    this.rotateSpeed = 1.0F;
+                } else {
+                    this.rotateSpeed *= 0.8F;
+                }
+            } else {
+                this.tentacleAngle = 0.0F;
+                this.randomMotionSpeed *= 0.9F;
+                this.rotateSpeed *= 0.99F;
+            }
+
+            if (!this.world.isRemote) {
+                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
+                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
+                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
+            }
+
+            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
+            this.rotationYaw = this.renderYawOffset;
+            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
+            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
+        } else {
+            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
+
+            if (!this.world.isRemote) {
+                this.motionX = 0.0D;
+                this.motionZ = 0.0D;
+
+                if (this.isPotionActive(MobEffects.LEVITATION)) {
+                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
+                } else if (!this.hasNoGravity()) {
+                    this.motionY -= 0.08D;
+                }
+
+                this.motionY *= 0.9800000190734863D;
+            }
+
+            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
+        }
+    }
+
+    public void travel(float strafe, float vertical, float forward) {
+        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+    }
+
+    /**
+     * Checks if the entity's current position is a valid location to spawn this entity.
+     */
+    public boolean getCanSpawnHere() {
+        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
+    }
+
+    /**
+     * Handler for {@link World#setEntityState}
+     */
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 19) {
+            this.squidRotation = 0.0F;
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
+        this.randomMotionVecX = randomMotionVecXIn;
+        this.randomMotionVecY = randomMotionVecYIn;
+        this.randomMotionVecZ = randomMotionVecZIn;
+    }
+
+    public boolean hasMovementVector() {
+        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
+    }
+
+    static class AIMoveRandom extends EntityAIBase {
+        private final EntitySeaTurtle squid;
+
+        public AIMoveRandom(EntitySeaTurtle p_i45859_1_) {
+            this.squid = p_i45859_1_;
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            return true;
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            int i = this.squid.getIdleTime();
+
+            if (i > 100) {
+                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
+            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
+                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
+                float f1 = MathHelper.cos(f) * 0.2F;
+                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
+                float f3 = MathHelper.sin(f) * 0.2F;
+                this.squid.setMovementVector(f1, f2, f3);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ArmorTM.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ArmorTM.java	(date 1523988244000)
+++ src/main/java/net/hdt/neutronia/items/ArmorTM.java	(date 1523988244000)
@@ -0,0 +1,74 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.proxy.ClientProxy;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.model.ModelBiped;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.ItemStack;
+import net.thegaminghuskymc.huskylib2.items.ItemModArmor;
+
+import javax.annotation.Nullable;
+
+public class ArmorTM extends ItemModArmor {
+
+    public ArmorTM(String name, ArmorMaterial material, int renderindex, EntityEquipmentSlot type) {
+        super(name, Reference.MOD_ID, material, renderindex, type);
+
+        this.setMaxStackSize(1);
+        this.setCreativeTab(CreativeTabs.COMBAT);
+
+    }
+
+    @Override
+    public String getUnlocalizedName() {
+        return String.format("item.%s%s", Reference.MOD_ID, getUnwrappedUnlocalizedName(super.getUnlocalizedName()));
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack itemstack) {
+        return String.format("item.%s%s", Reference.MOD_ID, getUnwrappedUnlocalizedName(super.getUnlocalizedName()));
+    }
+
+    protected String getUnwrappedUnlocalizedName(String unlocalizedName) {
+        return unlocalizedName.substring(unlocalizedName.indexOf('.') + 1);
+    }
+
+    @Nullable
+    @Override
+    public ModelBiped getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, ModelBiped _default) {
+
+        ModelBiped armorModel = ClientProxy.armorModels.get(this);
+
+        if (armorModel != null) {
+            armorModel.bipedHead.showModel = armorSlot == EntityEquipmentSlot.HEAD;
+            armorModel.bipedHeadwear.showModel = false;
+            armorModel.bipedBody.showModel = armorSlot == EntityEquipmentSlot.FEET || armorSlot == EntityEquipmentSlot.LEGS;
+            armorModel.bipedRightArm.showModel = armorSlot == EntityEquipmentSlot.FEET;
+            armorModel.bipedLeftArm.showModel = armorSlot == EntityEquipmentSlot.FEET;
+            armorModel.bipedRightLeg.showModel = armorSlot == EntityEquipmentSlot.LEGS || armorSlot == EntityEquipmentSlot.CHEST;
+            armorModel.bipedLeftLeg.showModel = armorSlot == EntityEquipmentSlot.LEGS || armorSlot == EntityEquipmentSlot.CHEST;
+
+            armorModel.isSneak = entityLiving.isSneaking();
+            armorModel.isRiding = entityLiving.isRiding();
+            armorModel.isChild = entityLiving.isChild();
+
+        }
+
+
+        return armorModel;
+    }
+
+    @Nullable
+    @Override
+    public String getArmorTexture(ItemStack stack, Entity entity, EntityEquipmentSlot slot, String type) {
+        String name = this.getUnwrappedUnlocalizedName(super.getUnlocalizedName());
+        name = name.substring(0, name.indexOf('_'));
+
+        return String.format("%s:textures/models/armor/%s_layer_%d.png", Reference.MOD_ID, name, slot == EntityEquipmentSlot.LEGS ? 2 : 1);
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockRodBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockRodBase.java	(date 1525281963000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockRodBase.java	(date 1525281963000)
@@ -0,0 +1,132 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.EnumPushReaction;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.util.*;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public class BlockRodBase extends BlockDirectional {
+
+    protected static final AxisAlignedBB BB_AXIS_Y = new AxisAlignedBB(0.375D, 0.0D, 0.375D, 0.625D, 1.0D, 0.625D);
+    protected static final AxisAlignedBB BB_AXIS_Z = new AxisAlignedBB(0.375D, 0.375D, 0.0D, 0.625D, 0.625D, 1.0D);
+    protected static final AxisAlignedBB BB_AXIS_X = new AxisAlignedBB(0.0D, 0.375D, 0.375D, 1.0D, 0.625D, 0.625D);
+
+    private Material mapColor = Material.SAND;
+
+    public BlockRodBase(String name, CreativeTabs creativeTabs) {
+        super(Material.CIRCUITS, name);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.UP));
+        this.setCreativeTab(creativeTabs);
+        this.setHardness(0.3F);
+        this.setLightLevel(1.0F);
+    }
+
+    @SuppressWarnings("unused")
+    public BlockRodBase(Material color, String name, CreativeTabs creativeTabs) {
+        super(Material.CIRCUITS, name);
+        mapColor = color;
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.UP));
+        this.setCreativeTab(creativeTabs);
+        this.setHardness(0.3F);
+        this.setLightLevel(1.0F);
+    }
+
+    @Override
+    public Material getMaterial(IBlockState state) {
+        return this.mapColor;
+    }
+
+    @Override
+    public IBlockState withRotation(IBlockState blockState, Rotation rotation) {
+        return blockState.withProperty(FACING, rotation.rotate(blockState.getValue(FACING)));
+    }
+
+    @Override
+    public IBlockState withMirror(IBlockState blockState, Mirror mirror) {
+        return blockState.withProperty(FACING, mirror.mirror(blockState.getValue(FACING)));
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox(IBlockState blockState, IBlockAccess blockAccess, BlockPos blockPos) {
+        switch (blockState.getValue(FACING).getAxis()) {
+            case X:
+            default:
+                return BB_AXIS_X;
+            case Z:
+                return BB_AXIS_Z;
+            case Y:
+                return BB_AXIS_Y;
+        }
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState blockState) {
+        return false;
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState blockState) {
+        return false;
+    }
+
+    @Override
+    public boolean canPlaceBlockAt(World world, BlockPos pos) {
+        return true;
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand) {
+        IBlockState iblockstate = world.getBlockState(pos.offset(facing.getOpposite()));
+
+        if (iblockstate.getBlock() == this) {
+            EnumFacing enumfacing = iblockstate.getValue(FACING);
+
+            if (enumfacing == facing) {
+                return this.getDefaultState().withProperty(FACING, facing.getOpposite());
+            }
+        }
+
+        return this.getDefaultState().withProperty(FACING, facing);
+    }
+
+    @Override
+    public void onBlockAdded(World world, BlockPos blockPos, IBlockState state) {
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        IBlockState state = this.getDefaultState();
+        state = state.withProperty(FACING, EnumFacing.getFront(meta));
+        return state;
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(FACING).getIndex();
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public BlockRenderLayer getBlockLayer() {
+        return BlockRenderLayer.CUTOUT;
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING);
+    }
+
+    @Override
+    public EnumPushReaction getMobilityFlag(IBlockState blockState) {
+        return EnumPushReaction.NORMAL;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksStairs.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksStairs.java	(date 1523987836000)
@@ -0,0 +1,17 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedPlanksStairs extends BlockOverworldStairBase implements IRecipeGrouped {
+
+    public BlockStainedPlanksStairs(BlockStainedPlanks.Variants variant) {
+        super(variant.getName() + "_stairs", HMBlocks.stained_planks.getDefaultState().withProperty(HMBlocks.stained_planks.getVariantProp(), variant));
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_planks_stairs";
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSnowBricksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSnowBricksSlab.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockSnowBricksSlab.java	(date 1525606885000)
@@ -0,0 +1,41 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [18/04/2016, 22:56:01 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+
+public class BlockSnowBricksSlab extends BlockOverworldSlabBase {
+
+    public BlockSnowBricksSlab(boolean doubleSlab) {
+        super("snow_bricks_slab", Material.CRAFTED_SNOW, doubleSlab);
+        setHardness(0.2F);
+        setSoundType(SoundType.SNOW);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public boolean isToolEffective(String type, IBlockState state) {
+        return type.equals("shovel");
+    }
+
+    @Override
+    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player) {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/handlers/BiomeTypeConfigHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/handlers/BiomeTypeConfigHandler.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/world/utils/handlers/BiomeTypeConfigHandler.java	(date 1525606898000)
@@ -0,0 +1,59 @@
+package net.hdt.neutronia.world.utils.handlers;
+
+import net.hdt.neutronia.world.gen.generators.StoneInfoBasedGenerator;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.biome.Biome;
+import net.minecraftforge.common.BiomeDictionary;
+import net.minecraftforge.common.config.Configuration;
+import org.apache.commons.lang3.text.WordUtils;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public final class BiomeTypeConfigHandler {
+
+    private static Configuration config;
+
+    public static List<BiomeDictionary.Type> parseBiomeTypeArrayConfig(String name, String category, BiomeDictionary.Type... biomes) {
+        String[] defaultBiomes = Arrays.stream(biomes).map(BiomeDictionary.Type::getName).toArray(String[]::new);
+        String[] readBiomes = config.getStringList(name, category, defaultBiomes,
+                "Biome Type List: https://github.com/MinecraftForge/MinecraftForge/blob/1.11.x/src/main/java/net/minecraftforge/common/BiomeDictionary.java#L44-L90\n"
+                        + "Types per Biome: https://github.com/MinecraftForge/MinecraftForge/blob/1.11.x/src/main/java/net/minecraftforge/common/BiomeDictionary.java#L402-L463");
+
+        return Arrays.stream(readBiomes).map(s -> BiomeDictionary.Type.getType(s)).collect(Collectors.toList());
+    }
+
+    public static boolean biomeTypeIntersectCheck(Iterable<BiomeDictionary.Type> biomeItr, Biome b) {
+        Set<BiomeDictionary.Type> currentTypes = BiomeDictionary.getTypes(b);
+
+        for (BiomeDictionary.Type type : biomeItr)
+            if (currentTypes.contains(type))
+                return true;
+
+        return false;
+    }
+
+    public static void debugStoneGeneration(Iterable<StoneInfoBasedGenerator> generators) {
+        System.out.println("### OUTPUTTING BIOME CSV DATA ###");
+        System.out.print("sep=;\nBiome");
+        for (StoneInfoBasedGenerator gen : generators)
+            System.out.print(";" + WordUtils.capitalize(gen.name));
+        System.out.print(";Biome Type");
+        System.out.println();
+        for (ResourceLocation r : Biome.REGISTRY.getKeys()) {
+            Biome b = Biome.REGISTRY.getObject(r);
+            System.out.print(b.getBiomeName());
+            for (StoneInfoBasedGenerator gen : generators) {
+                if (gen.canGenerateInBiome(b))
+                    System.out.print(";yes");
+                else System.out.print(";no");
+            }
+            System.out.print(";" + (b.isMutation() ? "mutation" : "normal"));
+            System.out.println();
+        }
+        System.out.println("### DONE ###");
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/commands/SearchResult.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/commands/SearchResult.java	(date 1523986191000)
+++ src/main/java/net/hdt/neutronia/commands/SearchResult.java	(date 1523986191000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.commands;
+
+public class SearchResult {
+
+    private int x;
+    private int z;
+    private int radius;
+    private int samples;
+    private boolean found;
+
+    public SearchResult(int x, int z, int radius, int samples, boolean found) {
+        this.x = x;
+        this.z = z;
+        this.radius = radius;
+        this.samples = samples;
+        this.found = found;
+    }
+
+    public int getX() {
+        return x;
+    }
+
+    public int getZ() {
+        return z;
+    }
+
+    public int getRadius() {
+        return radius;
+    }
+
+    public int getSamples() {
+        return samples;
+    }
+
+    public boolean found() {
+        return found;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomRubble.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomRubble.java	(date 1523986196000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomRubble.java	(date 1523986196000)
@@ -0,0 +1,44 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenRandomRubble extends WorldGenerator {
+    public WorldGenRandomRubble() {
+        super(true);
+    }
+
+    public boolean generate(World world, Random random, BlockPos pos) {
+        if (world.getBlockState(pos.down()).getBlock() == Blocks.DIRT && !world.getBlockState(pos.up()).getMaterial().isSolid() && !world.getBlockState(pos).getMaterial().isSolid() && !world.getBlockState(pos.south()).getMaterial().isSolid() && !world.getBlockState(pos.east()).getMaterial().isSolid() && !world.getBlockState(pos.west()).getMaterial().isSolid() && !world.getBlockState(pos.north()).getMaterial().isSolid() && world.isAirBlock(pos) && world.isAirBlock(pos.up())) {
+            for (int j1 = 0; j1 < 75; ++j1) {
+                BlockPos randomPos = pos.add(random.nextInt(8), random.nextInt(4), random.nextInt(8));
+                Material material6 = world.getBlockState(randomPos.down()).getMaterial();
+                if (world.isAirBlock(randomPos) && material6.isSolid()) {
+                    Block block = Blocks.COBBLESTONE;
+                    int chance = random.nextInt(31);
+                    if (chance < 10) {
+                        block = Blocks.COBBLESTONE;
+                    } else if (chance >= 10 && chance < 20) {
+                        block = Blocks.MOSSY_COBBLESTONE;
+                    } else if (chance >= 20 && chance < 30) {
+                        block = Blocks.PLANKS;
+                    } else {
+                        block = Blocks.BRICK_BLOCK;
+                    }
+
+                    world.setBlockState(randomPos, block.getDefaultState());
+                }
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockIronPlateSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockIronPlateSlab.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockIronPlateSlab.java	(date 1525606887000)
@@ -0,0 +1,28 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/06/2016, 14:49:11 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockIronPlateSlab extends BlockOverworldSlabBase {
+
+    public BlockIronPlateSlab(boolean doubleSlab) {
+        super("iron_plate_slab", Material.ROCK, doubleSlab);
+        setHardness(5.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.METAL);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockFloorTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockFloorTile.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockFloorTile.java	(date 1525606885000)
@@ -0,0 +1,76 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.minecraft.block.ITileEntityProvider;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.EnumPushReaction;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Mirror;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockFacing;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockFloorTile extends BlockFacing implements ITileEntityProvider {
+
+    public BlockFloorTile() {
+        super(Material.CARPET, MOD_ID, "floor_tile");
+        this.setDefaultState(getDefaultState().withProperty(FACING, EnumFacing.NORTH));
+        this.setHardness(1.4F);
+        this.setSoundType(SoundType.STONE);
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING);
+    }
+
+    /**
+     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
+     * blockstate.
+     */
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        return state.withProperty(FACING, rot.rotate(state.getValue(FACING)));
+    }
+
+    /**
+     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed
+     * blockstate.
+     */
+    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {
+        return state.withRotation(mirrorIn.toRotation(state.getValue(FACING)));
+    }
+
+    /**
+     * Called by ItemBlocks just before a block is actually set in the world, to allow for adjustments to the
+     * IBlockstate
+     */
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer) {
+        return this.getDefaultState().withProperty(FACING, placer.getHorizontalFacing().getOpposite());
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        int i = 0;
+        i = i | state.getValue(FACING).getHorizontalIndex();
+        return i;
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(FACING, EnumFacing.getHorizontal(meta));
+    }
+
+    public EnumPushReaction getMobilityFlag(IBlockState state) {
+        return EnumPushReaction.PUSH_ONLY;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndLeaves.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndLeaves.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndLeaves.java	(date 1524853001000)
@@ -0,0 +1,108 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+
+import javax.annotation.Nullable;
+
+public class BlockEndLeaves extends BlockLeavesEndEx
+{
+    public static final PropertyEnum<BlockEndLog.EnumType> TYPE = PropertyEnum.create("type", BlockEndLog.EnumType.class, type -> type.ordinal() < 4);
+
+    public BlockEndLeaves()
+    {
+        super("end_leaves", Material.LEAVES);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs item, NonNullList<ItemStack> list)
+    {
+        for(BlockEndLog.EnumType type : BlockEndLog.EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    protected ItemStack getSilkTouchDrop(IBlockState state)
+    {
+        return new ItemStack(Item.getItemFromBlock(this), 1, state.getValue(TYPE).ordinal());
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, getWoodType(meta)).withProperty(DECAYABLE, (meta & 4) == 0).withProperty(CHECK_DECAY, (meta & 8) > 0);
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        int i = 0;
+        i = i | state.getValue(TYPE).ordinal();
+
+        if(!state.getValue(DECAYABLE))
+        {
+            i |= 4;
+        }
+
+        if(state.getValue(CHECK_DECAY))
+        {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    @Override
+    public BlockEndLog.EnumType getWoodType(int meta)
+    {
+        return BlockEndLog.EnumType.fromMeta((meta & 3) % 4);
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE, CHECK_DECAY, DECAYABLE);
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack)
+    {
+        if(!worldIn.isRemote && stack.getItem() == Items.SHEARS)
+        {
+            player.addStat(StatList.getBlockStats(this));
+        }
+        else
+        {
+            super.harvestBlock(worldIn, player, pos, state, te, stack);
+        }
+    }
+
+    @Override
+    public NonNullList<ItemStack> onSheared(ItemStack item, IBlockAccess world, BlockPos pos, int fortune)
+    {
+        return NonNullList.withSize(1, new ItemStack(this, 1, world.getBlockState(pos).getValue(TYPE).ordinal()));
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabVerticalBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabVerticalBase.java	(date 1525023005000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabVerticalBase.java	(date 1525023005000)
@@ -0,0 +1,71 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+
+public class BlockOverworldSlabVerticalBase extends BlockModSlab {
+
+    public BlockOverworldSlabVerticalBase(String name, Material material, boolean isDouble) {
+        super(name, Reference.MOD_ID, material, isDouble);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    /*@Override
+    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
+        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.TRANSLUCENT;
+    }*/
+
+    @Override
+    public BlockRenderLayer getBlockLayer() {
+        return BlockRenderLayer.TRANSLUCENT;
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return isDouble();
+    }
+
+    @Override
+    public boolean isFullBlock(IBlockState state) {
+        return isDouble();
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        IBlockState iblockstate = blockAccess.getBlockState(pos.offset(side));
+        Block block = iblockstate.getBlock();
+
+        if (blockState != iblockstate) {
+            return true;
+        }
+
+        if (block == this) {
+            return false;
+        }
+
+        return block != this && super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+    }
+
+    @Override
+    public IProperty<?> getVariantProperty() {
+        return HALF;
+    }
+
+    @Override
+    public Comparable<?> getTypeForItem(ItemStack stack) {
+        return null;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/ItemFood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemFood.java	(date 1525284545000)
+++ src/main/java/net/hdt/neutronia/items/ItemFood.java	(date 1525284545000)
@@ -0,0 +1,16 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class ItemFood extends ItemModFood {
+
+    public ItemFood(String name, CreativeTabs creativeTabs, int amount, boolean isWolfFood) {
+        super(Reference.MOD_ID, name, creativeTabs, amount, isWolfFood);
+    }
+
+    public ItemFood(String name, CreativeTabs creativeTabs, int amount, float saturation, boolean isWolfFood) {
+        super(Reference.MOD_ID, name, creativeTabs, amount, saturation, isWolfFood);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSlabBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSlabBase.java	(date 1525541029000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherSlabBase.java	(date 1525541029000)
@@ -0,0 +1,36 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.item.ItemStack;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+
+public class BlockNetherSlabBase extends BlockModSlab {
+
+    public BlockNetherSlabBase(String name, boolean isDouble) {
+        super(name, Reference.MOD_ID, Material.ROCK, isDouble);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public IProperty<?> getVariantProperty() {
+        return HALF;
+    }
+
+    @Override
+    public Comparable<?> getTypeForItem(ItemStack stack) {
+        return null;
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/Feature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/Feature.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/Feature.java	(date 1525606899000)
@@ -0,0 +1,68 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.hdt.neutronia.api.world.gen.feature.IFeature;
+import net.hdt.neutronia.util.NumberHelper;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public abstract class Feature extends WorldGenerator implements IFeature {
+    protected int genAttempts;
+    protected float genProbability;
+    protected boolean randomizeGenAttempts;
+    protected int minHeight;
+    protected int maxHeight;
+
+    public Feature(IConfig config) {
+        genAttempts = config.getInt("genAttempts", 4);
+        genProbability = config.getFloat("genProbability", 1.0F);
+        randomizeGenAttempts = config.getBoolean("randomizeGenAttempts", false);
+        minHeight = config.getInt("minHeight", 16);
+        maxHeight = config.getInt("maxHeight", 112);
+    }
+
+    @Override
+    public abstract boolean generate(World world, Random rand, BlockPos pos);
+
+    @Override
+    public int getGenAttempts() {
+        return genAttempts;
+    }
+
+    @Override
+    public int getGenAttempts(Random rand) {
+        int attempts = genAttempts;
+
+        if (genProbability > 0.0F && genProbability < 1.0F && rand.nextFloat() > genProbability) {
+            attempts = 0;
+        }
+        if (randomizeGenAttempts) {
+            attempts = NumberHelper.getNumberInRange(1, attempts, rand);
+        }
+
+        return attempts;
+    }
+
+    @Override
+    public float getGenProbability() {
+        return genProbability;
+    }
+
+    @Override
+    public boolean randomizeGenAttempts() {
+        return randomizeGenAttempts;
+    }
+
+    @Override
+    public int getMinHeight() {
+        return minHeight;
+    }
+
+    @Override
+    public int getMaxHeight() {
+        return maxHeight;
+    }
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityEnderPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityEnderPhantom.java	(date 1523986177000)
+++ src/main/java/net/hdt/neutronia/entity/EntityEnderPhantom.java	(date 1523986177000)
@@ -0,0 +1,18 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.world.World;
+
+public class EntityEnderPhantom extends EntityLiving {
+
+    public EntityEnderPhantom(World worldIn) {
+        super(worldIn);
+        this.setHealth(this.getMaxHealth());
+        setSize(0.5F, 0.5F);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/client/rendering/ResourceProxy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/client/rendering/ResourceProxy.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/client/rendering/ResourceProxy.java	(date 1525606862000)
@@ -0,0 +1,61 @@
+package net.hdt.neutronia.client.rendering;
+
+import com.google.common.collect.ImmutableSet;
+import net.hdt.neutronia.Main;
+import net.minecraft.client.resources.AbstractResourcePack;
+import net.minecraftforge.fml.common.Loader;
+
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class ResourceProxy extends AbstractResourcePack {
+
+    private static final String MINECRAFT = "minecraft";
+    private static final Set<String> RESOURCE_DOMAINS = ImmutableSet.of(MINECRAFT);
+
+    private static final String BARE_FORMAT = "assets/%s/%s/%s/%s.%s";
+    private static final String OVERRIDE_FORMAT = "/assets/%s/%s/%s/overrides/%s.%s";
+
+    private static final Map<String, String> overrides = new HashMap<>();
+
+    public ResourceProxy() {
+        super(Loader.instance().activeModContainer().getSource());
+        overrides.put("pack.mcmeta", "/proxypack.mcmeta");
+    }
+
+    public void addResource(String space, String dir, String file, String ext) {
+        String bare = String.format(BARE_FORMAT, MINECRAFT, space, dir, file, ext);
+        String override = String.format(OVERRIDE_FORMAT, MOD_ID, space, dir, file, ext);
+        overrides.put(bare, override);
+    }
+
+    @Override
+    public Set<String> getResourceDomains() {
+        return RESOURCE_DOMAINS;
+    }
+
+    @Override
+    protected InputStream getInputStreamByName(String name) {
+        return Main.class.getResourceAsStream(overrides.get(name));
+    }
+
+    @Override
+    protected boolean hasResourceName(String name) {
+        return overrides.containsKey(name);
+    }
+
+    @Override
+    protected void logNameNotLowercase(String name) {
+        // NO-OP
+    }
+
+    @Override
+    public String getPackName() {
+        return "neutronia-texture-proxy";
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockDuskboundSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockDuskboundSlab.java	(date 1525606888000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockDuskboundSlab.java	(date 1525606888000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherSlabBase;
+import net.minecraft.block.SoundType;
+
+public class BlockDuskboundSlab extends BlockNetherSlabBase {
+
+    public BlockDuskboundSlab(boolean doubleSlab) {
+        super("duskbound_block_slab", doubleSlab);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockLeavesEndEx.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockLeavesEndEx.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockLeavesEndEx.java	(date 1524853001000)
@@ -0,0 +1,317 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import eex.init.EndExBlocks;
+import net.minecraft.block.Block;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyBool;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.common.IShearable;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+public abstract class BlockLeavesEndEx extends BlockEndEx implements IShearable
+{
+    public static final PropertyBool DECAYABLE = PropertyBool.create("decayable");
+    public static final PropertyBool CHECK_DECAY = PropertyBool.create("check_decay");
+    private int[] surroundings;
+
+    public BlockLeavesEndEx(String name, Material material)
+    {
+        super(name, material);
+
+        setTickRandomly(true);
+        setCreativeTab(CreativeTabs.DECORATIONS);
+        setHardness(0.2F);
+        setLightOpacity(1);
+        setSoundType(SoundType.PLANT);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public BlockRenderLayer getBlockLayer()
+    {
+        return Blocks.LEAVES.getBlockLayer();
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing side)
+    {
+        return Blocks.LEAVES.shouldSideBeRendered(state, world, pos, side);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void randomDisplayTick(IBlockState stateIn, World world, BlockPos pos, Random rand)
+    {
+        if(world.isRainingAt(pos.up()) && !world.getBlockState(pos.down()).isTopSolid() && rand.nextInt(15) == 1)
+        {
+            double posX = (double) ((float) pos.getX() + rand.nextFloat());
+            double posY = (double) pos.getY() - 0.05D;
+            double posZ = (double) ((float) pos.getZ() + rand.nextFloat());
+            world.spawnParticle(EnumParticleTypes.DRIP_WATER, posX, posY, posZ, 0.0D, 0.0D, 0.0D);
+        }
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state)
+    {
+        return Blocks.LEAVES.isOpaqueCube(state);
+    }
+
+    @Override
+    public void updateTick(World world, BlockPos pos, IBlockState state, Random rand)
+    {
+        if(!world.isRemote)
+        {
+            if((state.getValue(CHECK_DECAY) && state.getValue(DECAYABLE)))
+            {
+                int k = pos.getX();
+                int l = pos.getY();
+                int i1 = pos.getZ();
+
+                if(surroundings == null)
+                {
+                    surroundings = new int[32768];
+                }
+
+                if(world.isAreaLoaded(new BlockPos(k - 5, l - 5, i1 - 5), new BlockPos(k + 5, l + 5, i1 + 5)))
+                {
+                    BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+
+                    for(int i2 = -4; i2 <= 4; ++i2)
+                    {
+                        for(int j2 = -4; j2 <= 4; ++j2)
+                        {
+                            for(int k2 = -4; k2 <= 4; ++k2)
+                            {
+                                IBlockState testState = world.getBlockState(mutableBlockPos.setPos(k + i2, l + j2, i1 + k2));
+                                Block testBlock = testState.getBlock();
+
+                                if(!testBlock.canSustainLeaves(testState, world, mutableBlockPos.setPos(k + i2, l + j2, i1 + k2)))
+                                {
+                                    if(testBlock.isLeaves(testState, world, mutableBlockPos.setPos(k + i2, l + j2, i1 + k2)))
+                                    {
+                                        surroundings[(i2 + 16) * 1024 + (j2 + 16) * 32 + k2 + 16] = -2;
+                                    }
+                                    else
+                                    {
+                                        surroundings[(i2 + 16) * 1024 + (j2 + 16) * 32 + k2 + 16] = -1;
+                                    }
+                                }
+                                else
+                                {
+                                    surroundings[(i2 + 16) * 1024 + (j2 + 16) * 32 + k2 + 16] = 0;
+                                }
+                            }
+                        }
+                    }
+
+                    for(int i3 = 1; i3 <= 4; ++i3)
+                    {
+                        for(int j3 = -4; j3 <= 4; ++j3)
+                        {
+                            for(int k3 = -4; k3 <= 4; ++k3)
+                            {
+                                for(int l3 = -4; l3 <= 4; ++l3)
+                                {
+                                    if(surroundings[(j3 + 16) * 1024 + (k3 + 16) * 32 + l3 + 16] == i3 - 1)
+                                    {
+                                        if(surroundings[(j3 + 16 - 1) * 1024 + (k3 + 16) * 32 + l3 + 16] == -2)
+                                        {
+                                            surroundings[(j3 + 16 - 1) * 1024 + (k3 + 16) * 32 + l3 + 16] = i3;
+                                        }
+
+                                        if(surroundings[(j3 + 16 + 1) * 1024 + (k3 + 16) * 32 + l3 + 16] == -2)
+                                        {
+                                            surroundings[(j3 + 16 + 1) * 1024 + (k3 + 16) * 32 + l3 + 16] = i3;
+                                        }
+
+                                        if(surroundings[(j3 + 16) * 1024 + (k3 + 16 - 1) * 32 + l3 + 16] == -2)
+                                        {
+                                            surroundings[(j3 + 16) * 1024 + (k3 + 16 - 1) * 32 + l3 + 16] = i3;
+                                        }
+
+                                        if(surroundings[(j3 + 16) * 1024 + (k3 + 16 + 1) * 32 + l3 + 16] == -2)
+                                        {
+                                            surroundings[(j3 + 16) * 1024 + (k3 + 16 + 1) * 32 + l3 + 16] = i3;
+                                        }
+
+                                        if(surroundings[(j3 + 16) * 1024 + (k3 + 16) * 32 + (l3 + 16 - 1)] == -2)
+                                        {
+                                            surroundings[(j3 + 16) * 1024 + (k3 + 16) * 32 + (l3 + 16 - 1)] = i3;
+                                        }
+
+                                        if(surroundings[(j3 + 16) * 1024 + (k3 + 16) * 32 + l3 + 16 + 1] == -2)
+                                        {
+                                            surroundings[(j3 + 16) * 1024 + (k3 + 16) * 32 + l3 + 16 + 1] = i3;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                int l2 = surroundings[16912];
+
+                if(l2 >= 0)
+                {
+                    world.setBlockState(pos, state.withProperty(CHECK_DECAY, false), 4);
+                }
+                else
+                {
+                    destroy(world, pos);
+                }
+            }
+        }
+    }
+
+    @Override
+    public int quantityDropped(Random random)
+    {
+        return random.nextInt(20) == 0 ? 1 : 0;
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune)
+    {
+        return Item.getItemFromBlock(EndExBlocks.END_SAPLINGS);
+    }
+
+    @Override
+    public void dropBlockAsItemWithChance(World world, BlockPos pos, IBlockState state, float chance, int fortune)
+    {
+        super.dropBlockAsItemWithChance(world, pos, state, chance, fortune);
+    }
+
+    @Override
+    public void breakBlock(World world, BlockPos pos, IBlockState state)
+    {
+        int k = pos.getX();
+        int l = pos.getY();
+        int i1 = pos.getZ();
+
+        if(world.isAreaLoaded(new BlockPos(k - 2, l - 2, i1 - 2), new BlockPos(k + 2, l + 2, i1 + 2)))
+        {
+            for(int j1 = -1; j1 <= 1; ++j1)
+            {
+                for(int k1 = -1; k1 <= 1; ++k1)
+                {
+                    for(int l1 = -1; l1 <= 1; ++l1)
+                    {
+                        BlockPos newPos = pos.add(j1, k1, l1);
+                        IBlockState checkState = world.getBlockState(newPos);
+
+                        if(checkState.getBlock().isLeaves(checkState, world, newPos))
+                        {
+                            checkState.getBlock().beginLeavesDecay(checkState, world, newPos);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean causesSuffocation(IBlockState state)
+    {
+        return false;
+    }
+
+    @Override
+    public boolean
+    isShearable(ItemStack item, IBlockAccess world, BlockPos pos)
+    {
+        return true;
+    }
+
+    @Override
+    public boolean
+    isLeaves(IBlockState state, IBlockAccess world, BlockPos pos)
+    {
+        return true;
+    }
+
+    @Override
+    public void beginLeavesDecay(IBlockState state, World world, BlockPos pos)
+    {
+        if(!state.getValue(CHECK_DECAY))
+        {
+            world.setBlockState(pos, state.withProperty(CHECK_DECAY, true), 4);
+        }
+    }
+
+    @Override
+    public void getDrops(NonNullList<ItemStack> drops, IBlockAccess world, BlockPos pos, IBlockState state, int fortune)
+    {
+        Random rand = world instanceof World ? ((World) world).rand : new Random();
+        int chance = getSaplingDropChance(state);
+
+        if(fortune > 0)
+        {
+            chance -= 2 << fortune;
+
+            if(chance < 10)
+            {
+                chance = 10;
+            }
+        }
+        if(rand.nextInt(chance) == 0)
+        {
+
+            ItemStack drop = new ItemStack(getItemDropped(state, rand, fortune), 1, damageDropped(state));
+            if(!drop.isEmpty())
+            {
+                drops.add(drop);
+            }
+        }
+
+        chance = 200;
+
+        if(fortune > 0)
+        {
+            chance -= 10 << fortune;
+            if(chance < 40) chance = 40;
+        }
+
+        captureDrops(true);
+
+        if(world instanceof World)
+        {
+            dropApple((World) world, pos, state, chance);
+        }
+
+        drops.addAll(captureDrops(false));
+    }
+
+    public abstract BlockEndLog.EnumType getWoodType(int meta);
+
+    protected void dropApple(World world, BlockPos pos, IBlockState state, int chance)
+    {
+    }
+
+    protected int getSaplingDropChance(IBlockState state)
+    {
+        return 20;
+    }
+
+    private void destroy(World world, BlockPos pos)
+    {
+        dropBlockAsItem(world, pos, world.getBlockState(pos), 0);
+        world.setBlockToAir(pos);
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/entity/render/RenderCod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderCod.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderCod.java	(date 1523987837000)
@@ -0,0 +1,29 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityCod;
+import net.hdt.neutronia.entity.render.model.ModelCod;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+/*
+ *TODO:Add Custom Model and Textures
+ */
+public class RenderCod extends RenderLiving<EntityCod> {
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/fish/fish.png");
+
+    public RenderCod(RenderManager manager) {
+        super(manager, new ModelCod(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityCod entity) {
+        return SCORP_TEXTURE;
+    }
+
+    @Override
+    protected void applyRotations(EntityCod entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockVanillaSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockVanillaSlab.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockVanillaSlab.java	(date 1525606882000)
@@ -0,0 +1,29 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 19:31:28 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+
+public class BlockVanillaSlab extends BlockOverworldSlabBase {
+
+    public BlockVanillaSlab(String name, IBlockState state, boolean doubleSlab) {
+        super(name, state.getMaterial(), doubleSlab);
+
+        setHardness(state.getBlockHardness(null, new BlockPos(0, 0, 0)));
+        setResistance(state.getBlock().getExplosionResistance(null) * 5F / 3F);
+        setSoundType(state.getBlock().getSoundType());
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGenerator.java	(date 1525606897000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGenerator.java	(date 1525606897000)
@@ -0,0 +1,105 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.common.base.Strings;
+import com.google.gson.JsonObject;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public abstract class EnhancedGenerator extends WorldGenerator {
+    private final int generationAttempts;
+    private final float generationProbability;
+    private final int minHeight;
+    private final int maxHeight;
+
+    protected EnhancedGenerator(int generationAttemptsIn, float generationProbabilityIn, int minHeightIn, int maxHeightIn) {
+        generationAttempts = generationAttemptsIn;
+        generationProbability = generationProbabilityIn;
+        minHeight = minHeightIn;
+        maxHeight = maxHeightIn;
+    }
+
+    public static EnhancedGenerator deserialize(JsonObject config) {
+        GeneratorType generatorType = GeneratorType.getFromString(JsonUtils.getString(config, "generator", ""));
+
+        switch (generatorType) {
+            case FLUID:
+                return EnhancedGeneratorFluid.INSTANCE.deserializeConfig(config);
+            case SCATTER:
+                return EnhancedGeneratorScatter.INSTANCE.deserializeConfig(config);
+            case CLUSTER:
+                return EnhancedGeneratorCluster.INSTANCE.deserializeConfig(config);
+            case ORE:
+                return EnhancedGeneratorOre.INSTANCE.deserializeConfig(config);
+            case POOL:
+                return EnhancedGeneratorPool.INSTANCE.deserializeConfig(config);
+            case UNKNOWN:
+            default:
+                return null;
+        }
+    }
+
+    public abstract EnhancedGenerator deserializeConfig(JsonObject config);
+
+    @Override
+    public abstract boolean generate(World world, Random rand, BlockPos pos);
+
+    public int getGenerationAttempts() {
+        return generationAttempts;
+    }
+
+    public int getGenAttempts(Random rand) {
+        int attempts = getGenerationAttempts();
+        float probability = getGenerationProbability();
+
+        if (probability > 0.0F && probability < 1.0F && rand.nextFloat() > probability) {
+            attempts = 0;
+        }
+        if (attempts < 0) {
+            attempts = rand.nextInt(MathHelper.abs(attempts)) + 1;
+        }
+
+        return attempts;
+    }
+
+    public float getGenerationProbability() {
+        return generationProbability;
+    }
+
+    public int getMinHeight() {
+        return minHeight;
+    }
+
+    public int getMaxHeight() {
+        return maxHeight;
+    }
+
+    private enum GeneratorType {
+        STRUCTURE,
+        FLUID,
+        SCATTER,
+        CLUSTER,
+        ORE,
+        POOL,
+        THORNSTALK,
+        ENOKI,
+        UNKNOWN;
+
+        public static GeneratorType getFromString(String string) {
+            if (!Strings.isNullOrEmpty(string)) {
+                for (GeneratorType generatorType : values()) {
+                    if (generatorType.name().equalsIgnoreCase(string)) {
+                        return generatorType;
+                    }
+                }
+            }
+
+            return UNKNOWN;
+        }
+
+    }
+}
\ No newline at end of file
Index: src/main/resources/test.info
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/test.info	(date 1525459184000)
+++ src/main/resources/test.info	(date 1525459184000)
@@ -0,0 +1,20 @@
+[
+  {
+    "_comment": "Generated using Husky's JSON Generator v3.",
+    "mod_id": "neutronia",
+    "name": "Neutronia",
+    "description": "This is a test file",
+    "version": "0.0.1",
+    "credits": "This is the credits things",
+    "mcversion": "1.12.2",
+    "url": " ",
+    "authorList": [
+      "TheGamingHuskyMC"
+    ],
+    "parent": " ",
+    "logoFile": " ",
+    "screenshots": [
+      ""
+    ]
+  }
+]
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/WorldUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/WorldUtil.java	(date 1524932612000)
+++ src/main/java/net/hdt/neutronia/util/WorldUtil.java	(date 1524932612000)
@@ -0,0 +1,152 @@
+package net.hdt.neutronia.util;
+
+import com.google.common.base.Predicate;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.ClassInheritanceMultiMap;
+import net.minecraft.util.EntitySelectors;
+import net.minecraft.util.math.*;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+public class WorldUtil {
+
+    public static RayTraceResult rayTraceFromEntity(World world, Entity entity, boolean countNonSolidBlock, double range) {
+        float f = 1.0F;
+        float f1 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * f;
+        float f2 = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * f;
+        double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double) f;
+        double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double) f;
+
+        if (!world.isRemote && entity instanceof EntityPlayer) {
+            d1 += 1.62D;
+        }
+
+        double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double) f;
+        Vec3d vec3 = new Vec3d(d0, d1, d2);
+        float f3 = MathHelper.cos(-f2 * 0.017453292F - (float) Math.PI);
+        float f4 = MathHelper.sin(-f2 * 0.017453292F - (float) Math.PI);
+        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+        float f6 = MathHelper.sin(-f1 * 0.017453292F);
+        float f7 = f4 * f5;
+        float f8 = f3 * f5;
+        double d3 = range;
+
+        if (entity instanceof EntityPlayerMP) {
+            d3 = ((EntityPlayerMP) entity).interactionManager.getBlockReachDistance();
+        }
+
+        Vec3d vec31 = vec3.addVector((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        return world.rayTraceBlocks(vec3, vec31, countNonSolidBlock, !countNonSolidBlock, countNonSolidBlock);
+    }
+
+    public static void setEntityPosition(Entity e, double posX, double posY, double posZ) {
+        if (e instanceof EntityPlayerMP) {
+            EntityPlayerMP player = (EntityPlayerMP) e;
+            player.connection.setPlayerLocation(posX, posY, posZ, player.rotationYaw, player.rotationPitch);
+        } else {
+            e.setPositionAndUpdate(posX, posY, posZ);
+        }
+    }
+
+    public static boolean isValidPosition(BlockPos pos) {
+        return pos.getX() >= -30000000 && pos.getZ() >= -30000000 && pos.getX() < 30000000 && pos.getZ() < 30000000 && pos.getY() >= 0 && pos.getY() < 256;
+    }
+
+    public static BlockPos getHeighestPos(World worldObj, int x, int z) {
+        int startY = worldObj.getChunkFromBlockCoords(new BlockPos(x, 0, z)).getTopFilledSegment() + 16;
+
+        for (int y = startY; y >= 0; y--) {
+            BlockPos toCheck = new BlockPos(x, y, z);
+            if (!worldObj.isAirBlock(toCheck)) {
+                return toCheck;
+            }
+        }
+
+        return null;
+    }
+
+    public static List<Entity> getEntitiesWithinAABBs(World worldObj, Class classEntity, AxisAlignedBB... bbs) {
+        return getEntitiesWithinAABBs(worldObj, classEntity, EntitySelectors.NOT_SPECTATING, bbs);
+    }
+
+    public static List<Entity> getEntitiesWithinAABBs(World worldObj, Class clazz, Predicate<Entity> filter, AxisAlignedBB... bbs) {
+        ArrayList<Entity> arraylist = new ArrayList<Entity>();
+
+        HashMap<Vec3i, ArrayList<AxisAlignedBB>> boxMap = new HashMap<>();
+
+        for (AxisAlignedBB bb : bbs) {
+            int minChunkX = MathHelper.floor((bb.minX - World.MAX_ENTITY_RADIUS) / 16.0D);
+            int maxChunkX = MathHelper.floor((bb.maxX + World.MAX_ENTITY_RADIUS) / 16.0D);
+            int minChunkZ = MathHelper.floor((bb.minZ - World.MAX_ENTITY_RADIUS) / 16.0D);
+            int maxChunkZ = MathHelper.floor((bb.maxZ + World.MAX_ENTITY_RADIUS) / 16.0D);
+            int minChunkY = MathHelper.floor((bb.minY - World.MAX_ENTITY_RADIUS) / 16.0D);
+            int maxChunkY = MathHelper.floor((bb.maxY + World.MAX_ENTITY_RADIUS) / 16.0D);
+
+            for (int x = minChunkX; x <= maxChunkX; x++) {
+                for (int z = minChunkZ; z <= maxChunkZ; z++) {
+                    for (int y = minChunkY; y <= maxChunkY; y++) {
+                        if (y >= 0 && y < worldObj.getHeight() / 16) {
+                            Vec3i chunkVec = new Vec3i(x, y, z);
+
+                            ArrayList<AxisAlignedBB> boxList = boxMap.computeIfAbsent(chunkVec, k -> new ArrayList<>());
+
+                            boxList.add(bb);
+                        }
+                    }
+                }
+            }
+        }
+
+        for (Vec3i chunkVec : boxMap.keySet()) {
+            Chunk chunk = worldObj.getChunkFromChunkCoords(chunkVec.getX(), chunkVec.getZ());
+
+            ClassInheritanceMultiMap[] entityMapArray = chunk.getEntityLists();
+
+            for (Entity entity : (Iterable<Entity>) entityMapArray[chunkVec.getY()].getByClass(clazz)) {
+                for (AxisAlignedBB bb : boxMap.get(chunkVec)) {
+                    if (entity.getEntityBoundingBox().intersects(bb) && (filter == null || filter.apply(entity))) {
+                        arraylist.add(entity);
+
+                        Entity[] entityParts = entity.getParts();
+
+                        if (entityParts != null) {
+                            int i = 0;
+                            while (i < entityParts.length) {
+                                entity = entityParts[i];
+
+                                if (entity.getEntityBoundingBox().intersects(bb) && (filter == null || filter.apply(entity))) {
+                                    arraylist.add(entity);
+                                }
+                                i++;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return arraylist;
+    }
+
+    public static void spawnItemStack(World worldIn, BlockPos pos, ItemStack stack) {
+        spawnItemStack(worldIn, pos.getX(), pos.getY(), pos.getZ(), stack);
+    }
+
+    public static void spawnItemStack(World worldIn, double x, double y, double z, ItemStack stack) {
+        double d0 = worldIn.rand.nextFloat() * 0.5F + 0.25D;
+        double d1 = worldIn.rand.nextFloat() * 0.5F + 0.25D;
+        double d2 = worldIn.rand.nextFloat() * 0.5F + 0.25D;
+        EntityItem entityitem = new EntityItem(worldIn, x + d0, y + d1, z + d2, stack);
+        entityitem.setDefaultPickupDelay();
+        worldIn.spawnEntity(entityitem);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemEasterEgg.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemEasterEgg.java	(date 1523988245000)
+++ src/main/java/net/hdt/neutronia/items/ItemEasterEgg.java	(date 1523988245000)
@@ -0,0 +1,25 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.MobEffects;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.world.World;
+
+public class ItemEasterEgg extends ItemModFood {
+
+    public ItemEasterEgg() {
+        super(Reference.MOD_ID, "easter_egg_item", CreativeTabs.FOOD, 4, 0.3F, false);
+    }
+
+    @Override
+    protected void onFoodEaten(ItemStack stack, World worldIn, EntityPlayer player) {
+        super.onFoodEaten(stack, worldIn, player);
+        player.addPotionEffect(new PotionEffect(MobEffects.SPEED, 300, 2));
+        player.addPotionEffect(new PotionEffect(MobEffects.REGENERATION, 300, 1));
+        player.addPotionEffect(new PotionEffect(MobEffects.SATURATION, 300, 10));
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/config/CommonConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/config/CommonConfig.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/config/CommonConfig.java	(date 1525606878000)
@@ -0,0 +1,361 @@
+package net.hdt.neutronia.config;
+
+import net.minecraftforge.common.config.Config.Comment;
+
+public class CommonConfig {
+
+
+    public static class GameRules {
+
+        @Comment("Foods give bonus effects")
+        public boolean foodsGiveBonusEffects = true;
+
+        @Comment("Show mod update notification at startup")
+        public boolean showModUpdateNotification = true;
+
+        @Comment("Show male parts (modesty flag)")
+        public boolean showParts = true;
+
+        @Comment("Show particles when animals are unhappy")
+        public boolean showUnhappyParticles = true;
+
+        @Comment("Remove vanilla Cows")
+        public boolean replaceVanillaCows = true;
+
+        @Comment("Remove vanilla Pigs")
+        public boolean replaceVanillaPigs = true;
+
+        @Comment("Remove vanilla Chickens")
+        public boolean replaceVanillaChickens = true;
+
+        @Comment("Remove vanilla Rabbits")
+        public boolean replaceVanillaRabbits = true;
+
+        @Comment("Remove vanilla Sheep")
+        public boolean replaceVanillaSheep = true;
+
+        @Comment("Remove vanilla Horses")
+        public boolean replaceVanillaHorses = false;
+
+        @Comment("Allow eggs to be thrown")
+        public boolean allowEggThrowing = false;
+
+        @Comment("Allow dispensers to place seeds")
+        public boolean allowSeedDispenserPlacement = true;
+
+        @Comment("Shift-Right-Click for Seed Placement")
+        public boolean shiftSeedPlacement = false;
+
+        @Comment("Animals starve to death when not fed and watered")
+        public boolean animalsStarve = false;
+
+        @Comment("Allow random mobs to spawn on Animania animals")
+        public boolean allowMobRiding = true;
+
+        @Comment("Allow the trough to be automated with hoppers/pipes")
+        public boolean allowTroughAutomation = true;
+
+        @Comment("Multiplier for reducing fall damage when animals are leashed")
+        public float fallDamageReduceMultiplier = 0.45f;
+
+        @Comment("Capacity of RF that the Hamster Wheel has")
+        public int hamsterWheelCapacity = 200000;
+
+        @Comment("RF/tick that the Hamster wheel generates while in use")
+        public int hamsterWheelRFGeneration = 20;
+
+        @Comment("Ticks that the hamster stays in the wheel before it needs more food")
+        public int hamsterWheelUseTime = 900;
+
+        @Comment("Ticks that a Cheese takes to mature")
+        public int cheeseMaturityTime = 24000;
+
+        @Comment("Water blocks removed after large animals drink")
+        public boolean waterRemovedAfterDrinking = true;
+
+        @Comment("Plant blocks removed after animal eats")
+        public boolean plantsRemovedAfterEating = true;
+
+        @Comment("Animals do not have to eat or drink")
+        public boolean ambianceMode = false;
+
+        @Comment("Can sleep using Wagon")
+        public boolean sleepAllowedWagon = true;
+
+        @Comment("Animals can attack others")
+        public boolean animalsCanAttackOthers = true;
+
+        @Comment("Disable salt creation using cheese mold")
+        public boolean disableSaltCreation = false;
+
+        @Comment("Disable cart and wagon")
+        public boolean disableRollingVehicles = false;
+
+        @Comment("Food Items that can be placed in the trough (use # for meta)")
+        public String[] troughFood = {"minecraft:wheat", "simplecorn:corncob", "harvestcraft:barleyitem", "harvestcraft:oatsitem", "harvestcraft:ryeitem", "harvestcraft:cornitem", "minecraft:apple", "minecraft:carrot", "minecraft:beetroot", "minecraft:potato", "minecraft:poisonous_potato", "minecraft:wheat_seeds", "minecraft:melon_seeds", "minecraft:beetroot_seeds", "minecraft:pumpkin_seeds", "biomesoplenty:turnip_seeds"};
+
+    }
+
+    public static class Spawn {
+        @Comment("Spawn Animania Chickens in world")
+        public boolean spawnAnimaniaChickens = true;
+        @Comment("Spawn Animania Cows in world")
+        public boolean spawnAnimaniaCows = true;
+        @Comment("Spawn Animania Pigs in world")
+        public boolean spawnAnimaniaPigs = true;
+        @Comment("Spawn Animania Rodents in world")
+        public boolean spawnAnimaniaRodents = true;
+        @Comment("Spawn Animania Peacocks in world")
+        public boolean spawnAnimaniaPeacocks = true;
+        @Comment("Spawn Animania Horses in world")
+        public boolean spawnAnimaniaHorses = true;
+        @Comment("Spawn Animania Amphibians in world")
+        public boolean spawnAnimaniaAmphibians = true;
+        @Comment("Spawn Animania Goats in world")
+        public boolean spawnAnimaniaGoats = true;
+        @Comment("Spawn Animania Sheep in world")
+        public boolean spawnAnimaniaSheep = true;
+        @Comment("Spawn Animania Rabbits in world")
+        public boolean spawnAnimaniaRabbits = true;
+
+        @Comment("Spawn probability Cows in loaded chunks")
+        public int spawnProbabilityCows = 8;
+        @Comment("Spawn probability Horses in loaded chunks")
+        public int spawnProbabilityHorses = 6;
+        @Comment("Spawn probability Pigs in loaded chunks")
+        public int spawnProbabilityPigs = 8;
+        @Comment("Spawn probability Chickens in loaded chunks")
+        public int spawnProbabilityChickens = 8;
+        @Comment("Spawn probability Hedgehogs in loaded chunks")
+        public int spawnProbabilityHedgehogs = 8;
+        @Comment("Spawn probability Ferrets in loaded chunks")
+        public int spawnProbabilityFerrets = 8;
+        @Comment("Spawn probability Hamsters in loaded chunks")
+        public int spawnProbabilityHamsters = 8;
+        @Comment("Spawn probability Peacocks in loaded chunks")
+        public int spawnProbabilityPeacocks = 8;
+        @Comment("Spawn probability Amphibians in loaded chunks")
+        public int spawnProbabilityAmphibians = 6;
+        @Comment("Spawn probability Goats in loaded chunks")
+        public int spawnProbabilityGoats = 6;
+        @Comment("Spawn probability Sheep in loaded chunks")
+        public int spawnProbabilitySheep = 8;
+        @Comment("Spawn probability Rabbits in loaded chunks")
+        public int spawnProbabilityRabbits = 6;
+
+        @Comment("Number of potential Cow families per chunk")
+        public int numberCowFamilies = 1;
+        @Comment("Number of potential Pig families per chunk")
+        public int numberPigFamilies = 1;
+        @Comment("Number of potential Chicken families per chunk")
+        public int numberChickenFamilies = 1;
+        @Comment("Number of potential Horse families per chunk")
+        public int numberHorseFamilies = 1;
+        @Comment("Number of potential Goat families per chunk")
+        public int numberGoatFamilies = 1;
+        @Comment("Number of potential Sheep families per chunk")
+        public int numberSheepFamilies = 1;
+        @Comment("Number of potential Rabbit families per chunk")
+        public int numberRabbitFamilies = 1;
+
+        @Comment("Spawn limit for Cows in loaded chunks")
+        public int spawnLimitCows = 40;
+        @Comment("Spawn limit for Pigs in loaded chunks")
+        public int spawnLimitPigs = 40;
+        @Comment("Spawn limit for Chickens in loaded chunks")
+        public int spawnLimitChickens = 40;
+        @Comment("Spawn limit for Hedgehogs in loaded chunks")
+        public int spawnLimitHedgehogs = 40;
+        @Comment("Spawn limit for Ferrets in loaded chunks")
+        public int spawnLimitFerrets = 40;
+        @Comment("Spawn limit for Hamsters in loaded chunks")
+        public int spawnLimitHamsters = 40;
+        @Comment("Spawn limit for Peacocks in loaded chunks")
+        public int spawnLimitPeacocks = 40;
+        @Comment("Spawn limit for Amphibians in loaded chunks")
+        public int spawnLimitAmphibians = 40;
+        @Comment("Spawn limit for Horses in loaded chunks")
+        public int spawnLimitHorses = 40;
+        @Comment("Spawn limit for Goats in loaded chunks")
+        public int spawnLimitGoats = 40;
+        @Comment("Spawn limit for Sheep in loaded chunks")
+        public int spawnLimitSheep = 40;
+        @Comment("Spawn limit for Rabbits in loaded chunks")
+        public int spawnLimitRabbits = 40;
+
+
+    }
+
+    public static class CareAndFeeding {
+        @Comment("Ticks before next incremental growth")
+        public int childGrowthTick = 200;
+        @Comment("Ticks between feedings")
+        public int feedTimer = 12000;
+        @Comment("Ticks between drinking water")
+        public int waterTimer = 8000;
+        @Comment("Ticks between playing")
+        public int playTimer = 12000;
+        @Comment("Ticks between laying eggs")
+        public int laidTimer = 2000;
+        @Comment("Ticks between dropping feathers")
+        public int featherTimer = 12000;
+        @Comment("Ticks between birthings")
+        public int gestationTimer = 20000;
+        @Comment("Mammals mate/breed only after hand-feeding")
+        public boolean manualBreeding = false;
+        @Comment("Ticks before wool regrowth after shearing")
+        public int woolRegrowthTimer = 8000;
+        @Comment("Ticks between animals taking starvation damage")
+        public int starvationTimer = 400;
+        @Comment("Egg hatch chance (1/x)")
+        public int eggHatchChance = 2;
+        @Comment("Ticks between using Salt Lick")
+        public int saltLickTick = 8000;
+        @Comment("Maximum uses of the salt lick")
+        public int saltLickMaxUses = 200;
+
+        @Comment("Food Items that chickens can eat (use # for meta)")
+        public String[] chickenFood = {"minecraft:wheat_seeds", "minecraft:melon_seeds", "minecraft:beetroot_seeds", "minecraft:pumpkin_seeds", "simplecorn:corncob", "biomesoplenty:turnip_seeds", "harvestcraft:cornitem"};
+
+        @Comment("Food Items that cows can eat (use # for meta)")
+        public String[] cowFood = {"minecraft:wheat", "simplecorn:corncob", "harvestcraft:barleyitem", "harvestcraft:oatsitem", "harvestcraft:ryeitem", "harvestcraft:cornitem"};
+
+        @Comment("Food Items that goats can eat (use # for meta)")
+        public String[] goatFood = {"minecraft:wheat", "minecraft:string", "minecraft:stick", "minecraft:apple", "simplecorn:corncob", "harvestcraft:barleyitem", "harvestcraft:oatsitem", "harvestcraft:ryeitem", "harvestcraft:cornitem"};
+
+        @Comment("Food Items that horses can eat (use # for meta)")
+        public String[] horseFood = {"minecraft:wheat", "harvestcraft:barleyitem", "harvestcraft:oatsitem", "harvestcraft:ryeitem", "minecraft:apple", "minecraft:carrot"};
+
+        @Comment("Food Items that pigs can eat (use # for meta)")
+        public String[] pigFood = {"minecraft:carrot", "minecraft:beetroot", "minecraft:potato", "minecraft:poisonous_potato", "minecraft:bread"};
+
+        @Comment("Food Items that sheep can eat (use # for meta)")
+        public String[] sheepFood = {"minecraft:wheat", "harvestcraft:barleyitem", "harvestcraft:oatsitem", "harvestcraft:ryeitem"};
+
+        @Comment("Food Items that rabbits can eat (use # for meta)")
+        public String[] rabbitFood = {"minecraft:wheat", "minecraft:carrot", "minecraft:beetroot", "minecraft:apple"};
+    }
+
+    public static class Drops {
+        @Comment("Enable Animal Drops from Config")
+        public boolean customMobDrops = true;
+        @Comment("Enable Animals Drop their custom meat types")
+        public boolean oldMeatDrops = false;
+        @Comment("Set Custom Chicken Drop (if enabled)")
+        public String chickenDrop = "animania:raw_prime_chicken";
+        @Comment("Set Custom Chicken Secondary Drop")
+        public String chickenDrop2 = "minecraft:feather";
+        @Comment("Set Custom Chicken Secondary Drop Amount")
+        public int chickenDrop2Amount = 1;
+        @Comment("Set Custom Pig Drop (if enabled)")
+        public String pigDrop = "animania:raw_prime_pork";
+        @Comment("Set Custom Pig Secondary Drop")
+        public String pigDrop2 = "";
+        @Comment("Set Custom Pig Secondary Drop Amount")
+        public int pigDrop2Amount = 1;
+        @Comment("Set Custom Cow Drop (if enabled)")
+        public String cowDrop = "animania:raw_prime_beef";
+        @Comment("Set Custom Cow Secondary Drop")
+        public String cowDrop2 = "minecraft:leather";
+        @Comment("Set Custom Cow Secondary Drop Amount")
+        public int cowDrop2Amount = 1;
+        @Comment("Set Custom Horse Drop (if enabled)")
+        public String horseDrop = "";
+        @Comment("Set Custom Horse Secondary Drop")
+        public String horseDrop2 = "minecraft:leather";
+        @Comment("Set Custom Horse Secondary Drop Amount")
+        public int horseDrop2Amount = 1;
+        @Comment("Set Custom Blue Peacock Drop (if enabled)")
+        public String peacockBlueDrop = "animania:blue_peacock_feather";
+        @Comment("Set Custom Charcoal Peacock Drop (if enabled)")
+        public String peacockCharcoalDrop = "animania:charcoal_peacock_feather";
+        @Comment("Set Custom Opal Peacock Drop (if enabled)")
+        public String peacockOpalDrop = "animania:opal_peacock_feather";
+        @Comment("Set Custom Peach Peacock Drop (if enabled)")
+        public String peacockPeachDrop = "animania:peach_peacock_feather";
+        @Comment("Set Custom Purple Peacock Drop (if enabled)")
+        public String peacockPurpleDrop = "animania:purple_peacock_feather";
+        @Comment("Set Custom Taupe Peacock Drop (if enabled)")
+        public String peacockTaupeDrop = "animania:taupe_peacock_feather";
+        @Comment("Set Custom White Peacock Drop (if enabled)")
+        public String peacockWhiteDrop = "animania:white_peacock_feather";
+        @Comment("Set Custom Peacock Secondary Drop")
+        public String peacockDrop2 = "";
+        @Comment("Set Custom Peacock Secondary Drop Amount")
+        public int peacockDrop2Amount = 1;
+
+        @Comment("Set Custom Ferret Drop (if enabled)")
+        public String ferretDrop = "";
+        @Comment("Set Custom Ferret Secondary Drop")
+        public String ferretDrop2 = "";
+        @Comment("Set Custom Ferret Secondary Drop Amount")
+        public int ferretDrop2Amount = 1;
+
+        @Comment("Set Custom Hamster Drop (if enabled)")
+        public String hamsterDrop = "animania:hamster_food";
+        @Comment("Set Custom Hamster Secondary Drop")
+        public String hamsterDrop2 = "";
+        @Comment("Set Custom Hamster Secondary Drop Amount")
+        public int hamsterDrop2Amount = 1;
+
+        @Comment("Set Custom Hedgehog Drop (if enabled)")
+        public String hedgehogDrop = "";
+        @Comment("Set Custom Hedgehog Secondary Drop")
+        public String hedgehogDrop2 = "";
+        @Comment("Set Custom Hedgehog Secondary Drop Amount")
+        public int hedgehogDrop2Amount = 1;
+
+        @Comment("Set Custom Frog Drop")
+        public String frogDrop = "animania:raw_frog_legs";
+        @Comment("Set Custom Frog Secondary Drop")
+        public String frogDrop2 = "";
+        @Comment("Set Custom frog Secondary Drop Amount")
+        public int frogDrop2Amount = 1;
+
+        @Comment("Set Custom Toad Drop")
+        public String toadDrop = "";
+        @Comment("Set Custom Toad Secondary Drop")
+        public String toadDrop2 = "";
+        @Comment("Set Custom Toad Secondary Drop Amount")
+        public int toadDrop2Amount = 1;
+
+        @Comment("Set Custom Dart Frog Drop")
+        public String dartFrogDrop = "";
+        @Comment("Set Custom Dart Frog Secondary Drop")
+        public String dartFrogDrop2 = "";
+        @Comment("Set Custom Dart Frog Secondary Drop Amount")
+        public int dartFrogDrop2Amount = 1;
+
+        @Comment("Set Custom Goat Drop")
+        public String goatDrop = "animania:raw_chevon";
+        @Comment("Set Custom Goat Secondary Drop")
+        public String goatDrop2 = "";
+        @Comment("Set Custom Goat Secondary Drop Amount")
+        public int goatDrop2Amount = 1;
+
+        @Comment("Set Custom Sheep Drop")
+        public String sheepDrop = "animania:raw_prime_mutton";
+        @Comment("Set Custom Sheep Secondary Drop")
+        public String sheepDrop2 = "";
+        @Comment("Set Custom Sheep Secondary Drop Amount")
+        public int sheepDrop2Amount = 1;
+
+        @Comment("Set Custom Rabbit Drop")
+        public String rabbitDrop = "animania:raw_prime_rabbit";
+        @Comment("Set Custom Rabbit Secondary Drop")
+        public String rabbitDrop2 = "minecraft:rabbit_foot";
+        @Comment("Set Custom Rabbit Secondary Drop Amount")
+        public int rabbitDrop2Amount = 1;
+
+        @Comment("Allow Animania Chickens to drop Eggs")
+        public Boolean chickensDropEggs = false;
+        @Comment("Allow Animania Chickens to drop Feathers")
+        public Boolean chickensDropFeathers = true;
+    }
+
+    public static class FoodValues {
+        @Comment("Food Value Overrides")
+        public String[] foodValueOverrides = new String[]{};
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModPane.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModPane.java	(date 1523988403000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModPane.java	(date 1523988403000)
@@ -0,0 +1,184 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockPane;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyBool;
+import net.minecraft.block.state.BlockFaceShape;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Mirror;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import java.util.List;
+
+public class BlockModPane extends BlockMod implements IModBlock {
+
+    public static final PropertyBool NORTH = PropertyBool.create("north");
+    public static final PropertyBool EAST = PropertyBool.create("east");
+    public static final PropertyBool SOUTH = PropertyBool.create("south");
+    public static final PropertyBool WEST = PropertyBool.create("west");
+
+    protected static final AxisAlignedBB[] field_185730_f = new AxisAlignedBB[]{new AxisAlignedBB(0.4375D, 0.0D, 0.4375D, 0.5625D, 1.0D, 0.5625D), new AxisAlignedBB(0.4375D, 0.0D, 0.4375D, 0.5625D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.4375D, 0.5625D, 1.0D, 0.5625D), new AxisAlignedBB(0.0D, 0.0D, 0.4375D, 0.5625D, 1.0D, 1.0D), new AxisAlignedBB(0.4375D, 0.0D, 0.0D, 0.5625D, 1.0D, 0.5625D), new AxisAlignedBB(0.4375D, 0.0D, 0.0D, 0.5625D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.5625D, 1.0D, 0.5625D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.5625D, 1.0D, 1.0D), new AxisAlignedBB(0.4375D, 0.0D, 0.4375D, 1.0D, 1.0D, 0.5625D), new AxisAlignedBB(0.4375D, 0.0D, 0.4375D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.4375D, 1.0D, 1.0D, 0.5625D), new AxisAlignedBB(0.0D, 0.0D, 0.4375D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.4375D, 0.0D, 0.0D, 1.0D, 1.0D, 0.5625D), new AxisAlignedBB(0.4375D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 0.5625D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D)};
+
+    public BlockModPane(String name, Material materialIn) {
+        super(materialIn, Reference.MOD_ID, name);
+        setDefaultState(blockState.getBaseState().withProperty(NORTH, Boolean.valueOf(false)).withProperty(EAST, Boolean.valueOf(false)).withProperty(SOUTH, Boolean.valueOf(false)).withProperty(WEST, Boolean.valueOf(false)));
+    }
+
+    // COPYPASTA
+
+    private static int getBoundingBoxIndex(EnumFacing p_185729_0_) {
+        return 1 << p_185729_0_.getHorizontalIndex();
+    }
+
+    private static int getBoundingBoxIndex(IBlockState p_185728_0_) {
+        int i = 0;
+
+        if (p_185728_0_.getValue(NORTH).booleanValue())
+            i |= getBoundingBoxIndex(EnumFacing.NORTH);
+
+        if (p_185728_0_.getValue(EAST).booleanValue())
+            i |= getBoundingBoxIndex(EnumFacing.EAST);
+
+        if (p_185728_0_.getValue(SOUTH).booleanValue())
+            i |= getBoundingBoxIndex(EnumFacing.SOUTH);
+
+        if (p_185728_0_.getValue(WEST).booleanValue())
+            i |= getBoundingBoxIndex(EnumFacing.WEST);
+
+        return i;
+    }
+
+    @Override
+    public void addCollisionBoxToList(IBlockState state, World worldIn, BlockPos pos, AxisAlignedBB p_185477_4_, List<AxisAlignedBB> p_185477_5_, Entity p_185477_6_, boolean something) {
+        state = getActualState(state, worldIn, pos);
+        addCollisionBoxToList(pos, p_185477_4_, p_185477_5_, field_185730_f[0]);
+
+        if (state.getValue(NORTH).booleanValue())
+            addCollisionBoxToList(pos, p_185477_4_, p_185477_5_, field_185730_f[getBoundingBoxIndex(EnumFacing.NORTH)]);
+
+        if (state.getValue(SOUTH).booleanValue())
+            addCollisionBoxToList(pos, p_185477_4_, p_185477_5_, field_185730_f[getBoundingBoxIndex(EnumFacing.SOUTH)]);
+
+        if (state.getValue(EAST).booleanValue())
+            addCollisionBoxToList(pos, p_185477_4_, p_185477_5_, field_185730_f[getBoundingBoxIndex(EnumFacing.EAST)]);
+
+        if (state.getValue(WEST).booleanValue())
+            addCollisionBoxToList(pos, p_185477_4_, p_185477_5_, field_185730_f[getBoundingBoxIndex(EnumFacing.WEST)]);
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        state = getActualState(state, source, pos);
+        return field_185730_f[getBoundingBoxIndex(state)];
+    }
+
+    @Override
+    public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos) {
+        return state.withProperty(NORTH, canPaneConnectTo(worldIn, pos, EnumFacing.NORTH))
+                .withProperty(SOUTH, canPaneConnectTo(worldIn, pos, EnumFacing.SOUTH))
+                .withProperty(WEST, canPaneConnectTo(worldIn, pos, EnumFacing.WEST))
+                .withProperty(EAST, canPaneConnectTo(worldIn, pos, EnumFacing.EAST));
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    public final boolean canPaneConnectToBlock(Block blockIn) {
+        return blockIn.getDefaultState().isFullCube() || blockIn == this || blockIn == Blocks.GLASS || blockIn == Blocks.STAINED_GLASS || blockIn == Blocks.STAINED_GLASS_PANE || blockIn instanceof BlockPane;
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        return blockAccess.getBlockState(pos.offset(side)).getBlock() != this && super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+    }
+
+    @Override
+
+    protected boolean canSilkHarvest() {
+        return true;
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public BlockRenderLayer getBlockLayer() {
+        return BlockRenderLayer.CUTOUT_MIPPED;
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        return 0;
+    }
+
+    @Override
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        switch (rot) {
+            case CLOCKWISE_180:
+                return state.withProperty(NORTH, state.getValue(SOUTH)).withProperty(EAST, state.getValue(WEST)).withProperty(SOUTH, state.getValue(NORTH)).withProperty(WEST, state.getValue(EAST));
+            case COUNTERCLOCKWISE_90:
+                return state.withProperty(NORTH, state.getValue(EAST)).withProperty(EAST, state.getValue(SOUTH)).withProperty(SOUTH, state.getValue(WEST)).withProperty(WEST, state.getValue(NORTH));
+            case CLOCKWISE_90:
+                return state.withProperty(NORTH, state.getValue(WEST)).withProperty(EAST, state.getValue(NORTH)).withProperty(SOUTH, state.getValue(EAST)).withProperty(WEST, state.getValue(SOUTH));
+            default:
+                return state;
+        }
+    }
+
+    @Override
+    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {
+        switch (mirrorIn) {
+            case LEFT_RIGHT:
+                return state.withProperty(NORTH, state.getValue(SOUTH)).withProperty(SOUTH, state.getValue(NORTH));
+            case FRONT_BACK:
+                return state.withProperty(EAST, state.getValue(WEST)).withProperty(WEST, state.getValue(EAST));
+            default:
+                return super.withMirror(state, mirrorIn);
+        }
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, NORTH, EAST, WEST, SOUTH);
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{NORTH, EAST, WEST, SOUTH};
+    }
+
+    @Override
+    public BlockFaceShape getBlockFaceShape(IBlockAccess p_193383_1_, IBlockState p_193383_2_, BlockPos p_193383_3_, EnumFacing p_193383_4_) {
+        return p_193383_4_ != EnumFacing.UP && p_193383_4_ != EnumFacing.DOWN ? BlockFaceShape.MIDDLE_POLE_THIN : BlockFaceShape.CENTER_SMALL;
+    }
+
+    public boolean canPaneConnectTo(IBlockAccess world, BlockPos pos, EnumFacing dir) {
+        BlockPos off = pos.offset(dir);
+        IBlockState state = world.getBlockState(off);
+        return canPaneConnectToBlock(state.getBlock()) || state.isSideSolid(world, off, dir.getOpposite());
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/init/HMBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/HMBlocks.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/init/HMBlocks.java	(date 1525606886000)
@@ -0,0 +1,400 @@
+package net.hdt.neutronia.init;
+
+import json_generator.JsonGenerator;
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.*;
+import net.hdt.neutronia.blocks.nether.*;
+import net.hdt.neutronia.blocks.overworld.*;
+import net.hdt.neutronia.properties.*;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockChest;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.common.util.EnumHelper;
+import net.minecraftforge.event.RegistryEvent;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.compat.ModIntegrationHandler;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class HMBlocks {
+
+    public static final BlockChest.Type CUSTOM_TYPE_QUARK = EnumHelper.addEnum(BlockChest.Type.class, "QUARK", new Class[0]);
+    public static final BlockChest.Type CUSTOM_TYPE_QUARK_TRAP = EnumHelper.addEnum(BlockChest.Type.class, "QUARK_TRAP", new Class[0]);
+
+    public static final ResourceLocation TRAP_RESOURCE = new ResourceLocation(MOD_ID, "textures/blocks/chests/trap.png");
+    public static final ResourceLocation TRAP_DOUBLE_RESOURCE = new ResourceLocation(MOD_ID, "textures/blocks/chests/trap_double.png");
+    public static final Block dried_kelp_block;
+    public static final Block netherGlass, soulGlass, netherRod, netherSponge;
+    public static final BlockFloorTile floorTile;
+    // misc blocks
+    public static final Block glowingGrass;
+    public static final Block stoneAnvil, carbonAnvil, goldenAnvil, marbleAnvil, ironAnvil;
+    public static final Block stoneCauldron, carbonCauldron, goldenCauldron, marbleCauldron, ironCauldron, glassCauldron;
+    public static final BlockWorkbench craftingTable;
+    //Wood Blocks
+    public static BlockCustomChest customChest, prismarineChest;
+    public static BlockCustomChest prismarineChestTrap, customChestTrap;
+    public static BlockMod custom_bookshelf;
+    public static Block spruce_trapdoor, birch_trapdoor, jungle_trapdoor, acacia_trapdoor, dark_oak_trapdoor;
+    // Sea Blocks
+    public static Block[] brain_coral = new Block[5];
+    public static Block[] dead_brain_coral = new Block[5];
+    public static Block[] normal_coral = new Block[5];
+    public static Block[] dead_normal_coral = new Block[5];
+    public static Block[] coral_fan = new Block[5];
+    public static Block[] dead_coral_fan = new Block[5];
+    public static Block[] pipe_coral = new Block[5];
+    public static Block[] dead_pipe_coral = new Block[5];
+    public static Block[] sea_fan = new Block[5];
+    public static Block[] dead_sea_fan = new Block[5];
+    public static Block[] brainCoralStair = new Block[5];
+    public static Block[] deadBrainCoralStair = new Block[5];
+    public static Block[] coralStair = new Block[5];
+    public static Block[] deadCoralStair = new Block[5];
+    public static Block[] brainCoralFence = new Block[5];
+    public static Block[] brainCoralSlab = new Block[5];
+    public static Block[] deadBrainCoralSlab = new Block[5];
+    public static Block[] coralSlab = new Block[5];
+    public static Block[] deadCoralSlab = new Block[5];
+    public static Block[] brainCoralSlabDouble = new Block[5];
+    public static Block[] deadBrainCoralSlabDouble = new Block[5];
+    public static Block[] coralSlabDouble = new Block[5];
+    public static Block[] deadCoralSlabDouble = new Block[5];
+    public static Block[] naturalAquamarine = new Block[6];
+    public static Block[] aquamarine = new Block[6];
+    public static Block[] naturalAquamarineStairs = new Block[6];
+    public static Block[] aquamarineStairs = new Block[6];
+    public static Block[] naturalAquamarineSlabs = new Block[6];
+    public static Block[] aquamarineSlabs = new Block[6];
+    public static Block[] naturalAquamarineSlabsDouble = new Block[6];
+    public static Block[] aquamarineSlabsDouble = new Block[6];
+    public static Block[] coralPlants = new Block[16];
+    //Stone Blocks
+    public static Block[] newStoneVariants = new Block[30];
+    public static Block[] newStoneVariantStairs = new Block[30];
+    public static Block[] newStoneVariantSlabs = new Block[30];
+    public static Block[] newStoneVariantSlabsDouble = new Block[30];
+    //Blocks for the nether
+    public static Block[] netherBlocks = new Block[2];
+    public static Block[] glowingNetherBlocks = new Block[24];
+    public static Block[] soulStone = new Block[4];
+    public static Block[] soulStoneStairs = new Block[4];
+    public static Block[] soulStoneSlabs = new Block[4];
+    public static Block[] soulStoneSlabsDouble = new Block[4];
+    public static Block[] soulStoneFences = new Block[4];
+    public static Block[] soulStoneFenceGates = new Block[4];
+    public static Block[] netherPlants = new Block[3];
+    public static Block[] tallNetherPlants = new Block[2];
+    //Frosted versions of some blocks
+    public static Block[] frostedStones = new Block[25];
+    public static Block[] frostedStonesStairs = new Block[25];
+    public static Block[] frostedStonesSlabs = new Block[25];
+    public static Block[] frostedStonesSlabsDouble = new Block[25];
+    public static Block[] frostedDirts = new Block[25];
+    public static Block[] frostedDirtStairs = new Block[25];
+    public static Block[] frostedDirtSlabs = new Block[25];
+    public static Block[] frostedDirtSlabsDouble = new Block[25];
+    public static Block[] frostedClay = new Block[25];
+    public static Block[] frostedClayStairs = new Block[25];
+    public static Block[] frostedClaySlabs = new Block[25];
+    public static Block[] frostedClaySlabsDouble = new Block[25];
+    // New Stairs and slabs
+    public static Block[] stoneStairs = new Block[7];
+    public static Block[] terracottaStairs = new Block[16];
+    public static Block[] woolStairs = new Block[16];
+    public static Block[] glazedTerracottaStairs = new Block[16];
+    public static Block[] coloredGlassStairs = new Block[16];
+    public static Block[] stoneSlabs = new Block[7];
+    public static Block[] stoneSlabsDouble = new Block[7];
+    public static Block[] terracottaSlabs = new Block[16];
+    public static Block[] terracottaSlabsDouble = new Block[16];
+    public static Block[] woolSlabs = new Block[16];
+    public static Block[] woolSlabsDouble = new Block[16];
+    public static Block[] glazedTerracottaSlabs = new Block[16];
+    public static Block[] glazedTerracottaSlabsDouble = new Block[16];
+    public static Block[] coloredGlassSlabs = new Block[16];
+    public static Block[] coloredGlassSlabsDouble = new Block[16];
+    // Some colored blocks
+    public static Block[] coloredSand = new Block[16];
+    public static Block[] coloredCandles = new Block[16];
+    public static Block[] coloredLanterns = new Block[16];
+    public static Block[] coloredRedstoneLamp = new Block[16];
+    public static BlockMod stained_clay_tiles, stained_planks, hardened_clay_tiles;
+    public static BlockColoredVase[] pots = new BlockColoredVase[16];
+
+    static {
+
+        for (EnumCoralColor coralColor : EnumCoralColor.values()) {
+            brain_coral[coralColor.getMetadata()] = new BlockColoredWaterBlockBase(coralColor, "brain_coral");
+            dead_brain_coral[coralColor.getMetadata()] = new BlockColoredWaterBlockBase(coralColor, "brain_coral_dead");
+            normal_coral[coralColor.getMetadata()] = new BlockColoredWaterBlockBase(coralColor, "coral");
+            dead_normal_coral[coralColor.getMetadata()] = new BlockColoredWaterBlockBase(coralColor, "dead_coral");
+            coral_fan[coralColor.getMetadata()] = new BlockColoredWaterPlantBase(coralColor, "coral_fan");
+            /*dead_coral_fan[coralColor.getMetadata()] = new BlockColoredWaterPlantBase(coralColor, "dead_coral_fan");
+            pipe_coral[coralColor.getMetadata()] = new BlockNetherDoublePlantBase(coralColor, "pipe_coral");
+            dead_pipe_coral[coralColor.getMetadata()] = new BlockNetherDoublePlantBase(coralColor, "dead_coral_plant");
+            sea_fan[coralColor.getMetadata()] = new BlockNetherDoublePlantBase(coralColor, "sea_fan");
+            dead_sea_fan[coralColor.getMetadata()] = new BlockNetherDoublePlantBase(coralColor, "dead_sea_fan");*/
+
+            brainCoralFence[coralColor.getMetadata()] = new BlockModFence(Material.CORAL, MOD_ID, coralColor.getName() + "_brain_coral").setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+
+            /*brainCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_brain_coral_stairs", brain_coral[coralColor.getMetadata()].getDefaultState());
+            deadBrainCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_dead_brain_coral_stairs", dead_brain_coral[coralColor.getMetadata()].getDefaultState());
+            coralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_coral_stairs", normal_coral[coralColor.getMetadata()].getDefaultState());
+            deadCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_dead_coral_stairs", dead_normal_coral[coralColor.getMetadata()].getDefaultState());
+
+            BlockModStairs.initStairs(brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) brainCoralStair[coralColor.getMetadata()]);
+            BlockModStairs.initStairs(dead_brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) deadBrainCoralStair[coralColor.getMetadata()]);
+            BlockModStairs.initStairs(normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) coralStair[coralColor.getMetadata()]);
+            BlockModStairs.initStairs(dead_normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) deadCoralStair[coralColor.getMetadata()]);*/
+
+            /*brainCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_brain_coral_slab", Material.CORAL, false);
+            deadBrainCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_brain_coral_slab", Material.CORAL, false);
+            coralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_coral_slab", Material.CORAL, false);
+            deadCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_coral_slab", Material.CORAL, false);
+
+            brainCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_brain_coral_slab", Material.CORAL, true);
+            deadBrainCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_brain_coral_slab", Material.CORAL, true);
+            coralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_coral_slab", Material.CORAL, true);
+            deadCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_coral_slab", Material.CORAL, true);
+
+            BlockModSlab.initSlab(brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) brainCoralSlab[coralColor.getMetadata()], (BlockModSlab) brainCoralSlabDouble[coralColor.getMetadata()]);
+            BlockModSlab.initSlab(dead_brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) deadBrainCoralSlab[coralColor.getMetadata()], (BlockModSlab) deadBrainCoralSlabDouble[coralColor.getMetadata()]);
+            BlockModSlab.initSlab(normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) coralSlab[coralColor.getMetadata()], (BlockModSlab) coralSlabDouble[coralColor.getMetadata()]);
+            BlockModSlab.initSlab(dead_normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) deadCoralSlab[coralColor.getMetadata()], (BlockModSlab) deadCoralSlabDouble[coralColor.getMetadata()]);*/
+        }
+        for (EnumAquamarineVariants aquamarineVariants : EnumAquamarineVariants.values()) {
+            aquamarine[aquamarineVariants.ordinal()] = new BlockOverworldBase(Material.ROCK, aquamarineVariants.getName());
+            /*aquamarineStairs[aquamarineVariants.ordinal()] = new BlockOverworldStairBase(aquamarineVariants.getName() aquamarine[aquamarineVariants.ordinal()].getDefaultState());
+            BlockModStairs.initStairs(aquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModStairs) aquamarineStairs[aquamarineVariants.ordinal()]);*/
+            aquamarineSlabs[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_slab", Material.ROCK, false);
+            aquamarineSlabsDouble[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_slab", Material.ROCK, true);
+            BlockModSlab.initSlab(aquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModSlab) aquamarineSlabs[aquamarineVariants.ordinal()], (BlockModSlab) aquamarineSlabsDouble[aquamarineVariants.ordinal()]);
+        }
+        for (EnumNaturalAquamarineVariants naturalAquamarineVariants : EnumNaturalAquamarineVariants.values()) {
+            naturalAquamarine[naturalAquamarineVariants.getID()] = new BlockOverworldBase(Material.ROCK, naturalAquamarineVariants.getName());
+            /*naturalAquamarineStairs[naturalAquamarineVariants.getID()] = new BlockOverworldStairBase(naturalAquamarineVariants.getName(), naturalAquamarine[naturalAquamarineVariants.getID()].getDefaultState());
+            BlockModStairs.initStairs(naturalAquamarine[naturalAquamarineVariants.getID()], naturalAquamarineVariants.getID(), (BlockModStairs) naturalAquamarineStairs[naturalAquamarineVariants.getID()]);*/
+            naturalAquamarineSlabs[naturalAquamarineVariants.getID()] = new BlockOverworldSlabBase(naturalAquamarineVariants.getName() + "_slab", Material.ROCK, false);
+            naturalAquamarineSlabsDouble[naturalAquamarineVariants.getID()] = new BlockOverworldSlabBase(naturalAquamarineVariants.getName() + "_slab", Material.ROCK, true);
+            BlockModSlab.initSlab(naturalAquamarine[naturalAquamarineVariants.getID()], naturalAquamarineVariants.getID(), (BlockModSlab) naturalAquamarineSlabs[naturalAquamarineVariants.getID()], (BlockModSlab) naturalAquamarineSlabsDouble[naturalAquamarineVariants.getID()]);
+        }
+        for (EnumCoralTypes coralTypes : EnumCoralTypes.values()) {
+            coralPlants[coralTypes.getID()] = new BlockCoralPlantBase(coralTypes.getName());
+        }
+        dried_kelp_block = new BlockOverworldBase(Material.LEAVES, "dried_kelp_block");
+        prismarineChest = new BlockCustomChest("prismarine_chest", BlockChest.Type.BASIC);
+        prismarineChestTrap = new BlockCustomChest("prismarine_chest_trap", BlockChest.Type.TRAP);
+
+        //Wood Blocks
+        customChest = new BlockCustomChest("wooden_chest", CUSTOM_TYPE_QUARK);
+        customChestTrap = new BlockCustomChest("wooden_chest_trap", CUSTOM_TYPE_QUARK_TRAP);
+        for (EnumWoodType type : EnumWoodType.values()) {
+            custom_bookshelf = new BlockCustomBookshelf(type.getName());
+        }
+        spruce_trapdoor = new BlockModTrapdoor("spruce_trapdoor");
+        birch_trapdoor = new BlockModTrapdoor("birch_trapdoor");
+        jungle_trapdoor = new BlockModTrapdoor("jungle_trapdoor");
+        acacia_trapdoor = new BlockModTrapdoor("acacia_trapdoor");
+        dark_oak_trapdoor = new BlockModTrapdoor("dark_oak_trapdoor");
+        Blocks.TRAPDOOR.setUnlocalizedName("oak_trapdoor");
+
+        // Nether Blocks
+        for (EnumNetherBlocks netherBlockTypes : EnumNetherBlocks.values()) {
+            netherBlocks[netherBlockTypes.getMetadata()] = new BlockNetherBase(Material.ROCK, netherBlockTypes.getName());
+        }
+        for (EnumSoulStoneTypes soulStoneTypes : EnumSoulStoneTypes.values()) {
+            soulStone[soulStoneTypes.getMetadata()] = new BlockSoulStone(soulStoneTypes.getName());
+            soulStoneSlabs[soulStoneTypes.getMetadata()] = new BlockNetherSlabBase(soulStoneTypes.getName() + "_slab", false);
+            soulStoneSlabsDouble[soulStoneTypes.getMetadata()] = new BlockNetherSlabBase(soulStoneTypes.getName() + "_slab", true);
+            BlockModSlab.initSlab(soulStone[soulStoneTypes.getMetadata()], soulStoneTypes.getMetadata(), (BlockModSlab) soulStoneSlabs[soulStoneTypes.getMetadata()], (BlockModSlab) soulStoneSlabsDouble[soulStoneTypes.getMetadata()]);
+        }
+        for (EnumGlowingNetherBlocks enumGlowingNetherBlocks : EnumGlowingNetherBlocks.values()) {
+            glowingNetherBlocks[enumGlowingNetherBlocks.getMetadata()] = new BlockNetherGlowingBase(Material.GLASS, enumGlowingNetherBlocks.getName());
+        }
+        for (EnumNetherPlantTypes netherPlantTypes : EnumNetherPlantTypes.values()) {
+            netherPlants[netherPlantTypes.getID()] = new BlockNetherPlantBase(netherPlantTypes.getName());
+        }
+        for (EnumTallNetherPlantTypes netherPlantTypes : EnumTallNetherPlantTypes.values()) {
+            tallNetherPlants[netherPlantTypes.getID()] = new BlockNetherDoublePlantBase(netherPlantTypes.getName());
+        }
+        netherGlass = new BlockGlassBase("nether_glass").setCreativeTab(Main.NETHER_EXPANSION_TAB);
+        soulGlass = new BlockGlassBase("soul_glass").setCreativeTab(Main.NETHER_EXPANSION_TAB);
+        netherRod = new BlockRodBase("nether_rod", Main.NETHER_EXPANSION_TAB);
+        netherSponge = new BlockNetherSponge();
+
+        // New Stone Blocks
+        for (EnumNewStoneVariants newStoneVariant : EnumNewStoneVariants.values()) {
+            newStoneVariants[newStoneVariant.getMetadata()] = new BlockOverworldBase(Material.ROCK, newStoneVariant.getName());
+            newStoneVariantStairs[newStoneVariant.getMetadata()] = new BlockOverworldStairBase(newStoneVariant.getName() + "_stairs", newStoneVariants[newStoneVariant.getMetadata()].getDefaultState());
+            BlockModStairs.initStairs(newStoneVariants[newStoneVariant.getMetadata()], newStoneVariant.getMetadata(), (BlockModStairs) newStoneVariantStairs[newStoneVariant.getMetadata()]);
+            newStoneVariantSlabs[newStoneVariant.getMetadata()] = new BlockOverworldSlabBase(newStoneVariant.getName() + "_slab", Material.ROCK, false);
+            newStoneVariantSlabsDouble[newStoneVariant.getMetadata()] = new BlockOverworldSlabBase(newStoneVariant.getName() + "_slab", Material.ROCK, true);
+            BlockModSlab.initSlab(newStoneVariants[newStoneVariant.getMetadata()], newStoneVariant.getMetadata(), (BlockModSlab) newStoneVariantSlabs[newStoneVariant.getMetadata()], (BlockModSlab) newStoneVariantSlabsDouble[newStoneVariant.getMetadata()]);
+        }
+
+        // Frosted versions of vanilla stones & dirt
+        for (EnumFrostedStoneVariants frostedStoneVariants : EnumFrostedStoneVariants.values()) {
+            frostedStones[frostedStoneVariants.getMetadata()] = new BlockOverworldBase(Material.ROCK, frostedStoneVariants.getName());
+            frostedStonesSlabs[frostedStoneVariants.getMetadata()] = new BlockOverworldSlabBase(frostedStoneVariants.getName() + "_slab", Material.ICE, false);
+            frostedStonesSlabsDouble[frostedStoneVariants.getMetadata()] = new BlockOverworldSlabBase(frostedStoneVariants.getName() + "_slab", Material.ICE, true);
+            BlockModSlab.initSlab(frostedStones[frostedStoneVariants.getMetadata()], frostedStoneVariants.getMetadata(), (BlockModSlab) frostedStonesSlabs[frostedStoneVariants.getMetadata()], (BlockModSlab) frostedStonesSlabsDouble[frostedStoneVariants.getMetadata()]);
+        }
+        for (EnumFrostedDirtVariants frostedDirtVariants : EnumFrostedDirtVariants.values()) {
+            frostedDirts[frostedDirtVariants.getMetadata()] = new BlockOverworldBase(Material.ROCK, frostedDirtVariants.getName());
+            frostedDirtSlabs[frostedDirtVariants.getMetadata()] = new BlockOverworldSlabBase(frostedDirtVariants.getName() + "_slab", Material.ICE, false);
+            frostedDirtSlabsDouble[frostedDirtVariants.getMetadata()] = new BlockOverworldSlabBase(frostedDirtVariants.getName() + "_slab", Material.ICE, true);
+            BlockModSlab.initSlab(newStoneVariants[frostedDirtVariants.getMetadata()], frostedDirtVariants.getMetadata(), (BlockModSlab) frostedDirtSlabs[frostedDirtVariants.getMetadata()], (BlockModSlab) frostedDirtSlabsDouble[frostedDirtVariants.getMetadata()]);
+        }
+        for (EnumDyeColor dyeColor : EnumDyeColor.values()) {
+            frostedClay[dyeColor.getMetadata()] = new BlockOverworldBase(Material.ROCK, "frosted_" + dyeColor.getName() + "_terracotta");
+            frostedClaySlabs[dyeColor.getMetadata()] = new BlockOverworldSlabBase("frosted_" + dyeColor.getName() + "_terracotta_slab", Material.ICE, false);
+            frostedClaySlabsDouble[dyeColor.getMetadata()] = new BlockOverworldSlabBase("frosted_" + dyeColor.getName() + "_terracotta_slab", Material.ICE, true);
+            BlockModSlab.initSlab(newStoneVariants[dyeColor.getMetadata()], dyeColor.getMetadata(), (BlockModSlab) frostedClaySlabs[dyeColor.getMetadata()], (BlockModSlab) frostedClaySlabsDouble[dyeColor.getMetadata()]);
+            pots[dyeColor.getMetadata()] = new BlockColoredVase(EnumDyeColor.byMetadata(dyeColor.getMetadata()));
+        }
+
+        // New stairs & slabs and also new colored blocks
+        for (EnumDyeColor color : EnumDyeColor.values()) {
+            /*terracottaStairs[color.getMetadata()] = new BlockOverworldStairBase(color.getName() + "_terracotta_stairs", Blocks.STAINED_HARDENED_CLAY.getDefaultState());
+            BlockModStairs.initStairs(Blocks.STAINED_HARDENED_CLAY, color.getMetadata(), (BlockModStairs) terracottaStairs[color.getMetadata()]);
+            woolStairs[color.getMetadata()] = new BlockOverworldStairBase(color.getName() + "_wool_stairs", Blocks.WOOL.getDefaultState());
+            BlockModStairs.initStairs(Blocks.WOOL, color.getMetadata(), (BlockModStairs) woolStairs[color.getMetadata()]);
+            glazedTerracottaStairs[color.getMetadata()] = new BlockOverworldStairBase(color.getName() + "_glazed_terracotta_stairs", Block.getBlockFromName("minecraft:" + color.getName() + "_glazed_terracotta").getDefaultState());
+            BlockModStairs.initStairs(Block.getBlockFromName("minecraft:" + color.getName() + "_glazed_terracotta"), color.getMetadata(), (BlockModStairs) glazedTerracottaStairs[color.getMetadata()]);
+            coloredGlassStairs[color.getMetadata()] = new BlockOverworldStairBase(color.getName() + "_glass_stairs", Blocks.STAINED_GLASS.getDefaultState());
+            BlockModStairs.initStairs(Blocks.STAINED_GLASS, color.getMetadata(), (BlockModStairs) coloredGlassStairs[color.getMetadata()]);
+            terracottaSlabs[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_terracotta_slab", Material.ROCK, false);
+            terracottaSlabsDouble[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_terracotta_slab", Material.ROCK, true);
+            BlockModSlab.initSlab(Blocks.STAINED_HARDENED_CLAY, color.getMetadata(), (BlockModSlab) terracottaSlabs[color.getMetadata()], (BlockModSlab) terracottaSlabsDouble[color.getMetadata()]);
+            woolSlabs[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_wool_slab", Material.CLOTH, false);
+            woolSlabsDouble[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_wool_slab", Material.CLOTH, true);
+            BlockModSlab.initSlab(Blocks.WOOL, color.getMetadata(), (BlockModSlab) woolSlabs[color.getMetadata()], (BlockModSlab) woolSlabsDouble[color.getMetadata()]);
+            glazedTerracottaSlabs[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_glazed_terracotta_slab", Material.ROCK, false);
+            glazedTerracottaSlabsDouble[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_glazed_terracotta_slab", Material.ROCK, true);
+            BlockModSlab.initSlab(Block.getBlockFromName("minecraft:" + color.getName() + "_glazed_terracotta"), color.getMetadata(), (BlockModSlab) glazedTerracottaSlabs[color.getMetadata()], (BlockModSlab) glazedTerracottaSlabsDouble[color.getMetadata()]);
+            coloredGlassSlabs[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_glass_slab", Material.GLASS, false);
+            coloredGlassSlabsDouble[color.getMetadata()] = new BlockOverworldSlabBase(color.getName() + "_glass_slab", Material.GLASS, true);
+            BlockModSlab.initSlab(Blocks.STAINED_GLASS, color.getMetadata(), (BlockModSlab) coloredGlassSlabs[color.getMetadata()], (BlockModSlab) coloredGlassSlabsDouble[color.getMetadata()]);*/
+            coloredSand[color.getMetadata()] = new BlockColoredAlt(MOD_ID, "sand", color);
+            /*coloredCandles[color.getMetadata()] = new BlockColoredLightSourceWithParticlesAlt(MOD_ID, "candles", color);
+            coloredLanterns[color.getMetadata()] = new BlockColoredLightSourceWithParticlesAlt(MOD_ID, "lanterns", color);
+            coloredRedstoneLamp[color.getMetadata()] = new BlockColoredRedstoneLamp(color);*/
+        }
+        floorTile = new BlockFloorTile();
+        /*hardened_clay_tiles = new BlockHardenedClayTiles();
+
+        BlockModStairs.initStairs(hardened_clay_tiles, 0, new BlockHardenedClayTilesStairs());
+        BlockModSlab.initSlab(hardened_clay_tiles, 0, new BlockHardenedClayTilesSlab(false), new BlockHardenedClayTilesSlab(true));
+
+        stained_clay_tiles = new BlockStainedClayTiles();
+
+        for(BlockStainedClayTiles.Variants variant : BlockStainedClayTiles.Variants.class.getEnumConstants())
+            BlockModStairs.initStairs(stained_clay_tiles, variant.ordinal(), new BlockStainedClayTilesStairs(variant));
+        for(BlockStainedClayTiles.Variants variant : BlockStainedClayTiles.Variants.class.getEnumConstants())
+            BlockModSlab.initSlab(stained_clay_tiles, variant.ordinal(), new BlockStainedClayTilesSlab(variant, false), new BlockStainedClayTilesSlab(variant, true));
+
+        stained_planks = new BlockStainedPlanks();
+
+        for(BlockStainedPlanks.Variants variant : BlockStainedPlanks.Variants.class.getEnumConstants())
+            BlockModStairs.initStairs(stained_planks, variant.ordinal(), new BlockStainedPlanksStairs(variant));
+        for(BlockStainedPlanks.Variants variant : BlockStainedPlanks.Variants.class.getEnumConstants())
+            BlockModSlab.initSlab(stained_planks, variant.ordinal(), new BlockStainedPlanksSlab(variant, false), new BlockStainedPlanksSlab(variant, true));*/
+
+        /*add("stone", Blocks.STONE, 0, false, true, stone);
+        add("stone_granite", Blocks.STONE, 1, granite);
+        add("stone_diorite", Blocks.STONE, 3, diorite);
+        add("stone_andesite", Blocks.STONE, 5, andesite);
+        add("end_bricks", Blocks.END_BRICKS, 0, endBricks);
+        add("prismarine", Blocks.PRISMARINE, 0, prismarine);
+        add("prismarine_bricks", Blocks.PRISMARINE, 1, prismarineBricks);
+        add("prismarine_dark", Blocks.PRISMARINE, 2, darkPrismarine);
+        add("red_nether_brick", Blocks.RED_NETHER_BRICK, 0, redNetherBricks);
+
+        addWall("stone", Blocks.STONE, 0, stone);
+        addWall("stone_granite", Blocks.STONE, 1, granite);
+        addWall("stone_diorite", Blocks.STONE, 3, diorite);
+        addWall("stone_andesite", Blocks.STONE, 5, andesite);
+        addWall("sandstone", Blocks.SANDSTONE, 0, sandstone);
+        addWall("red_sandstone", Blocks.RED_SANDSTONE, 0, redSandstone);
+        addWall("stonebrick", Blocks.STONEBRICK, 0, stoneBricks);
+        addWall("brick", Blocks.BRICK_BLOCK, 0, bricks);
+        addWall("quartz", Blocks.QUARTZ_BLOCK, 0, quartz);
+        addWall("prismarine_rough", Blocks.PRISMARINE, 0, prismarine);
+        addWall("prismarine_bricks", Blocks.PRISMARINE, 1, prismarineBricks);
+        addWall("dark_prismarine", Blocks.PRISMARINE, 2, darkPrismarine);
+        addWall("purpur_block", Blocks.PURPUR_BLOCK, 0, purpurBlock);
+        addWall("end_bricks", Blocks.END_BRICKS, 0, endBricks);*/
+
+        glowingGrass = new BlockGlowingGrass();
+
+        stoneAnvil = new BlockModAnvil("stone_anvil", Main.OVERWORLD_EXPANSION_TAB);
+        carbonAnvil = new BlockModAnvil("carbon_anvil", Main.OVERWORLD_EXPANSION_TAB);
+        goldenAnvil = new BlockModAnvil("golden_anvil", Main.OVERWORLD_EXPANSION_TAB);
+        marbleAnvil = new BlockModAnvil("marble_anvil", Main.OVERWORLD_EXPANSION_TAB);
+        ironAnvil = new BlockModAnvil("iron_anvil", Main.OVERWORLD_EXPANSION_TAB);
+
+        stoneCauldron = new BlockModCauldron("stone_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        carbonCauldron = new BlockModCauldron("carbon_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        goldenCauldron = new BlockModCauldron("golden_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        marbleCauldron = new BlockModCauldron("marble_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        ironCauldron = new BlockModCauldron("iron_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        glassCauldron = new BlockModCauldron("glass_cauldron", Main.OVERWORLD_EXPANSION_TAB);
+        craftingTable = new BlockWorkbench();
+    }
+
+    @SubscribeEvent
+    public static void registerBlocks(RegistryEvent.Register<Block> event) {
+
+    }
+
+    private static void registerBlock(String name, String textureName) {
+        JsonGenerator.genBlock(MOD_ID, name, textureName);
+    }
+
+    private static void registerRecipe(String name, boolean isShaped, String row1, String row2, String row3, String[] keys, String[] values, int[] data, String result, String group, int resultCount) {
+        JsonGenerator.genRecipe(MOD_ID, name, isShaped, row1, row2, row3, keys, values, data, result, group, resultCount);
+    }
+
+    private static void registeChiselVariants(String group, Block block) {
+        ModIntegrationHandler.registerChiselVariant(group, ProxyRegistry.newStack(block, 1, 0));
+    }
+
+    public static void add(String name, Block block, int meta) {
+        add(name, block, meta, true, true);
+    }
+
+    public static void add(String name, Block block, int meta, boolean slab, boolean stairs) {
+        IBlockState state = block.getStateFromMeta(meta);
+        String stairsName = name;
+        String slabName = name;
+
+        if (stairs)
+            BlockModStairs.initStairs(block, meta, new BlockOverworldStairBase(stairsName, state));
+        if (slab)
+            BlockModSlab.initSlab(block, meta, new BlockOverworldSlabBase(slabName, block.getMaterial(state), false), new BlockOverworldSlabBase(slabName, block.getMaterial(state), true));
+    }
+
+    public static void addWall(String name, Block block, int meta) {
+        addWall(name, block, meta, BlockModWall::new);
+    }
+
+    public static void addWall(String name, Block block, int meta, WallSupplier supplier) {
+        IBlockState state = block.getStateFromMeta(meta);
+        String wallName = name + "_wall";
+        BlockModWall.initWall(block, meta, supplier.supply(wallName, state));
+    }
+
+    public interface WallSupplier {
+        BlockModWall supply(String wallName, IBlockState state);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockChorusMossEndStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockChorusMossEndStone.java	(date 1524853000000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockChorusMossEndStone.java	(date 1524853000000)
@@ -0,0 +1,136 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import eex.handler.ConfigHandler;
+import eex.init.EndExBlocks;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+public class BlockChorusMossEndStone extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockChorusMossEndStone()
+    {
+        super("end_stone_chorus_moss", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+        setTickRandomly(ConfigHandler.blockConfig.chorusMoss.doesSpread);
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public BlockRenderLayer getBlockLayer()
+    {
+        return BlockRenderLayer.CUTOUT_MIPPED;
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public void updateTick(World world, BlockPos pos, IBlockState state, Random rand)
+    {
+        if(!world.isRemote)
+        {
+            IBlockState setState = getMetaFromState(state) == 0 ? Blocks.END_STONE.getDefaultState() : EndExBlocks.END_STONE.getDefaultState().withProperty(BlockEndStone.TYPE, BlockEndStone.EnumType.fromMeta(getMetaFromState(state) - 1));
+
+            if(world.getLightFromNeighbors(pos.up()) < 4 && world.getBlockState(pos.up()).getLightOpacity(world, pos.up()) > 2)
+            {
+                world.setBlockState(pos, setState);
+            }
+            else
+            {
+                if(world.getLightFromNeighbors(pos.up()) >= 9)
+                {
+                    for(int i = 0; i < 4; ++i)
+                    {
+                        BlockPos newPos = pos.add(rand.nextInt(3) - 1, rand.nextInt(5) - 3, rand.nextInt(3) - 1);
+
+                        if(newPos.getY() >= 0 && newPos.getY() < 256 && !world.isBlockLoaded(newPos))
+                        {
+                            return;
+                        }
+
+                        IBlockState checkState = world.getBlockState(newPos);
+
+                        if(checkState.getBlock() == setState && world.getLightFromNeighbors(newPos.up()) >= 0)
+                        {
+                            world.setBlockState(newPos, getDefaultState().withProperty(TYPE, EnumType.fromMeta(getMetaFromState(state))));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/util/idk/RomanNumberHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/RomanNumberHelper.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/util/idk/RomanNumberHelper.java	(date 1525606900000)
@@ -0,0 +1,35 @@
+package net.hdt.neutronia.util.idk;
+
+import java.util.TreeMap;
+
+public class RomanNumberHelper {
+
+    private final static TreeMap<Integer, String> map = new TreeMap<Integer, String>();
+
+    static {
+
+        map.put(1000, "M");
+        map.put(900, "CM");
+        map.put(500, "D");
+        map.put(400, "CD");
+        map.put(100, "C");
+        map.put(90, "XC");
+        map.put(50, "L");
+        map.put(40, "XL");
+        map.put(10, "X");
+        map.put(9, "IX");
+        map.put(5, "V");
+        map.put(4, "IV");
+        map.put(1, "I");
+
+    }
+
+    public final static String toRoman(int number) {
+        int l = map.floorKey(number);
+        if (number == l) {
+            return map.get(number);
+        }
+        return map.get(l) + toRoman(number - l);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderDrowned.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderDrowned.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderDrowned.java	(date 1525606862000)
@@ -0,0 +1,32 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityDrowned;
+import net.hdt.neutronia.entity.render.layer.LayerDrownedOuter;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class RenderDrowned extends RenderBiped<EntityDrowned> {
+
+    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation("neutronia:textures/entity/drowned/drowned.png");
+
+    public RenderDrowned(RenderManager rendermanagerIn) {
+        super(rendermanagerIn, new ModelZombie(), 0.5F);
+        this.addLayer(new LayerDrownedOuter(this));
+    }
+
+    @Override
+    protected boolean setBrightness(EntityDrowned entitylivingbaseIn, float partialTicks, boolean combineTextures) {
+        return true;
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityDrowned entity) {
+        return MUMMY_TEXTURE;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterBlockBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterBlockBase.java	(date 1524926042000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockColoredWaterBlockBase.java	(date 1524926042000)
@@ -0,0 +1,80 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.properties.EnumCoralColor;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.Item;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+public class BlockColoredWaterBlockBase extends BlockMod {
+
+    private final EnumCoralColor color;
+
+    public BlockColoredWaterBlockBase(EnumCoralColor colorIn, String name) {
+        super(Material.CORAL, Reference.MOD_ID, colorIn + "_" + name);
+        this.color = colorIn;
+        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public static EnumCoralColor getColorFromItem(Item itemIn) {
+        return getColorFromBlock(Block.getBlockFromItem(itemIn));
+    }
+
+    @SideOnly(Side.CLIENT)
+    private static EnumCoralColor getColorFromBlock(Block blockIn) {
+        return blockIn instanceof BlockColoredWaterBlockBase ? ((BlockColoredWaterBlockBase) blockIn).getColor() : EnumCoralColor.BLUE;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        switch (face) {
+            case DOWN:
+                return false;
+            case UP:
+                return isWater(world, pos.add(0, 1, 0));
+            case NORTH:
+                return isWater(world, pos.add(0, 0, -1));
+            case SOUTH:
+                return isWater(world, pos.add(0, 0, 1));
+            case EAST:
+                return isWater(world, pos.add(1, 0, 0));
+            case WEST:
+                return isWater(world, pos.add(-1, 0, 0));
+        }
+        return false;
+    }
+
+    private boolean isWater(IBlockAccess world, BlockPos pos) {
+        return world.getBlockState(pos).getMaterial() == Material.WATER;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public EnumCoralColor getColor() {
+        return this.color;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBlackDesert.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBlackDesert.java	(date 1523988246000)
+++ src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBlackDesert.java	(date 1523988246000)
@@ -0,0 +1,50 @@
+package net.hdt.neutronia.world.biome.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.minecraft.entity.monster.EntityHusk;
+import net.minecraft.entity.monster.EntityZombie;
+import net.minecraft.entity.monster.EntityZombieVillager;
+import net.minecraft.entity.passive.EntityRabbit;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.chunk.ChunkPrimer;
+
+import java.util.Random;
+
+public class BiomeBlackDesert extends Biome {
+
+    public BiomeBlackDesert() {
+        super((new BiomeProperties("Black Desert")).setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled());
+        this.decorator.generateFalls = false;
+        this.decorator.treesPerChunk = -999;
+        this.decorator.flowersPerChunk = -999;
+        this.decorator.grassPerChunk = 4;
+        this.decorator.reedsPerChunk = 2;
+        this.decorator.cactiPerChunk = 1;
+
+        this.spawnableCreatureList.clear();
+        this.spawnableCreatureList.add(new Biome.SpawnListEntry(EntityRabbit.class, 4, 2, 3));
+
+        this.spawnableMonsterList.removeIf(biome$spawnlistentry -> biome$spawnlistentry.entityClass == EntityZombie.class || biome$spawnlistentry.entityClass == EntityZombieVillager.class);
+
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombie.class, 19, 4, 4));
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombieVillager.class, 1, 1, 1));
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityHusk.class, 80, 4, 4));
+    }
+
+    @Override
+    public void genTerrainBlocks(World worldIn, Random rand, ChunkPrimer chunkPrimerIn, int x, int z, double noiseVal) {
+        if (noiseVal > 1.9D) {
+            this.topBlock = Blocks.GRAVEL.getDefaultState();
+            this.fillerBlock = Blocks.GRAVEL.getDefaultState();
+        } else {
+            this.topBlock = HMBlocks.coloredSand[EnumDyeColor.BLACK.getMetadata()].getDefaultState();
+            this.fillerBlock = HMBlocks.coloredSand[EnumDyeColor.BLACK.getMetadata()].getDefaultState();
+        }
+
+        this.generateBiomeTerrain(worldIn, rand, chunkPrimerIn, x, z, noiseVal);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceAlt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceAlt.java	(date 1524550118000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceAlt.java	(date 1524550118000)
@@ -0,0 +1,13 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.item.EnumDyeColor;
+
+public class BlockColoredLightSourceAlt extends BlockColoredAlt {
+
+    public BlockColoredLightSourceAlt(String modid, String name, EnumDyeColor color) {
+        super(modid, name, color);
+        this.setTickRandomly(true);
+        setLightLevel(1.0F);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/idk/TimeHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/TimeHelper.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/util/idk/TimeHelper.java	(date 1525606898000)
@@ -0,0 +1,25 @@
+package net.hdt.neutronia.util.idk;
+
+public class TimeHelper {
+
+    public static final int SECOND = 20;
+    public static final int MINUTE = SECOND * 60;
+    public static final int HOUR = MINUTE * 60;
+    public static final int DAY = HOUR * 24;
+
+    public static String getTime(int ticks) {
+        int days = (ticks - (ticks % DAY)) / DAY;
+        ticks -= days * DAY;
+        int hours = (ticks - (ticks % HOUR)) / HOUR;
+        ticks -= hours * HOUR;
+        int minutes = (ticks - (ticks % MINUTE)) / MINUTE;
+        ticks -= minutes * MINUTE;
+        int seconds = (ticks - (ticks % SECOND)) / SECOND;
+
+        return (days > 0 ? days + " Day" + (days > 1 ? "s" : "") + ((hours > 0 || minutes > 0 || seconds > 0) ? ", " : "") : "") +
+                (hours > 0 ? hours + " Hour" + (hours > 1 ? "s" : "") + ((minutes > 0 || seconds > 0) ? ", " : "") : "") +
+                (minutes > 0 ? minutes + " Minute" + (minutes > 1 ? "s" : "") + ((seconds > 0) ? ", " : "") : "") +
+                (seconds > 0 ? seconds + " Second" + (seconds > 1 ? "s" : "") : "");
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/ai/PathNavigateAmphibious.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/PathNavigateAmphibious.java	(date 1525606871000)
+++ src/main/java/net/hdt/neutronia/entity/ai/PathNavigateAmphibious.java	(date 1525606871000)
@@ -0,0 +1,280 @@
+package net.hdt.neutronia.entity.ai;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.init.Blocks;
+import net.minecraft.pathfinding.*;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+
+public class PathNavigateAmphibious extends PathNavigate {
+    private boolean shouldAvoidSun;
+
+    public PathNavigateAmphibious(EntityLiving entitylivingIn, World worldIn) {
+        super(entitylivingIn, worldIn);
+        this.nodeProcessor.setCanSwim(true);
+    }
+
+    protected PathFinder getPathFinder() {
+        this.nodeProcessor = new WalkNodeProcessor();
+        this.nodeProcessor.setCanEnterDoors(true);
+        this.nodeProcessor.setCanSwim(true);
+        return new PathFinder(this.nodeProcessor);
+    }
+
+    /**
+     * If on ground or swimming and can swim
+     */
+    protected boolean canNavigate() {
+        return this.entity.onGround || this.getCanSwim() && this.isInLiquid() || this.entity.isRiding();
+    }
+
+    protected Vec3d getEntityPosition() {
+        return new Vec3d(this.entity.posX, this.entity.posY, this.entity.posZ);
+    }
+
+    /**
+     * Returns path to given BlockPos
+     */
+    public Path getPathToPos(BlockPos pos) {
+        if (this.world.getBlockState(pos).getMaterial() == Material.AIR) {
+            BlockPos blockpos;
+
+            for (blockpos = pos.down(); blockpos.getY() > 0 && this.world.getBlockState(blockpos).getMaterial() == Material.AIR; blockpos = blockpos.down()) {
+            }
+
+            if (blockpos.getY() > 0) {
+                return super.getPathToPos(blockpos.up());
+            }
+
+            while (blockpos.getY() < this.world.getHeight() && this.world.getBlockState(blockpos).getMaterial() == Material.AIR) {
+                blockpos = blockpos.up();
+            }
+
+            pos = blockpos;
+        }
+
+        if (!this.world.getBlockState(pos).getMaterial().isSolid()) {
+            return super.getPathToPos(pos);
+        } else {
+            BlockPos blockpos1;
+
+            for (blockpos1 = pos.up(); blockpos1.getY() < this.world.getHeight() && this.world.getBlockState(blockpos1).getMaterial().isSolid(); blockpos1 = blockpos1.up()) {
+            }
+
+            return super.getPathToPos(blockpos1);
+        }
+    }
+
+    /**
+     * Returns the path to the given EntityLiving. Args : entity
+     */
+    public Path getPathToEntityLiving(Entity entityIn) {
+        return this.getPathToPos(new BlockPos(entityIn));
+    }
+
+    /**
+     * Gets the safe pathing Y position for the entity depending on if it can path swim or not
+     */
+    private int getPathablePosY() {
+        if (false) {
+            int i = (int) this.entity.getEntityBoundingBox().minY;
+            Block block = this.world.getBlockState(new BlockPos(MathHelper.floor(this.entity.posX), i, MathHelper.floor(this.entity.posZ))).getBlock();
+            int j = 0;
+
+            while (block == Blocks.FLOWING_WATER || block == Blocks.WATER) {
+                ++i;
+                block = this.world.getBlockState(new BlockPos(MathHelper.floor(this.entity.posX), i, MathHelper.floor(this.entity.posZ))).getBlock();
+                ++j;
+
+                if (j > 16) {
+                    return (int) this.entity.getEntityBoundingBox().minY;
+                }
+            }
+
+            return i;
+        } else {
+            return (int) (this.entity.getEntityBoundingBox().minY + 0.5D);
+        }
+    }
+
+    /**
+     * Trims path data from the end to the first sun covered block
+     */
+    protected void removeSunnyPath() {
+        super.removeSunnyPath();
+
+        if (this.shouldAvoidSun) {
+            if (this.world.canSeeSky(new BlockPos(MathHelper.floor(this.entity.posX), (int) (this.entity.getEntityBoundingBox().minY + 0.5D), MathHelper.floor(this.entity.posZ)))) {
+                return;
+            }
+
+            for (int i = 0; i < this.currentPath.getCurrentPathLength(); ++i) {
+                PathPoint pathpoint = this.currentPath.getPathPointFromIndex(i);
+
+                if (this.world.canSeeSky(new BlockPos(pathpoint.x, pathpoint.y, pathpoint.z))) {
+                    this.currentPath.setCurrentPathLength(i - 1);
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks if the specified entity can safely walk to the specified location.
+     */
+    protected boolean isDirectPathBetweenPoints(Vec3d posVec31, Vec3d posVec32, int sizeX, int sizeY, int sizeZ) {
+        int i = MathHelper.floor(posVec31.x);
+        int j = MathHelper.floor(posVec31.z);
+        double d0 = posVec32.x - posVec31.x;
+        double d1 = posVec32.z - posVec31.z;
+        double d2 = d0 * d0 + d1 * d1;
+
+        if (d2 < 1.0E-8D) {
+            return false;
+        } else {
+            double d3 = 1.0D / Math.sqrt(d2);
+            d0 = d0 * d3;
+            d1 = d1 * d3;
+            sizeX = sizeX + 2;
+            sizeZ = sizeZ + 2;
+
+            if (!this.isSafeToStandAt(i, (int) posVec31.y, j, sizeX, sizeY, sizeZ, posVec31, d0, d1)) {
+                return false;
+            } else {
+                sizeX = sizeX - 2;
+                sizeZ = sizeZ - 2;
+                double d4 = 1.0D / Math.abs(d0);
+                double d5 = 1.0D / Math.abs(d1);
+                double d6 = (double) i - posVec31.x;
+                double d7 = (double) j - posVec31.z;
+
+                if (d0 >= 0.0D) {
+                    ++d6;
+                }
+
+                if (d1 >= 0.0D) {
+                    ++d7;
+                }
+
+                d6 = d6 / d0;
+                d7 = d7 / d1;
+                int k = d0 < 0.0D ? -1 : 1;
+                int l = d1 < 0.0D ? -1 : 1;
+                int i1 = MathHelper.floor(posVec32.x);
+                int j1 = MathHelper.floor(posVec32.z);
+                int k1 = i1 - i;
+                int l1 = j1 - j;
+
+                while (k1 * k > 0 || l1 * l > 0) {
+                    if (d6 < d7) {
+                        d6 += d4;
+                        i += k;
+                        k1 = i1 - i;
+                    } else {
+                        d7 += d5;
+                        j += l;
+                        l1 = j1 - j;
+                    }
+
+                    if (!this.isSafeToStandAt(i, (int) posVec31.y, j, sizeX, sizeY, sizeZ, posVec31, d0, d1)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+        }
+    }
+
+    /**
+     * Returns true when an entity could stand at a position, including solid blocks under the entire entity.
+     */
+    private boolean isSafeToStandAt(int x, int y, int z, int sizeX, int sizeY, int sizeZ, Vec3d vec31, double p_179683_8_, double p_179683_10_) {
+        int i = x - sizeX / 2;
+        int j = z - sizeZ / 2;
+
+        if (!this.isPositionClear(i, y, j, sizeX, sizeY, sizeZ, vec31, p_179683_8_, p_179683_10_)) {
+            return false;
+        } else {
+            for (int k = i; k < i + sizeX; ++k) {
+                for (int l = j; l < j + sizeZ; ++l) {
+                    double d0 = (double) k + 0.5D - vec31.x;
+                    double d1 = (double) l + 0.5D - vec31.z;
+
+                    if (d0 * p_179683_8_ + d1 * p_179683_10_ >= 0.0D) {
+                        PathNodeType pathnodetype = this.nodeProcessor.getPathNodeType(this.world, k, y - 1, l, this.entity, sizeX, sizeY, sizeZ, true, true);
+                        if (pathnodetype == PathNodeType.LAVA) {
+                            return false;
+                        }
+
+                        if (pathnodetype == PathNodeType.OPEN) {
+                            return false;
+                        }
+
+                        pathnodetype = this.nodeProcessor.getPathNodeType(this.world, k, y, l, this.entity, sizeX, sizeY, sizeZ, true, true);
+                        float f = this.entity.getPathPriority(pathnodetype);
+
+                        if (f < 0.0F || f >= 8.0F) {
+                            return false;
+                        }
+
+                        if (pathnodetype == PathNodeType.DAMAGE_FIRE || pathnodetype == PathNodeType.DANGER_FIRE || pathnodetype == PathNodeType.DAMAGE_OTHER) {
+                            return false;
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+
+    /**
+     * Returns true if an entity does not collide with any solid blocks at the position.
+     */
+    private boolean isPositionClear(int x, int y, int z, int sizeX, int sizeY, int sizeZ, Vec3d p_179692_7_, double p_179692_8_, double p_179692_10_) {
+        for (BlockPos blockpos : BlockPos.getAllInBox(new BlockPos(x, y, z), new BlockPos(x + sizeX - 1, y + sizeY - 1, z + sizeZ - 1))) {
+            double d0 = (double) blockpos.getX() + 0.5D - p_179692_7_.x;
+            double d1 = (double) blockpos.getZ() + 0.5D - p_179692_7_.z;
+
+            if (d0 * p_179692_8_ + d1 * p_179692_10_ >= 0.0D) {
+                Block block = this.world.getBlockState(blockpos).getBlock();
+
+                if (!block.isPassable(this.world, blockpos)) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public void setBreakDoors(boolean canBreakDoors) {
+        this.nodeProcessor.setCanOpenDoors(canBreakDoors);
+    }
+
+    public boolean getEnterDoors() {
+        return this.nodeProcessor.getCanEnterDoors();
+    }
+
+    public void setEnterDoors(boolean enterDoors) {
+        this.nodeProcessor.setCanEnterDoors(enterDoors);
+    }
+
+    public boolean getCanSwim() {
+        return this.nodeProcessor.getCanSwim();
+    }
+
+    public void setCanSwim(boolean canSwim) {
+        this.nodeProcessor.setCanSwim(canSwim);
+    }
+
+    public void setAvoidSun(boolean avoidSun) {
+        this.shouldAvoidSun = avoidSun;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockThatchSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockThatchSlab.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockThatchSlab.java	(date 1525606886000)
@@ -0,0 +1,36 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:55:17 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.hdt.neutronia.modules.building.features.Thatch;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+public class BlockThatchSlab extends BlockOverworldSlabBase {
+
+    public BlockThatchSlab(boolean doubleSlab) {
+        super("thatch_slab", Material.PLANTS, doubleSlab);
+        setHardness(0.5F);
+        setSoundType(SoundType.PLANT);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public void onFallenUpon(World worldIn, BlockPos pos, Entity entityIn, float fallDistance) {
+        entityIn.fall(fallDistance, Thatch.fallDamageMultiplier);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/proxy/CommonProxy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/proxy/CommonProxy.java	(date 1525600919000)
+++ src/main/java/net/hdt/neutronia/proxy/CommonProxy.java	(date 1525600919000)
@@ -0,0 +1,41 @@
+package net.hdt.neutronia.proxy;
+
+import net.hdt.neutronia.init.HMBiomes;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.hdt.neutronia.tileentity.TileEntityCraftingTable;
+import net.hdt.neutronia.tileentity.TileEntityFloorTile;
+import net.hdt.neutronia.world.events.WorldGenEvents;
+import net.hdt.neutronia.world.gen.OreGen;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.fml.common.registry.GameRegistry;
+
+public class CommonProxy {
+
+    public void preInit(FMLPreInitializationEvent event) {
+//        OreGenEvents events = new OreGenEvents(event);
+//        MinecraftForge.ORE_GEN_BUS.register(events.getClass());
+    }
+
+    public void init(FMLInitializationEvent event) {
+//        GameRegistry.registerWorldGenerator(new WorldGenCustomStructures(), 0);
+        GameRegistry.registerWorldGenerator(new OreGen(), 0);
+        MinecraftForge.TERRAIN_GEN_BUS.register(WorldGenEvents.class);
+//        GameRegistry.registerWorldGenerator(new WorldGenerationHandler(), 1);
+        GameRegistry.registerTileEntity(TileCustomChest.class, "neutronia:custom_chest");
+        GameRegistry.registerTileEntity(TileEntityFloorTile.class, "neutronia:floor_tile");
+        GameRegistry.registerTileEntity(TileEntityCraftingTable.class, "minecraft:workbench");
+        HMBiomes.registerBiomes();
+    }
+
+    public void postInit(FMLPostInitializationEvent event) {
+
+    }
+
+    public void addResourceOverride(String space, String dir, String file, String ext) {
+
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Decorator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Decorator.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Decorator.java	(date 1525606902000)
@@ -0,0 +1,601 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.text.DecimalFormat;
+import java.util.*;
+
+/* This class statically loads blueprints and mod configuration and overrides generate method @author Ternsip */
+public class Decorator implements IWorldGenerator {
+
+    static double ratioA = 1, ratioB = 0.5; // Logistic f(x) = 2 / (1 + e ^ (-A * x ^ B)) - 1, default A = 1, B = 0.5
+    static boolean strictMode = false; // Prevent floating islands to spawn in common biome additionally
+    static boolean balanceMode = true; // Replace rich blocks to poor
+    static boolean preventCommandBlock = false; // Prevent command block for spawning
+    static double roughnessFactor = 1.0; // Multiplier of minimal acceptable roughness
+    static double lootChance = 0.25; // Chest loot chance [0..1]
+    static int forceLift = 0; // Pull out structure from the ground and lift up (recommended 0)
+    static boolean preventMobSpawners = false; // Prevent mobspawners for spawning
+    static boolean allowOnlyVanillaBlocks = true; // Allow only vanilla blocks to spawn
+    static int minChestItems = 2; // Min number of stack per chest inclusive
+    static int maxChestItems = 7; // Max number of stacks per chest exclusive
+    static int maxChestStackSize = 3; // Max item stack size for chest loot
+    static boolean loadOutput = true; // Prints load output to console
+    static ArrayList<Integer> allowedDimensions = new ArrayList<Integer>() {
+        {
+            add(-1);
+            add(0);
+            add(1);
+        }
+    }; // Allow spawning structures only in dimensions with given ids
+    static boolean[] soil = new boolean[256]; // Ground soil blocks
+    static boolean[] overlook = new boolean[256]; // Plants, stuff, web, fire, decorative, etc.
+    static boolean[] liquid = new boolean[256]; // Liquid blocks
+    static Block[] vanillaBlocks = new Block[256]; // Default vanilla blocks by classical indices
+    private static Distributor distributor = null;
+    private static double density = 0.005; // Drop probability per chunk
+
+    static {
+
+        configure(new File("config/placemod.cfg"));
+
+        soil[Block.getIdFromBlock(Blocks.GRASS)] = true;
+        soil[Block.getIdFromBlock(Blocks.DIRT)] = true;
+        soil[Block.getIdFromBlock(Blocks.STONE)] = true;
+        soil[Block.getIdFromBlock(Blocks.COBBLESTONE)] = true;
+        soil[Block.getIdFromBlock(Blocks.SANDSTONE)] = true;
+        soil[Block.getIdFromBlock(Blocks.NETHERRACK)] = true;
+        soil[Block.getIdFromBlock(Blocks.GRAVEL)] = true;
+        soil[Block.getIdFromBlock(Blocks.SAND)] = true;
+
+        overlook[Block.getIdFromBlock(Blocks.AIR)] = true;
+        overlook[Block.getIdFromBlock(Blocks.LOG)] = true;
+        overlook[Block.getIdFromBlock(Blocks.LOG2)] = true;
+        overlook[Block.getIdFromBlock(Blocks.LEAVES)] = true;
+        overlook[Block.getIdFromBlock(Blocks.LEAVES2)] = true;
+        overlook[Block.getIdFromBlock(Blocks.SAPLING)] = true;
+        overlook[Block.getIdFromBlock(Blocks.WEB)] = true;
+        overlook[Block.getIdFromBlock(Blocks.TALLGRASS)] = true;
+        overlook[Block.getIdFromBlock(Blocks.DEADBUSH)] = true;
+        overlook[Block.getIdFromBlock(Blocks.YELLOW_FLOWER)] = true;
+        overlook[Block.getIdFromBlock(Blocks.RED_FLOWER)] = true;
+        overlook[Block.getIdFromBlock(Blocks.RED_MUSHROOM_BLOCK)] = true;
+        overlook[Block.getIdFromBlock(Blocks.BROWN_MUSHROOM_BLOCK)] = true;
+        overlook[Block.getIdFromBlock(Blocks.BROWN_MUSHROOM)] = true;
+        overlook[Block.getIdFromBlock(Blocks.FIRE)] = true;
+        overlook[Block.getIdFromBlock(Blocks.WHEAT)] = true;
+        overlook[Block.getIdFromBlock(Blocks.SNOW_LAYER)] = true;
+        overlook[Block.getIdFromBlock(Blocks.SNOW)] = true;
+        overlook[Block.getIdFromBlock(Blocks.CACTUS)] = true;
+        overlook[Block.getIdFromBlock(Blocks.PUMPKIN)] = true;
+        overlook[Block.getIdFromBlock(Blocks.VINE)] = true;
+        overlook[Block.getIdFromBlock(Blocks.WATERLILY)] = true;
+        overlook[Block.getIdFromBlock(Blocks.DOUBLE_PLANT)] = true;
+
+        liquid[Block.getIdFromBlock(Blocks.WATER)] = true;
+        liquid[Block.getIdFromBlock(Blocks.FLOWING_WATER)] = true;
+        liquid[Block.getIdFromBlock(Blocks.ICE)] = true;
+        liquid[Block.getIdFromBlock(Blocks.LAVA)] = true;
+        liquid[Block.getIdFromBlock(Blocks.FLOWING_LAVA)] = true;
+
+
+        vanillaBlocks[0] = Blocks.AIR;
+        vanillaBlocks[1] = Blocks.STONE;
+        vanillaBlocks[2] = Blocks.GRASS;
+        vanillaBlocks[3] = Blocks.DIRT;
+        vanillaBlocks[4] = Blocks.COBBLESTONE;
+        vanillaBlocks[5] = Blocks.PLANKS;
+        vanillaBlocks[6] = Blocks.SAPLING;
+        vanillaBlocks[7] = Blocks.BEDROCK;
+        vanillaBlocks[8] = Blocks.FLOWING_WATER;
+        vanillaBlocks[9] = Blocks.WATER;
+        vanillaBlocks[10] = Blocks.FLOWING_LAVA;
+        vanillaBlocks[11] = Blocks.LAVA;
+        vanillaBlocks[12] = Blocks.SAND;
+        vanillaBlocks[13] = Blocks.GRAVEL;
+        vanillaBlocks[14] = Blocks.GOLD_ORE;
+        vanillaBlocks[15] = Blocks.IRON_ORE;
+        vanillaBlocks[16] = Blocks.COAL_ORE;
+        vanillaBlocks[17] = Blocks.LOG;
+        vanillaBlocks[18] = Blocks.LEAVES;
+        vanillaBlocks[19] = Blocks.SPONGE;
+        vanillaBlocks[20] = Blocks.GLASS;
+        vanillaBlocks[21] = Blocks.LAPIS_ORE;
+        vanillaBlocks[22] = Blocks.LAPIS_BLOCK;
+        vanillaBlocks[23] = Blocks.DISPENSER;
+        vanillaBlocks[24] = Blocks.SANDSTONE;
+        vanillaBlocks[25] = Blocks.NOTEBLOCK;
+        vanillaBlocks[26] = Blocks.BED;
+        vanillaBlocks[27] = Blocks.GOLDEN_RAIL;
+        vanillaBlocks[28] = Blocks.DETECTOR_RAIL;
+        vanillaBlocks[29] = Blocks.STICKY_PISTON;
+        vanillaBlocks[30] = Blocks.WEB;
+        vanillaBlocks[31] = Blocks.TALLGRASS;
+        vanillaBlocks[32] = Blocks.DEADBUSH;
+        vanillaBlocks[33] = Blocks.PISTON;
+        vanillaBlocks[34] = Blocks.PISTON_HEAD;
+        vanillaBlocks[35] = Blocks.WOOL;
+        vanillaBlocks[36] = Blocks.PISTON_EXTENSION;
+        vanillaBlocks[37] = Blocks.YELLOW_FLOWER;
+        vanillaBlocks[38] = Blocks.RED_FLOWER;
+        vanillaBlocks[39] = Blocks.BROWN_MUSHROOM;
+        vanillaBlocks[40] = Blocks.RED_MUSHROOM;
+        vanillaBlocks[41] = Blocks.GOLD_BLOCK;
+        vanillaBlocks[42] = Blocks.IRON_BLOCK;
+        vanillaBlocks[43] = Blocks.DOUBLE_STONE_SLAB;
+        vanillaBlocks[44] = Blocks.STONE_SLAB;
+        vanillaBlocks[45] = Blocks.BRICK_BLOCK;
+        vanillaBlocks[46] = Blocks.TNT;
+        vanillaBlocks[47] = Blocks.BOOKSHELF;
+        vanillaBlocks[48] = Blocks.MOSSY_COBBLESTONE;
+        vanillaBlocks[49] = Blocks.OBSIDIAN;
+        vanillaBlocks[50] = Blocks.TORCH;
+        vanillaBlocks[51] = Blocks.FIRE;
+        vanillaBlocks[52] = Blocks.MOB_SPAWNER;
+        vanillaBlocks[53] = Blocks.OAK_STAIRS;
+        vanillaBlocks[54] = Blocks.CHEST;
+        vanillaBlocks[55] = Blocks.REDSTONE_WIRE;
+        vanillaBlocks[56] = Blocks.DIAMOND_ORE;
+        vanillaBlocks[57] = Blocks.DIAMOND_BLOCK;
+        vanillaBlocks[58] = Blocks.CRAFTING_TABLE;
+        vanillaBlocks[59] = Blocks.WHEAT;
+        vanillaBlocks[60] = Blocks.FARMLAND;
+        vanillaBlocks[61] = Blocks.FURNACE;
+        vanillaBlocks[62] = Blocks.LIT_FURNACE;
+        vanillaBlocks[63] = Blocks.STANDING_SIGN;
+        vanillaBlocks[64] = Blocks.OAK_DOOR;
+        vanillaBlocks[65] = Blocks.LADDER;
+        vanillaBlocks[66] = Blocks.RAIL;
+        vanillaBlocks[67] = Blocks.STONE_STAIRS;
+        vanillaBlocks[68] = Blocks.WALL_SIGN;
+        vanillaBlocks[69] = Blocks.LEVER;
+        vanillaBlocks[70] = Blocks.STONE_PRESSURE_PLATE;
+        vanillaBlocks[71] = Blocks.IRON_DOOR;
+        vanillaBlocks[72] = Blocks.WOODEN_PRESSURE_PLATE;
+        vanillaBlocks[73] = Blocks.REDSTONE_ORE;
+        vanillaBlocks[74] = Blocks.LIT_REDSTONE_ORE;
+        vanillaBlocks[75] = Blocks.UNLIT_REDSTONE_TORCH;
+        vanillaBlocks[76] = Blocks.REDSTONE_TORCH;
+        vanillaBlocks[77] = Blocks.STONE_BUTTON;
+        vanillaBlocks[78] = Blocks.SNOW_LAYER;
+        vanillaBlocks[79] = Blocks.ICE;
+        vanillaBlocks[80] = Blocks.SNOW;
+        vanillaBlocks[81] = Blocks.CACTUS;
+        vanillaBlocks[82] = Blocks.CLAY;
+        vanillaBlocks[83] = Blocks.REEDS;
+        vanillaBlocks[84] = Blocks.JUKEBOX;
+        vanillaBlocks[85] = Blocks.OAK_FENCE;
+        vanillaBlocks[86] = Blocks.PUMPKIN;
+        vanillaBlocks[87] = Blocks.NETHERRACK;
+        vanillaBlocks[88] = Blocks.SOUL_SAND;
+        vanillaBlocks[89] = Blocks.GLOWSTONE;
+        vanillaBlocks[90] = Blocks.PORTAL;
+        vanillaBlocks[91] = Blocks.LIT_PUMPKIN;
+        vanillaBlocks[92] = Blocks.CAKE;
+        vanillaBlocks[93] = Blocks.UNPOWERED_REPEATER;
+        vanillaBlocks[94] = Blocks.POWERED_REPEATER;
+        vanillaBlocks[95] = Blocks.STAINED_GLASS;
+        vanillaBlocks[96] = Blocks.TRAPDOOR;
+        vanillaBlocks[97] = Blocks.MONSTER_EGG;
+        vanillaBlocks[98] = Blocks.STONEBRICK;
+        vanillaBlocks[99] = Blocks.BROWN_MUSHROOM_BLOCK;
+        vanillaBlocks[100] = Blocks.RED_MUSHROOM_BLOCK;
+        vanillaBlocks[101] = Blocks.IRON_BARS;
+        vanillaBlocks[102] = Blocks.GLASS_PANE;
+        vanillaBlocks[103] = Blocks.MELON_BLOCK;
+        vanillaBlocks[104] = Blocks.PUMPKIN_STEM;
+        vanillaBlocks[105] = Blocks.MELON_STEM;
+        vanillaBlocks[106] = Blocks.VINE;
+        vanillaBlocks[107] = Blocks.OAK_FENCE_GATE;
+        vanillaBlocks[108] = Blocks.BRICK_STAIRS;
+        vanillaBlocks[109] = Blocks.STONE_BRICK_STAIRS;
+        vanillaBlocks[110] = Blocks.MYCELIUM;
+        vanillaBlocks[111] = Blocks.WATERLILY;
+        vanillaBlocks[112] = Blocks.NETHER_BRICK;
+        vanillaBlocks[113] = Blocks.NETHER_BRICK_FENCE;
+        vanillaBlocks[114] = Blocks.NETHER_BRICK_STAIRS;
+        vanillaBlocks[115] = Blocks.NETHER_WART;
+        vanillaBlocks[116] = Blocks.ENCHANTING_TABLE;
+        vanillaBlocks[117] = Blocks.BREWING_STAND;
+        vanillaBlocks[118] = Blocks.CAULDRON;
+        vanillaBlocks[119] = Blocks.END_PORTAL;
+        vanillaBlocks[120] = Blocks.END_PORTAL_FRAME;
+        vanillaBlocks[121] = Blocks.END_STONE;
+        vanillaBlocks[122] = Blocks.DRAGON_EGG;
+        vanillaBlocks[123] = Blocks.REDSTONE_LAMP;
+        vanillaBlocks[124] = Blocks.LIT_REDSTONE_LAMP;
+        vanillaBlocks[125] = Blocks.DOUBLE_WOODEN_SLAB;
+        vanillaBlocks[126] = Blocks.WOODEN_SLAB;
+        vanillaBlocks[127] = Blocks.COCOA;
+        vanillaBlocks[128] = Blocks.SANDSTONE_STAIRS;
+        vanillaBlocks[129] = Blocks.EMERALD_ORE;
+        vanillaBlocks[130] = Blocks.ENDER_CHEST;
+        vanillaBlocks[131] = Blocks.TRIPWIRE_HOOK;
+        vanillaBlocks[132] = Blocks.TRIPWIRE;
+        vanillaBlocks[133] = Blocks.EMERALD_BLOCK;
+        vanillaBlocks[134] = Blocks.SPRUCE_STAIRS;
+        vanillaBlocks[135] = Blocks.BIRCH_STAIRS;
+        vanillaBlocks[136] = Blocks.JUNGLE_STAIRS;
+        vanillaBlocks[137] = Blocks.COMMAND_BLOCK;
+        vanillaBlocks[138] = Blocks.BEACON;
+        vanillaBlocks[139] = Blocks.COBBLESTONE_WALL;
+        vanillaBlocks[140] = Blocks.FLOWER_POT;
+        vanillaBlocks[141] = Blocks.CARROTS;
+        vanillaBlocks[142] = Blocks.POTATOES;
+        vanillaBlocks[143] = Blocks.WOODEN_BUTTON;
+        vanillaBlocks[144] = Blocks.SKULL;
+        vanillaBlocks[145] = Blocks.ANVIL;
+        vanillaBlocks[146] = Blocks.TRAPPED_CHEST;
+        vanillaBlocks[147] = Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE;
+        vanillaBlocks[148] = Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE;
+        vanillaBlocks[149] = Blocks.UNPOWERED_COMPARATOR;
+        vanillaBlocks[150] = Blocks.POWERED_COMPARATOR;
+        vanillaBlocks[151] = Blocks.DAYLIGHT_DETECTOR;
+        vanillaBlocks[152] = Blocks.REDSTONE_BLOCK;
+        vanillaBlocks[153] = Blocks.QUARTZ_ORE;
+        vanillaBlocks[154] = Blocks.HOPPER;
+        vanillaBlocks[155] = Blocks.QUARTZ_BLOCK;
+        vanillaBlocks[156] = Blocks.QUARTZ_STAIRS;
+        vanillaBlocks[157] = Blocks.ACTIVATOR_RAIL;
+        vanillaBlocks[158] = Blocks.DROPPER;
+        vanillaBlocks[159] = Blocks.STAINED_HARDENED_CLAY;
+        vanillaBlocks[160] = Blocks.STAINED_GLASS_PANE;
+        vanillaBlocks[161] = Blocks.LEAVES2;
+        vanillaBlocks[162] = Blocks.LOG2;
+        vanillaBlocks[163] = Blocks.ACACIA_STAIRS;
+        vanillaBlocks[164] = Blocks.DARK_OAK_STAIRS;
+        vanillaBlocks[165] = Blocks.SLIME_BLOCK;
+        vanillaBlocks[166] = Blocks.BARRIER;
+        vanillaBlocks[167] = Blocks.IRON_TRAPDOOR;
+        vanillaBlocks[168] = Blocks.PRISMARINE;
+        vanillaBlocks[169] = Blocks.SEA_LANTERN;
+        vanillaBlocks[170] = Blocks.HAY_BLOCK;
+        vanillaBlocks[171] = Blocks.CARPET;
+        vanillaBlocks[172] = Blocks.HARDENED_CLAY;
+        vanillaBlocks[173] = Blocks.COAL_BLOCK;
+        vanillaBlocks[174] = Blocks.PACKED_ICE;
+        vanillaBlocks[175] = Blocks.DOUBLE_PLANT;
+        vanillaBlocks[176] = Blocks.STANDING_BANNER;
+        vanillaBlocks[177] = Blocks.WALL_BANNER;
+        vanillaBlocks[178] = Blocks.DAYLIGHT_DETECTOR_INVERTED;
+        vanillaBlocks[179] = Blocks.RED_SANDSTONE;
+        vanillaBlocks[180] = Blocks.RED_SANDSTONE_STAIRS;
+        vanillaBlocks[181] = Blocks.DOUBLE_STONE_SLAB2;
+        vanillaBlocks[182] = Blocks.STONE_SLAB2;
+        vanillaBlocks[183] = Blocks.SPRUCE_FENCE_GATE;
+        vanillaBlocks[184] = Blocks.BIRCH_FENCE_GATE;
+        vanillaBlocks[185] = Blocks.JUNGLE_FENCE_GATE;
+        vanillaBlocks[186] = Blocks.DARK_OAK_FENCE_GATE;
+        vanillaBlocks[187] = Blocks.ACACIA_FENCE_GATE;
+        vanillaBlocks[188] = Blocks.SPRUCE_FENCE;
+        vanillaBlocks[189] = Blocks.BIRCH_FENCE;
+        vanillaBlocks[190] = Blocks.JUNGLE_FENCE;
+        vanillaBlocks[191] = Blocks.DARK_OAK_FENCE;
+        vanillaBlocks[192] = Blocks.ACACIA_FENCE;
+        vanillaBlocks[193] = Blocks.SPRUCE_DOOR;
+        vanillaBlocks[194] = Blocks.BIRCH_DOOR;
+        vanillaBlocks[195] = Blocks.JUNGLE_DOOR;
+        vanillaBlocks[196] = Blocks.ACACIA_DOOR;
+        vanillaBlocks[197] = Blocks.DARK_OAK_DOOR;
+        vanillaBlocks[198] = Blocks.END_ROD;
+        vanillaBlocks[199] = Blocks.CHORUS_PLANT;
+        vanillaBlocks[200] = Blocks.CHORUS_FLOWER;
+        vanillaBlocks[201] = Blocks.PURPUR_BLOCK;
+        vanillaBlocks[202] = Blocks.PURPUR_PILLAR;
+        vanillaBlocks[203] = Blocks.PURPUR_STAIRS;
+        vanillaBlocks[204] = Blocks.PURPUR_DOUBLE_SLAB;
+        vanillaBlocks[205] = Blocks.PURPUR_SLAB;
+        vanillaBlocks[206] = Blocks.END_BRICKS;
+        vanillaBlocks[207] = Blocks.BEETROOTS;
+        vanillaBlocks[208] = Blocks.GRASS_PATH;
+        vanillaBlocks[209] = Blocks.END_GATEWAY;
+        vanillaBlocks[210] = Blocks.REPEATING_COMMAND_BLOCK;
+        vanillaBlocks[211] = Blocks.CHAIN_COMMAND_BLOCK;
+        vanillaBlocks[212] = Blocks.FROSTED_ICE;
+        vanillaBlocks[213] = null;
+        vanillaBlocks[214] = null;
+        vanillaBlocks[215] = null;
+        vanillaBlocks[216] = null;
+        vanillaBlocks[217] = null;
+        vanillaBlocks[218] = null;
+        vanillaBlocks[219] = null;
+        vanillaBlocks[220] = null;
+        vanillaBlocks[221] = null;
+        vanillaBlocks[222] = null;
+        vanillaBlocks[223] = null;
+        vanillaBlocks[224] = null;
+        vanillaBlocks[225] = null;
+        vanillaBlocks[226] = null;
+        vanillaBlocks[227] = null;
+        vanillaBlocks[228] = null;
+        vanillaBlocks[229] = null;
+        vanillaBlocks[230] = null;
+        vanillaBlocks[231] = null;
+        vanillaBlocks[232] = null;
+        vanillaBlocks[233] = null;
+        vanillaBlocks[234] = null;
+        vanillaBlocks[235] = null;
+        vanillaBlocks[236] = null;
+        vanillaBlocks[237] = null;
+        vanillaBlocks[238] = null;
+        vanillaBlocks[239] = null;
+        vanillaBlocks[240] = null;
+        vanillaBlocks[241] = null;
+        vanillaBlocks[242] = null;
+        vanillaBlocks[243] = null;
+        vanillaBlocks[244] = null;
+        vanillaBlocks[245] = null;
+        vanillaBlocks[246] = null;
+        vanillaBlocks[247] = null;
+        vanillaBlocks[248] = null;
+        vanillaBlocks[249] = null;
+        vanillaBlocks[250] = null;
+        vanillaBlocks[251] = null;
+        vanillaBlocks[252] = null;
+        vanillaBlocks[253] = null;
+        vanillaBlocks[254] = null;
+        vanillaBlocks[255] = Blocks.STRUCTURE_BLOCK;
+
+        loadStructures(new File("Placemod/Schematics/"));
+
+        bindHooks();
+
+    }
+
+    /* Load/Generate mod settings */
+    private static void configure(File file) {
+        if (new File(file.getParent()).mkdirs()) {
+            new Report().add("CREATE CONFIG", file.getParent());
+        }
+        Properties config = new Properties();
+        if (file.exists()) {
+            try {
+                FileInputStream fis = new FileInputStream(file);
+                config.load(fis);
+                density = Double.parseDouble(config.getProperty("DENSITY", Double.toString(density)));
+                ratioA = Double.parseDouble(config.getProperty("RATIO_A", Double.toString(ratioA)));
+                ratioB = Double.parseDouble(config.getProperty("RATIO_B", Double.toString(ratioB)));
+                strictMode = Boolean.parseBoolean(config.getProperty("STRICT_MODE", Boolean.toString(strictMode)));
+                balanceMode = Boolean.parseBoolean(config.getProperty("BALANCE_MODE", Boolean.toString(balanceMode)));
+                preventCommandBlock = Boolean.parseBoolean(config.getProperty("PREVENT_COMMAND_BLOCK", Boolean.toString(preventCommandBlock)));
+                roughnessFactor = Double.parseDouble(config.getProperty("ROUGHNESS_FACTOR", Double.toString(roughnessFactor)));
+                lootChance = Double.parseDouble(config.getProperty("CHEST_LOOT_CHANCE", Double.toString(lootChance)));
+                forceLift = (int) Double.parseDouble(config.getProperty("FORCE_LIFT", Double.toString(forceLift)));
+                preventMobSpawners = Boolean.parseBoolean(config.getProperty("PREVENT_MOB_SPAWNERS", Boolean.toString(preventMobSpawners)));
+                allowOnlyVanillaBlocks = Boolean.parseBoolean(config.getProperty("ALLOW_ONLY_VANILLA_BLOCKS", Boolean.toString(allowOnlyVanillaBlocks)));
+                minChestItems = (int) Double.parseDouble(config.getProperty("MIN_CHEST_ITEMS", Double.toString(minChestItems)));
+                maxChestItems = (int) Double.parseDouble(config.getProperty("MAX_CHEST_ITEMS", Double.toString(maxChestItems)));
+                maxChestStackSize = (int) Double.parseDouble(config.getProperty("MAX_CHEST_STACK_SIZE", Double.toString(maxChestStackSize)));
+                loadOutput = Boolean.parseBoolean(config.getProperty("LOAD_OUTPUT", Boolean.toString(loadOutput)));
+                allowedDimensions = stringToArray(config.getProperty("ALLOWED_DIMENSIONS", "-1, 0, 1"));
+                fis.close();
+            } catch (IOException ioe) {
+                ioe.printStackTrace();
+            }
+        }
+        try {
+            FileOutputStream fos = new FileOutputStream(file);
+            config.setProperty("DENSITY", Double.toString(density));
+            config.setProperty("RATIO_A", Double.toString(ratioA));
+            config.setProperty("RATIO_B", Double.toString(ratioB));
+            config.setProperty("STRICT_MODE", Boolean.toString(strictMode));
+            config.setProperty("BALANCE_MODE", Boolean.toString(balanceMode));
+            config.setProperty("PREVENT_COMMAND_BLOCK", Boolean.toString(preventCommandBlock));
+            config.setProperty("ROUGHNESS_FACTOR", Double.toString(roughnessFactor));
+            config.setProperty("CHEST_LOOT_CHANCE", Double.toString(lootChance));
+            config.setProperty("FORCE_LIFT", Integer.toString(forceLift));
+            config.setProperty("PREVENT_MOB_SPAWNERS", Boolean.toString(preventMobSpawners));
+            config.setProperty("ALLOW_ONLY_VANILLA_BLOCKS", Boolean.toString(allowOnlyVanillaBlocks));
+            config.setProperty("MIN_CHEST_ITEMS", Integer.toString(minChestItems));
+            config.setProperty("MAX_CHEST_ITEMS", Integer.toString(maxChestItems));
+            config.setProperty("MAX_CHEST_STACK_SIZE", Integer.toString(maxChestStackSize));
+            config.setProperty("LOAD_OUTPUT", Boolean.toString(loadOutput));
+            config.setProperty("ALLOWED_DIMENSIONS", arrayToString(allowedDimensions));
+            config.store(fos, null);
+            fos.close();
+        } catch (IOException ioe) {
+            ioe.printStackTrace();
+        }
+    }
+
+    private static ArrayList<Integer> stringToArray(String array) {
+        ArrayList<Integer> result = new ArrayList<Integer>();
+        for (String stringValue : array.split("\\s*,\\s*")) {
+            try {
+                result.add(Integer.parseInt(stringValue));
+            } catch (NumberFormatException ignored) {
+            }
+        }
+        return result;
+    }
+
+    private static String arrayToString(ArrayList<Integer> array) {
+        String result = "";
+        for (Integer integerValue : array) {
+            result += (result.isEmpty() ? "" : ", ") + integerValue.toString();
+        }
+        return result;
+    }
+
+    private static void loadStructures(File folder) {
+        long startTime = System.currentTimeMillis();
+        new Report().add("LOADING SCHEMATICS FROM", folder.getPath()).print();
+        Stack<File> folders = new Stack<File>();
+        folders.add(folder);
+        ArrayList<Cluster> clusters = new ArrayList<Cluster>();
+        HashMap<String, Cluster> villages = new HashMap<String, Cluster>();
+        int loaded = 0;
+        while (!folders.empty()) {
+            File dir = folders.pop();
+            File[] listOfFiles = dir.listFiles();
+            for (File file : listOfFiles != null ? listOfFiles : new File[0]) {
+                if (file.isFile()) {
+                    try {
+                        String pathParallel = file.getPath().replace("\\", "/").replace("//", "/").replace("/Schematics/", "/Structures/");
+                        String pathFlags = pathParallel.replace(".schematic", ".flags");
+                        String pathStructure = pathParallel.replace(".schematic", ".structure");
+                        final Structure structure = new Structure(file, new File(pathFlags), new File(pathStructure));
+                        loaded++;
+                        String parent = file.getParent();
+                        if (structure.flags.getString("Method").equalsIgnoreCase("Village")) {
+                            if (villages.containsKey(parent)) {
+                                villages.get(parent).add(structure);
+                            } else {
+                                villages.put(parent, new Cluster(parent).add(structure));
+                            }
+                        } else {
+                            clusters.add(new Cluster(parent).add(structure));
+                        }
+                        int width = structure.flags.getShort("Width");
+                        int height = structure.flags.getShort("Height");
+                        int length = structure.flags.getShort("Length");
+                        if (loadOutput) {
+                            new Report()
+                                    .add("LOAD", file.getPath())
+                                    .add("SIZE", "[W=" + width + ";H=" + height + ";L=" + length + "]")
+                                    .add("LIFT", String.valueOf(structure.flags.getInteger("Lift")))
+                                    .add("METHOD", structure.flags.getString("Method"))
+                                    .add("BIOME", Biome.Style.valueOf(structure.flags.getInteger("Biome")).name)
+                                    .print();
+                        }
+                    } catch (IOException ioe) {
+                        new Report()
+                                .add("CAN'T LOAD SCHEMATIC", file.getPath())
+                                .add("ERROR", ioe.getMessage())
+                                .print();
+                    }
+                } else if (file.isDirectory()) {
+                    folders.add(file);
+                }
+            }
+        }
+        clusters.addAll(villages.values());
+        distributor = new Distributor(clusters);
+        long loadTime = (System.currentTimeMillis() - startTime);
+        new Report()
+                .add("LOADED CLUSTERS", String.valueOf(clusters.size()))
+                .add("LOADED SCHEMATICS", String.valueOf(loaded))
+                .add("LOAD TIME", new DecimalFormat("###0.00").format(loadTime / 1000.0) + "s")
+                .print();
+        new Report()
+                .add("POSSIBLE_DIMENSIONS", arrayToString(allowedDimensions))
+                .print();
+    }
+
+    private static Random getRandom(long seed, int chunkX, int chunkZ) {
+        long chunkIndex = (long) chunkX << 32 | chunkZ & 0xFFFFFFFFL;
+        Random random = new Random(chunkIndex ^ seed);
+        for (int i = 0; i < 16; ++i) {
+            random.nextDouble();
+        }
+        return random;
+    }
+
+    private static void bindHooks() {
+        //ResourceLocation hooks = LootTableList.register("Placemod");
+        //for (ResourceLocation itemName : GameData.getItemRegistry().getKeys()) {
+        //    Item item = Item.itemRegistry.getObject(itemName);
+        //    int maxDmg = item.getMaxDamage();
+        //    for (int meta = 0; meta <= maxDmg; ++meta) {
+        //        hooks.addItem(new WeightedRandomChestContent(new ItemStack(item, 1, meta), 1, maxChestStackSize, 256 / (1 + maxDmg)));
+        //    }
+        //}
+        //hooks.setMin(minChestItems);
+        //hooks.setMax(maxChestItems);
+    }
+
+    @Override
+    public void generate(Random randomDefault, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
+        if (!allowedDimensions.contains(world.provider.getDimension())) {
+            return; // Dimension with given id is not allowed
+        }
+        Random random = getRandom(world.getSeed(), chunkX, chunkZ);
+        int drops = (int) density + (random.nextDouble() <= (density - (int) density) ? 1 : 0);
+        net.minecraft.world.biome.Biome biome = world.getBiome(new BlockPos(chunkX * 16, 64, chunkZ * 16));
+        Biome.Style biomeStyle = Biome.determine(biome);
+        ArrayList<Cluster> biomeClusters = distributor.getClusters(biomeStyle);
+        for (int i = 0; i < drops; ++i) {
+            double pointer = random.nextDouble();
+            for (Cluster cluster : biomeClusters) {
+                if (pointer <= cluster.getChance()) {
+                    place(world, cluster, chunkX, chunkZ, random.nextLong());
+                    break;
+                }
+                pointer -= cluster.getChance();
+            }
+        }
+    }
+
+    private void place(World world, Cluster cluster, int chunkX, int chunkZ, long seed) {
+        Random random = new Random(seed);
+        int cx = chunkX * 16 + Math.abs(random.nextInt()) % 16;
+        int cz = chunkZ * 16 + Math.abs(random.nextInt()) % 16;
+        new Report()
+                .add("PLACE CLUSTER", cluster.getSign())
+                .add("POS", "[CHUNK_X=" + chunkX + ";CHUNK_Z=" + chunkZ + "]")
+                .add("SIZE", String.valueOf(cluster.getStructures().size()))
+                .print();
+        int curX = cx, curZ = cz, maxZ = 0;
+        int timer = 0, delay = (int) Math.ceil(Math.sqrt(cluster.getStructures().size()));
+        ArrayList<Structure> structures = new ArrayList<Structure>(cluster.getStructures());
+        Collections.shuffle(structures, random);
+        for (Structure structure : structures) {
+            int rotX = 0, rotY = random.nextInt() % 4, rotZ = 0;
+            boolean flipX = random.nextBoolean(), flipY = false, flipZ = random.nextBoolean();
+            int width = structure.flags.getShort("Width");
+            int height = structure.flags.getShort("Height");
+            int length = structure.flags.getShort("Length");
+            Posture posture = new Posture(0, 0, 0, rotX, rotY, rotZ, flipX, flipY, flipZ, width, height, length);
+            if (--timer <= 0) {
+                timer = delay;
+                curX = cx;
+                curZ += maxZ;
+                maxZ = 0;
+            }
+            int sx = curX;
+            int sz = curZ;
+            curX += posture.getSizeX() + 1;
+            maxZ = Math.max(maxZ, posture.getSizeZ());
+            posture.shift(sx, 0, sz);
+            long startTime = System.currentTimeMillis();
+            try {
+                Calibrator calibrator = new Calibrator(world, posture);
+                posture.shift(0, calibrator.calibrate(structure, seed), 0);
+                structure.paste(world, posture, random.nextLong());
+                long spawnTime = System.currentTimeMillis() - startTime;
+                new Report()
+                        .add("PASTED", structure.schematicFile.getPath())
+                        .add("SPAWN TIME", new DecimalFormat("###0.00").format(spawnTime / 1000.0) + "s")
+                        .add("POS", "[X=" + posture.getPosX() + ";Y=" + posture.getPosY() + ";Z=" + posture.getPosZ() + "]")
+                        .add("SIZE", "[W=" + width + ";H=" + height + ";L=" + length + "]")
+                        .add("BIOME", Biome.Style.valueOf(structure.flags.getInteger("Biome")).name)
+                        .add("ROTATE", "[X=" + posture.getRotateX() + ";Y=" + posture.getRotateY() + ";Z=" + posture.getRotateZ() + "]")
+                        .add("FLIP", "[X=" + posture.isFlipX() + ";Y=" + posture.isFlipY() + ";Z=" + posture.isFlipZ() + "]")
+                        .print();
+            } catch (IOException ioe) {
+                long spentTime = System.currentTimeMillis() - startTime;
+                new Report()
+                        .add("CAN'T PASTE", structure.schematicFile.getPath())
+                        .add("ERROR", ioe.getMessage())
+                        .add("POS", "[X=" + posture.getPosX() + ";Y=" + posture.getPosY() + ";Z=" + posture.getPosZ() + "]")
+                        .add("SIZE", "[W=" + width + ";H=" + height + ";L=" + length + "]")
+                        .add("BIOME", Biome.Style.valueOf(structure.flags.getInteger("Biome")).name)
+                        .add("ROTATE", "[X=" + posture.getRotateX() + ";Y=" + posture.getRotateY() + ";Z=" + posture.getRotateZ() + "]")
+                        .add("FLIP", "[X=" + posture.isFlipX() + ";Y=" + posture.isFlipY() + ";Z=" + posture.isFlipZ() + "]")
+                        .add("SPENT TIME", new DecimalFormat("###0.00").format(spentTime / 1000.0) + "s")
+                        .print();
+            }
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/NeutroniaBuilding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/NeutroniaBuilding.java	(date 1525538557000)
+++ src/main/java/net/hdt/neutronia/modules/building/NeutroniaBuilding.java	(date 1525538557000)
@@ -0,0 +1,42 @@
+package net.hdt.neutronia.modules.building;
+
+import net.hdt.neutronia.modules.building.features.*;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemStack;
+import net.thegaminghuskymc.huskylib2.module.Module;
+
+public class NeutroniaBuilding extends Module {
+
+    @Override
+    public void addFeatures() {
+        registerFeature(new HardenedClayTiles());
+        registerFeature(new VanillaStairsAndSlabs());
+        registerFeature(new WorldStoneBricks());
+        registerFeature(new Thatch());
+        registerFeature(new SandyBricks());
+        registerFeature(new ReedBlock(), "Sugar cane blocks");
+        registerFeature(new BarkBlocks());
+        registerFeature(new VanillaWalls());
+        registerFeature(new PolishedStone());
+        registerFeature(new CarvedWood());
+        registerFeature(new SnowBricks());
+        registerFeature(new CharredNetherBricks());
+        registerFeature(new MoreSandstone());
+        registerFeature(new MidoriBlocks());
+        registerFeature(new IronPlates());
+        registerFeature(new VerticalWoodPlanks());
+        registerFeature(new SoulSandstone());
+        registerFeature(new StainedPlanks());
+        registerFeature(new PolishedNetherrack());
+        registerFeature(new DuskboundBlocks());
+        registerFeature(new SturdyStone());
+        registerFeature(new QuiltedWool());
+        registerFeature(new MagmaBricks());
+    }
+
+    @Override
+    public ItemStack getIconStack() {
+        return new ItemStack(Blocks.BRICK_BLOCK);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModCauldron.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModCauldron.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModCauldron.java	(date 1525606879000)
@@ -0,0 +1,291 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyInteger;
+import net.minecraft.block.state.BlockFaceShape;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.init.Items;
+import net.minecraft.init.PotionTypes;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemArmor;
+import net.minecraft.item.ItemBanner;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.PotionUtils;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntityBanner;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Random;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockModCauldron extends BlockMod {
+    public static final PropertyInteger LEVEL = PropertyInteger.create("level", 0, 3);
+    protected static final AxisAlignedBB AABB_LEGS = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.3125D, 1.0D);
+    protected static final AxisAlignedBB AABB_WALL_NORTH = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 0.125D);
+    protected static final AxisAlignedBB AABB_WALL_SOUTH = new AxisAlignedBB(0.0D, 0.0D, 0.875D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_WALL_EAST = new AxisAlignedBB(0.875D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_WALL_WEST = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.125D, 1.0D, 1.0D);
+
+    public BlockModCauldron(String name, CreativeTabs creativeTabs) {
+        super(Material.IRON, MOD_ID, name);
+        setCreativeTab(creativeTabs);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(LEVEL, 0));
+    }
+
+    public void addCollisionBoxToList(IBlockState state, World worldIn, BlockPos pos, AxisAlignedBB entityBox, List<AxisAlignedBB> collidingBoxes, @Nullable Entity entityIn, boolean isActualState) {
+        addCollisionBoxToList(pos, entityBox, collidingBoxes, AABB_LEGS);
+        addCollisionBoxToList(pos, entityBox, collidingBoxes, AABB_WALL_WEST);
+        addCollisionBoxToList(pos, entityBox, collidingBoxes, AABB_WALL_NORTH);
+        addCollisionBoxToList(pos, entityBox, collidingBoxes, AABB_WALL_EAST);
+        addCollisionBoxToList(pos, entityBox, collidingBoxes, AABB_WALL_SOUTH);
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return FULL_BLOCK_AABB;
+    }
+
+    /**
+     * Used to determine ambient occlusion and culling when rebuilding chunks for render
+     */
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    /**
+     * Called When an Entity Collided with the Block
+     */
+    public void onEntityCollidedWithBlock(World worldIn, BlockPos pos, IBlockState state, Entity entityIn) {
+        int i = state.getValue(LEVEL).intValue();
+        float f = (float) pos.getY() + (6.0F + (float) (3 * i)) / 16.0F;
+
+        if (!worldIn.isRemote && entityIn.isBurning() && i > 0 && entityIn.getEntityBoundingBox().minY <= (double) f) {
+            entityIn.extinguish();
+            this.setWaterLevel(worldIn, pos, state, i - 1);
+        }
+    }
+
+    /**
+     * Called when the block is right clicked by a player.
+     */
+    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
+        ItemStack itemstack = playerIn.getHeldItem(hand);
+
+        if (itemstack.isEmpty()) {
+            return true;
+        } else {
+            int i = state.getValue(LEVEL).intValue();
+            Item item = itemstack.getItem();
+
+            if (item == Items.WATER_BUCKET) {
+                if (i < 3 && !worldIn.isRemote) {
+                    if (!playerIn.capabilities.isCreativeMode) {
+                        playerIn.setHeldItem(hand, new ItemStack(Items.BUCKET));
+                    }
+
+                    playerIn.addStat(StatList.CAULDRON_FILLED);
+                    this.setWaterLevel(worldIn, pos, state, 3);
+                    worldIn.playSound(null, pos, SoundEvents.ITEM_BUCKET_EMPTY, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                }
+
+                return true;
+            } else if (item == Items.BUCKET) {
+                if (i == 3 && !worldIn.isRemote) {
+                    if (!playerIn.capabilities.isCreativeMode) {
+                        itemstack.shrink(1);
+
+                        if (itemstack.isEmpty()) {
+                            playerIn.setHeldItem(hand, new ItemStack(Items.WATER_BUCKET));
+                        } else if (!playerIn.inventory.addItemStackToInventory(new ItemStack(Items.WATER_BUCKET))) {
+                            playerIn.dropItem(new ItemStack(Items.WATER_BUCKET), false);
+                        }
+                    }
+
+                    playerIn.addStat(StatList.CAULDRON_USED);
+                    this.setWaterLevel(worldIn, pos, state, 0);
+                    worldIn.playSound(null, pos, SoundEvents.ITEM_BUCKET_FILL, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                }
+
+                return true;
+            } else if (item == Items.GLASS_BOTTLE) {
+                if (i > 0 && !worldIn.isRemote) {
+                    if (!playerIn.capabilities.isCreativeMode) {
+                        ItemStack itemstack3 = PotionUtils.addPotionToItemStack(new ItemStack(Items.POTIONITEM), PotionTypes.WATER);
+                        playerIn.addStat(StatList.CAULDRON_USED);
+                        itemstack.shrink(1);
+
+                        if (itemstack.isEmpty()) {
+                            playerIn.setHeldItem(hand, itemstack3);
+                        } else if (!playerIn.inventory.addItemStackToInventory(itemstack3)) {
+                            playerIn.dropItem(itemstack3, false);
+                        } else if (playerIn instanceof EntityPlayerMP) {
+                            ((EntityPlayerMP) playerIn).sendContainerToPlayer(playerIn.inventoryContainer);
+                        }
+                    }
+
+                    worldIn.playSound(null, pos, SoundEvents.ITEM_BOTTLE_FILL, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                    this.setWaterLevel(worldIn, pos, state, i - 1);
+                }
+
+                return true;
+            } else if (item == Items.POTIONITEM && PotionUtils.getPotionFromItem(itemstack) == PotionTypes.WATER) {
+                if (i < 3 && !worldIn.isRemote) {
+                    if (!playerIn.capabilities.isCreativeMode) {
+                        ItemStack itemstack2 = new ItemStack(Items.GLASS_BOTTLE);
+                        playerIn.addStat(StatList.CAULDRON_USED);
+                        playerIn.setHeldItem(hand, itemstack2);
+
+                        if (playerIn instanceof EntityPlayerMP) {
+                            ((EntityPlayerMP) playerIn).sendContainerToPlayer(playerIn.inventoryContainer);
+                        }
+                    }
+
+                    worldIn.playSound(null, pos, SoundEvents.ITEM_BOTTLE_EMPTY, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                    this.setWaterLevel(worldIn, pos, state, i + 1);
+                }
+
+                return true;
+            } else {
+                if (i > 0 && item instanceof ItemArmor) {
+                    ItemArmor itemarmor = (ItemArmor) item;
+
+                    if (itemarmor.getArmorMaterial() == ItemArmor.ArmorMaterial.LEATHER && itemarmor.hasColor(itemstack) && !worldIn.isRemote) {
+                        itemarmor.removeColor(itemstack);
+                        this.setWaterLevel(worldIn, pos, state, i - 1);
+                        playerIn.addStat(StatList.ARMOR_CLEANED);
+                        return true;
+                    }
+                }
+
+                if (i > 0 && item instanceof ItemBanner) {
+                    if (TileEntityBanner.getPatterns(itemstack) > 0 && !worldIn.isRemote) {
+                        ItemStack itemstack1 = itemstack.copy();
+                        itemstack1.setCount(1);
+                        TileEntityBanner.removeBannerData(itemstack1);
+                        playerIn.addStat(StatList.BANNER_CLEANED);
+
+                        if (!playerIn.capabilities.isCreativeMode) {
+                            itemstack.shrink(1);
+                            this.setWaterLevel(worldIn, pos, state, i - 1);
+                        }
+
+                        if (itemstack.isEmpty()) {
+                            playerIn.setHeldItem(hand, itemstack1);
+                        } else if (!playerIn.inventory.addItemStackToInventory(itemstack1)) {
+                            playerIn.dropItem(itemstack1, false);
+                        } else if (playerIn instanceof EntityPlayerMP) {
+                            ((EntityPlayerMP) playerIn).sendContainerToPlayer(playerIn.inventoryContainer);
+                        }
+                    }
+
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        }
+    }
+
+    public void setWaterLevel(World worldIn, BlockPos pos, IBlockState state, int level) {
+        worldIn.setBlockState(pos, state.withProperty(LEVEL, Integer.valueOf(MathHelper.clamp(level, 0, 3))), 2);
+        worldIn.updateComparatorOutputLevel(pos, this);
+    }
+
+    /**
+     * Called similar to random ticks, but only when it is raining.
+     */
+    public void fillWithRain(World worldIn, BlockPos pos) {
+        if (worldIn.rand.nextInt(20) == 1) {
+            float f = worldIn.getBiome(pos).getTemperature(pos);
+
+            if (worldIn.getBiomeProvider().getTemperatureAtHeight(f, pos.getY()) >= 0.15F) {
+                IBlockState iblockstate = worldIn.getBlockState(pos);
+
+                if (iblockstate.getValue(LEVEL).intValue() < 3) {
+                    worldIn.setBlockState(pos, iblockstate.cycleProperty(LEVEL), 2);
+                }
+            }
+        }
+    }
+
+    /**
+     * Get the Item that this Block should drop when harvested.
+     */
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Items.CAULDRON;
+    }
+
+    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
+        return new ItemStack(Items.CAULDRON);
+    }
+
+    public boolean hasComparatorInputOverride(IBlockState state) {
+        return true;
+    }
+
+    public int getComparatorInputOverride(IBlockState blockState, World worldIn, BlockPos pos) {
+        return blockState.getValue(LEVEL).intValue();
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(LEVEL, Integer.valueOf(meta));
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(LEVEL).intValue();
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, LEVEL);
+    }
+
+    /**
+     * Determines if an entity can path through this block
+     */
+    public boolean isPassable(IBlockAccess worldIn, BlockPos pos) {
+        return true;
+    }
+
+    /**
+     * Get the geometry of the queried face at the given position and state. This is used to decide whether things like
+     * buttons are allowed to be placed on the face, or how glass panes connect to the face, among other things.
+     * <p>
+     * Common values are {@code SOLID}, which is the default, and {@code UNDEFINED}, which represents something that
+     * does not fit the other descriptions and will generally cause other things not to connect to the face.
+     *
+     * @return an approximation of the form of the given face
+     */
+    public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face) {
+        if (face == EnumFacing.UP) {
+            return BlockFaceShape.BOWL;
+        } else {
+            return face == EnumFacing.DOWN ? BlockFaceShape.UNDEFINED : BlockFaceShape.SOLID;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/layer/LayerPhantomEyes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/layer/LayerPhantomEyes.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/entity/render/layer/LayerPhantomEyes.java	(date 1523987837000)
@@ -0,0 +1,46 @@
+package net.hdt.neutronia.entity.render.layer;
+
+import net.hdt.neutronia.entity.EntityPhantom;
+import net.hdt.neutronia.entity.render.RenderPhantom;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.entity.layers.LayerRenderer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class LayerPhantomEyes implements LayerRenderer<EntityPhantom> {
+
+    private static final ResourceLocation PHANTOM_EYES_TEXTURES = new ResourceLocation("neutronia:textures/entity/phantom/phantom_eyes.png");
+    private final RenderPhantom phantomRenderer;
+
+    public LayerPhantomEyes(RenderPhantom phantomRendererIn) {
+        this.phantomRenderer = phantomRendererIn;
+    }
+
+    public void doRenderLayer(EntityPhantom entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
+        this.phantomRenderer.bindTexture(PHANTOM_EYES_TEXTURES);
+        GlStateManager.enableBlend();
+        GlStateManager.disableAlpha();
+        GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+        GlStateManager.disableLighting();
+        GlStateManager.depthFunc(514);
+        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
+        GlStateManager.enableLighting();
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+        Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+        this.phantomRenderer.getMainModel().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+        Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
+        this.phantomRenderer.setLightmap(entitylivingbaseIn);
+        GlStateManager.disableBlend();
+        GlStateManager.enableAlpha();
+        GlStateManager.depthFunc(515);
+    }
+
+    public boolean shouldCombineTextures() {
+        return false;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/ItemTrident.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemTrident.java	(date 1523988246000)
+++ src/main/java/net/hdt/neutronia/items/ItemTrident.java	(date 1523988246000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.Main;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class ItemTrident extends ItemBase {
+
+    public ItemTrident(String name, CreativeTabs creativeTabs) {
+        super("trident", Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/dungeons/TFMaze.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/dungeons/TFMaze.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/world/dungeons/TFMaze.java	(date 1525606901000)
@@ -0,0 +1,759 @@
+package net.hdt.neutronia.world.dungeons;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.world.gen.structure.WorldGenWastelandBigTree;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+
+/**
+ * This is a maze of cells and walls.
+ * <p>
+ * The cells are at odd numbered x and y values, and the walls are at even numbered ones.  This does make the storage slightly inefficient, but oh wells.
+ *
+ * @author Ben
+ */
+public class TFMaze {
+
+    public static final int OUT_OF_BOUNDS = Integer.MIN_VALUE;
+    public static final int OOB = OUT_OF_BOUNDS;
+    public static final int ROOM = 5;
+    public static final int DOOR = 6;
+    public int width; // cells wide (x)
+    public int depth; // cells deep (z)
+    public int oddBias; // corridor thickness, default 3
+    public int evenBias; // wall thickness here.  NYI
+    public int tall; // wall blocks tall
+    public int head;// blocks placed above the maze
+    public int roots;// blocks placed under the maze (used for hedge mazes)
+    public int worldX; // set when we first copy the maze into the world
+    public int worldY;
+    public int worldZ;
+    public int type; // 1-3 = various sizes hollow hills
+    public IBlockState wallBlockState;
+    public IBlockState wallVar0State;
+    public float wallVarRarity;
+    public IBlockState headBlockState;
+    public IBlockState rootBlockState;
+    public IBlockState pillarBlockState;
+    public IBlockState doorBlockState;
+    public float doorRarity;
+    public IBlockState torchBlockState;
+    public float torchRarity;
+    public Random rand;
+    protected int rawWidth;
+    protected int rawDepth;
+    protected int[] storage;
+
+    public TFMaze(int cellsWidth, int cellsDepth) {
+        // default values
+        oddBias = 3;
+        evenBias = 1;
+        tall = 3;
+        head = 0;
+        roots = 0;
+        wallBlockState = Blocks.STONEBRICK.getDefaultState();
+        rootBlockState = Blocks.DIRT.getDefaultState();
+        torchBlockState = Blocks.TORCH.getDefaultState();
+        pillarBlockState = null;
+
+        torchRarity = 0.75F;
+        doorRarity = 0F;
+
+        this.width = cellsWidth;
+        this.depth = cellsDepth;
+
+        this.rawWidth = width * 2 + 1;
+        this.rawDepth = depth * 2 + 1;
+        storage = new int[rawWidth * rawDepth];
+
+        rand = new Random();
+    }
+
+    /**
+     * Gets the value from a cell in the maze
+     */
+    private int getCell(int x, int z) {
+        return getRaw(x * 2 + 1, z * 2 + 1);
+    }
+
+    /**
+     * Puts a value into a cell in the maze
+     */
+    private void putCell(int x, int z, int value) {
+        putRaw(x * 2 + 1, z * 2 + 1, value);
+    }
+
+    /**
+     * Returns true if the specified cell equals the specified value
+     */
+    private boolean cellEquals(int x, int z, int value) {
+        return getCell(x, z) == value;
+    }
+
+    /**
+     * Gets the wall value, or OUT_OF_BOUNDS if the area is out of bounds or the coordinates are not orthogonally adjacent.
+     */
+    private int getWall(int sx, int sz, int dx, int dz) {
+        if (dx == sx + 1 && dz == sz) {
+            return getRaw(sx * 2 + 2, sz * 2 + 1);
+        }
+        if (dx == sx - 1 && dz == sz) {
+            return getRaw(sx * 2, sz * 2 + 1);
+        }
+        if (dx == sx && dz == sz + 1) {
+            return getRaw(sx * 2 + 1, sz * 2 + 2);
+        }
+        if (dx == sx && dz == sz - 1) {
+            return getRaw(sx * 2 + 1, sz * 2);
+        }
+
+        Main.LOGGER.info("Wall check out of bounds; s = " + sx + ", " + sz + "; d = " + dx + ", " + dz);
+
+        return OUT_OF_BOUNDS;
+    }
+
+    private void putWall(int sx, int sz, int dx, int dz, int value) {
+        if (dx == sx + 1 && dz == sz) {
+            putRaw(sx * 2 + 2, sz * 2 + 1, value);
+        }
+        if (dx == sx - 1 && dz == sz) {
+            putRaw(sx * 2, sz * 2 + 1, value);
+        }
+        if (dx == sx && dz == sz + 1) {
+            putRaw(sx * 2 + 1, sz * 2 + 2, value);
+        }
+        if (dx == sx && dz == sz - 1) {
+            putRaw(sx * 2 + 1, sz * 2, value);
+        }
+    }
+
+    /**
+     * Returns true if there is a wall there
+     */
+    public boolean isWall(int sx, int sz, int dx, int dz) {
+        return getWall(sx, sz, dx, dz) == 0;
+    }
+
+    /**
+     * Puts a value into the raw storage.
+     */
+    public void putRaw(int rawx, int rawz, int value) {
+        if (rawx >= 0 && rawx < rawWidth && rawz >= 0 && rawz < rawDepth) {
+            storage[rawz * rawWidth + rawx] = value;
+        }
+    }
+
+    /**
+     * Gets a value from raw storage
+     */
+    private int getRaw(int rawx, int rawz) {
+        if (rawx < 0 || rawx >= rawWidth || rawz < 0 || rawz >= rawDepth) {
+            return OUT_OF_BOUNDS;
+        } else {
+            return storage[rawz * rawWidth + rawx];
+        }
+    }
+
+    /**
+     * Sets the random seed to a specific value
+     */
+    public void setSeed(long newSeed) {
+        rand.setSeed(newSeed);
+    }
+
+    /**
+     * Copies the maze into the world by placing walls.
+     */
+    public void copyToWorld(World world, int dx, int dy, int dz) {
+        worldX = dx;
+        worldY = dy;
+        worldZ = dz;
+
+        for (int x = 0; x < rawWidth; x++) {
+            for (int z = 0; z < rawDepth; z++) {
+                if (getRaw(x, z) == 0) {
+                    int mdx = dx + (x / 2 * (evenBias + oddBias));
+                    int mdz = dz + (z / 2 * (evenBias + oddBias));
+
+                    if (isEven(x) && isEven(z)) {
+                        if (type == 4 && shouldTree(x, z)) {
+                            // occasionally make a tree
+                            (new WorldGenWastelandBigTree(false)).generate(world, rand, new BlockPos(mdx, dy, mdz));
+                        } else {
+                            // make a block!
+                            for (int y = 0; y < head; y++) {
+                                putHeadBlock(world, mdx, dy + tall + y, mdz);
+                            }
+                            for (int y = 0; y < tall; y++) {
+                                putWallBlock(world, mdx, dy + y, mdz);
+                            }
+                            for (int y = 1; y <= roots; y++) {
+                                putRootBlock(world, mdx, dy - y, mdz);
+                            }
+                        }
+                    }
+                    if (isEven(x) && !isEven(z)) {
+                        // make a | vertical | wall!
+                        for (int even = 0; even < evenBias; even++) {
+                            for (int odd = 1; odd <= oddBias; odd++) {
+                                for (int y = 0; y < head; y++) {
+                                    putHeadBlock(world, mdx + even, dy + tall + y, mdz + odd);
+                                }
+                                for (int y = 0; y < tall; y++) {
+                                    putWallBlock(world, mdx + even, dy + y, mdz + odd);
+                                }
+                                for (int y = 1; y <= roots; y++) {
+                                    putRootBlock(world, mdx + even, dy - y, mdz + odd);
+                                }
+                            }
+                        }
+                    }
+                    if (!isEven(x) && isEven(z)) {
+                        // make a - horizontal - wall!
+                        for (int even = 0; even < evenBias; even++) {
+                            for (int odd = 1; odd <= oddBias; odd++) {
+                                for (int y = 0; y < head; y++) {
+                                    putHeadBlock(world, mdx + odd, dy + tall + y, mdz + even);
+                                }
+                                for (int y = 0; y < tall; y++) {
+                                    putWallBlock(world, mdx + odd, dy + y, mdz + even);
+                                }
+                                for (int y = 1; y <= roots; y++) {
+                                    putRootBlock(world, mdx + odd, dy - y, mdz + even);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        placeTorches(world);
+    }
+
+    /**
+     * Copies the maze into the world by carving out empty spaces.
+     */
+    public void carveToWorld(World world, int dx, int dy, int dz) {
+        worldX = dx;
+        worldY = dy;
+        worldZ = dz;
+
+        for (int x = 0; x < rawWidth; x++) {
+            for (int z = 0; z < rawDepth; z++) {
+                if (getRaw(x, z) != 0) {
+                    int mdx = dx + (x / 2 * (evenBias + oddBias));
+                    int mdz = dz + (z / 2 * (evenBias + oddBias));
+
+                    if (isEven(x) && isEven(z)) {
+                        // carve a one-block wide pillar
+                        for (int y = 0; y < tall; y++) {
+                            carveBlock(world, mdx, dy + y, mdz);
+                        }
+                    } else if (isEven(x) && !isEven(z)) {
+                        // carve a | vertical | wall
+                        for (int i = 1; i <= oddBias; i++) {
+                            for (int y = 0; y < tall; y++) {
+                                carveBlock(world, mdx, dy + y, mdz + i);
+                            }
+                        }
+                    } else if (!isEven(x) && isEven(z)) {
+                        // carve a - horizontal - wall!
+                        for (int i = 1; i <= oddBias; i++) {
+                            for (int y = 0; y < tall; y++) {
+                                carveBlock(world, mdx + i, dy + y, mdz);
+                            }
+                        }
+                    } else if (!isEven(x) && !isEven(z)) // this should always be true at this point
+                    {
+                        // carve an open space
+                        for (int mx = 1; mx <= oddBias; mx++) {
+                            for (int mz = 1; mz <= oddBias; mz++) {
+                                for (int y = 0; y < tall; y++) {
+                                    carveBlock(world, mdx + mx, dy + y, mdz + mz);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        placeTorches(world);
+    }
+
+
+    /**
+     * Copy the maze into a StructureTFComponentOld
+     */
+	/*public void copyToStructure(World world, int dx, int dy, int dz, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		for (int x = 0; x < rawWidth; x++) {
+			for (int z = 0; z < rawDepth; z++) {
+				// only draw walls.  if the data is 0 the there's a wall
+				if (getRaw(x, z) == 0) {
+					int mdx = dx + (x / 2 * (evenBias + oddBias));
+					int mdz = dz + (z / 2 * (evenBias + oddBias));
+
+					if (evenBias > 1) {
+						mdx--;
+						mdz--;
+					}
+
+					if (isEven(x) && isEven(z)) {
+						if (type == 4 && shouldTree(x, z)) {
+							// occasionally make a tree 
+//							(new TFGenCanopyTree()).generate(world, rand, mdx, dy, mdz);
+							putCanopyTree(world, mdx, dy, mdz, component, sbb);
+						} else {
+							// make a block!
+							for (int even = 0; even < evenBias; even++) {
+								for (int even2 = 0; even2 < evenBias; even2++) {
+									for (int y = 0; y < head; y++) {
+										putHeadBlock(world, mdx + even, dy + tall + y, mdz + even2, component, sbb);
+									}
+									for (int y = 0; y < tall; y++) {
+										if (shouldPillar(x, z)) {
+											putPillarBlock(world, mdx + even, dy + y, mdz + even2, component, sbb);
+										} else {
+											putWallBlock(world, mdx + even, dy + y, mdz + even2, component, sbb);
+										}
+									}
+									for (int y = 1; y <= roots; y++) {
+										putRootBlock(world, mdx + even, dy - y, mdz + even2, component, sbb);
+									}
+								}
+							}
+						}
+					}
+					if (isEven(x) && !isEven(z)) {
+						// make a | vertical | wall!
+						for (int even = 0; even < evenBias; even++) {
+							for (int odd = 1; odd <= oddBias; odd++) {
+								makeWallThing(world, dy, component, sbb, mdx, mdz, even, odd);
+							}
+						}
+					}
+					if (!isEven(x) && isEven(z)) {
+						// make a - horizontal - wall!
+						for (int even = 0; even < evenBias; even++) {
+							for (int odd = 1; odd <= oddBias; odd++) {
+								makeWallThing(world, dy, component, sbb, mdx, mdz, odd, even);
+							}
+						}
+					}
+				} else if (getRaw(x, z) == DOOR) {
+					int mdx = dx + (x / 2 * (evenBias + oddBias));
+					int mdz = dz + (z / 2 * (evenBias + oddBias));
+
+					if (evenBias > 1) {
+						mdx--;
+						mdz--;
+					}
+
+					if (isEven(x) && !isEven(z)) {
+						// make a | vertical | door!
+						for (int even = 0; even < evenBias; even++) {
+							for (int odd = 1; odd <= oddBias; odd++) {
+								for (int y = 0; y < head; y++) {
+									putHeadBlock(world, mdx + even, dy + tall + y, mdz + odd, component, sbb);
+								}
+								for (int y = 0; y < tall; y++) {
+									putDoorBlock(world, mdx + even, dy + y, mdz + odd, component, sbb);
+								}
+								for (int y = 1; y <= roots; y++) {
+									putRootBlock(world, mdx + even, dy - y, mdz + odd, component, sbb);
+								}
+							}
+						}
+					}
+					if (!isEven(x) && isEven(z)) {
+						// make a - horizontal - door!
+						for (int even = 0; even < evenBias; even++) {
+							for (int odd = 1; odd <= oddBias; odd++) {
+								for (int y = 0; y < head; y++) {
+									putHeadBlock(world, mdx + odd, dy + tall + y, mdz + even, component, sbb);
+								}
+								for (int y = 0; y < tall; y++) {
+									putDoorBlock(world, mdx + odd, dy + y, mdz + even, component, sbb);
+								}
+								for (int y = 1; y <= roots; y++) {
+									putRootBlock(world, mdx + odd, dy - y, mdz + even, component, sbb);
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+
+		// instead of putting placetorches in a seperate function, I just put it here.
+		for (int x = 0; x < rawWidth; x++) {
+			for (int z = 0; z < rawDepth; z++) {
+				if (getRaw(x, z) == 0) {
+					int mdx = dx + (x / 2 * (evenBias + oddBias));
+					int mdy = dy + 1;
+					int mdz = dz + (z / 2 * (evenBias + oddBias));
+
+					if (isEven(x) && isEven(z)) {
+						if (shouldTorch(x, z) && component.getBlockStateFromPos(world, mdx, mdy, mdz, sbb).getBlock() == wallBlockState.getBlock()) {
+							component.setBlockState(world, torchBlockState, mdx, mdy, mdz, sbb);
+						}
+					}
+				}
+			}
+		}
+
+	}*/
+
+	/*private void makeWallThing(World world, int dy, StructureTFComponentOld component, StructureBoundingBox sbb, int mdx, int mdz, int even, int odd) {
+		for (int y = 0; y < head; y++) {
+			putHeadBlock(world, mdx + even, dy + tall + y, mdz + odd, component, sbb);
+		}
+		for (int y = 0; y < tall; y++) {
+			putWallBlock(world, mdx + even, dy + y, mdz + odd, component, sbb);
+		}
+		for (int y = 1; y <= roots; y++) {
+			putRootBlock(world, mdx + even, dy - y, mdz + odd, component, sbb);
+		}
+	}
+
+	*//**
+     * Puts a wall block in the structure, if pillar blocks are properly specified
+     *//*
+	private void putPillarBlock(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		component.setBlockState(world, pillarBlockState, x, y, z, sbb);
+	}*/
+
+    /**
+     * Puts a wall block in the world, at the specified world coordinates.
+     */
+    private void putWallBlock(World world, int x, int y, int z) {
+        world.setBlockState(new BlockPos(x, y, z), wallBlockState, 2);
+    }
+
+    /**
+     * Puts a wall block in the structure, at the specified structure coordinates.
+     */
+	/*private void putWallBlock(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		if (wallVarRarity > 0 && rand.nextFloat() < this.wallVarRarity) {
+			component.setBlockState(world, wallVar0State, x, y, z, sbb);
+		} else {
+			component.setBlockState(world, wallBlockState, x, y, z, sbb);
+		}
+	}
+
+	*//**
+     * Puts a wall block in the structure, at the specified structure coordinates.
+     *//*
+	private void putDoorBlock(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		component.setBlockState(world, doorBlockState, x, y, z, sbb);
+	}*/
+
+    /**
+     * Carves a block into the world.
+     * TODO: check what's there?  maybe only certain blocks?
+     */
+    private void carveBlock(World world, int x, int y, int z) {
+        world.setBlockState(new BlockPos(x, y, z), Blocks.AIR.getDefaultState(), 2);
+    }
+
+    private void putHeadBlock(World world, int x, int y, int z) {
+        world.setBlockState(new BlockPos(x, y, z), headBlockState, 2);
+    }
+
+	/*private void putHeadBlock(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		component.setBlockState(world, headBlockState, x, y, z, sbb);
+	}*/
+
+
+    /**
+     * Puts a root block in the world, at the specified world coordinates.
+     */
+    private void putRootBlock(World world, int x, int y, int z) {
+        world.setBlockState(new BlockPos(x, y, z), rootBlockState, 2);
+    }
+
+    /**
+     * Puts a root block in the structure, at the specified structure coordinates.
+     */
+	/*private void putRootBlock(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		component.setBlockState(world, rootBlockState, x, y, z, sbb);
+	}
+
+	*/
+
+    /**
+     * Puts a canopy tree in the world at the specified structure coordinates.
+     *//*
+	private void putCanopyTree(World world, int x, int y, int z, StructureTFComponentOld component, StructureBoundingBox sbb) {
+		BlockPos pos = component.getBlockPosWithOffset(x, y, z);
+
+		// only place it if we're actually generating the chunk the tree is in (or at least the middle of the tree)
+		if (sbb.isVecInside(pos)) {
+			(new TFGenCanopyTree()).generate(world, rand, pos);
+		}
+	}*/
+    private boolean isEven(int n) {
+        return n % 2 == 0;
+    }
+
+    /**
+     * Called after copyToWorld.  Places torches in the maze as appropriate
+     */
+    private void placeTorches(World world) {
+
+        int torchHeight = 1;
+
+        for (int x = 0; x < rawWidth; x++) {
+            for (int z = 0; z < rawDepth; z++) {
+                if (getRaw(x, z) == 0) {
+                    int mdx = worldX + (x / 2 * (evenBias + oddBias));
+                    int mdy = worldY + torchHeight;
+                    int mdz = worldZ + (z / 2 * (evenBias + oddBias));
+
+                    BlockPos pos = new BlockPos(mdx, mdy, mdz);
+
+                    if (isEven(x) && isEven(z)) {
+                        if (shouldTorch(x, z) && world.getBlockState(pos).getBlock() == wallBlockState.getBlock()) {
+                            world.setBlockState(pos, torchBlockState, 2);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Should we put a torch here?  Intended to be called on the in-between spots where x and y are even.
+     */
+    public boolean shouldTorch(int rx, int rz) {
+        // if there is out of bounds in any direction, no
+        if (getRaw(rx + 1, rz) == OOB || getRaw(rx - 1, rz) == OOB || getRaw(rx, rz + 1) == OOB || getRaw(rx, rz - 1) == OOB) {
+            return false;
+        }
+
+        // if there are walls in two opposite directions, no
+        if ((getRaw(rx + 1, rz) == 0 && getRaw(rx - 1, rz) == 0) || (getRaw(rx, rz + 1) == 0 && getRaw(rx, rz - 1) == 0)) {
+            return false;
+        }
+
+        // otherwise, I suppose yes
+
+        // check rarity
+        return rand.nextFloat() <= this.torchRarity;
+    }
+
+    /**
+     * Should we put a torch here?  Intended to be called on the in-between spots where x and y are even.
+     */
+    public boolean shouldPillar(int rx, int rz) {
+        // if the pillar block is not defined, no
+        if (pillarBlockState == null) {
+            return false;
+        }
+
+        // if there is out of bounds in any direction, no
+        if (getRaw(rx + 1, rz) == OOB || getRaw(rx - 1, rz) == OOB || getRaw(rx, rz + 1) == OOB || getRaw(rx, rz - 1) == OOB) {
+            return false;
+        }
+
+        // if there are walls in two opposite directions, no
+        return (getRaw(rx + 1, rz) != 0 || getRaw(rx - 1, rz) != 0) && (getRaw(rx, rz + 1) != 0 || getRaw(rx, rz - 1) != 0);
+    }
+
+    /**
+     * Should we put a tree instead of a post?
+     * Essentially the answer is yes for the corners and the exits.
+     */
+    public boolean shouldTree(int rx, int rz) {
+        if ((rx == 0 || rx == rawWidth - 1) && (getRaw(rx, rz + 1) != 0 || getRaw(rx, rz - 1) != 0)) {
+            return true;
+        }
+        if ((rz == 0 || rz == rawDepth - 1) && (getRaw(rx + 1, rz) != 0 || getRaw(rx - 1, rz) != 0)) {
+            return true;
+        }
+
+
+        return rand.nextInt(50) == 0;
+    }
+
+    /**
+     * If the worldX is set properly, this returns where in that world the maze coordinate x lies
+     *
+     * @param x
+     * @return
+     */
+    int getWorldX(int x) {
+        return worldX + (x * (evenBias + oddBias)) + 1;
+    }
+
+    /**
+     * If the worldZ is set properly, this returns where in that world the maze coordinate z lies
+     *
+     * @param z
+     * @return
+     */
+    int getWorldZ(int z) {
+        return worldZ + (z * (evenBias + oddBias)) + 1;
+    }
+
+
+    /**
+     * Carves a room into the maze.  The coordinates given are cell coordinates.
+     */
+    public void carveRoom0(int cx, int cz) {
+
+        putCell(cx, cz, 5);
+
+        putCell(cx + 1, cz, 5);
+        putWall(cx, cz, cx + 1, cz, 5);
+        putCell(cx - 1, cz, 5);
+        putWall(cx, cz, cx - 1, cz, 5);
+        putCell(cx, cz + 1, 5);
+        putWall(cx, cz, cx, cz + 1, 5);
+        putCell(cx, cz - 1, 5);
+        putWall(cx, cz, cx, cz - 1, 5);
+    }
+
+    /**
+     * This room is a 3x3 cell room with exits in every direction.
+     */
+    public void carveRoom1(int cx, int cz) {
+        int rx = cx * 2 + 1;
+        int rz = cz * 2 + 1;
+
+        // remove walls and cells
+        for (int i = -2; i <= 2; i++) {
+            for (int j = -2; j <= 2; j++) {
+                putRaw(rx + i, rz + j, ROOM);
+            }
+        }
+
+        // mark the exit areas as unmazed
+        putCell(rx, rz + 1, 0);
+        putCell(rx, rz - 1, 0);
+        putCell(rx + 1, rz, 0);
+        putCell(rx - 1, rz, 0);
+
+        // make 4 exits (if not at the edge of the maze)
+        if (getRaw(rx, rz + 4) != OUT_OF_BOUNDS) {
+            putRaw(rx, rz + 3, ROOM);
+        }
+        if (getRaw(rx, rz - 4) != OUT_OF_BOUNDS) {
+            putRaw(rx, rz - 3, ROOM);
+        }
+        if (getRaw(rx + 4, rz) != OUT_OF_BOUNDS) {
+            putRaw(rx + 3, rz, ROOM);
+        }
+        if (getRaw(rx - 4, rz) != OUT_OF_BOUNDS) {
+            putRaw(rx - 3, rz, ROOM);
+        }
+    }
+
+
+    /**
+     * Adds four exits into the maze.
+     */
+    public void add4Exits() {
+        int hx = rawWidth / 2 + 1;
+        int hz = rawDepth / 2 + 1;
+
+        putRaw(hx, 0, ROOM);
+        putRaw(hx, rawDepth - 1, ROOM);
+        putRaw(0, hz, ROOM);
+        putRaw(rawWidth - 1, hz, ROOM);
+    }
+
+    /**
+     * Generates a maze using the recursive backtracking algorithm.
+     *
+     * @param sx The starting x coordinate
+     * @param sz The starting y coordinate
+     */
+    public void generateRecursiveBacktracker(int sx, int sz) {
+        rbGen(sx, sz);
+    }
+
+    /**
+     * Mark the cell as visited.  If we have any unvisited neighbors, pick one randomly, carve the wall between them, then call this function on that neighbor.
+     *
+     * @param sx
+     * @param sz
+     */
+    public void rbGen(int sx, int sz) {
+        // mark cell as visited
+        putCell(sx, sz, 1);
+
+        // count the unvisted neighbors
+        int unvisited = 0;
+        if (cellEquals(sx + 1, sz, 0)) {
+            unvisited++;
+        }
+        if (cellEquals(sx - 1, sz, 0)) {
+            unvisited++;
+        }
+        if (cellEquals(sx, sz + 1, 0)) {
+            unvisited++;
+        }
+        if (cellEquals(sx, sz - 1, 0)) {
+            unvisited++;
+        }
+
+        // if there are no unvisited neighbors, return
+        if (unvisited == 0) {
+            return;
+        }
+
+        // otherwise, pick a random neighbor to visit
+        int rn = rand.nextInt(unvisited);
+        int dx, dz;
+        dx = dz = 0;
+
+        if (cellEquals(sx + 1, sz, 0)) {
+            if (rn == 0) {
+                dx = sx + 1;
+                dz = sz;
+            }
+            rn--;
+        }
+        if (cellEquals(sx - 1, sz, 0)) {
+            if (rn == 0) {
+                dx = sx - 1;
+                dz = sz;
+            }
+            rn--;
+        }
+        if (cellEquals(sx, sz + 1, 0)) {
+            if (rn == 0) {
+                dx = sx;
+                dz = sz + 1;
+            }
+            rn--;
+        }
+        if (cellEquals(sx, sz - 1, 0)) {
+            if (rn == 0) {
+                dx = sx;
+                dz = sz - 1;
+            }
+        }
+
+        // carve wall or door
+        if (rand.nextFloat() <= this.doorRarity) {
+            putWall(sx, sz, dx, dz, DOOR);
+        } else {
+            putWall(sx, sz, dx, dz, 2);
+        }
+
+        // call function recursively at the destination
+        rbGen(dx, dz);
+
+        // the destination has run out of free spaces, let's try this square again, up to 2 more times
+        rbGen(sx, sz);
+        rbGen(sx, sz);
+    }
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/magma.png.mcmeta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/magma.png.mcmeta	(date 1466340928000)
+++ src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/magma.png.mcmeta	(date 1466340928000)
@@ -0,0 +1,10 @@
+{
+  "animation": {
+    "frametime": 30,
+    "interpolate": true,
+    "frames": [
+      0,
+      1,
+    ]
+  }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockReedSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockReedSlab.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockReedSlab.java	(date 1525606886000)
@@ -0,0 +1,28 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:45:26 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockReedSlab extends BlockOverworldSlabBase {
+
+    public BlockReedSlab(boolean doubleSlab) {
+        super("reed_block_slab", Material.WOOD, doubleSlab);
+        setHardness(0.5F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
+	
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderEnderPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderEnderPhantom.java	(date 1525606859000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderEnderPhantom.java	(date 1525606859000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityEnderPhantom;
+import net.hdt.neutronia.entity.render.model.ModelPhantom;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderEnderPhantom extends RenderLiving<EntityEnderPhantom> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/ender_phantom.png");
+
+    public RenderEnderPhantom(RenderManager manager) {
+        super(manager, new ModelPhantom(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityEnderPhantom entity) {
+        return SCORP_TEXTURE;
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMidoriSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMidoriSlab.java	(date 1525606879000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockMidoriSlab.java	(date 1525606879000)
@@ -0,0 +1,26 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [29/06/2016, 18:29:08 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+
+public class BlockMidoriSlab extends BlockOverworldSlabBase {
+
+    public BlockMidoriSlab(boolean doubleSlab) {
+        super("midori_block_slab", Material.ROCK, doubleSlab);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTiles.java	(date 1523987838000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTiles.java	(date 1523987838000)
@@ -0,0 +1,29 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockHardenedClayTiles extends BlockMod implements IModBlock {
+
+    public BlockHardenedClayTiles() {
+        super(Material.ROCK, Reference.MOD_ID, "hardened_clay_tiles");
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+}
\ No newline at end of file
Index: src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/sea_lantern.png.mcmeta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/sea_lantern.png.mcmeta	(date 1446912529000)
+++ src/main/resources/assets/neutronia/textures/blocks/new_blocks/idk_yet/s/sea_lantern.png.mcmeta	(date 1446912529000)
@@ -0,0 +1,10 @@
+{
+  "animation": {
+    "frametime": 3,
+    "interpolate": true,
+    "frames": [
+      0,
+      1,
+    ]
+  }
+}
Index: src/main/java/net/hdt/neutronia/util/RecipeUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/RecipeUtil.java	(date 1523986183000)
+++ src/main/java/net/hdt/neutronia/util/RecipeUtil.java	(date 1523986183000)
@@ -0,0 +1,226 @@
+package net.hdt.neutronia.util;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import net.minecraft.block.Block;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.*;
+
+/**
+ * Turns recipes into json form.
+ * <p>
+ * Written by the Botania Team here:
+ * https://github.com/Vazkii/Botania/blob/209b52bb80a766b15eff3c48cd1cd581f4020e97/src/main/java/vazkii/botania/common/crafting/ModCraftingRecipes.java
+ *
+ * @author Choonster
+ */
+public class RecipeUtil {
+
+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
+    private static final Set<String> USED_ORE_DICTIONARY_NAMES = new TreeSet<>();
+    private static final Set<String> USED_REGISTRY_NAMES = new TreeSet<>();
+    private static File RECIPE_DIR = null;
+
+    public static void setupDir(File file) {
+        if (RECIPE_DIR == null) {
+            RECIPE_DIR = file;
+        }
+        if (!RECIPE_DIR.exists()) {
+            RECIPE_DIR.mkdir();
+        }
+    }
+
+    private static void addShaped(ItemStack result, Object... components) {
+        Map<String, Object> json = new LinkedHashMap<>();
+
+        int i = 0;
+
+        List<String> pattern = new ArrayList<>();
+
+        while (i < components.length && components[i] instanceof String) {
+            pattern.add((String) components[i]);
+            i++;
+        }
+
+        boolean isOreDict = false;
+        Map<String, Map<String, Object>> key = new HashMap<>();
+        Character curKey = null;
+
+        for (; i < components.length; i++) {
+            Object o = components[i];
+
+            if (o instanceof Character) {
+                if (curKey != null) {
+                    throw new IllegalArgumentException("Provided two char keys in a row");
+                }
+                curKey = (Character) o;
+            } else {
+                if (curKey == null) {
+                    throw new IllegalArgumentException("Providing object without a char key");
+                }
+                if (o instanceof String) {
+                    isOreDict = true;
+                }
+                key.put(Character.toString(curKey), serializeItem(o));
+                curKey = null;
+            }
+        }
+
+        json.put("type", isOreDict ? "forge:ore_shaped" : "minecraft:crafting_shaped");
+        json.put("pattern", pattern);
+        json.put("key", key);
+        json.put("result", serializeItem(result));
+
+        String registryName = result.getItem().getRegistryName().getResourcePath() + "_" + result.getItemDamage();
+        File f = new File(RECIPE_DIR, registryName + ".json");
+
+        while (f.exists()) {
+            registryName = findSuitableName(registryName);
+            f = new File(RECIPE_DIR, registryName + ".json");
+        }
+
+        try (FileWriter w = new FileWriter(f)) {
+            GSON.toJson(json, w);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        USED_REGISTRY_NAMES.add(registryName);
+    }
+
+    private static void addShapeless(ItemStack result, Object... components) {
+        Map<String, Object> json = new LinkedHashMap<>();
+
+        boolean isOreDict = false;
+        List<Map<String, Object>> ingredients = new ArrayList<>();
+
+        for (Object o : components) {
+            if (o instanceof String) {
+                isOreDict = true;
+            }
+
+            ingredients.add(serializeItem(o));
+        }
+
+        json.put("type", isOreDict ? "forge:ore_shapeless" : "minecraft:crafting_shapeless");
+        json.put("ingredients", ingredients);
+        json.put("result", serializeItem(result));
+
+        String registryName = Objects.requireNonNull(result.getItem().getRegistryName()).getResourcePath() + "_" + result.getItemDamage();
+        File f = new File(RECIPE_DIR, registryName + ".json");
+
+        while (f.exists()) {
+            registryName = findSuitableName(registryName);
+            f = new File(RECIPE_DIR, registryName + ".json");
+        }
+
+        try (FileWriter w = new FileWriter(f)) {
+            GSON.toJson(json, w);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        USED_REGISTRY_NAMES.add(registryName);
+    }
+
+    private static String findSuitableName(String registryName) {
+        if (registryName.contains("neutronia:")) {
+            registryName = registryName.replace("neutronia:", "");
+        }
+
+        if (registryName.contains("minecraft:")) {
+            registryName = registryName.replace("minecraft:", "");
+        }
+
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName + "_alt";
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt", "_alt_2");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_2", "_alt_3");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_3", "_alt_4");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_4", "_alt_5");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_5", "_alt_6");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_6", "_alt_7");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_7", "_alt_8");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_8", "_alt_9");
+        }
+        if (USED_REGISTRY_NAMES.contains(registryName)) {
+            registryName = registryName.replace("_alt_9", "_alt_10");
+        }
+
+        return registryName;
+    }
+
+    private static Map<String, Object> serializeItem(Object thing) {
+        if (thing instanceof Item) {
+            return serializeItem(new ItemStack((Item) thing));
+        }
+        if (thing instanceof Block) {
+            return serializeItem(new ItemStack((Block) thing));
+        }
+        if (thing instanceof ItemStack) {
+            ItemStack stack = (ItemStack) thing;
+            Map<String, Object> ret = new HashMap<>();
+            ret.put("item", stack.getItem().getRegistryName().toString());
+
+            if (stack.getItem().getHasSubtypes() || stack.getItemDamage() != 0) {
+                ret.put("data", stack.getItemDamage());
+            }
+            if (stack.getCount() > 1) {
+                ret.put("count", stack.getCount());
+            }
+
+            if (stack.hasTagCompound()) {
+                ret.put("nbt", stack.getTagCompound().toString());
+            }
+
+            return ret;
+        }
+        if (thing instanceof String) {
+            Map<String, Object> ret = new HashMap<>();
+            USED_ORE_DICTIONARY_NAMES.add((String) thing);
+            ret.put("item", "#" + ((String) thing).toUpperCase(Locale.ROOT));
+            return ret;
+        }
+
+        throw new IllegalArgumentException("Not a animation.animations.blocks, item, stack, or od name");
+    }
+
+    private static void generateConstants() {
+        List<Map<String, Object>> json = new ArrayList<>();
+
+        for (String s : USED_ORE_DICTIONARY_NAMES) {
+            Map<String, Object> entry = new HashMap<>();
+            entry.put("name", s.toUpperCase(Locale.ROOT));
+            entry.put("ingredient", ImmutableMap.of("type", "forge:ore_dict", "ore", s));
+            json.add(entry);
+        }
+
+        try (FileWriter w = new FileWriter(new File(RECIPE_DIR, "_constants.json"))) {
+            GSON.toJson(json, w);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/WorldProviderBOPHell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/WorldProviderBOPHell.java	(date 1524916602000)
+++ src/main/java/net/hdt/neutronia/world/WorldProviderBOPHell.java	(date 1524916602000)
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright 2014-2017, the Biomes O' Plenty Team
+ *
+ * This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License.
+ *
+ * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.
+ ******************************************************************************//*
+
+package net.hdt.neutronia.world;
+
+import net.hdt.neutronia.world.gen.ChunkGeneratorHellBOP;
+import net.minecraft.world.WorldProviderHell;
+import net.minecraft.world.gen.IChunkGenerator;
+
+public class WorldProviderBOPHell extends WorldProviderHell
+{
+    @Override
+    public void init()
+    {
+        this.biomeProvider = new BiomeProviderBOPHell(this.world);
+        this.doesWaterVaporize = true;
+        this.nether = true;
+    }
+
+    @Override
+    public IChunkGenerator createChunkGenerator()
+    {
+        return new ChunkGeneratorHellBOP(this.world, this.world.getWorldInfo().isMapFeaturesEnabled(), this.world.getSeed());
+    }
+}*/
Index: src/main/java/net/hdt/neutronia/world/dungeons/generator/HallwayStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/dungeons/generator/HallwayStructure.java	(date 1523988242000)
+++ src/main/java/net/hdt/neutronia/world/dungeons/generator/HallwayStructure.java	(date 1523988242000)
@@ -0,0 +1,47 @@
+package net.hdt.neutronia.world.dungeons.generator;
+
+import net.hdt.neutronia.util.Reference;
+import net.hdt.neutronia.util.interfaces.IStructure;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.gen.structure.template.TemplateManager;
+
+import java.util.Random;
+
+public class HallwayStructure extends WorldGenerator implements IStructure {
+
+    private static String structureName;
+
+    public HallwayStructure(String name) {
+        structureName = name;
+    }
+
+    private static void generateStructure(World world, BlockPos pos) {
+        MinecraftServer mcServer = world.getMinecraftServer();
+        TemplateManager manager = worldServer.getStructureTemplateManager();
+        ResourceLocation location = new ResourceLocation(Reference.MOD_ID, structureName);
+        Template template = manager.get(mcServer, location);
+
+        if (template != null) {
+            IBlockState state = world.getBlockState(pos);
+            world.notifyBlockUpdate(pos, state, state, 3);
+            template.addBlocksToWorldChunk(world, pos, settings);
+        }
+
+        if (template == null) {
+            System.out.println("NO STRUCTURE");
+        }
+
+    }
+
+    @Override
+    public boolean generate(World worldIn, Random rand, BlockPos position) {
+        generateStructure(worldIn, position);
+        return true;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/WorldGenCustomStructures.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/WorldGenCustomStructures.java	(date 1524930481000)
+++ src/main/java/net/hdt/neutronia/world/gen/WorldGenCustomStructures.java	(date 1524930481000)
@@ -0,0 +1,140 @@
+package net.hdt.neutronia.world.gen;
+
+import net.hdt.neutronia.world.gen.generators.WorldGenStructure;
+import net.hdt.neutronia.world.gen.structure.WorldGenCivilizationRuins;
+import net.hdt.neutronia.world.utils.WorldGenUtils;
+import net.minecraft.block.Block;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldType;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Random;
+
+public class WorldGenCustomStructures implements IWorldGenerator {
+
+    public static final WorldGenStructure LIVING_CORAL_REEF = new WorldGenStructure("living_coral_reef");
+    public static final WorldGenStructure DEAD_CORAL_REEF = new WorldGenStructure("dead_coral_reef");
+    public static final WorldGenStructure VOLCANO = new WorldGenStructure("volcano");
+    public static final WorldGenStructure DESERT_HOUSE_1 = new WorldGenStructure("desert_house_1");
+    public static final WorldGenStructure DESERT_HOUSE_2 = new WorldGenStructure("desert_house_2");
+    public static final WorldGenStructure JUNGLE_VILLAGER_TOTEM = new WorldGenStructure("jungle_villager_totem");
+
+    public static final WorldGenStructure CORAL_PINK = new WorldGenStructure("coral_pink");
+    public static final WorldGenStructure CORAL_YELLOW = new WorldGenStructure("coral_yellow");
+    public static final WorldGenStructure CORAL_PURPLE = new WorldGenStructure("coral_purple");
+    public static final WorldGenStructure CORAL_BLUE = new WorldGenStructure("coral_blue");
+    public static final WorldGenStructure CORAL_RED = new WorldGenStructure("coral_red");
+
+    public static final WorldGenStructure CRUST1 = new WorldGenStructure("ocean_structures/corals/crust1");
+    public static final WorldGenStructure CRUST2 = new WorldGenStructure("ocean_structures/corals/crust2");
+    public static final WorldGenStructure CRUST3 = new WorldGenStructure("ocean_structures/corals/crust3");
+    public static final WorldGenStructure CRUST4 = new WorldGenStructure("ocean_structures/corals/crust4");
+    public static final WorldGenStructure CRUST5 = new WorldGenStructure("ocean_structures/corals/crust5");
+
+    public static final WorldGenStructure SPHINX_FRONT = new WorldGenStructure("large_sphinx_front");
+    public static final WorldGenStructure SPHINX_BACK = new WorldGenStructure("large_sphinx_ass");
+
+    public static final WorldGenerator ruins = new WorldGenCivilizationRuins();
+
+    public WorldGenCustomStructures() {
+        super();
+    }
+
+    @Override
+    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
+        switch (world.provider.getDimension()) {
+            case 1:
+                break;
+            case 0:
+//                generateCoral(CORAL_PINK, world, random, chunkX, chunkZ, 5);
+//                generateCoral(CORAL_YELLOW, world, random, chunkX, chunkZ, 8);
+//                generateCoral(CORAL_PURPLE, world, random, chunkX, chunkZ, 2);
+//                generateCoral(CORAL_BLUE, world, random, chunkX, chunkZ, 10);
+//                generateCoral(CORAL_RED, world, random, chunkX, chunkZ, 7);
+
+//                generateCoral(CRUST1, world, random, chunkX, chunkZ, 5);
+//                generateCoral(CRUST2, world, random, chunkX, chunkZ, 8);
+//                generateCoral(CRUST3, world, random, chunkX, chunkZ, 2);
+//                generateCoral(CRUST4, world, random, chunkX, chunkZ, 10);
+//                generateCoral(CRUST5, world, random, chunkX, chunkZ, 7);
+
+//                generateStructure(SPHINX_FRONT, world, random, chunkX, chunkZ, 10, Blocks.SAND, Biomes.DESERT, Biomes.DESERT_HILLS);
+//                generateStructure(SPHINX_BACK, world, random, chunkX, chunkZ, 10, Blocks.SAND, Biomes.DESERT, Biomes.DESERT_HILLS);
+
+                generateStructure(ruins, world, random, chunkX, chunkZ, 10, Blocks.GRASS);
+
+                break;
+            case -1:
+                break;
+        }
+    }
+
+    private void generateStructure(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance, Block topBlock, Biome... classes) {
+        ArrayList<Biome> classesList = new ArrayList<>(Arrays.asList(classes));
+
+        int x = (chunkX * 16) + random.nextInt(15);
+        int z = (chunkZ * 16) + random.nextInt(15);
+        int y = WorldGenUtils.calculateGenerationHeight(world, x, z, topBlock);
+        BlockPos pos = new BlockPos(x, y, z);
+
+        Class<?> biome = world.provider.getBiomeForCoords(pos).getClass();
+
+        if (world.getWorldType() != WorldType.FLAT) {
+            if (classesList.contains(biome)) {
+                if (random.nextInt(chance) == 0) {
+                    generator.generate(world, random, pos);
+                }
+            }
+        }
+    }
+
+    private void generateUndergroundStructure(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance, int structureHeight, Block topBlock, Biome... classes) {
+        ArrayList<Biome> classesList = new ArrayList<>(Arrays.asList(classes));
+
+        int x = (chunkX * 16) + random.nextInt(15);
+        int z = (chunkZ * 16) + random.nextInt(15);
+        int y = WorldGenUtils.calculateGenerationHeight(world, x, z, topBlock);
+        BlockPos pos = new BlockPos(x, y, z);
+
+        Class<?> biome = world.provider.getBiomeForCoords(pos).getClass();
+
+        if (world.getWorldType() != WorldType.FLAT) {
+            if (classesList.contains(biome)) {
+                if (random.nextInt(chance) == 0) {
+                    if (y + structureHeight < world.getHeight()) {
+                        generator.generate(world, random, pos);
+                    }
+                }
+            }
+        }
+    }
+
+    private void generateCoral(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance) {
+        int x = (chunkX * 16) + random.nextInt(15);
+        int z = (chunkZ * 16) + random.nextInt(15);
+        int y = WorldGenUtils.calculateGenerationHeight(world, x, z, Blocks.GRAVEL);
+        BlockPos pos = new BlockPos(x, y, z);
+
+        Biome biome = world.provider.getBiomeForCoords(pos);
+
+        if (world.getWorldType() != WorldType.FLAT) {
+            if (biome == Biomes.DEEP_OCEAN || biome == Biomes.OCEAN || biome == Biomes.FROZEN_OCEAN) {
+                if (random.nextInt(chance) == 0) {
+                    if (y + 19 < world.getSeaLevel()) {
+                        generator.generate(world, random, pos);
+                    }
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/utils/ClayGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/ClayGenerator.java	(date 1523986188000)
+++ src/main/java/net/hdt/neutronia/world/utils/ClayGenerator.java	(date 1523986188000)
@@ -0,0 +1,35 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraft.world.gen.feature.WorldGenMinable;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.util.Random;
+
+public class ClayGenerator implements IWorldGenerator {
+
+    int clusterCount;
+    WorldGenMinable generator;
+
+    public ClayGenerator(int clusterSize, int clusterCount) {
+        this.clusterCount = clusterCount;
+
+        generator = new WorldGenMinable(Blocks.CLAY.getDefaultState(), clusterSize);
+    }
+
+    @Override
+    public void generate(Random rand, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
+        for (int i = 0; i < clusterCount; i++) {
+            int x = chunkX * 16 + rand.nextInt(16);
+            int y = rand.nextInt(60);
+            int z = chunkZ * 16 + rand.nextInt(16);
+
+            generator.generate(world, rand, new BlockPos(x, y, z));
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityGreatHunger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityGreatHunger.java	(date 1523987835000)
+++ src/main/java/net/hdt/neutronia/entity/EntityGreatHunger.java	(date 1523987835000)
@@ -0,0 +1,52 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAILookIdle;
+import net.minecraft.entity.ai.EntityAIWatchClosest;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.world.World;
+
+import javax.annotation.Nullable;
+
+public class EntityGreatHunger extends EntityMob {
+
+    public EntityGreatHunger(World worldIn) {
+        super(worldIn);
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_SILVERFISH_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_SILVERFISH_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_SILVERFISH_DEATH;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.DROWNED;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/ai/EntityAIMummyAttack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/EntityAIMummyAttack.java	(date 1523987841000)
+++ src/main/java/net/hdt/neutronia/entity/ai/EntityAIMummyAttack.java	(date 1523987841000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.entity.ai;
+
+import net.hdt.neutronia.entity.EntityMummy;
+import net.minecraft.entity.ai.EntityAIAttackMelee;
+
+public class EntityAIMummyAttack extends EntityAIAttackMelee {
+
+    private final EntityMummy mummy;
+    private int raiseArmTicks;
+
+    public EntityAIMummyAttack(EntityMummy mummyIn, double speedIn, boolean longMemoryIn) {
+        super(mummyIn, speedIn, longMemoryIn);
+        this.mummy = mummyIn;
+    }
+
+    @Override
+    public void startExecuting() {
+        super.startExecuting();
+        this.raiseArmTicks = 0;
+    }
+
+    @Override
+    public void resetTask() {
+        super.resetTask();
+        this.mummy.setArmsRaised(false);
+    }
+
+    @Override
+    public void updateTask() {
+        super.updateTask();
+        ++this.raiseArmTicks;
+
+        if (this.raiseArmTicks >= 5 && this.attackTick < 10) {
+            this.mummy.setArmsRaised(true);
+        } else {
+            this.mummy.setArmsRaised(false);
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/Main.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/Main.java	(date 1525606898000)
@@ -0,0 +1,140 @@
+package net.hdt.neutronia;
+
+import net.hdt.neutronia.commands.TPBiomeCommand;
+import net.hdt.neutronia.commands.TPDimensionCommand;
+import net.hdt.neutronia.init.HMBlocks;
+import net.hdt.neutronia.modules.building.NeutroniaBuilding;
+import net.hdt.neutronia.proxy.CommonProxy;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.item.crafting.CraftingManager;
+import net.minecraft.item.crafting.IRecipe;
+import net.minecraft.item.crafting.Ingredient;
+import net.minecraft.item.crafting.ShapedRecipes;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.fml.common.Mod;
+import net.minecraftforge.fml.common.SidedProxy;
+import net.minecraftforge.fml.common.event.*;
+import net.minecraftforge.fml.common.network.simpleimpl.SimpleNetworkWrapper;
+import net.thegaminghuskymc.huskylib2.module.ModuleLoader;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+import static net.hdt.neutronia.util.Reference.*;
+
+@Mod(modid = MOD_ID, name = NAME, version = VERSION, dependencies = DEPENDENCIES)
+public class Main {
+
+    public static final Logger LOGGER = LogManager.getLogger(NAME);
+    public static CreativeTabs OVERWORLD_EXPANSION_TAB = new CreativeTabs("overworld_expansion") {
+        @Override
+        public ItemStack getTabIconItem() {
+            return new ItemStack(Item.getItemFromBlock(HMBlocks.brain_coral[0]));
+        }
+    };
+    public static CreativeTabs NETHER_EXPANSION_TAB = new CreativeTabs("nether_expansion") {
+        @Override
+        public ItemStack getTabIconItem() {
+            return new ItemStack(Item.getItemFromBlock(Blocks.NETHER_BRICK));
+        }
+    };
+    public static CreativeTabs END_EXPANSION_TAB = new CreativeTabs("end_expansion") {
+        @Override
+        public ItemStack getTabIconItem() {
+            return new ItemStack(Item.getItemFromBlock(Blocks.END_BRICKS));
+        }
+    };
+    public static CreativeTabs FOOD_EXPANSION_TAB = new CreativeTabs("food_expansion") {
+        @Override
+        public ItemStack getTabIconItem() {
+            return new ItemStack(Items.COOKED_BEEF);
+        }
+    };
+    public static CreativeTabs ITEM_EXPANSION_TAB = new CreativeTabs("item_expansion") {
+        @Override
+        public ItemStack getTabIconItem() {
+            return new ItemStack(Items.MAP);
+        }
+    };
+    @Mod.Instance
+    public static Main instance;
+    public static SimpleNetworkWrapper network;
+    @SidedProxy(clientSide = Reference.CLIENT_PROXY, serverSide = Reference.SERVER_PROXY)
+    public static CommonProxy proxy;
+    public static File configDirectory;
+
+    @Mod.EventHandler
+    public static void preInit(FMLPreInitializationEvent event) {
+        ModuleLoader.registerModule(NeutroniaBuilding.class);
+        MinecraftForge.EVENT_BUS.register(HMBlocks.class);
+
+        List<ResourceLocation> recipeList = new ArrayList<>(CraftingManager.REGISTRY.getKeys());
+        for (ResourceLocation res : recipeList) {
+            IRecipe recipe = CraftingManager.REGISTRY.getObject(res);
+            ItemStack out = recipe.getRecipeOutput();
+            if (recipe instanceof ShapedRecipes && !out.isEmpty() && (out.getItem() == Item.getItemFromBlock(Blocks.TRAPDOOR))) {
+                ShapedRecipes shaped = (ShapedRecipes) recipe;
+                NonNullList<Ingredient> ingredients = shaped.recipeItems;
+                for (int i = 0; i < ingredients.size(); i++) {
+                    Ingredient ingr = ingredients.get(i);
+                    if (ingr.apply(ProxyRegistry.newStack(Blocks.PLANKS))) {
+                        ingredients.set(i, Ingredient.fromStacks(ProxyRegistry.newStack(Blocks.PLANKS, 1, 0)));
+                        out.setCount(6);
+                    }
+                }
+            }
+            if (recipe instanceof ShapedRecipes && !out.isEmpty() && (out.getItem() == Item.getItemFromBlock(Blocks.CHEST) || out.getItem() == Item.getItemFromBlock(Blocks.TRAPPED_CHEST))) {
+                ShapedRecipes shaped = (ShapedRecipes) recipe;
+                NonNullList<Ingredient> ingredients = shaped.recipeItems;
+                for (int i = 0; i < ingredients.size(); i++) {
+                    Ingredient ingr = ingredients.get(i);
+                    if (ingr.apply(ProxyRegistry.newStack(Blocks.PLANKS)))
+                        ingredients.set(i, Ingredient.fromStacks(ProxyRegistry.newStack(Blocks.PLANKS, 1, 0)));
+                }
+            }
+            if (recipe instanceof ShapedRecipes && !out.isEmpty() && (out.getItem() == Item.getItemFromBlock(Blocks.BOOKSHELF))) {
+                ShapedRecipes shaped = (ShapedRecipes) recipe;
+                NonNullList<Ingredient> ingredients = shaped.recipeItems;
+                for (int i = 0; i < ingredients.size(); i++) {
+                    Ingredient ingr = ingredients.get(i);
+                    if (ingr.apply(ProxyRegistry.newStack(Blocks.PLANKS)))
+                        ingredients.set(i, Ingredient.fromStacks(ProxyRegistry.newStack(Blocks.PLANKS, 1, 0)));
+                }
+            }
+        }
+        proxy.preInit(event);
+    }
+
+    @Mod.EventHandler
+    public static void init(FMLInitializationEvent event) {
+        proxy.init(event);
+    }
+
+    @Mod.EventHandler
+    public static void postInit(FMLPostInitializationEvent event) {
+        proxy.postInit(event);
+    }
+
+    @Mod.EventHandler
+    public static void serverInit(FMLServerStartingEvent event) {
+        event.registerServerCommand(new TPBiomeCommand());
+        event.registerServerCommand(new TPDimensionCommand());
+    }
+
+    @Mod.EventHandler
+    public void onFMLServerStopping(FMLServerStoppingEvent event) {
+
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceWithParticlesAlt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceWithParticlesAlt.java	(date 1524550118000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockColoredLightSourceWithParticlesAlt.java	(date 1524550118000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Random;
+
+public class BlockColoredLightSourceWithParticlesAlt extends BlockColoredLightSourceAlt {
+
+    public BlockColoredLightSourceWithParticlesAlt(String modid, String name, EnumDyeColor color) {
+        super(modid, name, color);
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand) {
+        double d0 = (double) pos.getX() + 0.5D;
+        double d1 = (double) pos.getY() + 0.7D;
+        double d2 = (double) pos.getZ() + 0.5D;
+
+        worldIn.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, d0, d1, d2, 0.0D, 0.0D, 0.0D);
+        worldIn.spawnParticle(EnumParticleTypes.FLAME, d0, d1, d2, 0.0D, 0.0D, 0.0D);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Structure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Structure.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Structure.java	(date 1525606896000)
@@ -0,0 +1,444 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.init.Blocks;
+import net.minecraft.nbt.CompressedStreamTools;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.common.util.Constants;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.*;
+
+/* Holds schematic-extended information and can load/spawn/calibrate it */
+public class Structure {
+
+    public NBTTagCompound flags = new NBTTagCompound();
+    public File schematicFile;
+    public File flagFile;
+    public File structureFile;
+
+    public Structure(File schematicFile, File flagFile, File structureFile) throws IOException {
+
+        /* Load structure if it exists */
+        this.schematicFile = schematicFile;
+        this.flagFile = flagFile;
+        this.structureFile = structureFile;
+        if (flagFile.exists() && structureFile.exists()) {
+            FileInputStream fis = new FileInputStream(flagFile);
+            flags = CompressedStreamTools.readCompressed(fis);
+            fis.close();
+            return;
+        }
+
+        /* Load schematic */
+        FileInputStream fis = new FileInputStream(schematicFile);
+        NBTTagCompound schematic = CompressedStreamTools.readCompressed(fis);
+        fis.close();
+        String materials = schematic.getString("Materials");
+        if (!materials.equals("Alpha")) {
+            throw new IOException("Material of schematic is not an alpha");
+        }
+        int width = schematic.getShort("Width");
+        int height = schematic.getShort("Height");
+        int length = schematic.getShort("Length");
+        if (width == 0 || height == 0 || length == 0) {
+            throw new IOException("Zero size schematic");
+        }
+        byte[] addBlocks = schematic.getByteArray("AddBlocks");
+        byte[] blocksID = schematic.getByteArray("Blocks");
+        if (width * height * length != blocksID.length) {
+            throw new IOException("Wrong schematic size: " + width * height * length + "/" + blocksID.length);
+        }
+        short[] blocks = compose(blocksID, addBlocks);
+
+        /* Set flags */
+        String path = schematicFile.getPath().toLowerCase().replace("\\", "/").replace("//", "/");
+        flags.setString("Method", "Common");
+        if (path.contains("/underground/")) flags.setString("Method", "Underground");
+        if (path.contains("/village/") ||
+                path.contains("/town/") ||
+                path.contains("/villa/")) flags.setString("Method", "Village");
+        if (path.contains("/floating/")) flags.setString("Method", "Floating");
+        if (path.contains("/water/")) flags.setString("Method", "Water");
+        if (path.contains("/underwater/")) flags.setString("Method", "Underwater");
+        flags.setInteger("Biome", Biome.detect(blocks).value);
+        if (flags.getString("Method").equalsIgnoreCase("Water") ||
+                flags.getString("Method").equalsIgnoreCase("Underwater")) {
+            flags.setInteger("Biome", Biome.Style.WATER.value);
+        }
+        flags.setShort("Width", (short) width);
+        flags.setShort("Height", (short) height);
+        flags.setShort("Length", (short) length);
+        flags.setInteger("Lift", getLift(blocks));
+
+        /* Generate structure over schematic */
+        schematic.setByteArray("Skin", getSkin(blocks).toByteArray());
+
+        /* Save flags */
+        flagFile.getParentFile().mkdirs();
+        FileOutputStream fosFlag = new FileOutputStream(flagFile);
+        CompressedStreamTools.writeCompressed(flags, fosFlag);
+        fosFlag.close();
+
+        /* Save structure */
+        structureFile.getParentFile().mkdirs();
+        FileOutputStream fosStruct = new FileOutputStream(structureFile);
+        CompressedStreamTools.writeCompressed(schematic, fosStruct);
+        fosStruct.close();
+
+    }
+
+    void paste(World world, Posture posture, long seed) throws IOException {
+
+        /* Load ad paste structure */
+        NBTTagCompound structure;
+        FileInputStream fis = new FileInputStream(structureFile);
+        structure = CompressedStreamTools.readCompressed(fis);
+        fis.close();
+        NBTTagList entities = structure.getTagList("TileEntities", Constants.NBT.TAG_COMPOUND);
+        byte[] blocksMetadata = structure.getByteArray("Data");
+        final byte[] addBlocks = structure.getByteArray("AddBlocks");
+        byte[] blocksID = structure.getByteArray("Blocks");
+        short[] blocks = compose(blocksID, addBlocks);
+        BitSet skin = BitSet.valueOf(structure.getByteArray("Skin"));
+
+        /* Prepare tiles */
+        Random random = new Random(seed);
+        ArrayList<ResourceLocation> lootTables = new ArrayList<ResourceLocation>() {{
+            add(LootTableList.CHESTS_ABANDONED_MINESHAFT);
+            add(LootTableList.CHESTS_JUNGLE_TEMPLE);
+            add(LootTableList.CHESTS_SIMPLE_DUNGEON);
+            add(LootTableList.CHESTS_SPAWN_BONUS_CHEST);
+            add(LootTableList.CHESTS_STRONGHOLD_CORRIDOR);
+            add(LootTableList.CHESTS_STRONGHOLD_CROSSING);
+            add(LootTableList.CHESTS_STRONGHOLD_LIBRARY);
+        }};
+        if (flags.getString("Method").equalsIgnoreCase("Village")) {
+            lootTables.add(LootTableList.CHESTS_VILLAGE_BLACKSMITH);
+        }
+        if (flags.getString("Biome").equalsIgnoreCase("Sand")) {
+            lootTables.add(LootTableList.CHESTS_DESERT_PYRAMID);
+        }
+        if (flags.getString("Biome").equalsIgnoreCase("Snow")) {
+            lootTables.add(LootTableList.CHESTS_IGLOO_CHEST);
+        }
+        if (flags.getString("Biome").equalsIgnoreCase("Nether")) {
+            lootTables.add(LootTableList.CHESTS_NETHER_BRIDGE);
+        }
+        if (flags.getString("Biome").equalsIgnoreCase("End")) {
+            lootTables.add(LootTableList.CHESTS_END_CITY_TREASURE);
+        }
+
+        /* Paste */
+        int width = posture.getWidth();
+        int height = posture.getHeight();
+        int length = posture.getLength();
+        int startChunkX = posture.getStartChunkX();
+        int startChunkZ = posture.getStartChunkZ();
+        int sizeChunkX = posture.getEndChunkX() - startChunkX + 1;
+        int sizeChunkZ = posture.getEndChunkZ() - startChunkZ + 1;
+        ExtendedBlockStorage[][][] storage = new ExtendedBlockStorage[sizeChunkX][sizeChunkZ][16];
+        for (int cx = 0; cx < sizeChunkX; ++cx) {
+            for (int cz = 0; cz < sizeChunkZ; ++cz) {
+                Chunk chunk = world.getChunkFromChunkCoords(cx + startChunkX, cz + startChunkZ);
+                for (int sy = 0; sy < 256; sy += 16) {
+                    IBlockState state = chunk.getBlockState(new BlockPos(0, sy, 0));
+                    chunk.setBlockState(new BlockPos(0, sy, 0), Blocks.LOG.getDefaultState());
+                    chunk.setBlockState(new BlockPos(0, sy, 0), state);
+                }
+                ExtendedBlockStorage[] stack = chunk.getBlockStorageArray();
+                System.arraycopy(stack, 0, storage[cx][cz], 0, 16);
+            }
+        }
+
+        int[] blockReplaces = new int[256];
+        for (int blockID = 0; blockID < 256; ++blockID) {
+            blockReplaces[blockID] = blockID;
+        }
+        if (Decorator.balanceMode) {
+            blockReplaces[Block.getIdFromBlock(Blocks.BEDROCK)] = Block.getIdFromBlock(Blocks.COBBLESTONE);
+            blockReplaces[Block.getIdFromBlock(Blocks.IRON_BLOCK)] = Block.getIdFromBlock(Blocks.MOSSY_COBBLESTONE);
+            blockReplaces[Block.getIdFromBlock(Blocks.GOLD_BLOCK)] = Block.getIdFromBlock(Blocks.STONEBRICK);
+            blockReplaces[Block.getIdFromBlock(Blocks.DIAMOND_BLOCK)] = Block.getIdFromBlock(Blocks.MOSSY_COBBLESTONE);
+            blockReplaces[Block.getIdFromBlock(Blocks.LAPIS_BLOCK)] = Block.getIdFromBlock(Blocks.STONEBRICK);
+            blockReplaces[Block.getIdFromBlock(Blocks.EMERALD_BLOCK)] = Block.getIdFromBlock(Blocks.MOSSY_COBBLESTONE);
+            blockReplaces[Block.getIdFromBlock(Blocks.WOOL)] = Block.getIdFromBlock(Blocks.LOG);
+            blockReplaces[Block.getIdFromBlock(Blocks.BEACON)] = Block.getIdFromBlock(Blocks.QUARTZ_BLOCK);
+        }
+        if (Decorator.preventCommandBlock) {
+            blockReplaces[Block.getIdFromBlock(Blocks.COMMAND_BLOCK)] = Block.getIdFromBlock(Blocks.MOSSY_COBBLESTONE);
+        }
+        if (Decorator.preventMobSpawners) {
+            blockReplaces[Block.getIdFromBlock(Blocks.MOB_SPAWNER)] = Block.getIdFromBlock(Blocks.MOSSY_COBBLESTONE);
+        }
+
+        double lootChance = Decorator.lootChance;
+        String[] mobs = new String[]{"Enderman", "CaveSpider", "Chicken", "Creeper",
+                "Witch", "Slime", "Spider", "Sheep", "Blaze", "Bat", "PigZombie",
+                "Ghast", "Cow", "SnowMan", "LavaSlime", "Zombie", "Skeleton", "Pig"};
+
+        Block[] vanillaBlocks = Decorator.vanillaBlocks;
+        boolean allowOnlyVanillaBlocks = Decorator.allowOnlyVanillaBlocks;
+
+        // getStateFromMeta -> IllegalArgumentException
+        for (int y = 0, index = 0; y < height; ++y) {
+            for (int z = 0; z < length; ++z) {
+                for (int x = 0; x < width; ++x, ++index) {
+                    if (skin.get(index)) {
+                        continue;
+                    }
+                    BlockPos blockPos = posture.getWorldPos(x, y, z);
+                    if (blockPos.getY() < 0 || blockPos.getY() > 255) {
+                        continue;
+                    }
+                    int blockID = blocks[index];
+                    Block block = null;
+                    int meta = 0;
+                    if (blockID >= 0 && blockID < 256) {
+                        blockID = blockReplaces[blockID];
+                        block = vanillaBlocks[blockID];
+                    }
+                    if (block == null) {
+                        if (allowOnlyVanillaBlocks) {
+                            continue;
+                        }
+                        block = Block.getBlockById(blockID);
+                    } else {
+                        meta = posture.getWorldMeta(block, blocksMetadata[index]);
+                    }
+                    IBlockState state = block.getDefaultState();
+                    try {
+                        state = block.getStateFromMeta(meta);
+                    } catch (IllegalArgumentException ignore) {
+                    }
+                    int rx = blockPos.getX() - startChunkX * 16;
+                    int ry = blockPos.getY();
+                    int rz = blockPos.getZ() - startChunkZ * 16;
+                    ExtendedBlockStorage store = storage[rx / 16][rz / 16][ry / 16];
+                    if (store != null) {
+                        store.set(rx % 16, ry % 16, rz % 16, state);
+                    } else {
+                        world.setBlockState(blockPos, state);
+                    }
+                    //world.markBlockRangeForRenderUpdate(blockPos, blockPos);
+                    //world.setBlockState(blockPos, state);
+                    //chunk.setModified(true);
+                    //world.setBlockState(blockPos, state, 2);
+                    TileEntity blockTile = world.getTileEntity(blockPos);
+                    if (blockTile != null) {
+                        if (blockTile instanceof TileEntityChest && lootChance >= random.nextDouble()) {
+                            TileEntityChest chest = (TileEntityChest) blockTile;
+                            int id = Math.abs(random.nextInt() % lootTables.size());
+                            chest.setLootTable(lootTables.get(id), random.nextLong());
+                        }
+                        if (blockTile instanceof TileEntityMobSpawner) {
+                            TileEntityMobSpawner spawner = (TileEntityMobSpawner) blockTile;
+                            spawner.getSpawnerBaseLogic().setEntityId(new ResourceLocation(mobs[Math.abs(random.nextInt()) % mobs.length]));
+                        }
+                    }
+                }
+            }
+        }
+        world.markBlockRangeForRenderUpdate(posture.getWorldPos(0, 0, 0), posture.getWorldPos(width, height, length));
+
+        /* Populate village */
+        if (flags.getString("Method").equalsIgnoreCase("Village")) {
+            int count = (int) (1 + Math.cbrt(Math.abs(posture.getWidth() * posture.getLength()))) / 2;
+            int maxTries = 16 + count * count;
+            for (int i = 0; i < maxTries && count > 0; ++i) {
+                int xPos = posture.getPosX() + Math.abs(random.nextInt()) % posture.getSizeX();
+                int yPos = posture.getPosY() + Math.abs(random.nextInt()) % posture.getSizeY();
+                int zPos = posture.getPosZ() + Math.abs(random.nextInt()) % posture.getSizeZ();
+                if (!world.isAirBlock(new BlockPos(xPos, yPos, zPos)) || !world.isAirBlock(new BlockPos(xPos, yPos + 1, zPos))) {
+                    continue;
+                }
+                EntityVillager villager = new EntityVillager(world, Math.abs(random.nextInt()) % 5);
+                float facing = random.nextFloat() * 360.0F;
+                villager.setLocationAndAngles(xPos + 0.5, yPos + 0.1, zPos + 0.5, facing, 0.0F);
+                world.spawnEntity(villager);
+                villager.playLivingSound();
+                --count;
+            }
+        }
+
+        /* Spawn entities */
+
+
+    }
+
+    /* Combine all 8b-blocksID and 8b-addBlocks to 16b-block */
+    private short[] compose(byte[] blocksID, byte[] addBlocks) {
+        short[] blocks = new short[blocksID.length];
+        for (int index = 0; index < blocksID.length; index++) {
+            if ((index >> 1) >= addBlocks.length) {
+                blocks[index] = (short) (blocksID[index] & 0xFF);
+            } else {
+                if ((index & 1) == 0) {
+                    blocks[index] = (short) (((addBlocks[index >> 1] & 0x0F) << 8) + (blocksID[index] & 0xFF));
+                } else {
+                    blocks[index] = (short) (((addBlocks[index >> 1] & 0xF0) << 4) + (blocksID[index] & 0xFF));
+                }
+            }
+        }
+        return blocks;
+    }
+
+    /* Get structure ground level (lift) to dig it down */
+    private int getLift(short[] blocks) {
+        int width = flags.getShort("Width");
+        int height = flags.getShort("Height");
+        int length = flags.getShort("Length");
+        int[][] level = new int[width][length];
+        int[][] levelMax = new int[width][length];
+        boolean[] liquid = Decorator.liquid;
+        boolean[] soil = Decorator.soil;
+        boolean dry = !flags.getString("Method").equalsIgnoreCase("Underwater");
+        Posture posture = new Posture(0, 0, 0, 0, 0, 0, false, false, false, width, height, length);
+        for (int index = 0; index < blocks.length; ++index) {
+            if (blocks[index] >= 0 && blocks[index] < 256) {
+                if (soil[blocks[index]] || (dry && liquid[blocks[index]])) {
+                    level[posture.getX(index)][posture.getZ(index)] += 1;
+                    levelMax[posture.getX(index)][posture.getZ(index)] = posture.getY(index) + 1;
+                }
+            }
+        }
+        long borders = 0, totals = 0;
+        for (int x = 0; x < width; ++x) {
+            for (int z = 0; z < length; ++z) {
+                totals += level[x][z];
+                if (x == 0 || z == 0 || x == width - 1 || z == length - 1) {
+                    borders += levelMax[x][z];
+                }
+            }
+        }
+        int borderLevel = (int) Math.round(borders / ((width + length) * 2.0));
+        int wholeLevel = Math.round(totals / (width * length));
+        return Math.max(borderLevel, wholeLevel);
+    }
+
+    /* Generate schematic skin as bitset of possible(0) and restricted(1) to spawn blocks */
+    private BitSet getSkin(short[] blocks) {
+        final byte Y_INC = 1;
+        final byte Y_DEC = 32;
+        final byte X_INC = 4;
+        final byte X_DEC = 2;
+        final byte Z_INC = 16;
+        final byte Z_DEC = 8;
+        int width = flags.getShort("Width");
+        int height = flags.getShort("Height");
+        int length = flags.getShort("Length");
+        Posture posture = new Posture(0, 0, 0, 0, 0, 0, false, false, false, width, height, length);
+        HashSet<Integer> skinBlocks = new HashSet<Integer>();
+        skinBlocks.add(Block.getIdFromBlock(Blocks.AIR));
+        if (flags.getString("Method").equalsIgnoreCase("Water") ||
+                flags.getString("Method").equalsIgnoreCase("Underwater")) {
+            skinBlocks.add(Block.getIdFromBlock(Blocks.WATER));
+            skinBlocks.add(Block.getIdFromBlock(Blocks.FLOWING_WATER));
+        }
+        Queue<Integer> indexQueue = new LinkedList<Integer>();
+        byte[] clipped = new byte[width * height * length];
+        BitSet working = new BitSet(width * height * length);
+        BitSet skin = new BitSet(width * height * length);
+        for (int dir = 0; dir <= 1; ++dir) {
+            for (int y = 0; y < height; ++y) {
+                for (int z = 0; z < length; ++z) {
+                    int index = dir == 0 ? posture.getIndex(0, y, z) : posture.getIndex(width - 1, y, z);
+                    int flag = dir == 0 ? X_INC : X_DEC;
+                    if (skinBlocks.contains((int) blocks[index])) {
+                        if (!working.get(index)) {
+                            indexQueue.add(index);
+                            working.set(index);
+                        }
+                        clipped[index] |= flag;
+                        skin.set(index);
+                    }
+                }
+                for (int x = 0; x < width; ++x) {
+                    int index = dir == 0 ? posture.getIndex(x, y, 0) : posture.getIndex(x, y, length - 1);
+                    int flag = dir == 0 ? Z_INC : Z_DEC;
+                    if (skinBlocks.contains((int) blocks[index])) {
+                        if (!working.get(index)) {
+                            indexQueue.add(index);
+                            working.set(index);
+                        }
+                        clipped[index] |= flag;
+                        skin.set(index);
+                    }
+                }
+            }
+        }
+        byte[] headID = {Y_INC, Y_DEC, X_INC, X_DEC, Z_INC, Z_DEC};
+        byte[] backID = {Y_DEC, Y_INC, X_DEC, X_INC, Z_DEC, Z_INC};
+        while (!indexQueue.isEmpty()) {
+            int index = indexQueue.remove();
+            working.clear(index);
+            int x = posture.getX(index);
+            int y = posture.getY(index);
+            int z = posture.getZ(index);
+            int[] idx = {
+                    posture.getIndex(x, y + 1, z),
+                    posture.getIndex(x, y - 1, z),
+                    posture.getIndex(x + 1, y, z),
+                    posture.getIndex(x - 1, y, z),
+                    posture.getIndex(x, y, z + 1),
+                    posture.getIndex(x, y, z - 1)
+            };
+            boolean[] cond = {
+                    y < height - 1,
+                    y > 0,
+                    x < width - 1,
+                    x > 0,
+                    z < length - 1,
+                    z > 0
+            };
+            for (int k = 0; k < 6; ++k) {
+                int next = idx[k];
+                if (cond[k] &&
+                        (clipped[index] & headID[k]) > 0 &&
+                        (clipped[next] & headID[k]) == 0 &&
+                        (clipped[next] & backID[k]) == 0 &&
+                        (skinBlocks.contains((int) blocks[next]))) {
+                    if (!working.get(next)) {
+                        working.set(next);
+                        indexQueue.add(next);
+                    }
+                    clipped[next] |= headID[k];
+                    skin.set(next);
+                }
+            }
+        }
+        for (int index = 0; index < skin.size(); ++index) {
+            if (skin.get(index)) {
+                int x = posture.getX(index);
+                int y = posture.getY(index);
+                int z = posture.getZ(index);
+                while (y-- > 0) {
+                    int next = posture.getIndex(x, y, z);
+                    if (!skin.get(next) && skinBlocks.contains((int) blocks[next])) {
+                        skin.set(next);
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+        return skin;
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockBarkSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockBarkSlab.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/slab/BlockBarkSlab.java	(date 1525606886000)
@@ -0,0 +1,24 @@
+package net.hdt.neutronia.modules.building.blocks.slab;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldSlabBase;
+import net.hdt.neutronia.modules.building.blocks.BlockBark;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockBarkSlab extends BlockOverworldSlabBase implements IRecipeGrouped {
+
+    public BlockBarkSlab(BlockBark.Variants variant, boolean doubleSlab) {
+        super(variant.getName() + "_slab", Material.WOOD, doubleSlab);
+        setHardness(2.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "bark_slab";
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/events/WorldGenEvents.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/events/WorldGenEvents.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/world/events/WorldGenEvents.java	(date 1525606901000)
@@ -0,0 +1,157 @@
+package net.hdt.neutronia.world.events;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.common.DungeonHooks;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.terraingen.PopulateChunkEvent;
+import net.minecraftforge.fml.common.Loader;
+import net.minecraftforge.fml.common.eventhandler.Event;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class WorldGenEvents {
+
+    @SubscribeEvent
+    public void onDungeonSpawn(PopulateChunkEvent.Populate event) {
+        if (event.getType() != PopulateChunkEvent.Populate.EventType.DUNGEON)
+            return;
+
+        int i = event.getChunkX() * 16;
+        int j = event.getChunkZ() * 16;
+
+        BlockPos blockpos = new BlockPos(i, 0, j);
+        World world = event.getWorld();
+        Random rand = event.getRand();
+
+        int x = rand.nextInt(16) + 8;
+        int y = rand.nextInt(256);
+        int z = rand.nextInt(16) + 8;
+        BlockPos generatePos = blockpos.add(x, y, z);
+        if (couldDungeonGenerate(world, rand, generatePos) && world instanceof WorldServer) {
+            placeDungeonAt((WorldServer) world, rand, generatePos);
+            event.setResult(Event.Result.DENY);
+        }
+    }
+
+    public boolean couldDungeonGenerate(World worldIn, Random rand, BlockPos position) {
+        int i = 3;
+        int j = rand.nextInt(2) + 2;
+        int k = -j - 1;
+        int l = j + 1;
+        int i1 = -1;
+        int j1 = 4;
+        int k1 = rand.nextInt(2) + 2;
+        int l1 = -k1 - 1;
+        int i2 = k1 + 1;
+        int j2 = 0;
+
+        for (int k2 = k; k2 <= l; ++k2) {
+            for (int l2 = -1; l2 <= 4; ++l2) {
+                for (int i3 = l1; i3 <= i2; ++i3) {
+                    BlockPos blockpos = position.add(k2, l2, i3);
+                    Material material = worldIn.getBlockState(blockpos).getMaterial();
+                    boolean flag = material.isSolid();
+
+                    if (l2 == -1 && !flag)
+                        return false;
+
+                    if (l2 == 4 && !flag)
+                        return false;
+
+                    if ((k2 == k || k2 == l || i3 == l1 || i3 == i2) && l2 == 0 && worldIn.isAirBlock(blockpos) && worldIn.isAirBlock(blockpos.up()))
+                        ++j2;
+                }
+            }
+        }
+
+        return j2 >= 1 && j2 <= 5;
+    }
+
+    public void placeDungeonAt(WorldServer world, Random rand, BlockPos position) {
+        int dungeonType = rand.nextInt(10);
+
+        MinecraftServer server = world.getMinecraftServer();
+        Template template = world.getStructureTemplateManager().getTemplate(server, new ResourceLocation("quark", "dungeon_" + dungeonType));
+        PlacementSettings settings = new PlacementSettings();
+        settings.setRotation(Rotation.values()[rand.nextInt(Rotation.values().length)]);
+
+        BlockPos size = template.getSize();
+        for (int x = 0; x < size.getX(); x++)
+            for (int y = 0; y < size.getY(); y++)
+                for (int z = 0; z < size.getZ(); z++) {
+                    BlockPos checkPos = position.add(Template.transformedBlockPos(settings, new BlockPos(x, y, z)));
+                    IBlockState checkState = world.getBlockState(checkPos);
+                    if (checkState.getBlock().getBlockHardness(checkState, world, checkPos) == -1 || world.canBlockSeeSky(checkPos))
+                        return; // Obstructed or exposed, can't generate here
+                }
+
+        template.addBlocksToWorld(world, position, settings);
+
+        int spawners = 0;
+        List<BlockPos> chests = new ArrayList();
+        Map<BlockPos, String> dataBlocks = template.getDataBlocks(position, settings);
+
+        for (Map.Entry<BlockPos, String> entry : dataBlocks.entrySet()) {
+            BlockPos pos = entry.getKey();
+            String data = entry.getValue();
+
+            if (data.equals("spawner")) {
+                spawners++;
+                world.setBlockState(pos, Blocks.MOB_SPAWNER.getDefaultState(), 2);
+                TileEntity tile = world.getTileEntity(pos);
+
+                if (tile instanceof TileEntityMobSpawner) {
+                    if (Loader.isModLoaded("dungeontweaks")) {
+                        try {
+                            Constructor<? extends Event> constructor = (Constructor<? extends Event>) Class.forName("com.EvilNotch.dungeontweeks.main.Events.EventDungeon$Post").getConstructor(TileEntity.class, BlockPos.class, Random.class, ResourceLocation.class, World.class);
+                            Event event = constructor.newInstance(tile, tile.getPos(), world.rand, new ResourceLocation("neutronia:dungeon"), world);
+                            MinecraftForge.EVENT_BUS.post(event);
+                        } catch (Throwable t) {
+                            t.printStackTrace();
+                        }
+                    } else
+                        ((TileEntityMobSpawner) tile).getSpawnerBaseLogic().setEntityId(DungeonHooks.getRandomDungeonMob(rand));
+                }
+            } else if (data.equals("chest"))
+                chests.add(pos);
+        }
+
+        int maxChests = spawners * 2 + rand.nextInt(spawners + 2);
+        while (chests.size() > maxChests) {
+            int i = rand.nextInt(chests.size());
+            BlockPos chestPos = chests.get(i);
+            chests.remove(i);
+            world.setBlockToAir(chestPos);
+        }
+
+        for (BlockPos pos : chests) {
+            world.setBlockState(pos, Blocks.CHEST.correctFacing(world, pos, Blocks.CHEST.getDefaultState()), 2);
+            TileEntity tile = world.getTileEntity(pos);
+
+            if (tile instanceof TileEntityChest) {
+                ((TileEntityChest) tile).setLootTable(LootTableList.CHESTS_SIMPLE_DUNGEON, rand.nextLong());
+            }
+        }
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/util/handlers/LootTableHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/LootTableHandler.java	(date 1525361508000)
+++ src/main/java/net/hdt/neutronia/util/handlers/LootTableHandler.java	(date 1525361508000)
@@ -0,0 +1,19 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.storage.loot.LootTableList;
+
+public class LootTableHandler {
+
+    public static final ResourceLocation MUMMY = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "mummy"));
+    public static final ResourceLocation MUMMY_VILLAGER = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "mummy_villager"));
+    public static final ResourceLocation SCORPION = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "scorpion"));
+    public static final ResourceLocation DROWNED = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "drowned"));
+    public static final ResourceLocation TURTLE = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "turtle"));
+    public static final ResourceLocation DOLPHIN = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "dolphin"));
+    public static final ResourceLocation PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "phantom"));
+    public static final ResourceLocation RED_PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "red_phantom"));
+    public static final ResourceLocation ENDER_PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "ender_phantom"));
+    public static final ResourceLocation LOST_MINER = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "lost_miner"));
+}
Index: src/main/java/net/hdt/neutronia/entity/render/RenderHoveringInferno.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderHoveringInferno.java	(date 1525606861000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderHoveringInferno.java	(date 1525606861000)
@@ -0,0 +1,26 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityHoveringInferno;
+import net.hdt.neutronia.entity.render.model.ModelHoveringInferno;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderHoveringInferno extends RenderLiving<EntityHoveringInferno> {
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/nether/hovering_inferno/hovering_inferno.png");
+
+    public RenderHoveringInferno(RenderManager manager) {
+        super(manager, new ModelHoveringInferno(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityHoveringInferno entity) {
+        return SCORP_TEXTURE;
+    }
+
+    @Override
+    protected void applyRotations(EntityHoveringInferno entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelPhantom.java	(date 1523986199000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelPhantom.java	(date 1523986199000)
@@ -0,0 +1,71 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class ModelPhantom extends ModelBase {
+
+    ModelRenderer head;
+    ModelRenderer body;
+    ModelRenderer leftWing;
+    ModelRenderer rightWing;
+    ModelRenderer bodyLeft;
+    ModelRenderer bodyMiddle;
+    ModelRenderer tailStart;
+    ModelRenderer tailEnd;
+
+    public ModelPhantom() {
+        this.textureWidth = 128;
+        this.textureHeight = 32;
+        this.bodyLeft = new ModelRenderer(this, 0, 8);
+        this.bodyLeft.setRotationPoint(2.6F, 17.0F, 1.1F);
+        this.bodyLeft.addBox(0.0F, 0.0F, 0.0F, 6, 2, 9, 0.0F);
+        this.leftWing = new ModelRenderer(this, 0, 20);
+        this.leftWing.setRotationPoint(6.0F, 0.0F, 0.0F);
+        this.leftWing.addBox(0.0F, 0.0F, 0.0F, 13, 1, 9, 0.0F);
+        this.tailStart = new ModelRenderer(this, 26, 0);
+        this.tailStart.setRotationPoint(-1.4F, 17.0F, 10.1F);
+        this.tailStart.addBox(0.0F, 0.0F, 0.0F, 3, 2, 6, 0.0F);
+        this.tailEnd = new ModelRenderer(this, 46, 0);
+        this.tailEnd.setRotationPoint(1.0F, 0.0F, 6.0F);
+        this.tailEnd.addBox(0.0F, 0.0F, 0.0F, 1, 1, 6, 0.0F);
+        this.rightWing = new ModelRenderer(this, 44, 20);
+        this.rightWing.setRotationPoint(-13.0F, 0.0F, 0.0F);
+        this.rightWing.addBox(0.0F, 0.0F, 0.0F, 13, 1, 9, 0.0F);
+        this.head = new ModelRenderer(this, 0, 0);
+        this.head.setRotationPoint(0.0F, 18.0F, 1.27F);
+        this.head.addBox(-3.4F, 0.0F, -5.0F, 7, 3, 5, 0.0F);
+        this.bodyMiddle = new ModelRenderer(this, 28, 8);
+        this.bodyMiddle.setRotationPoint(-2.4F, 17.0F, 1.1F);
+        this.bodyMiddle.addBox(0.0F, 0.0F, 0.0F, 5, 3, 9, 0.0F);
+        this.body = new ModelRenderer(this, 56, 8);
+        this.body.setRotationPoint(-8.4F, 17.0F, 1.1F);
+        this.body.addBox(0.0F, 0.0F, 0.0F, 6, 2, 9, 0.0F);
+        this.bodyLeft.addChild(this.leftWing);
+        this.tailStart.addChild(this.tailEnd);
+        this.body.addChild(this.rightWing);
+    }
+
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.bodyLeft.render(f5);
+        this.tailStart.render(f5);
+        this.head.render(f5);
+        this.bodyMiddle.render(f5);
+        this.body.render(f5);
+    }
+
+    private void setRotation(ModelRenderer model, float x, float y, float z) {
+        model.rotateAngleX = x;
+        model.rotateAngleY = y;
+        model.rotateAngleZ = z;
+    }
+
+    public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5, Entity entity) {
+        super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndBase.java	(date 1524852097000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndBase.java	(date 1524852097000)
@@ -0,0 +1,17 @@
+package net.hdt.neutronia.blocks.end;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+public class BlockEndBase extends BlockMod {
+
+    public BlockEndBase(Material material, String name) {
+        super(material, Reference.MOD_ID, name);
+        setCreativeTab(Main.END_EXPANSION_TAB);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorOre.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorOre.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorOre.java	(date 1525606898000)
@@ -0,0 +1,131 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.util.BlockUtil;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.block.state.pattern.BlockMatcher;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.Random;
+
+public class EnhancedGeneratorOre extends EnhancedGenerator {
+    public static final EnhancedGeneratorOre INSTANCE = new EnhancedGeneratorOre(0, 0.0F, 0, 0, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), 0);
+    private final IBlockState blockToSpawn;
+    private final IBlockState blockToReplace;
+    private final int size;
+
+    private EnhancedGeneratorOre(int generationAttempts, float generationProbability, int minHeight, int maxHeight, IBlockState blockToSpawnIn, IBlockState blockToReplaceIn, int sizeIn) {
+        super(generationAttempts, generationProbability, minHeight, maxHeight);
+
+        blockToSpawn = blockToSpawnIn;
+        blockToReplace = blockToReplaceIn;
+        size = sizeIn;
+    }
+
+    @Override
+    public EnhancedGeneratorOre deserializeConfig(JsonObject config) {
+        int generationAttempts = JsonUtils.getInt(config, "generationAttempts", 10);
+        float generationProbability = JsonUtils.getFloat(config, "generationProbability", 1.0F);
+        int minHeight = JsonUtils.getInt(config, "minHeight", 32);
+        int maxHeight = JsonUtils.getInt(config, "maxHeight", 128);
+
+        IBlockState blockToSpawn = null;
+        IBlockState blockToReplace = null;
+
+        JsonObject blockToSpawnJson = JsonUtils.getJsonObject(config, "blockToSpawn", new JsonObject());
+        JsonObject blockToReplaceJson = JsonUtils.getJsonObject(config, "blockToReplace", new JsonObject());
+
+        if (blockToSpawnJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSpawnJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSpawn = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+        if (blockToReplaceJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToReplaceJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToReplace = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+
+        JsonObject blockToSpawnProperties = JsonUtils.getJsonObject(blockToSpawnJson, "properties", new JsonObject());
+        JsonObject blockToReplaceProperties = JsonUtils.getJsonObject(blockToReplaceJson, "properties", new JsonObject());
+
+        if (blockToSpawnProperties.entrySet().size() > 0) {
+            blockToSpawn = BlockUtil.getBlockWithProperties(blockToSpawn, JsonUtils.getJsonObject(blockToSpawnJson, "properties"));
+        }
+        if (blockToReplaceProperties.entrySet().size() > 0) {
+            blockToReplace = BlockUtil.getBlockWithProperties(blockToReplace, JsonUtils.getJsonObject(blockToReplaceJson, "properties"));
+        }
+
+        int size = JsonUtils.getInt(config, "size", 16);
+
+        if (blockToSpawn != null && blockToReplace != null) {
+            return new EnhancedGeneratorOre(generationAttempts, generationProbability, minHeight, maxHeight, blockToSpawn, blockToReplace, size);
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        float f = rand.nextFloat() * (float) Math.PI;
+        double d0 = (double) ((float) pos.getX() + MathHelper.sin(f) * (float) size / 8.0F);
+        double d1 = (double) ((float) pos.getX() - MathHelper.sin(f) * (float) size / 8.0F);
+        double d2 = (double) ((float) pos.getZ() + MathHelper.cos(f) * (float) size / 8.0F);
+        double d3 = (double) ((float) pos.getZ() - MathHelper.cos(f) * (float) size / 8.0F);
+        double d4 = (double) (pos.getY() + rand.nextInt(3) - 2);
+        double d5 = (double) (pos.getY() + rand.nextInt(3) - 2);
+
+        for (int i = 0; i < size; ++i) {
+            float f1 = (float) i / (float) size;
+            double d6 = d0 + (d1 - d0) * (double) f1;
+            double d7 = d4 + (d5 - d4) * (double) f1;
+            double d8 = d2 + (d3 - d2) * (double) f1;
+            double d9 = rand.nextDouble() * (double) size / 16.0D;
+            double d10 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
+            double d11 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
+            int j = MathHelper.floor(d6 - d10 / 2.0D);
+            int k = MathHelper.floor(d7 - d11 / 2.0D);
+            int l = MathHelper.floor(d8 - d10 / 2.0D);
+            int i1 = MathHelper.floor(d6 + d10 / 2.0D);
+            int j1 = MathHelper.floor(d7 + d11 / 2.0D);
+            int k1 = MathHelper.floor(d8 + d10 / 2.0D);
+
+            for (int l1 = j; l1 <= i1; ++l1) {
+                double d12 = ((double) l1 + 0.5D - d6) / (d10 / 2.0D);
+
+                if (d12 * d12 < 1.0D) {
+                    for (int i2 = k; i2 <= j1; ++i2) {
+                        double d13 = ((double) i2 + 0.5D - d7) / (d11 / 2.0D);
+
+                        if (d12 * d12 + d13 * d13 < 1.0D) {
+                            for (int j2 = l; j2 <= k1; ++j2) {
+                                double d14 = ((double) j2 + 0.5D - d8) / (d10 / 2.0D);
+
+                                if (d12 * d12 + d13 * d13 + d14 * d14 < 1.0D) {
+                                    BlockPos newPos = new BlockPos(l1, i2, j2);
+                                    IBlockState state = world.getBlockState(newPos);
+
+                                    if (state.getBlock().isReplaceableOreGen(state, world, newPos, BlockMatcher.forBlock(blockToReplace.getBlock())) && state == blockToReplace) {
+                                        world.setBlockState(newPos, blockToSpawn, 2);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldStairBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldStairBase.java	(date 1525541029000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldStairBase.java	(date 1525541029000)
@@ -0,0 +1,24 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.state.IBlockState;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+
+public class BlockOverworldStairBase extends BlockModStairs {
+
+    public BlockOverworldStairBase(String name, IBlockState state) {
+        super(name, state);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelScorpion.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelScorpion.java	(date 1523986184000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelScorpion.java	(date 1523986184000)
@@ -0,0 +1,148 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+/**
+ * ModelScorpion - Dion - Trikzon
+ * Created using Tabula 7.0.0
+ */
+public class ModelScorpion extends ModelBase {
+    public ModelRenderer body;
+    public ModelRenderer head;
+    public ModelRenderer tail1;
+    public ModelRenderer clawRight1;
+    public ModelRenderer clawLeft1;
+    public ModelRenderer tail2;
+    public ModelRenderer tail3;
+    public ModelRenderer tail4;
+    public ModelRenderer tail5;
+    public ModelRenderer stinger;
+    public ModelRenderer clawRight2;
+    public ModelRenderer clawLeft2;
+    public ModelRenderer legLeft1;
+    public ModelRenderer legLeft2;
+    public ModelRenderer legLeft3;
+    public ModelRenderer legLeft4;
+    public ModelRenderer legRight1;
+    public ModelRenderer legRight2;
+    public ModelRenderer legRight3;
+    public ModelRenderer legRight4;
+
+    public ModelScorpion() {
+        this.textureWidth = 64;
+        this.textureHeight = 32;
+        this.legLeft4 = new ModelRenderer(this, 45, 24);
+        this.legLeft4.setRotationPoint(4.0F, 20.5F, 3.5F);
+        this.legLeft4.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legLeft4, 0.0F, -0.4363323129985824F, 0.4886921905584123F);
+        this.tail5 = new ModelRenderer(this, 0, 8);
+        this.tail5.setRotationPoint(0.0F, 0.2F, 3.2F);
+        this.tail5.addBox(-1.0F, -1.0F, 0.0F, 2, 2, 4, 0.0F);
+        this.setRotateAngle(tail5, 0.5009094953223726F, 0.0F, 0.0F);
+        this.clawLeft2 = new ModelRenderer(this, 18, 4);
+        this.clawLeft2.setRotationPoint(0.0F, 0.0F, -2.8F);
+        this.clawLeft2.addBox(-1.0F, -1.0F, -2.8F, 2, 2, 3, 0.0F);
+        this.setRotateAngle(clawLeft2, 0.0F, 0.6981317007977318F, 0.0F);
+        this.head = new ModelRenderer(this, 44, 16);
+        this.head.setRotationPoint(0.0F, 20.5F, -5.0F);
+        this.head.addBox(-3.0F, -2.0F, -4.0F, 6, 4, 4, 0.0F);
+        this.tail1 = new ModelRenderer(this, 0, 22);
+        this.tail1.setRotationPoint(0.0F, 20.0F, 4.0F);
+        this.tail1.addBox(-2.5F, -2.0F, 0.0F, 5, 4, 6, 0.0F);
+        this.setRotateAngle(tail1, 0.3490658503988659F, 0.0F, 0.0F);
+        this.clawRight1 = new ModelRenderer(this, 20, 0);
+        this.clawRight1.setRotationPoint(-2.5F, 20.5F, -6.0F);
+        this.clawRight1.addBox(-0.5F, -0.5F, -3.0F, 1, 1, 3, 0.0F);
+        this.setRotateAngle(clawRight1, 0.0F, 0.6981317007977318F, 0.0F);
+        this.legRight3 = new ModelRenderer(this, 45, 24);
+        this.legRight3.setRotationPoint(-4.0F, 20.5F, 1.1F);
+        this.legRight3.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legRight3, 0.0F, 0.2617993877991494F, -0.4886921905584123F);
+        this.legLeft3 = new ModelRenderer(this, 45, 24);
+        this.legLeft3.setRotationPoint(4.0F, 20.5F, 1.1F);
+        this.legLeft3.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legLeft3, 0.0F, -0.2617993877991494F, 0.4886921905584123F);
+        this.legRight2 = new ModelRenderer(this, 45, 24);
+        this.legRight2.setRotationPoint(-4.0F, 20.5F, -1.2F);
+        this.legRight2.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legRight2, 0.0F, -0.2617993877991494F, -0.4886921905584123F);
+        this.body = new ModelRenderer(this, 28, 0);
+        this.body.setRotationPoint(0.0F, 20.5F, 0.0F);
+        this.body.addBox(-4.0F, -3.0F, -5.0F, 8, 6, 10, 0.0F);
+        this.clawLeft1 = new ModelRenderer(this, 20, 0);
+        this.clawLeft1.setRotationPoint(2.5F, 20.5F, -6.0F);
+        this.clawLeft1.addBox(-0.5F, -0.5F, -3.0F, 1, 1, 3, 0.0F);
+        this.setRotateAngle(clawLeft1, 0.0F, -0.6981317007977318F, 0.0F);
+        this.tail3 = new ModelRenderer(this, 0, 14);
+        this.tail3.setRotationPoint(0.0F, 0.0F, 4.3F);
+        this.tail3.addBox(-2.0F, -1.5F, 0.0F, 4, 3, 5, 0.0F);
+        this.setRotateAngle(tail3, 0.3490658503988659F, 0.0F, 0.0F);
+        this.legLeft1 = new ModelRenderer(this, 45, 24);
+        this.legLeft1.setRotationPoint(4.0F, 20.5F, -3.5F);
+        this.legLeft1.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legLeft1, 0.0F, 0.4363323129985824F, 0.4886921905584123F);
+        this.legRight1 = new ModelRenderer(this, 45, 24);
+        this.legRight1.setRotationPoint(-4.0F, 20.5F, -3.5F);
+        this.legRight1.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legRight1, 0.0F, -0.4363323129985824F, -0.4886921905584123F);
+        this.stinger = new ModelRenderer(this, 0, 4);
+        this.stinger.setRotationPoint(0.0F, 0.0F, 4.0F);
+        this.stinger.addBox(-0.5F, -0.5F, 0.0F, 1, 1, 3, 0.0F);
+        this.setRotateAngle(stinger, 0.2617993877991494F, 0.0F, 0.0F);
+        this.tail2 = new ModelRenderer(this, 0, 14);
+        this.tail2.setRotationPoint(0.0F, -0.9F, 4.9F);
+        this.tail2.addBox(-2.0F, -1.5F, 0.0F, 4, 3, 5, 0.0F);
+        this.setRotateAngle(tail2, 0.7853981633974483F, 0.0F, 0.0F);
+        this.legRight4 = new ModelRenderer(this, 45, 24);
+        this.legRight4.setRotationPoint(-4.0F, 20.5F, 3.5F);
+        this.legRight4.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legRight4, 0.0F, 0.4455668605402397F, -0.4886921905584123F);
+        this.legLeft2 = new ModelRenderer(this, 45, 24);
+        this.legLeft2.setRotationPoint(4.0F, 20.5F, -1.2F);
+        this.legLeft2.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
+        this.setRotateAngle(legLeft2, 0.0F, 0.2617993877991494F, 0.4886921905584123F);
+        this.tail4 = new ModelRenderer(this, 0, 8);
+        this.tail4.setRotationPoint(0.0F, 0.0F, 4.3F);
+        this.tail4.addBox(-1.0F, -1.0F, 0.0F, 2, 2, 4, 0.0F);
+        this.setRotateAngle(tail4, 0.8726646259971648F, 0.0F, 0.0F);
+        this.clawRight2 = new ModelRenderer(this, 18, 4);
+        this.clawRight2.setRotationPoint(0.0F, 0.0F, -2.8F);
+        this.clawRight2.addBox(-1.0F, -1.0F, -2.8F, 2, 2, 3, 0.0F);
+        this.setRotateAngle(clawRight2, 0.0F, -0.6981317007977318F, 0.0F);
+        this.tail4.addChild(this.tail5);
+        this.clawLeft1.addChild(this.clawLeft2);
+        this.tail2.addChild(this.tail3);
+        this.tail5.addChild(this.stinger);
+        this.tail1.addChild(this.tail2);
+        this.tail3.addChild(this.tail4);
+        this.clawRight1.addChild(this.clawRight2);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.legLeft4.render(f5);
+        this.head.render(f5);
+        this.tail1.render(f5);
+        this.clawRight1.render(f5);
+        this.legRight3.render(f5);
+        this.legLeft3.render(f5);
+        this.legRight2.render(f5);
+        this.body.render(f5);
+        this.clawLeft1.render(f5);
+        this.legLeft1.render(f5);
+        this.legRight1.render(f5);
+        this.legRight4.render(f5);
+        this.legLeft2.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndSaplings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndSaplings.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndSaplings.java	(date 1524853001000)
@@ -0,0 +1,175 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import eex.init.EndExPlantTypes;
+import eex.world.gen.feature.WorldGenEndpalm;
+import net.minecraft.block.IGrowable;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.properties.PropertyInteger;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenBigTree;
+import net.minecraft.world.gen.feature.WorldGenTrees;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraftforge.common.EnumPlantType;
+
+import java.util.Random;
+
+public class BlockEndSaplings extends BlockBushEndEx implements IGrowable
+{
+    public static final PropertyEnum<BlockEndLog.EnumType> TYPE = PropertyEnum.create("type", BlockEndLog.EnumType.class);
+    public static final PropertyInteger STAGE = PropertyInteger.create("stage", 0, 1);
+    protected static final AxisAlignedBB SAPLING_AABB = new AxisAlignedBB(0.09999999403953552D, 0.0D, 0.09999999403953552D, 0.8999999761581421D, 0.800000011920929D, 0.8999999761581421D);
+
+    public BlockEndSaplings()
+    {
+        super("end_saplings", Material.PLANTS);
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos)
+    {
+        return SAPLING_AABB;
+    }
+
+    @Override
+    public void updateTick(World world, BlockPos pos, IBlockState state, Random rand)
+    {
+        if(!world.isRemote)
+        {
+            super.updateTick(world, pos, state, rand);
+
+            if(world.getLightFromNeighbors(pos.up()) >= 9 && rand.nextInt(7) == 0)
+            {
+                grow(world, pos, state, rand);
+            }
+        }
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(BlockEndLog.EnumType type : BlockEndLog.EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public EnumPlantType getPlantType(IBlockAccess world, BlockPos pos)
+    {
+        return EndExPlantTypes.END;
+    }
+
+    @Override
+    public boolean canGrow(World world, BlockPos pos, IBlockState state, boolean isClient)
+    {
+        return true;
+    }
+
+    @Override
+    public boolean canUseBonemeal(World world, Random rand, BlockPos pos, IBlockState state)
+    {
+        return (double) world.rand.nextFloat() < 0.45D;
+    }
+
+    @Override
+    public void grow(World world, Random rand, BlockPos pos, IBlockState state)
+    {
+        grow(world, pos, state, rand);
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, BlockEndLog.EnumType.fromMeta(meta & 7)).withProperty(STAGE, (meta & 8) >> 3);
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        int i = 0;
+        i = i | (state.getValue(TYPE)).ordinal();
+        i = i | (state.getValue(STAGE)) << 3;
+        return i;
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE, STAGE);
+    }
+
+    public void grow(World world, BlockPos pos, IBlockState state, Random rand)
+    {
+        if(state.getValue(STAGE) == 0)
+        {
+            world.setBlockState(pos, state.cycleProperty(STAGE), 4);
+        }
+        else
+        {
+            generateTree(world, pos, state, rand);
+        }
+    }
+
+    public void generateTree(World world, BlockPos pos, IBlockState state, Random rand)
+    {
+        if(!net.minecraftforge.event.terraingen.TerrainGen.saplingGrowTree(world, rand, pos)) return;
+        WorldGenerator treeGenerator = rand.nextInt(10) == 0 ? new WorldGenBigTree(true) : new WorldGenTrees(true);
+        int posX = 0;
+        int posZ = 0;
+        boolean flag = false;
+
+        switch(state.getValue(TYPE))
+        {
+            case ENDPALM:
+                treeGenerator = new WorldGenEndpalm(2, 32);
+                break;
+        }
+
+        IBlockState stateAir = Blocks.AIR.getDefaultState();
+
+        if(flag)
+        {
+            world.setBlockState(pos.add(posX, 0, posZ), stateAir, 4);
+            world.setBlockState(pos.add(posX + 1, 0, posZ), stateAir, 4);
+            world.setBlockState(pos.add(posX, 0, posZ + 1), stateAir, 4);
+            world.setBlockState(pos.add(posX + 1, 0, posZ + 1), stateAir, 4);
+        }
+        else
+        {
+            world.setBlockState(pos, stateAir, 4);
+        }
+
+        if(!treeGenerator.generate(world, rand, pos.add(posX, 0, posZ)))
+        {
+            if(flag)
+            {
+                world.setBlockState(pos.add(posX, 0, posZ), state, 4);
+                world.setBlockState(pos.add(posX + 1, 0, posZ), state, 4);
+                world.setBlockState(pos.add(posX, 0, posZ + 1), state, 4);
+                world.setBlockState(pos.add(posX + 1, 0, posZ + 1), state, 4);
+            }
+            else
+            {
+                world.setBlockState(pos, state, 4);
+            }
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorPool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorPool.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/EnhancedGeneratorPool.java	(date 1525606898000)
@@ -0,0 +1,156 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.util.BlockUtil;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.JsonUtils;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.Random;
+
+public class EnhancedGeneratorPool extends EnhancedGenerator {
+    public static final EnhancedGeneratorPool INSTANCE = new EnhancedGeneratorPool(0, 0.0F, 0, 0, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState());
+    private final IBlockState blockToSpawn;
+    private final IBlockState blockToSurround;
+
+    private EnhancedGeneratorPool(int generationAttempts, float generationProbability, int minHeight, int maxHeight, IBlockState blockToSpawnIn, IBlockState blockToSurroundIn) {
+        super(generationAttempts, generationProbability, minHeight, maxHeight);
+
+        blockToSpawn = blockToSpawnIn;
+        blockToSurround = blockToSurroundIn;
+    }
+
+    @Override
+    public EnhancedGeneratorPool deserializeConfig(JsonObject config) {
+        int generationAttempts = JsonUtils.getInt(config, "generationAttempts", 10);
+        float generationProbability = JsonUtils.getFloat(config, "generationProbability", 1.0F);
+        int minHeight = JsonUtils.getInt(config, "minHeight", 32);
+        int maxHeight = JsonUtils.getInt(config, "maxHeight", 128);
+
+        IBlockState blockToSpawn = null;
+        IBlockState blockToSurround = null;
+
+        JsonObject blockToSpawnJson = JsonUtils.getJsonObject(config, "blockToSpawn", new JsonObject());
+        JsonObject blockToSurroundJson = JsonUtils.getJsonObject(config, "blockToSurround", new JsonObject());
+
+        if (blockToSpawnJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSpawnJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSpawn = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+        if (blockToSurroundJson.entrySet().size() > 0) {
+            ResourceLocation block = new ResourceLocation(JsonUtils.getString(blockToSurroundJson, "block"));
+
+            if (ForgeRegistries.BLOCKS.containsKey(block)) {
+                blockToSurround = ForgeRegistries.BLOCKS.getValue(block).getDefaultState();
+            }
+        }
+
+        JsonObject blockToSpawnProperties = JsonUtils.getJsonObject(blockToSpawnJson, "properties", new JsonObject());
+        JsonObject blockToSurroundProperties = JsonUtils.getJsonObject(blockToSurroundJson, "properties", new JsonObject());
+
+        if (blockToSpawnProperties.entrySet().size() > 0) {
+            blockToSpawn = BlockUtil.getBlockWithProperties(blockToSpawn, JsonUtils.getJsonObject(blockToSpawnJson, "properties"));
+        }
+        if (blockToSurroundProperties.entrySet().size() > 0) {
+            blockToSurround = BlockUtil.getBlockWithProperties(blockToSurround, JsonUtils.getJsonObject(blockToSurroundJson, "properties"));
+        }
+
+        if (blockToSpawn != null && blockToSurround != null) {
+            return new EnhancedGeneratorPool(generationAttempts, generationProbability, minHeight, maxHeight, blockToSpawn, blockToSurround);
+        }
+
+        return null;
+
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        for (pos = pos.add(-8, 0, -8); pos.getY() > getMinHeight() && world.isAirBlock(pos); pos = pos.down()) {
+
+        }
+
+        if (pos.getY() <= 4 || pos.getY() < getMinHeight()) {
+            return false;
+        } else {
+            pos = pos.down(4);
+            boolean[] hasSpace = new boolean[2048];
+            int i = rand.nextInt(4) + 4;
+
+            for (int j = 0; j < i; ++j) {
+                double d0 = rand.nextDouble() * 6.0D + 3.0D;
+                double d1 = rand.nextDouble() * 4.0D + 2.0D;
+                double d2 = rand.nextDouble() * 6.0D + 3.0D;
+                double d3 = rand.nextDouble() * (16.0D - d0 - 2.0D) + 1.0D + d0 / 2.0D;
+                double d4 = rand.nextDouble() * (8.0D - d1 - 4.0D) + 2.0D + d1 / 2.0D;
+                double d5 = rand.nextDouble() * (16.0D - d2 - 2.0D) + 1.0D + d2 / 2.0D;
+
+                for (int l = 1; l < 15; ++l) {
+                    for (int i1 = 1; i1 < 15; ++i1) {
+                        for (int j1 = 1; j1 < 7; ++j1) {
+                            double d6 = ((double) l - d3) / (d0 / 2.0D);
+                            double d7 = ((double) j1 - d4) / (d1 / 2.0D);
+                            double d8 = ((double) i1 - d5) / (d2 / 2.0D);
+                            double d9 = d6 * d6 + d7 * d7 + d8 * d8;
+
+                            if (d9 < 1.0D) {
+                                hasSpace[(l * 16 + i1) * 8 + j1] = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            for (int k1 = 0; k1 < 16; ++k1) {
+                for (int l2 = 0; l2 < 16; ++l2) {
+                    for (int k = 0; k < 8; ++k) {
+                        boolean flag = !hasSpace[(k1 * 16 + l2) * 8 + k] && (k1 < 15 && hasSpace[((k1 + 1) * 16 + l2) * 8 + k] || k1 > 0 && hasSpace[((k1 - 1) * 16 + l2) * 8 + k] || l2 < 15 && hasSpace[(k1 * 16 + l2 + 1) * 8 + k] || l2 > 0 && hasSpace[(k1 * 16 + (l2 - 1)) * 8 + k] || k < 7 && hasSpace[(k1 * 16 + l2) * 8 + k + 1] || k > 0 && hasSpace[(k1 * 16 + l2) * 8 + (k - 1)]);
+
+                        if (flag) {
+                            Material material = world.getBlockState(pos.add(k1, k, l2)).getMaterial();
+
+                            if (k >= 4 && material.isLiquid()) {
+                                return false;
+                            }
+
+                            if (k < 4 && !material.isSolid() && world.getBlockState(pos.add(k1, k, l2)) != blockToSpawn) {
+                                return false;
+                            }
+                        }
+                    }
+                }
+            }
+
+            for (int l1 = 0; l1 < 16; ++l1) {
+                for (int i3 = 0; i3 < 16; ++i3) {
+                    for (int i4 = 0; i4 < 8; ++i4) {
+                        if (hasSpace[(l1 * 16 + i3) * 8 + i4]) {
+                            world.setBlockState(pos.add(l1, i4, i3), i4 >= 4 ? Blocks.AIR.getDefaultState() : blockToSpawn, 2);
+                        }
+                    }
+                }
+            }
+
+            for (int j2 = 0; j2 < 16; ++j2) {
+                for (int k3 = 0; k3 < 16; ++k3) {
+                    for (int k4 = 0; k4 < 8; ++k4) {
+                        boolean flag1 = !hasSpace[(j2 * 16 + k3) * 8 + k4] && (j2 < 15 && hasSpace[((j2 + 1) * 16 + k3) * 8 + k4] || j2 > 0 && hasSpace[((j2 - 1) * 16 + k3) * 8 + k4] || k3 < 15 && hasSpace[(j2 * 16 + k3 + 1) * 8 + k4] || k3 > 0 && hasSpace[(j2 * 16 + (k3 - 1)) * 8 + k4] || k4 < 7 && hasSpace[(j2 * 16 + k3) * 8 + k4 + 1] || k4 > 0 && hasSpace[(j2 * 16 + k3) * 8 + (k4 - 1)]);
+
+                        if (flag1 && (k4 < 4 || rand.nextInt(2) != 0) && world.getBlockState(pos.add(j2, k4, k3)).getMaterial().isSolid()) {
+                            world.setBlockState(pos.add(j2, k4, k3), blockToSurround, 2);
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModPillar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModPillar.java	(date 1523987840000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModPillar.java	(date 1523987840000)
@@ -0,0 +1,89 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.BlockRotatedPillar;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockModPillar extends BlockMod implements IModBlock {
+
+    public BlockModPillar(String name, Material materialIn, String... variants) {
+        super(materialIn, Reference.MOD_ID, name, variants);
+    }
+
+    @Override
+    public boolean rotateBlock(net.minecraft.world.World world, BlockPos pos, EnumFacing axis) {
+        net.minecraft.block.state.IBlockState state = world.getBlockState(pos);
+        for (net.minecraft.block.properties.IProperty<?> prop : state.getProperties().keySet()) {
+            if (prop == BlockRotatedPillar.AXIS) {
+                world.setBlockState(pos, state.cycleProperty(prop));
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        switch (rot) {
+            case COUNTERCLOCKWISE_90:
+            case CLOCKWISE_90:
+                switch (state.getValue(BlockRotatedPillar.AXIS)) {
+                    case X:
+                        return state.withProperty(BlockRotatedPillar.AXIS, EnumFacing.Axis.Z);
+                    case Z:
+                        return state.withProperty(BlockRotatedPillar.AXIS, EnumFacing.Axis.X);
+                    default:
+                        return state;
+                }
+
+            default:
+                return state;
+        }
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        EnumFacing.Axis enumfacing$axis = EnumFacing.Axis.Y;
+        int i = meta & 12;
+
+        if (i == 4)
+            enumfacing$axis = EnumFacing.Axis.X;
+        else if (i == 8)
+            enumfacing$axis = EnumFacing.Axis.Z;
+
+        return getDefaultState().withProperty(BlockRotatedPillar.AXIS, enumfacing$axis);
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        int i = 0;
+        EnumFacing.Axis enumfacing$axis = state.getValue(BlockRotatedPillar.AXIS);
+
+        if (enumfacing$axis == EnumFacing.Axis.X)
+            i |= 4;
+        else if (enumfacing$axis == EnumFacing.Axis.Z)
+            i |= 8;
+
+        return i;
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, BlockRotatedPillar.AXIS);
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer) {
+        return super.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, meta, placer).withProperty(BlockRotatedPillar.AXIS, facing.getAxis());
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityHoveringInferno.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityHoveringInferno.java	(date 1523986183000)
+++ src/main/java/net/hdt/neutronia/entity/EntityHoveringInferno.java	(date 1523986183000)
@@ -0,0 +1,277 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntitySmallFireball;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNodeType;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+
+public class EntityHoveringInferno extends EntityMob {
+
+    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityHoveringInferno.class, DataSerializers.BYTE);
+    /**
+     * Random offset used in floating behaviour
+     */
+    private float heightOffset = 0.5F;
+    /**
+     * ticks until heightOffset is randomized
+     */
+    private int heightOffsetUpdateTime;
+
+    public EntityHoveringInferno(World worldIn) {
+        super(worldIn);
+        this.setPathPriority(PathNodeType.WATER, -1.0F);
+        this.setPathPriority(PathNodeType.LAVA, 8.0F);
+        this.setPathPriority(PathNodeType.DANGER_FIRE, 0.0F);
+        this.setPathPriority(PathNodeType.DAMAGE_FIRE, 0.0F);
+        this.isImmuneToFire = true;
+        this.experienceValue = 10;
+    }
+
+    public static void registerFixesBlaze(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityHoveringInferno.class);
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(4, new EntityHoveringInferno.AIFireballAttack(this));
+        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
+        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(ON_FIRE, (byte) 0);
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_BLAZE_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_BLAZE_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_BLAZE_DEATH;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getBrightnessForRender() {
+        return 15728880;
+    }
+
+    /**
+     * Gets how bright this entity is.
+     */
+    public float getBrightness() {
+        return 1.0F;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        if (!this.onGround && this.motionY < 0.0D) {
+            this.motionY *= 0.6D;
+        }
+
+        if (this.world.isRemote) {
+            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
+                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
+            }
+
+            for (int i = 0; i < 2; ++i) {
+                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
+            }
+        }
+
+        super.onLivingUpdate();
+    }
+
+    protected void updateAITasks() {
+        if (this.isWet()) {
+            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
+        }
+
+        --this.heightOffsetUpdateTime;
+
+        if (this.heightOffsetUpdateTime <= 0) {
+            this.heightOffsetUpdateTime = 100;
+            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
+        }
+
+        EntityLivingBase entitylivingbase = this.getAttackTarget();
+
+        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
+            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
+            this.isAirBorne = true;
+        }
+
+        super.updateAITasks();
+    }
+
+    public void fall(float distance, float damageMultiplier) {
+    }
+
+    /**
+     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
+     */
+    public boolean isBurning() {
+        return this.isCharged();
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_BLAZE;
+    }
+
+    private boolean isCharged() {
+        return (this.dataManager.get(ON_FIRE) & 1) != 0;
+    }
+
+    private void setOnFire(boolean onFire) {
+        byte b0 = this.dataManager.get(ON_FIRE);
+
+        if (onFire) {
+            b0 = (byte) (b0 | 1);
+        } else {
+            b0 = (byte) (b0 & -2);
+        }
+
+        this.dataManager.set(ON_FIRE, b0);
+    }
+
+    /**
+     * Checks to make sure the light is not too bright where the mob is spawning
+     */
+    protected boolean isValidLightLevel() {
+        return true;
+    }
+
+    static class AIFireballAttack extends EntityAIBase {
+        private final EntityHoveringInferno blaze;
+        private int attackStep;
+        private int attackTime;
+
+        AIFireballAttack(EntityHoveringInferno blazeIn) {
+            this.blaze = blazeIn;
+            this.setMutexBits(3);
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            return entitylivingbase != null && entitylivingbase.isEntityAlive();
+        }
+
+        /**
+         * Execute a one shot task or start executing a continuous task
+         */
+        public void startExecuting() {
+            this.attackStep = 0;
+        }
+
+        /**
+         * Reset the task's internal state. Called when this task is interrupted by another one
+         */
+        public void resetTask() {
+            this.blaze.setOnFire(false);
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            --this.attackTime;
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
+
+            if (d0 < 4.0D) {
+                if (this.attackTime <= 0) {
+                    this.attackTime = 20;
+                    this.blaze.attackEntityAsMob(entitylivingbase);
+                }
+
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
+                double d1 = entitylivingbase.posX - this.blaze.posX;
+                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
+                double d3 = entitylivingbase.posZ - this.blaze.posZ;
+
+                if (this.attackTime <= 0) {
+                    ++this.attackStep;
+
+                    if (this.attackStep == 1) {
+                        this.attackTime = 60;
+                        this.blaze.setOnFire(true);
+                    } else if (this.attackStep <= 4) {
+                        this.attackTime = 6;
+                    } else {
+                        this.attackTime = 100;
+                        this.attackStep = 0;
+                        this.blaze.setOnFire(false);
+                    }
+
+                    if (this.attackStep > 1) {
+                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
+                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
+
+                        for (int i = 0; i < 1; ++i) {
+                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
+                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
+                            this.blaze.world.spawnEntity(entitysmallfireball);
+                        }
+                    }
+                }
+
+                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
+            } else {
+                this.blaze.getNavigator().clearPath();
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            }
+
+            super.updateTask();
+        }
+
+        private double getFollowDistance() {
+            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
+            return iattributeinstance.getAttributeValue();
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockWorldStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockWorldStoneBricks.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockWorldStoneBricks.java	(date 1525606882000)
@@ -0,0 +1,58 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.modules.building.features.WorldStoneBricks;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.ModuleLoader;
+
+import java.util.function.Supplier;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockWorldStoneBricks extends BlockMetaVariants implements IModBlock {
+
+    public BlockWorldStoneBricks() {
+        super("world_stone_bricks", MOD_ID, Material.ROCK, Variants.class);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public boolean shouldDisplayVariant(int variant) {
+        return Variants.class.getEnumConstants()[variant].isEnabled();
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+
+        STONE_GRANITE_BRICKS(WorldStoneBricks.class),
+        STONE_DIORITE_BRICKS(WorldStoneBricks.class),
+        STONE_ANDESITE_BRICKS(WorldStoneBricks.class)/*,
+		STONE_BASALT_BRICKS(Basalt.class),
+		STONE_MARBLE_BRICKS(RevampStoneGen.class, () -> RevampStoneGen.enableMarble),
+		STONE_LIMESTONE_BRICKS(RevampStoneGen.class, () -> RevampStoneGen.enableLimestone)*/;
+
+        public final Class<? extends Feature> featureLink;
+        private final Supplier<Boolean> enabledCond;
+
+        Variants(Class<? extends Feature> clazz) {
+            this(clazz, () -> true);
+        }
+
+        Variants(Class<? extends Feature> clazz, Supplier<Boolean> enabledCond) {
+            featureLink = clazz;
+            this.enabledCond = enabledCond;
+        }
+
+        public boolean isEnabled() {
+            return ModuleLoader.isFeatureEnabled(featureLink) && enabledCond.get();
+        }
+
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomChest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomChest.java	(date 1523987842000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockCustomChest.java	(date 1523987842000)
@@ -0,0 +1,368 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.hdt.neutronia.items.ItemChestBlock;
+import net.hdt.neutronia.properties.ChestType;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockChest;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.passive.EntityOcelot;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.inventory.InventoryLargeChest;
+import net.minecraft.item.ItemStack;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.ILockableContainer;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class BlockCustomChest extends BlockChest implements IModBlock {
+
+    private final String[] variants;
+    private final String bareName;
+
+    public BlockCustomChest(String name, Type type) {
+        super(type);
+
+        variants = new String[]{name};
+        bareName = name;
+        setUnlocalizedName(name);
+        setHardness(2.5F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(type == Type.TRAP ? CreativeTabs.REDSTONE : CreativeTabs.DECORATIONS);
+    }
+
+    @Override
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(new ItemChestBlock(this, new ResourceLocation(getPrefix(), name)));
+
+        return this;
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return createBlockState().getProperties().toArray(new IProperty[0]);
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+    @Override
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        ChestType myType = getCustomType(source, pos);
+        return getCustomType(source, pos.north()) == myType ? NORTH_CHEST_AABB : getCustomType(source, pos.south()) == myType ? SOUTH_CHEST_AABB : getCustomType(source, pos.west()) == myType ? WEST_CHEST_AABB : getCustomType(source, pos.east()) == myType ? EAST_CHEST_AABB : NOT_CONNECTED_AABB;
+    }
+
+    @Override
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        // NO-OP
+    }
+
+    @Override
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer) {
+        return getDefaultState().withProperty(FACING, placer.getHorizontalFacing());
+    }
+
+    @Override
+    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
+        EnumFacing facing = EnumFacing.getHorizontal(MathHelper.floor(placer.rotationYaw * 4.0F / 360.0F + 0.5D) & 3).getOpposite();
+        state = state.withProperty(FACING, facing);
+        BlockPos northPos = pos.north();
+        BlockPos southPos = pos.south();
+        BlockPos westPos = pos.west();
+        BlockPos eastPos = pos.east();
+
+        ChestType myType = getCustomType(stack);
+
+        boolean northChest = myType == getCustomType(worldIn, northPos);
+        boolean southChest = myType == getCustomType(worldIn, southPos);
+        boolean westChest = myType == getCustomType(worldIn, westPos);
+        boolean eastChest = myType == getCustomType(worldIn, eastPos);
+
+        if (!northChest && !southChest && !westChest && !eastChest) {
+            worldIn.setBlockState(pos, state, 3);
+        } else if (facing.getAxis() != EnumFacing.Axis.X || !northChest && !southChest) {
+            if (facing.getAxis() == EnumFacing.Axis.Z && (westChest || eastChest)) {
+                if (westChest)
+                    setState(worldIn, westPos, state, 3);
+                else
+                    setState(worldIn, eastPos, state, 3);
+
+                worldIn.setBlockState(pos, state, 3);
+            } else {
+                EnumFacing corrected = facing.rotateY();
+                setState(worldIn, pos, state.withProperty(FACING, corrected), 3);
+                if (northChest)
+                    setState(worldIn, northPos, state.withProperty(FACING, corrected), 3);
+                else if (southChest)
+                    setState(worldIn, southPos, state.withProperty(FACING, corrected), 3);
+                else if (westChest)
+                    setState(worldIn, westPos, state.withProperty(FACING, corrected), 3);
+                else if (eastChest)
+                    setState(worldIn, eastPos, state.withProperty(FACING, corrected), 3);
+            }
+        } else {
+            if (northChest)
+                setState(worldIn, northPos, state, 3);
+            else
+                setState(worldIn, southPos, state, 3);
+
+            worldIn.setBlockState(pos, state, 3);
+        }
+
+        TileEntity te = worldIn.getTileEntity(pos);
+        if (te instanceof TileCustomChest) {
+            TileCustomChest chest = (TileCustomChest) te;
+            if (stack.hasDisplayName())
+                chest.setCustomName(stack.getDisplayName());
+
+            chest.chestType = myType;
+        }
+
+        onBlockAdded(worldIn, pos, state);
+    }
+
+    public void setState(World worldIn, BlockPos pos, IBlockState state, int flag) {
+        TileEntity te = worldIn.getTileEntity(pos);
+        worldIn.setBlockState(pos, state, flag);
+        if (te != null) {
+            te.validate();
+            worldIn.setTileEntity(pos, te);
+
+            if (te instanceof TileCustomChest)
+                ((TileCustomChest) te).adjacentChestChecked = false;
+        }
+    }
+
+    @Override
+    public boolean canProvidePower(IBlockState state) {
+        return chestType == HMBlocks.CUSTOM_TYPE_QUARK_TRAP;
+    }
+
+    @Override
+    @Deprecated
+    public IBlockState checkForSurroundingChests(World worldIn, BlockPos pos, IBlockState state) {
+        return state;
+    }
+
+    @Override
+    @Deprecated
+    public IBlockState correctFacing(World worldIn, BlockPos pos, IBlockState state) {
+        return correctFacing(worldIn, pos, state, ChestType.NONE);
+    }
+
+    public IBlockState correctFacing(World worldIn, BlockPos pos, IBlockState state, ChestType myType) {
+        EnumFacing facing = null;
+
+        for (EnumFacing horizFace : EnumFacing.Plane.HORIZONTAL) {
+            if (getCustomType(worldIn, pos.offset(horizFace)) == myType)
+                return state;
+
+            if (worldIn.getBlockState(pos.offset(horizFace)).isFullBlock()) {
+                if (facing != null) {
+                    facing = null;
+                    break;
+                }
+
+                facing = horizFace;
+            }
+        }
+
+        if (facing != null) {
+            return state.withProperty(FACING, facing.getOpposite());
+        } else {
+            EnumFacing enumfacing2 = state.getValue(FACING);
+
+            if (worldIn.getBlockState(pos.offset(enumfacing2)).isFullBlock())
+                enumfacing2 = enumfacing2.getOpposite();
+
+            if (worldIn.getBlockState(pos.offset(enumfacing2)).isFullBlock())
+                enumfacing2 = enumfacing2.rotateY();
+
+            if (worldIn.getBlockState(pos.offset(enumfacing2)).isFullBlock())
+                enumfacing2 = enumfacing2.getOpposite();
+
+            return state.withProperty(FACING, enumfacing2);
+        }
+    }
+
+    @Override
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        return true;
+    }
+
+    public boolean isDoubleChest(World worldIn, BlockPos pos, ChestType myType) {
+        if (getCustomType(worldIn, pos) != myType) {
+            return false;
+        } else {
+            ChestType theType = getCustomType(worldIn, pos);
+            for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
+                if (getCustomType(worldIn, pos.offset(enumfacing)) == theType)
+                    return true;
+
+            return false;
+        }
+    }
+
+    @Override
+    public boolean removedByPlayer(IBlockState state, World world, BlockPos pos, EntityPlayer player, boolean willHarvest) {
+        return willHarvest || super.removedByPlayer(state, world, pos, player, false);
+    }
+
+    @Override
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, @Nullable ItemStack stack) {
+        super.harvestBlock(worldIn, player, pos, state, te, stack);
+
+        worldIn.setBlockToAir(pos);
+
+        if (te instanceof TileCustomChest)
+            te.invalidate();
+    }
+
+    @Override
+    public TileEntity createNewTileEntity(World worldIn, int meta) {
+        return new TileCustomChest();
+    }
+
+    public ChestType getCustomType(IBlockAccess source, BlockPos pos) {
+        if (source.getBlockState(pos).getBlock() == this) {
+            TileEntity te = source.getTileEntity(pos);
+            if (te instanceof TileCustomChest)
+                return ((TileCustomChest) te).chestType;
+        }
+
+        return ChestType.NONE;
+    }
+
+    public ChestType getCustomType(ItemStack stack) {
+        return ChestType.class.getEnumConstants()[Math.min(5, stack.getItemDamage() + 1)];
+    }
+
+    public ItemStack setCustomType(ItemStack stack, ChestType type) {
+        stack.setItemDamage(type.ordinal() - 1);
+
+        return stack;
+    }
+
+    @Override
+    public ILockableContainer getContainer(World world, BlockPos pos, boolean locked) {
+        TileEntity tile = world.getTileEntity(pos);
+
+        if (!(tile instanceof TileCustomChest)) {
+            return null;
+        } else {
+            ILockableContainer myChest = (TileCustomChest) tile;
+            ChestType myType = ((TileCustomChest) tile).chestType;
+
+            if (!locked && isBlocked(world, pos)) {
+                return null;
+            } else {
+                for (EnumFacing facing : EnumFacing.Plane.HORIZONTAL) {
+                    BlockPos adjPos = pos.offset(facing);
+
+                    TileEntity adjTile = world.getTileEntity(adjPos);
+
+                    if (world.getBlockState(adjPos).getBlock() == this && adjTile instanceof TileCustomChest && ((TileCustomChest) adjTile).chestType == myType) {
+                        if (isBlocked(world, adjPos))
+                            return null;
+
+                        if (facing != EnumFacing.WEST && facing != EnumFacing.NORTH)
+                            myChest = new InventoryLargeChest("container.chestDouble", myChest, (TileCustomChest) adjTile);
+                        else
+                            myChest = new InventoryLargeChest("container.chestDouble", (TileCustomChest) adjTile, myChest);
+                    }
+                }
+
+                return myChest;
+            }
+        }
+    }
+
+    private boolean isBlocked(World worldIn, BlockPos pos) {
+        return isBelowSolidBlock(worldIn, pos) || isOcelotSittingOnChest(worldIn, pos);
+    }
+
+    private boolean isBelowSolidBlock(World worldIn, BlockPos pos) {
+        return worldIn.getBlockState(pos.up()).isSideSolid(worldIn, pos.up(), EnumFacing.DOWN);
+    }
+
+    private boolean isOcelotSittingOnChest(World worldIn, BlockPos pos) {
+        for (Entity entity : worldIn.getEntitiesWithinAABB(EntityOcelot.class, new AxisAlignedBB(pos.getX(), pos.getY() + 1, pos.getZ(), pos.getX() + 1, pos.getY() + 2, pos.getZ() + 1))) {
+            EntityOcelot cat = (EntityOcelot) entity;
+
+            if (cat.isSitting())
+                return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public List<ItemStack> getDrops(IBlockAccess world, BlockPos pos, IBlockState state, int fortune) {
+        return new ArrayList<>(Collections.singletonList(setCustomType(new ItemStack(this, 1), getCustomType(world, pos))));
+    }
+
+    @Override
+    public ItemStack getPickBlock(IBlockState state, RayTraceResult target, World world, BlockPos pos, EntityPlayer player) {
+        return setCustomType(new ItemStack(this, 1), getCustomType(world, pos));
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockMod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockMod.java	(date 1525606871000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockMod.java	(date 1525606871000)
@@ -0,0 +1,245 @@
+package net.hdt.neutronia.blocks.base;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.client.renderer.block.statemap.IStateMapper;
+import net.minecraft.client.renderer.block.statemap.StateMapperBase;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.CharEncoding;
+import org.apache.commons.lang3.StringEscapeUtils;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Random;
+
+public abstract class BlockMod extends Block implements IModBlock {
+
+    private final String[] variants;
+    private String bareName, modid;
+
+    public BlockMod(Material material, String modid, String name, String textureName, String... variants) {
+        super(material);
+
+        if (variants.length == 0)
+            variants = new String[]{name};
+
+        bareName = name;
+        this.variants = variants;
+        this.modid = modid;
+
+        if (registerInConstruction())
+            setUnlocalizedName(name, textureName);
+
+        setHardness(1.5F);
+        setResistance(30F);
+        setHarvestLevel("pickaxe", 1);
+    }
+
+    public static void genBlock(String modId, String blockName, String textureName) {
+
+        Gson gson = new GsonBuilder().setPrettyPrinting().create();
+
+        Path base = Paths.get("src", "main", "resources", "assets", modId, "blockstates");
+        if (!base.toFile().exists()) {
+            base.toFile().mkdirs();
+        }
+
+        JsonObject root = new JsonObject();
+        root.addProperty("_comment", "Generated using Husky's JSON Generator v2.");
+        root.addProperty("forge_marker", 1);
+
+        JsonObject defaults = new JsonObject();
+        defaults.addProperty("model", "cube_all");
+
+        JsonObject textures = new JsonObject();
+        textures.addProperty("all", modId + ":blocks/" + textureName);
+        defaults.add("textures", textures);
+
+        defaults.addProperty("transform", "forge:default-block");
+        root.add("defaults", defaults);
+
+        JsonObject variants = new JsonObject();
+
+        JsonArray empty = new JsonArray();
+        empty.add(new JsonObject());
+
+        variants.add("normal", empty);
+        variants.add("inventory", empty);
+        root.add("variants", variants);
+
+        String json = gson.toJson(root);
+
+        try {
+            FileUtils.writeStringToFile(base.resolve(blockName + ".json").toFile(), StringEscapeUtils.unescapeJson(json), CharEncoding.UTF_8);
+        } catch (IOException e) {
+            System.out.print(String.format("Error creating file %s.json" + "\n", blockName));
+        }
+
+//        genBlockModel(modId, blockName, textureName);
+        genBlockItemModel(modId, blockName, textureName);
+    }
+
+    public static void genBlockModel(String modId, String blockName, String textureName) {
+        Gson gson = new GsonBuilder().setPrettyPrinting().create();
+
+        Path base = Paths.get("src", "main", "resources", "assets", modId, "models", "block");
+        if (!base.toFile().exists()) {
+            base.toFile().mkdirs();
+        }
+
+        JsonObject root = new JsonObject();
+        root.addProperty("_comment", "Generated using Husky's JSON Generator v2.");
+        root.addProperty("parent", "block/cube_all");
+
+        JsonObject textures = new JsonObject();
+        textures.addProperty("all", modId + ":blocks/" + textureName);
+        root.add("textures", textures);
+
+        String json = gson.toJson(root);
+
+        try {
+            FileUtils.writeStringToFile(base.resolve(blockName + ".json").toFile(), StringEscapeUtils.unescapeJson(json), CharEncoding.UTF_8);
+        } catch (IOException e) {
+            System.out.print(String.format("Error creating file %s.json" + "\n", blockName));
+        }
+
+    }
+
+    public static void genBlockItemModel(String modId, String blockName, String textureName) {
+        Gson gson = new GsonBuilder().setPrettyPrinting().create();
+
+        Path base = Paths.get("src", "main", "resources", "assets", modId, "models", "item");
+        if (!base.toFile().exists()) {
+            base.toFile().mkdirs();
+        }
+
+        JsonObject root = new JsonObject();
+        root.addProperty("_comment", "Generated using Husky's JSON Generator v2.");
+        root.addProperty("parent", "block/cube_all");
+
+        JsonObject textures = new JsonObject();
+        textures.addProperty("all", modId + ":blocks/" + textureName);
+        root.add("textures", textures);
+
+        String json = gson.toJson(root);
+
+        try {
+            FileUtils.writeStringToFile(base.resolve(blockName + ".json").toFile(), StringEscapeUtils.unescapeJson(json), CharEncoding.UTF_8);
+        } catch (IOException e) {
+            System.out.print(String.format("Error creating file %s.json" + "\n", blockName));
+        }
+
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    @Override
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    public Block setUnlocalizedName(String name, String textureName) {
+        super.setUnlocalizedName(name);
+        this.setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(createItemBlock(new ResourceLocation(getPrefix(), name)));
+        genBlock(getPrefix(), name, textureName);
+        return this;
+    }
+
+    private ItemBlock createItemBlock(ResourceLocation res) {
+        return new ItemModBlock(this, res);
+    }
+
+    private boolean registerInConstruction() {
+        return true;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public IStateMapper getStateMapper() {
+        return new StateMapperBase() {
+            @Override
+            protected ModelResourceLocation getModelResourceLocation(IBlockState state) {
+                return new ModelResourceLocation(new ResourceLocation(getPrefix(), getBareName()), "normal");
+            }
+        };
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
+        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.SOLID || layer == BlockRenderLayer.TRANSLUCENT;
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[0];
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockDoubleWaterPlantBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockDoubleWaterPlantBase.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockDoubleWaterPlantBase.java	(date 1525606883000)
@@ -0,0 +1,223 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.blocks.base.BlockModBush;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockHorizontal;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+import java.util.Random;
+
+import static net.minecraft.block.BlockLiquid.LEVEL;
+
+public class BlockDoubleWaterPlantBase extends BlockModBush {
+
+    public static final PropertyEnum<BlockDoubleWaterPlantBase.EnumBlockHalf> HALF = PropertyEnum.create("half", BlockDoubleWaterPlantBase.EnumBlockHalf.class);
+    public static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
+
+    public BlockDoubleWaterPlantBase(String name) {
+        super(Material.WATER, name, Reference.MOD_ID);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.LOWER).withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return FULL_BLOCK_AABB;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
+        switch (face) {
+            case DOWN:
+                return false;
+            case UP:
+                return isWater(world, pos.add(0, 1, 0));
+            case NORTH:
+                return isWater(world, pos.add(0, 0, -1));
+            case SOUTH:
+                return isWater(world, pos.add(0, 0, 1));
+            case EAST:
+                return isWater(world, pos.add(1, 0, 0));
+            case WEST:
+                return isWater(world, pos.add(-1, 0, 0));
+        }
+        return false;
+    }
+
+    private boolean isWater(IBlockAccess world, BlockPos pos) {
+        return world.getBlockState(pos).getMaterial() == Material.WATER;
+    }
+
+    @Override
+    public boolean isTranslucent(IBlockState state) {
+        return true;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{LEVEL};
+    }
+
+    protected void checkAndDropBlock(World worldIn, BlockPos pos, IBlockState state) {
+        if (!this.canBlockStay(worldIn, pos, state)) {
+            boolean flag = state.getValue(HALF) == BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER;
+            BlockPos blockpos = flag ? pos : pos.up();
+            BlockPos blockpos1 = flag ? pos.down() : pos;
+            Block block = (flag ? this : worldIn.getBlockState(blockpos).getBlock());
+            Block block1 = (flag ? worldIn.getBlockState(blockpos1).getBlock() : this);
+
+            if (!flag) this.dropBlockAsItem(worldIn, pos, state, 0); //Forge move above the setting to air.
+
+            if (block == this) {
+                worldIn.setBlockState(blockpos, Blocks.AIR.getDefaultState(), 2);
+            }
+
+            if (block1 == this) {
+                worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 3);
+            }
+        }
+    }
+
+    public void placeAt(World worldIn, BlockPos lowerPos, int flags) {
+        worldIn.setBlockState(lowerPos, this.getDefaultState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.LOWER), flags);
+        worldIn.setBlockState(lowerPos.up(), this.getDefaultState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER), flags);
+    }
+
+    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
+        worldIn.setBlockState(pos.up(), this.getDefaultState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER), 2);
+    }
+
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack) {
+        {
+            super.harvestBlock(worldIn, player, pos, state, te, stack);
+        }
+    }
+
+    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        if (state.getValue(HALF) == BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER) {
+            if (worldIn.getBlockState(pos.down()).getBlock() == this) {
+                if (player.capabilities.isCreativeMode) {
+                    worldIn.setBlockToAir(pos.down());
+                } else {
+                    IBlockState iblockstate = worldIn.getBlockState(pos.down());
+
+                    if (worldIn.isRemote) {
+                        worldIn.setBlockToAir(pos.down());
+                    } else if (!player.getHeldItemMainhand().isEmpty() && player.getHeldItemMainhand().getItem() == Items.SHEARS) {
+                        this.onHarvest(worldIn, pos, iblockstate, player);
+                        worldIn.setBlockToAir(pos.down());
+                    } else {
+                        worldIn.destroyBlock(pos.down(), true);
+                    }
+                }
+            }
+        } else if (worldIn.getBlockState(pos.up()).getBlock() == this) {
+            worldIn.setBlockState(pos.up(), Blocks.AIR.getDefaultState(), 2);
+        }
+
+        super.onBlockHarvested(worldIn, pos, state, player);
+    }
+
+    private boolean onHarvest(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
+        player.addStat(Objects.requireNonNull(StatList.getBlockStats(this)));
+        return true;
+    }
+
+    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
+        return new ItemStack(this, 1);
+    }
+
+    public IBlockState getStateFromMeta(int meta) {
+        return (meta & 8) > 0 ? this.getDefaultState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER) : this.getDefaultState().withProperty(HALF, BlockDoubleWaterPlantBase.EnumBlockHalf.LOWER);
+    }
+
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(HALF) == BlockDoubleWaterPlantBase.EnumBlockHalf.UPPER ? 8 : (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, HALF, FACING, LEVEL);
+    }
+
+    public EnumOffsetType getOffsetType() {
+        return EnumOffsetType.XZ;
+    }
+
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canBlockStay(IBlockAccess worldIn, BlockPos pos, IBlockState state) {
+        Block block = worldIn.getBlockState(new BlockPos(pos.add(0, -1, 0))).getBlock();
+        return (block == Blocks.DIRT || block == Blocks.SAND || block == Blocks.SPONGE || block == Blocks.STONE || block == Blocks.CLAY || block == Blocks.GRAVEL || block == Blocks.GRASS) && worldIn.getBlockState(new BlockPos(pos.add(0, 2, 0))).getBlock() != Blocks.AIR;
+    }
+
+    public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
+        Block ground = worldIn.getBlockState(pos.add(0, -1, 0)).getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL && worldIn.getBlockState(pos.add(0, 2, 0)).getBlock() != Blocks.AIR;
+    }
+
+    public boolean isReplaceable(IBlockAccess access, BlockPos pos) {
+        return access.getBlockState(pos).getBlock() == Blocks.WATER && canBlockStay(access, pos, getDefaultState()) && access.getBlockState(pos.add(0, 1, 0)).getBlock() != Blocks.AIR;
+    }
+
+    protected boolean canSustainBush(IBlockState state) {
+        Block ground = state.getBlock();
+        return ground == Blocks.SAND || ground == Blocks.GRASS || ground == Blocks.DIRT || ground == Blocks.GRAVEL;
+    }
+
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        checkAndDropBlock(worldIn, pos, state);
+        super.onBlockAdded(worldIn, pos, state);
+    }
+
+    public boolean isReplaceable(World worldIn, BlockPos pos) {
+        return false;
+    }
+
+    public enum EnumBlockHalf implements IStringSerializable {
+        UPPER,
+        LOWER;
+
+        public String toString() {
+            return this.getName();
+        }
+
+        public String getName() {
+            return this == UPPER ? "upper" : "lower";
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockFarmingBlockBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockFarmingBlockBase.java	(date 1525606888000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockFarmingBlockBase.java	(date 1525606888000)
@@ -0,0 +1,186 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyInteger;
+import net.minecraft.block.state.BlockFaceShape;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import java.util.Random;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockFarmingBlockBase extends BlockMod {
+
+    public static final PropertyInteger MOISTURE = PropertyInteger.create("moisture", 0, 7);
+    protected static final AxisAlignedBB FARMLAND_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.9375D, 1.0D);
+    protected static final AxisAlignedBB field_194405_c = new AxisAlignedBB(0.0D, 0.9375D, 0.0D, 1.0D, 1.0D, 1.0D);
+
+    private static Block normalBlock;
+
+    public BlockFarmingBlockBase(String name, Block normalBlock) {
+        super(Material.CARPET, MOD_ID, name);
+        this.setDefaultState(this.blockState.getBaseState().withProperty(MOISTURE, Integer.valueOf(0)));
+        this.setTickRandomly(true);
+        this.setLightOpacity(255);
+        BlockFarmingBlockBase.normalBlock = normalBlock;
+    }
+
+    private static void turnToDirt(World p_190970_0_, BlockPos worldIn) {
+        p_190970_0_.setBlockState(worldIn, normalBlock.getDefaultState());
+        AxisAlignedBB axisalignedbb = field_194405_c.offset(worldIn);
+
+        for (Entity entity : p_190970_0_.getEntitiesWithinAABBExcludingEntity(null, axisalignedbb)) {
+            double d0 = Math.min(axisalignedbb.maxY - axisalignedbb.minY, axisalignedbb.maxY - entity.getEntityBoundingBox().minY);
+            entity.setPositionAndUpdate(entity.posX, entity.posY + d0 + 0.001D, entity.posZ);
+        }
+    }
+
+    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return FARMLAND_AABB;
+    }
+
+    /**
+     * Used to determine ambient occlusion and culling when rebuilding chunks for render
+     */
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
+        int i = state.getValue(MOISTURE);
+
+        if (!this.hasWater(worldIn, pos) && !worldIn.isRainingAt(pos.up())) {
+            if (i > 0) {
+                worldIn.setBlockState(pos, state.withProperty(MOISTURE, i - 1), 2);
+            } else if (!this.hasCrops(worldIn, pos)) {
+                turnToDirt(worldIn, pos);
+            }
+        } else if (i < 7) {
+            worldIn.setBlockState(pos, state.withProperty(MOISTURE, 7), 2);
+        }
+    }
+
+    /**
+     * Block's chance to react to a living entity falling on it.
+     */
+    public void onFallenUpon(World worldIn, BlockPos pos, Entity entityIn, float fallDistance) {
+        if (!worldIn.isRemote && entityIn.canTrample(worldIn, this, pos, fallDistance)) // Forge: Move logic to Entity#canTrample
+        {
+            turnToDirt(worldIn, pos);
+        }
+
+        super.onFallenUpon(worldIn, pos, entityIn, fallDistance);
+    }
+
+    private boolean hasCrops(World worldIn, BlockPos pos) {
+        Block block = worldIn.getBlockState(pos.up()).getBlock();
+        return block instanceof net.minecraftforge.common.IPlantable && canSustainPlant(worldIn.getBlockState(pos), worldIn, pos, net.minecraft.util.EnumFacing.UP, (net.minecraftforge.common.IPlantable) block);
+    }
+
+    private boolean hasWater(World worldIn, BlockPos pos) {
+        for (BlockPos.MutableBlockPos blockpos$mutableblockpos : BlockPos.getAllInBoxMutable(pos.add(-4, 0, -4), pos.add(4, 1, 4))) {
+            if (worldIn.getBlockState(blockpos$mutableblockpos).getMaterial() == Material.WATER) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Called when a neighboring block was changed and marks that this state should perform any checks during a neighbor
+     * change. Cases may include when redstone power is updated, cactus blocks popping off due to a neighboring solid
+     * block, etc.
+     */
+    public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) {
+        super.neighborChanged(state, worldIn, pos, blockIn, fromPos);
+
+        if (worldIn.getBlockState(pos.up()).getMaterial().isSolid()) {
+            turnToDirt(worldIn, pos);
+        }
+    }
+
+    /**
+     * Called after the block is set in the Chunk data, but before the Tile Entity is set
+     */
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        super.onBlockAdded(worldIn, pos, state);
+
+        if (worldIn.getBlockState(pos.up()).getMaterial().isSolid()) {
+            turnToDirt(worldIn, pos);
+        }
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        switch (side) {
+            case UP:
+                return true;
+            case NORTH:
+            case SOUTH:
+            case WEST:
+            case EAST:
+                IBlockState iblockstate = blockAccess.getBlockState(pos.offset(side));
+                Block block = iblockstate.getBlock();
+                return !iblockstate.isOpaqueCube() && block != this && block != Blocks.GRASS_PATH && block != Blocks.FARMLAND;
+            default:
+                return super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+        }
+    }
+
+    /**
+     * Get the Item that this Block should drop when harvested.
+     */
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        return this.getDefaultState().withProperty(MOISTURE, meta & 7);
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(MOISTURE);
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, MOISTURE);
+    }
+
+    /**
+     * Get the geometry of the queried face at the given position and state. This is used to decide whether things like
+     * buttons are allowed to be placed on the face, or how glass panes connect to the face, among other things.
+     * <p>
+     * Common values are {@code SOLID}, which is the default, and {@code UNDEFINED}, which represents something that
+     * does not fit the other descriptions and will generally cause other things not to connect to the face.
+     *
+     * @return an approximation of the form of the given face
+     */
+    public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face) {
+        return face == EnumFacing.DOWN ? BlockFaceShape.SOLID : BlockFaceShape.UNDEFINED;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabBase.java	(date 1525541029000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldSlabBase.java	(date 1525541029000)
@@ -0,0 +1,66 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+
+public class BlockOverworldSlabBase extends BlockModSlab {
+
+    public BlockOverworldSlabBase(String name, Material material, boolean isDouble) {
+        super(name, Reference.MOD_ID, material, isDouble);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+    @Override
+    public BlockRenderLayer getBlockLayer() {
+        return BlockRenderLayer.CUTOUT_MIPPED;
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return isDouble();
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState state) {
+        return isDouble();
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean shouldSideBeRendered(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+        IBlockState iblockstate = blockAccess.getBlockState(pos.offset(side));
+        Block block = iblockstate.getBlock();
+
+        if (blockState != iblockstate) {
+            return true;
+        }
+
+        if (block == this) {
+            return false;
+        }
+
+        return block != this && super.shouldSideBeRendered(blockState, blockAccess, pos, side);
+    }
+
+    @Override
+    public IProperty<?> getVariantProperty() {
+        return HALF;
+    }
+
+    @Override
+    public Comparable<?> getTypeForItem(ItemStack stack) {
+        return null;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockFacing.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockFacing.java	(date 1525201367000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockFacing.java	(date 1525201367000)
@@ -0,0 +1,100 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyDirection;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.item.ItemStack;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModContainer;
+
+import javax.annotation.Nullable;
+
+public abstract class BlockFacing extends BlockModContainer {
+
+    public static final PropertyDirection FACING = PropertyDirection.create("facing");
+
+    public BlockFacing(Material materialIn, String modid, String name, String... variants) {
+        super(materialIn, modid, name, variants);
+        setDefaultState(makeDefaultState());
+    }
+
+    @Nullable
+    @Override
+    public TileEntity createNewTileEntity(World worldIn, int meta) {
+        return null;
+    }
+
+    public IBlockState makeDefaultState() {
+        return blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH);
+    }
+
+    @Override
+    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
+        worldIn.setBlockState(pos, state.withProperty(FACING, placer.getHorizontalFacing().getOpposite()), 2);
+    }
+
+    /**
+     * Called after the animation.animations.blocks is set in the Chunk data, but before the Tile Entity is set
+     */
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
+        this.setDefaultFacing(worldIn, pos, state);
+    }
+
+    private void setDefaultFacing(World worldIn, BlockPos pos, IBlockState state) {
+        if (!worldIn.isRemote) {
+            IBlockState iblockstate = worldIn.getBlockState(pos.north());
+            IBlockState iblockstate1 = worldIn.getBlockState(pos.south());
+            IBlockState iblockstate2 = worldIn.getBlockState(pos.west());
+            IBlockState iblockstate3 = worldIn.getBlockState(pos.east());
+            IBlockState iblockstate4 = worldIn.getBlockState(pos.up());
+            IBlockState iblockstate5 = worldIn.getBlockState(pos.down());
+            EnumFacing enumfacing = state.getValue(FACING);
+
+            if (enumfacing == EnumFacing.NORTH && iblockstate.isFullBlock() && !iblockstate1.isFullBlock()) {
+                enumfacing = EnumFacing.SOUTH;
+            } else if (enumfacing == EnumFacing.SOUTH && iblockstate1.isFullBlock() && !iblockstate.isFullBlock()) {
+                enumfacing = EnumFacing.NORTH;
+            } else if (enumfacing == EnumFacing.WEST && iblockstate2.isFullBlock() && !iblockstate3.isFullBlock()) {
+                enumfacing = EnumFacing.EAST;
+            } else if (enumfacing == EnumFacing.EAST && iblockstate3.isFullBlock() && !iblockstate2.isFullBlock()) {
+                enumfacing = EnumFacing.WEST;
+            } else if (enumfacing == EnumFacing.UP && iblockstate4.isFullBlock() && !iblockstate4.isFullBlock()) {
+                enumfacing = EnumFacing.UP;
+            } else if (enumfacing == EnumFacing.DOWN && iblockstate5.isFullBlock() && !iblockstate5.isFullBlock()) {
+                enumfacing = EnumFacing.DOWN;
+            }
+
+            worldIn.setBlockState(pos, state.withProperty(FACING, enumfacing), 2);
+        }
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta) {
+        EnumFacing enumfacing = EnumFacing.getFront(meta);
+
+        if (enumfacing.getAxis() == EnumFacing.Axis.Y)
+            enumfacing = EnumFacing.UP;
+        if (enumfacing.getAxis() == EnumFacing.Axis.X)
+            enumfacing = EnumFacing.NORTH;
+        if (enumfacing.getAxis() == EnumFacing.Axis.Z)
+            enumfacing = EnumFacing.EAST;
+
+        return getDefaultState().withProperty(FACING, enumfacing);
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state) {
+        return state.getValue(FACING).getIndex();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, FACING);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityTurtle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityTurtle.java	(date 1523986194000)
+++ src/main/java/net/hdt/neutronia/entity/EntityTurtle.java	(date 1523986194000)
@@ -0,0 +1,266 @@
+package net.hdt.neutronia.entity;
+
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.*;
+import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.projectile.EntitySmallFireball;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.storage.loot.LootTableList;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+
+public class EntityTurtle extends EntityMob {
+
+    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityTurtle.class, DataSerializers.BYTE);
+    /**
+     * Random offset used in floating behaviour
+     */
+    private float heightOffset = 0.5F;
+    /**
+     * ticks until heightOffset is randomized
+     */
+    private int heightOffsetUpdateTime;
+
+    public EntityTurtle(World worldIn) {
+        super(worldIn);
+        this.isImmuneToFire = true;
+        this.experienceValue = 10;
+    }
+
+    protected void initEntityAI() {
+        this.tasks.addTask(4, new EntityTurtle.AIFireballAttack(this));
+        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
+        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
+        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
+        this.tasks.addTask(8, new EntityAILookIdle(this));
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
+    }
+
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
+    }
+
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(ON_FIRE, (byte) 0);
+    }
+
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_BLAZE_AMBIENT;
+    }
+
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_BLAZE_HURT;
+    }
+
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_BLAZE_DEATH;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getBrightnessForRender() {
+        return 15728880;
+    }
+
+    /**
+     * Gets how bright this entity is.
+     */
+    public float getBrightness() {
+        return 1.0F;
+    }
+
+    /**
+     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
+     * use this to react to sunlight and start to burn.
+     */
+    public void onLivingUpdate() {
+        if (!this.onGround && this.motionY < 0.0D) {
+            this.motionY *= 0.6D;
+        }
+
+        if (this.world.isRemote) {
+            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
+                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
+            }
+
+            for (int i = 0; i < 2; ++i) {
+                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
+            }
+        }
+
+        super.onLivingUpdate();
+    }
+
+    protected void updateAITasks() {
+        if (this.isWet()) {
+            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
+        }
+
+        --this.heightOffsetUpdateTime;
+
+        if (this.heightOffsetUpdateTime <= 0) {
+            this.heightOffsetUpdateTime = 100;
+            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
+        }
+
+        EntityLivingBase entitylivingbase = this.getAttackTarget();
+
+        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
+            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
+            this.isAirBorne = true;
+        }
+
+        super.updateAITasks();
+    }
+
+    public void fall(float distance, float damageMultiplier) {
+    }
+
+    /**
+     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
+     */
+    public boolean isBurning() {
+        return this.isCharged();
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableList.ENTITIES_BLAZE;
+    }
+
+    private boolean isCharged() {
+        return (this.dataManager.get(ON_FIRE) & 1) != 0;
+    }
+
+    private void setOnFire(boolean onFire) {
+        byte b0 = this.dataManager.get(ON_FIRE);
+
+        if (onFire) {
+            b0 = (byte) (b0 | 1);
+        } else {
+            b0 = (byte) (b0 & -2);
+        }
+
+        this.dataManager.set(ON_FIRE, b0);
+    }
+
+    /**
+     * Checks to make sure the light is not too bright where the mob is spawning
+     */
+    protected boolean isValidLightLevel() {
+        return true;
+    }
+
+    static class AIFireballAttack extends EntityAIBase {
+        private final EntityTurtle blaze;
+        private int attackStep;
+        private int attackTime;
+
+        AIFireballAttack(EntityTurtle blazeIn) {
+            this.blaze = blazeIn;
+            this.setMutexBits(3);
+        }
+
+        /**
+         * Returns whether the EntityAIBase should begin execution.
+         */
+        public boolean shouldExecute() {
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            return entitylivingbase != null && entitylivingbase.isEntityAlive();
+        }
+
+        /**
+         * Execute a one shot task or start executing a continuous task
+         */
+        public void startExecuting() {
+            this.attackStep = 0;
+        }
+
+        /**
+         * Reset the task's internal state. Called when this task is interrupted by another one
+         */
+        public void resetTask() {
+            this.blaze.setOnFire(false);
+        }
+
+        /**
+         * Keep ticking a continuous task that has already been started
+         */
+        public void updateTask() {
+            --this.attackTime;
+            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
+            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
+
+            if (d0 < 4.0D) {
+                if (this.attackTime <= 0) {
+                    this.attackTime = 20;
+                    this.blaze.attackEntityAsMob(entitylivingbase);
+                }
+
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
+                double d1 = entitylivingbase.posX - this.blaze.posX;
+                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
+                double d3 = entitylivingbase.posZ - this.blaze.posZ;
+
+                if (this.attackTime <= 0) {
+                    ++this.attackStep;
+
+                    if (this.attackStep == 1) {
+                        this.attackTime = 60;
+                        this.blaze.setOnFire(true);
+                    } else if (this.attackStep <= 4) {
+                        this.attackTime = 6;
+                    } else {
+                        this.attackTime = 100;
+                        this.attackStep = 0;
+                        this.blaze.setOnFire(false);
+                    }
+
+                    if (this.attackStep > 1) {
+                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
+                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
+
+                        for (int i = 0; i < 1; ++i) {
+                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
+                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
+                            this.blaze.world.spawnEntity(entitysmallfireball);
+                        }
+                    }
+                }
+
+                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
+            } else {
+                this.blaze.getNavigator().clearPath();
+                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
+            }
+
+            super.updateTask();
+        }
+
+        private double getFollowDistance() {
+            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
+            return iattributeinstance.getAttributeValue();
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureCluster.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureCluster.java	(date 1525606897000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureCluster.java	(date 1525606897000)
@@ -0,0 +1,84 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public class FeatureCluster extends Feature {
+    private IBlockState blockToSpawn;
+    private IBlockState blockToAttachTo;
+    private EnumFacing direction;
+
+    public FeatureCluster(IConfig config) {
+        super(config);
+        blockToSpawn = config.getBlock("blockToSpawn", Blocks.BARRIER.getDefaultState());
+        blockToAttachTo = config.getBlock("blockToAttachTo", Blocks.BARRIER.getDefaultState());
+        direction = config.getEnum("direction", EnumFacing.class, EnumFacing.DOWN);
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (blockToSpawn.getBlock() == Blocks.BARRIER || blockToAttachTo.getBlock() == Blocks.BARRIER) {
+            return false;
+        }
+
+        if (!world.isAirBlock(pos)) {
+            return false;
+        } else if (world.getBlockState(pos.offset(direction.getOpposite())) != blockToAttachTo) {
+            return false;
+        } else {
+            world.setBlockState(pos, blockToSpawn, 3);
+
+            for (int i = 0; i < 1500; i++) {
+                BlockPos newPos;
+
+                switch (direction) {
+                    default:
+                    case DOWN:
+                        newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), -rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8));
+                        break;
+                    case UP:
+                        newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8));
+                        break;
+                    case NORTH:
+                        newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(8) - rand.nextInt(8), -rand.nextInt(12));
+                        break;
+                    case SOUTH:
+                        newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(8) - rand.nextInt(8), rand.nextInt(12));
+                        break;
+                    case WEST:
+                        newPos = pos.add(-rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8), rand.nextInt(8) - rand.nextInt(8));
+                        break;
+                    case EAST:
+                        newPos = pos.add(rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8), rand.nextInt(8) - rand.nextInt(8));
+                        break;
+                }
+
+                if (world.isAirBlock(newPos)) {
+                    int j = 0;
+
+                    for (EnumFacing facing : EnumFacing.values()) {
+                        if (world.getBlockState(newPos.offset(facing)).getBlock() == blockToSpawn.getBlock()) {
+                            j++;
+                        }
+
+                        if (j > 1) {
+                            break;
+                        }
+                    }
+
+                    if (j == 1) {
+                        world.setBlockState(newPos, blockToSpawn, 3);
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingStairBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingStairBase.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingStairBase.java	(date 1525606887000)
@@ -0,0 +1,77 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.enchantment.EnchantmentHelper;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+
+import java.util.Random;
+
+public class BlockNetherGlowingStairBase extends BlockModStairs {
+
+    public BlockNetherGlowingStairBase(String name, IBlockState state) {
+        super(name + "_stair", state);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+        this.setLightLevel(0.2F);
+        this.setTickRandomly(true);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    /**
+     * Called when the given entity walks on this Block
+     */
+    public void onEntityWalk(World worldIn, BlockPos pos, Entity entityIn) {
+        if (!entityIn.isImmuneToFire() && entityIn instanceof EntityLivingBase && !EnchantmentHelper.hasFrostWalkerEnchantment((EntityLivingBase) entityIn)) {
+            entityIn.attackEntityFrom(DamageSource.HOT_FLOOR, 1.0F);
+        }
+
+        super.onEntityWalk(worldIn, pos, entityIn);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+    public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
+        BlockPos blockpos = pos.up();
+        IBlockState iblockstate = worldIn.getBlockState(blockpos);
+
+        if (iblockstate.getBlock() == Blocks.WATER || iblockstate.getBlock() == Blocks.FLOWING_WATER) {
+            worldIn.setBlockToAir(blockpos);
+            worldIn.playSound(null, pos, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (worldIn.rand.nextFloat() - worldIn.rand.nextFloat()) * 0.8F);
+
+            if (worldIn instanceof WorldServer) {
+                ((WorldServer) worldIn).spawnParticle(EnumParticleTypes.SMOKE_LARGE, (double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.25D, (double) blockpos.getZ() + 0.5D, 8, 0.5D, 0.25D, 0.5D, 0.0D);
+            }
+        }
+    }
+
+    public boolean canEntitySpawn(IBlockState state, Entity entityIn) {
+        return entityIn.isImmuneToFire();
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/render/RenderMummyVillager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderMummyVillager.java	(date 1523987840000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderMummyVillager.java	(date 1523987840000)
@@ -0,0 +1,49 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityMummyVillager;
+import net.hdt.neutronia.entity.render.model.ModelMummyVillager;
+import net.minecraft.client.renderer.entity.RenderBiped;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class RenderMummyVillager extends RenderBiped<EntityMummyVillager> {
+
+    private static final ResourceLocation ZOMBIE_VILLAGER_TEXTURES = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/villager.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_FARMER_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/farmer.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_LIBRARIAN_LOC = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/librarian.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_PRIEST_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/priest.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_SMITH_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/smith.png");
+    private static final ResourceLocation ZOMBIE_VILLAGER_BUTCHER_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/butcher.png");
+
+    public RenderMummyVillager(RenderManager renderManagerIn) {
+        super(renderManagerIn, new ModelMummyVillager(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityMummyVillager entity) {
+        switch (entity.getProfession()) {
+            case 0:
+                return ZOMBIE_VILLAGER_FARMER_LOCATION;
+            case 1:
+                return ZOMBIE_VILLAGER_LIBRARIAN_LOC;
+            case 2:
+                return ZOMBIE_VILLAGER_PRIEST_LOCATION;
+            case 3:
+                return ZOMBIE_VILLAGER_SMITH_LOCATION;
+            case 4:
+                return ZOMBIE_VILLAGER_BUTCHER_LOCATION;
+            case 5:
+            default:
+                return ZOMBIE_VILLAGER_TEXTURES;
+        }
+    }
+
+    @Override
+    protected void applyRotations(EntityMummyVillager entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        if (entityLiving.isConverting())
+            rotationYaw += (float) (Math.cos((double) entityLiving.ticksExisted * 3.25D) * Math.PI * 0.25D);
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumNetherBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumNetherBlocks.java	(date 1524947219000)
+++ src/main/java/net/hdt/neutronia/properties/EnumNetherBlocks.java	(date 1524947219000)
@@ -0,0 +1,46 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumNetherBlocks implements IStringSerializable {
+
+    ASH(0, "ash"),
+    NETHER_DIRT(1, "nether_dirt");
+
+    private static final EnumNetherBlocks[] META_LOOKUP = new EnumNetherBlocks[values().length];
+
+    static {
+        for (EnumNetherBlocks blockstone$enumtype : values()) {
+            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumNetherBlocks(int p_i46384_3_, String p_i46384_5_) {
+        this.meta = p_i46384_3_;
+        this.name = p_i46384_5_;
+    }
+
+    public static EnumNetherBlocks byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndStoneBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndStoneBricks.java	(date 1524853000000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndStoneBricks.java	(date 1524853000000)
@@ -0,0 +1,81 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockEndStoneBricks extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockEndStoneBricks()
+    {
+        super("end_stone_bricks", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/properties/EnumCoralColor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumCoralColor.java	(date 1523986184000)
+++ src/main/java/net/hdt/neutronia/properties/EnumCoralColor.java	(date 1523986184000)
@@ -0,0 +1,71 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+public enum EnumCoralColor implements IStringSerializable {
+
+    YELLOW(0, "yellow", 16701501),
+    PINK(1, "pink", 15961002),
+    PURPLE(2, "purple", 8991416),
+    BLUE(3, "blue", 3949738),
+    RED(4, "red", 11546150);
+
+    private static final EnumCoralColor[] META_LOOKUP = new EnumCoralColor[values().length];
+
+    static {
+        for (EnumCoralColor enumdyecolor : values()) {
+            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+    private final int colorValue;
+    private final float[] colorComponentValues;
+
+    EnumCoralColor(int metaIn, String nameIn, int colorValueIn) {
+        this.meta = metaIn;
+        this.name = nameIn;
+        this.colorValue = colorValueIn;
+        int i = (colorValueIn & 16711680) >> 16;
+        int j = (colorValueIn & 65280) >> 8;
+        int k = (colorValueIn & 255);
+        this.colorComponentValues = new float[]{(float) i / 255.0F, (float) j / 255.0F, (float) k / 255.0F};
+    }
+
+    public static EnumCoralColor byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public String getDyeColorName() {
+        return this.name;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getColorValue() {
+        return this.colorValue;
+    }
+
+    public float[] getColorComponentValues() {
+        return this.colorComponentValues;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalStainedPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalStainedPlanks.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalStainedPlanks.java	(date 1525606883000)
@@ -0,0 +1,40 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockVerticalStainedPlanks extends BlockMetaVariants implements IModBlock {
+
+    public BlockVerticalStainedPlanks() {
+        super("vertical_stained_planks", MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        VERTICAL_STAINED_PLANKS_WHITE,
+        VERTICAL_STAINED_PLANKS_ORANGE,
+        VERTICAL_STAINED_PLANKS_MAGENTA,
+        VERTICAL_STAINED_PLANKS_LIGHT_BLUE,
+        VERTICAL_STAINED_PLANKS_YELLOW,
+        VERTICAL_STAINED_PLANKS_LIME,
+        VERTICAL_STAINED_PLANKS_PINK,
+        VERTICAL_STAINED_PLANKS_GRAY,
+        VERTICAL_STAINED_PLANKS_SILVER,
+        VERTICAL_STAINED_PLANKS_CYAN,
+        VERTICAL_STAINED_PLANKS_PURPLE,
+        VERTICAL_STAINED_PLANKS_BLUE,
+        VERTICAL_STAINED_PLANKS_BROWN,
+        VERTICAL_STAINED_PLANKS_GREEN,
+        VERTICAL_STAINED_PLANKS_RED,
+        VERTICAL_STAINED_PLANKS_BLACK
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingSlabBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingSlabBase.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingSlabBase.java	(date 1525606880000)
@@ -0,0 +1,89 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.enchantment.EnchantmentHelper;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+
+import java.util.Random;
+
+public class BlockNetherGlowingSlabBase extends BlockModSlab {
+
+    public BlockNetherGlowingSlabBase(String name, boolean isDouble) {
+        super(name + "_slab", Reference.MOD_ID, Material.ROCK, isDouble);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+        this.setLightLevel(0.2F);
+        this.setTickRandomly(true);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    /**
+     * Called when the given entity walks on this Block
+     */
+    public void onEntityWalk(World worldIn, BlockPos pos, Entity entityIn) {
+        if (!entityIn.isImmuneToFire() && entityIn instanceof EntityLivingBase && !EnchantmentHelper.hasFrostWalkerEnchantment((EntityLivingBase) entityIn)) {
+            entityIn.attackEntityFrom(DamageSource.HOT_FLOOR, 1.0F);
+        }
+
+        super.onEntityWalk(worldIn, pos, entityIn);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+    public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
+        BlockPos blockpos = pos.up();
+        IBlockState iblockstate = worldIn.getBlockState(blockpos);
+
+        if (iblockstate.getBlock() == Blocks.WATER || iblockstate.getBlock() == Blocks.FLOWING_WATER) {
+            worldIn.setBlockToAir(blockpos);
+            worldIn.playSound(null, pos, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (worldIn.rand.nextFloat() - worldIn.rand.nextFloat()) * 0.8F);
+
+            if (worldIn instanceof WorldServer) {
+                ((WorldServer) worldIn).spawnParticle(EnumParticleTypes.SMOKE_LARGE, (double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.25D, (double) blockpos.getZ() + 0.5D, 8, 0.5D, 0.25D, 0.5D, 0.0D);
+            }
+        }
+    }
+
+    public boolean canEntitySpawn(IBlockState state, Entity entityIn) {
+        return entityIn.isImmuneToFire();
+    }
+
+    @Override
+    public IProperty<?> getVariantProperty() {
+        return HALF;
+    }
+
+    @Override
+    public Comparable<?> getTypeForItem(ItemStack stack) {
+        return null;
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockGlassBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockGlassBase.java	(date 1524916857000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockGlassBase.java	(date 1524916857000)
@@ -0,0 +1,44 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.BlockRenderLayer;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import java.util.Random;
+
+public class BlockGlassBase extends BlockMod {
+
+    public BlockGlassBase(String name) {
+        super(Material.ICE, Reference.MOD_ID, name);
+    }
+
+    /**
+     * Used to determine ambient occlusion and culling when rebuilding chunks for render
+     */
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    /**
+     * Returns the quantity of items to drop on block destruction.
+     */
+    public int quantityDropped(Random random) {
+        return 0;
+    }
+
+    @Override
+    public BlockRenderLayer getBlockLayer() {
+        return BlockRenderLayer.TRANSLUCENT;
+    }
+
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    protected boolean canSilkHarvest() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/base/tools/BaseSword.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/tools/BaseSword.java	(date 1523988244000)
+++ src/main/java/net/hdt/neutronia/items/base/tools/BaseSword.java	(date 1523988244000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.items.base.tools;
+
+import net.hdt.neutronia.util.Reference;
+import net.thegaminghuskymc.huskylib2.items.ItemModSword;
+
+public class BaseSword extends ItemModSword {
+
+    public BaseSword(String name, ToolMaterial material) {
+        super(name, Reference.MOD_ID, material);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/LibObfuscation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/LibObfuscation.java	(date 1523986200000)
+++ src/main/java/net/hdt/neutronia/util/LibObfuscation.java	(date 1523986200000)
@@ -0,0 +1,8 @@
+package net.hdt.neutronia.util;
+
+public final class LibObfuscation {
+
+    // Minecraft
+    public static final String[] DEFAULT_RESOURCE_PACKS = new String[]{"aD", "field_110449_ao", "defaultResourcePacks"};
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/RenderPhantom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderPhantom.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderPhantom.java	(date 1523987839000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntityPhantom;
+import net.hdt.neutronia.entity.render.model.ModelPhantom;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderPhantom extends RenderLiving<EntityPhantom> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/phantom.png");
+
+    public RenderPhantom(RenderManager manager) {
+        super(manager, new ModelPhantom(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntityPhantom entity) {
+        return SCORP_TEXTURE;
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksSlab.java	(date 1525537564000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanksSlab.java	(date 1525537564000)
@@ -0,0 +1,22 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.modules.building.blocks.BlockStainedPlanks;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedPlanksSlab extends BlockOverworldSlabBase implements IRecipeGrouped {
+
+    public BlockStainedPlanksSlab(BlockStainedPlanks.Variants variant, boolean doubleSlab) {
+        super(variant.getName() + "_slab", Material.WOOD, doubleSlab);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_planks_slab";
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldBase.java	(date 1523987838000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockOverworldBase.java	(date 1523987838000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+public class BlockOverworldBase extends BlockMod {
+
+    public BlockOverworldBase(Material material, String name) {
+        super(material, Reference.MOD_ID, name);
+        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenStructure.java	(date 1523988245000)
+++ src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenStructure.java	(date 1523988245000)
@@ -0,0 +1,46 @@
+package net.hdt.neutronia.world.gen.generators;
+
+import net.hdt.neutronia.util.Reference;
+import net.hdt.neutronia.util.interfaces.IStructure;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.gen.structure.template.TemplateManager;
+
+import java.util.Random;
+
+public class WorldGenStructure extends WorldGenerator implements IStructure {
+    private static String structureName;
+
+    public WorldGenStructure(String name) {
+        structureName = name;
+    }
+
+    private static void generateStructure(World world, BlockPos pos) {
+        MinecraftServer mcServer = world.getMinecraftServer();
+        TemplateManager manager = worldServer.getStructureTemplateManager();
+        ResourceLocation location = new ResourceLocation(Reference.MOD_ID, structureName);
+        Template template = manager.get(mcServer, location);
+
+        if (template != null) {
+            IBlockState state = world.getBlockState(pos);
+            world.notifyBlockUpdate(pos, state, state, 3);
+            template.addBlocksToWorldChunk(world, pos, settings);
+        }
+
+        if (template == null) {
+            System.out.println("NO STRUCTURE");
+        }
+
+    }
+
+    @Override
+    public boolean generate(World worldIn, Random rand, BlockPos position) {
+        generateStructure(worldIn, position);
+        return true;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherStairBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherStairBase.java	(date 1525541029000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherStairBase.java	(date 1525541029000)
@@ -0,0 +1,25 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.state.IBlockState;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+
+public class BlockNetherStairBase extends BlockModStairs {
+
+    public BlockNetherStairBase(String name, IBlockState state) {
+        super(name, state);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalPlanks.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockVerticalPlanks.java	(date 1525606883000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockVerticalPlanks extends BlockMetaVariants implements IModBlock {
+
+    public BlockVerticalPlanks() {
+        super("vertical_planks", MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+        VERTICAL_OAK_PLANKS,
+        VERTICAL_SPRUCE_PLANKS,
+        VERTICAL_BIRCH_PLANKS,
+        VERTICAL_JUNGLE_PLANKS,
+        VERTICAL_ACACIA_PLANKS,
+        VERTICAL_DARK_OAK_PLANKS
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBasaltOverworld.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBasaltOverworld.java	(date 1523988243000)
+++ src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeBasaltOverworld.java	(date 1523988243000)
@@ -0,0 +1,28 @@
+package net.hdt.neutronia.world.biome.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+
+import java.util.Random;
+
+public class BiomeBasaltOverworld extends Biome {
+
+    public BiomeBasaltOverworld() {
+        super(new BiomeProperties("Basalt").setBaseHeight(1.0F).setHeightVariation(0.3F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled());
+
+        topBlock = HMBlocks.newStoneVariants[6].getDefaultState();
+        fillerBlock = HMBlocks.newStoneVariants[6].getDefaultState();
+
+        this.spawnableCaveCreatureList.clear();
+        this.spawnableCreatureList.clear();
+        this.spawnableMonsterList.clear();
+        this.spawnableWaterCreatureList.clear();
+    }
+
+    public void decorate(World worldIn, Random rand, BlockPos pos) {
+
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/NumberHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/NumberHelper.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/util/NumberHelper.java	(date 1525606898000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.util;
+
+import java.util.Random;
+
+public class NumberHelper {
+    private static final Random RAND = new Random();
+
+    public static int getNumberInRange(int min, int max, Random rand) {
+        return rand.nextInt(max - min + 1) + min;
+    }
+
+    public static Random getRand() {
+        return RAND;
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedPlanks.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedPlanks.java	(date 1525606883000)
@@ -0,0 +1,40 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockStainedPlanks extends BlockMetaVariants implements IModBlock {
+
+    public BlockStainedPlanks() {
+        super("stained_planks", MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+        STAINED_PLANKS_WHITE,
+        STAINED_PLANKS_ORANGE,
+        STAINED_PLANKS_MAGENTA,
+        STAINED_PLANKS_LIGHT_BLUE,
+        STAINED_PLANKS_YELLOW,
+        STAINED_PLANKS_LIME,
+        STAINED_PLANKS_PINK,
+        STAINED_PLANKS_GRAY,
+        STAINED_PLANKS_SILVER,
+        STAINED_PLANKS_CYAN,
+        STAINED_PLANKS_PURPLE,
+        STAINED_PLANKS_BLUE,
+        STAINED_PLANKS_BROWN,
+        STAINED_PLANKS_GREEN,
+        STAINED_PLANKS_RED,
+        STAINED_PLANKS_BLACK
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockThatch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockThatch.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockThatch.java	(date 1525606881000)
@@ -0,0 +1,39 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:41:27 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.modules.building.features.Thatch;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockThatch extends BlockMod implements IModBlock {
+
+    public BlockThatch() {
+        super(Material.GRASS, MOD_ID, "thatch");
+        setHardness(0.5F);
+        setSoundType(SoundType.PLANT);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public void onFallenUpon(World worldIn, BlockPos pos, Entity entityIn, float fallDistance) {
+        entityIn.fall(fallDistance, Thatch.fallDamageMultiplier);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSturdyStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSturdyStone.java	(date 1525606887000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSturdyStone.java	(date 1525606887000)
@@ -0,0 +1,28 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.EnumPushReaction;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockSturdyStone extends BlockMod implements IModBlock {
+
+    public BlockSturdyStone() {
+        super(Material.ROCK, MOD_ID, "sturdy_stone");
+        setHardness(4.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public EnumPushReaction getMobilityFlag(IBlockState state) {
+        return EnumPushReaction.BLOCK;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityMummyVillager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityMummyVillager.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/entity/EntityMummyVillager.java	(date 1525606862000)
@@ -0,0 +1,266 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.IEntityLivingData;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+import net.minecraftforge.fml.common.registry.VillagerRegistry;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
+import java.util.UUID;
+
+
+/**
+ * TODO: Fix Texture and Model
+ */
+public class EntityMummyVillager extends EntityMummy {
+
+    private static final DataParameter<Boolean> CONVERTING = EntityDataManager.createKey(EntityMummyVillager.class, DataSerializers.BOOLEAN);
+    private static final DataParameter<Integer> PROFESSION = EntityDataManager.createKey(EntityMummyVillager.class, DataSerializers.VARINT);
+
+    private int conversionTime;
+    private UUID converstionStarter;
+    @Nullable
+    private VillagerRegistry.VillagerProfession prof;
+
+    public EntityMummyVillager(World worldIn) {
+        super(worldIn);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(CONVERTING, Boolean.FALSE);
+        this.dataManager.register(PROFESSION, 0);
+    }
+
+    public int getProfession() {
+        return Math.max(this.dataManager.get(PROFESSION), 0);
+    }
+
+    public void setProfession(int profession) {
+        this.dataManager.set(PROFESSION, profession);
+    }
+
+    @Override
+    public void writeEntityToNBT(NBTTagCompound compound) {
+        super.writeEntityToNBT(compound);
+        compound.setInteger("Profession", this.getProfession());
+        compound.setString("ProfessionName", Objects.requireNonNull(this.getForgeProfession().getRegistryName()).toString());
+        compound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);
+
+        if (this.converstionStarter != null) {
+            compound.setUniqueId("ConversionStarter", this.converstionStarter);
+        }
+    }
+
+    @Override
+    public void readEntityFromNBT(NBTTagCompound compound) {
+        super.readEntityFromNBT(compound);
+        this.setProfession(compound.getInteger("Profession"));
+        if (compound.hasKey("ProfessionName")) {
+            VillagerRegistry.VillagerProfession p = ForgeRegistries.VILLAGER_PROFESSIONS.getValue(new net.minecraft.util.ResourceLocation(compound.getString("ProfessionName")));
+            if (p == null) p = VillagerRegistry.FARMER;
+            this.setForgeProfession(p);
+        }
+
+        if (compound.hasKey("ConversionTime", 99) && compound.getInteger("ConversionTime") > -1) {
+            this.startConverting(compound.hasUniqueId("ConversionPlayer") ? compound.getUniqueId("ConversionPlayer") : null, compound.getInteger("ConversionTime"));
+        }
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        this.setProfession(this.world.rand.nextInt(6));
+        return super.onInitialSpawn(difficulty, livingdata);
+    }
+
+    @Override
+    public void onUpdate() {
+        if (!this.world.isRemote && this.isConverting()) {
+            int i = this.getConversionProgress();
+            this.conversionTime -= i;
+
+            if (this.conversionTime <= 0) {
+                this.finishConversion();
+            }
+        }
+        super.onUpdate();
+    }
+
+    @Override
+    protected boolean processInteract(EntityPlayer player, EnumHand hand) {
+        ItemStack itemstack = player.getHeldItem(hand);
+
+        if (itemstack.getItem() == Items.GOLDEN_APPLE && itemstack.getMetadata() == 0 && this.isPotionActive(MobEffects.WEAKNESS)) {
+            if (!player.capabilities.isCreativeMode) {
+                itemstack.shrink(1);
+            }
+
+            if (!this.world.isRemote) {
+                this.startConverting(player.getUniqueID(), this.rand.nextInt(2401) + 3600);
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected boolean canDespawn() {
+        return !this.isConverting();
+    }
+
+    public boolean isConverting() {
+        return this.getDataManager().get(CONVERTING);
+    }
+
+    protected void startConverting(@Nullable UUID conversionStarterIn, int conversionTimeIn) {
+        this.converstionStarter = conversionStarterIn;
+        this.conversionTime = conversionTimeIn;
+        this.getDataManager().set(CONVERTING, Boolean.TRUE);
+        this.removePotionEffect(MobEffects.WEAKNESS);
+        this.addPotionEffect(new PotionEffect(MobEffects.STRENGTH, conversionTimeIn, Math.min(this.world.getDifficulty().getDifficultyId() - 1, 0)));
+        this.world.setEntityState(this, (byte) 16);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 16) {
+            if (!this.isSilent()) {
+                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_ZOMBIE_VILLAGER_CURE, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
+            }
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    protected void finishConversion() {
+        EntityVillager entityvillager = new EntityVillager(this.world);
+        entityvillager.copyLocationAndAnglesFrom(this);
+        entityvillager.setProfession(this.getForgeProfession());
+        entityvillager.finalizeMobSpawn(this.world.getDifficultyForLocation(new BlockPos(entityvillager)), null, false);
+        entityvillager.setLookingForHome();
+        this.world.removeEntity(this);
+        entityvillager.setNoAI(this.isAIDisabled());
+
+        if (this.hasCustomName()) {
+            entityvillager.setCustomNameTag(this.getCustomNameTag());
+            entityvillager.setAlwaysRenderNameTag(this.getAlwaysRenderNameTag());
+        }
+
+        this.world.spawnEntity(entityvillager);
+        entityvillager.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 200, 0));
+        this.world.playEvent(null, 1027, new BlockPos((int) this.posX, (int) this.posY, (int) this.posZ), 0);
+    }
+
+    protected int getConversionProgress() {
+        int i = 1;
+
+        if (this.rand.nextFloat() < 0.01F) {
+            int j = 0;
+            BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
+
+            for (int k = (int) this.posX - 4; k < (int) this.posX + 4 && j < 14; ++k) {
+                for (int l = (int) this.posY - 4; l < (int) this.posY + 4 && j < 14; ++l) {
+                    for (int i1 = (int) this.posZ - 4; i1 < (int) this.posZ + 4 && j < 14; ++i1) {
+                        Block block = this.world.getBlockState(blockpos$mutableblockpos.setPos(k, l, i1)).getBlock();
+
+                        if (block == Blocks.IRON_BARS || block == Blocks.BED) {
+                            if (this.rand.nextFloat() < 0.3F) {
+                                ++i;
+                            }
+
+                            ++j;
+                        }
+                    }
+                }
+            }
+        }
+
+        return i;
+    }
+
+    protected float getSoundPitch() {
+        return (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
+    }
+
+    /**
+     * TODO: FIX NEW SOUNDS
+     */
+
+    public SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_AMBIENT;
+    }
+
+    public SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_HURT;
+    }
+
+    public SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_DEATH;
+    }
+
+    //TODO: ^
+
+    public SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_STEP;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.MUMMY_VILLAGER;
+    }
+
+
+    /* ======================================== FORGE START =====================================*/
+
+    protected ItemStack getSkullDrop() {
+        return ItemStack.EMPTY;
+    }
+
+    public VillagerRegistry.VillagerProfession getForgeProfession() {
+        if (this.prof == null) {
+            this.prof = VillagerRegistry.getById(this.getProfession());
+            if (this.prof == null)
+                return VillagerRegistry.FARMER;
+        }
+        return this.prof;
+    }
+
+    public void setForgeProfession(VillagerRegistry.VillagerProfession prof) {
+        this.prof = prof;
+        this.setProfession(VillagerRegistry.getId(prof));
+    }
+
+    @Override
+    public void notifyDataManagerChange(DataParameter<?> key) {
+        super.notifyDataManagerChange(key);
+    }
+
+    /* ======================================== FORGE END =====================================*/
+}
Index: src/main/java/net/hdt/neutronia/items/ItemAnimaniaFood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemAnimaniaFood.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/items/ItemAnimaniaFood.java	(date 1525606882000)
@@ -0,0 +1,102 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.config.AnimaniaConfig;
+import net.hdt.neutronia.util.idk.FoodValueHandler;
+import net.hdt.neutronia.util.idk.RomanNumberHelper;
+import net.hdt.neutronia.util.idk.TimeHelper;
+import net.minecraft.client.util.ITooltipFlag;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.EnumAction;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.potion.Potion;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.util.text.TextFormatting;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+
+import java.util.List;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class ItemAnimaniaFood extends ItemModFood {
+
+    private PotionEffect[] effects;
+    private String name;
+
+    public ItemAnimaniaFood(int amount, float saturation, boolean isWolfFood, String name, PotionEffect... potionEffects) {
+        super(MOD_ID, name, Main.FOOD_EXPANSION_TAB, amount, saturation, isWolfFood);
+        this.effects = potionEffects;
+        this.name = name;
+        this.setAlwaysEdible();
+
+    }
+
+    public ItemAnimaniaFood(int amount, float saturation, String name) {
+        this(amount, saturation, true, name);
+    }
+
+    public ItemAnimaniaFood(int amount, float saturation, String name, PotionEffect... potionEffects) {
+        this(amount, saturation, true, name, potionEffects);
+    }
+
+    @Override
+    public int getHealAmount(ItemStack stack) {
+        Item item = stack.getItem();
+        if (FoodValueHandler.hasOverride(item))
+            return FoodValueHandler.getHealAmount(item);
+        else
+            return super.getHealAmount(stack);
+    }
+
+    @Override
+    public float getSaturationModifier(ItemStack stack) {
+        Item item = stack.getItem();
+        if (FoodValueHandler.hasOverride(item))
+            return FoodValueHandler.getSaturation(item);
+        else
+            return super.getSaturationModifier(stack);
+    }
+
+    @Override
+    public EnumAction getItemUseAction(ItemStack itemstack) {
+        return EnumAction.EAT;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    @Override
+    protected void onFoodEaten(ItemStack itemstack, World worldObj, EntityPlayer entityplayer) {
+        if (!worldObj.isRemote && AnimaniaConfig.gameRules.foodsGiveBonusEffects && this.effects != null)
+            for (PotionEffect effect : this.effects.clone()) {
+                Potion pot = effect.getPotion();
+                int duration = effect.getDuration();
+                int amplifier = effect.getAmplifier();
+                boolean isAmbient = effect.getIsAmbient();
+                entityplayer.addPotionEffect(new PotionEffect(pot, duration, amplifier, isAmbient, false));
+            }
+    }
+
+
+    @Override
+    public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
+        if (AnimaniaConfig.gameRules.foodsGiveBonusEffects && this.effects != null)
+            for (PotionEffect effect : this.effects.clone()) {
+                Potion pot = effect.getPotion();
+                int duration = effect.getDuration();
+                int amplifier = effect.getAmplifier();
+                boolean isInstant = pot.isInstant();
+                boolean isPositive = pot.isBeneficial();
+                String name = pot.getRegistryName().getResourcePath().replace("_", "");
+                if (isPositive)
+                    tooltip.add(TextFormatting.GREEN + I18n.translateToLocal("tooltip.an." + name) + " " + RomanNumberHelper.toRoman(amplifier + 1) + (!isInstant ? " (" + TimeHelper.getTime(duration) + ")" : ""));
+            }
+
+        tooltip.add(TextFormatting.GOLD + I18n.translateToLocal("tooltip.an.edibleanytime"));
+
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/BlockStateHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/BlockStateHelper.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/util/BlockStateHelper.java	(date 1525606895000)
@@ -0,0 +1,44 @@
+/*
+ * LibEx
+ * Copyright (c) 2017-2018 by MineEx
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package net.hdt.neutronia.util;
+
+import com.google.common.collect.ImmutableSet;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+
+public class BlockStateHelper {
+    public static IProperty getProperty(IBlockState state, String propertyName) {
+        for (IProperty property : state.getProperties().keySet()) {
+            if (property.getName().equalsIgnoreCase(propertyName)) {
+                return property;
+            }
+        }
+
+        return null;
+    }
+
+    public static Comparable getPropertyValue(IProperty property, String propertyValue) {
+        for (Comparable value : (ImmutableSet<Comparable>) property.getAllowedValues()) {
+            if (value.toString().equalsIgnoreCase(propertyValue)) {
+                return value;
+            }
+        }
+
+        return null;
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/utils/StructureTFHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/StructureTFHelper.java	(date 1525606896000)
+++ src/main/java/net/hdt/neutronia/world/utils/StructureTFHelper.java	(date 1525606896000)
@@ -0,0 +1,52 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockPlanks;
+import net.minecraft.block.BlockSapling;
+import net.minecraft.block.BlockSlab;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+
+/**
+ * Created by Joseph on 7/16/2017.
+ */
+public class StructureTFHelper {
+
+    public static final IBlockState stoneSlab = getSlab(Blocks.STONE_SLAB);
+    public static final IBlockState stoneSlabTop = getSlabTop(Blocks.STONE_SLAB);
+    public static final IBlockState stoneSlabDouble = Blocks.DOUBLE_STONE_SLAB.getDefaultState();
+
+    public static final IBlockState birchSlab = getSlab(Blocks.WOODEN_SLAB).withProperty(BlockPlanks.VARIANT, BlockPlanks.EnumType.BIRCH);
+    public static final IBlockState birchSlabTop = getSlabTop(Blocks.WOODEN_SLAB).withProperty(BlockPlanks.VARIANT, BlockPlanks.EnumType.BIRCH);
+    public static final IBlockState birchPlanks = Blocks.PLANKS.getDefaultState().withProperty(BlockPlanks.VARIANT, BlockPlanks.EnumType.BIRCH);
+
+
+    private static IBlockState getSlabType(Block type, BlockSlab.EnumBlockHalf side) {
+        return type.getDefaultState().withProperty(BlockSlab.HALF, side);
+    }
+
+
+    public static IBlockState getSlab(Block type) {
+        return getSlabType(type, BlockSlab.EnumBlockHalf.BOTTOM);
+    }
+
+    public static IBlockState getSlabTop(Block type) {
+        return getSlabType(type, BlockSlab.EnumBlockHalf.TOP);
+    }
+
+    public static IBlockState randomPlant(int i) {
+        if (i < 4) return randomSapling(i);
+        else return randomMushroom(i - 4);
+    }
+
+    public static IBlockState randomSapling(int i) {
+        return Blocks.SAPLING.getDefaultState().withProperty(BlockSapling.TYPE, BlockPlanks.EnumType.values()[i]);
+    }
+
+    public static IBlockState randomMushroom(int i) {
+        if (i == 0) return Blocks.RED_MUSHROOM.getDefaultState();
+        else return Blocks.BROWN_MUSHROOM.getDefaultState();
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/init/UtilChat.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/init/UtilChat.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/init/UtilChat.java	(date 1525606885000)
@@ -0,0 +1,147 @@
+package net.hdt.neutronia.init;
+
+import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.command.ICommandSender;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.text.ITextComponent;
+import net.minecraft.util.text.TextComponentTranslation;
+import net.minecraft.util.text.translation.I18n;
+import net.minecraft.world.World;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+
+//import net.minecraft.client.resources.I18n;
+
+@SuppressWarnings("deprecation")
+public class UtilChat {
+
+    public static void addChatMessage(EntityPlayer player, String text) {
+        player.sendMessage(new TextComponentTranslation(lang(text)));
+    }
+
+    public static void addChatMessage(ICommandSender sender, String text) {
+        sender.sendMessage(new TextComponentTranslation(lang(text)));
+    }
+
+    public static void addChatMessage(EntityPlayer player, ITextComponent textComponentTranslation) {
+        player.sendMessage(textComponentTranslation);
+    }
+
+    public static String blockPosToString(BlockPos pos) {
+        return pos.getX() + ", " + pos.getY() + ", " + pos.getZ();
+    }
+
+    public static String lang(String string) {
+        //if we use the clientside one, it literally does not work & crashes on serverside run
+        return I18n.translateToLocal(string);
+    }
+
+    public static void addChatMessage(World worldObj, ITextComponent textComponentTranslation) {
+        if (worldObj.getMinecraftServer() != null) {
+            worldObj.getMinecraftServer().sendMessage(textComponentTranslation);
+        }
+    }
+
+    public static void addChatMessage(World worldObj, String s) {
+        addChatMessage(worldObj, new TextComponentTranslation(s));
+    }
+
+    public static List<String> splitIntoEqualLengths(FontRenderer fr, String input, int lineWidth) {
+        List<String> lines = new ArrayList<String>();
+        String aLine = "";
+        for (char chr : input.toCharArray()) {
+            if (fr.getCharWidth(chr) + fr.getStringWidth(aLine) < lineWidth) {
+                //we have room on this line for this char
+                aLine = aLine + chr;
+            } else {
+                lines.add(new String(aLine));
+                //then the current character has to be pushed to next line
+                aLine = "" + chr;
+            }
+        }
+        if (aLine.isEmpty() == false) {
+            // the last line did not hit max length so add it now
+            lines.add(aLine);
+        }
+        return lines;
+    }
+
+    public static String[] splitIntoLine(String input, int maxCharInLine) {
+        // https://stackoverflow.com/questions/7528045/large-string-split-into-lines-with-maximum-length-in-java
+        // better than spell.getInfo().split("(?<=\\G.{25})")
+        StringTokenizer tok = new StringTokenizer(input, " ");
+        StringBuilder output = new StringBuilder(input.length());
+        int lineLen = 0;
+        while (tok.hasMoreTokens()) {
+            String word = tok.nextToken();
+            while (word.length() > maxCharInLine) {
+                if (maxCharInLine - lineLen < 0) {
+                    break;
+                }
+                output.append(word.substring(0, maxCharInLine - lineLen) + "\n");
+                word = word.substring(maxCharInLine - lineLen);
+                lineLen = 0;
+            }
+            if (lineLen + word.length() > maxCharInLine) {
+                output.append("\n");
+                lineLen = 0;
+            }
+            output.append(word + " ");
+            lineLen += word.length() + 1;
+        }
+        return output.toString().split("\n");
+    }
+
+    public static String getDirectionsString(ICommandSender player, BlockPos pos) {
+        //https://github.com/LothrazarMinecraftMods/MinecraftSearchCommands/blob/master/src/main/java/com/lothrazar/searchcommands/command/CommandSearchItem.java
+        int x = pos.getX();
+        int y = pos.getY();
+        int z = pos.getZ();
+        int xDist, yDist, zDist;
+        xDist = player.getPosition().getX() - x;
+        yDist = player.getPosition().getY() - y;
+        zDist = player.getPosition().getZ() - z;
+        //in terms of directon copmass:
+        //North is -z;  south is +z
+        //east is +x, west is -x
+        //so for Distances:
+        boolean isNorth = (zDist > 0);
+        boolean isSouth = (zDist < 0);
+        boolean isWest = (xDist > 0);
+        boolean isEast = (xDist < 0);
+        boolean isUp = (yDist < 0);
+        boolean isDown = (zDist > 0);
+        String xStr = "";
+        String yStr = "";
+        String zStr = "";
+        if (isWest)
+            xStr = Math.abs(xDist) + " west ";
+        if (isEast)
+            xStr = Math.abs(xDist) + " east ";
+        if (isNorth)
+            zStr = Math.abs(zDist) + " north ";
+        if (isSouth)
+            zStr = Math.abs(zDist) + " south ";
+        if (isUp)
+            yStr = Math.abs(yDist) + " up ";
+        if (isDown)
+            yStr = Math.abs(yDist) + " down ";
+        return xStr + yStr + zStr;
+    }
+
+    public static void sendStatusMessage(EntityPlayer player, String string) {
+        player.sendStatusMessage(new TextComponentTranslation(string), true);
+    }
+
+    public static String formatSecondsToMinutes(int secontsTotal) {
+        if (secontsTotal < 0) {
+            return "";
+        }
+        int minutes = secontsTotal / 60;
+        int secs = secontsTotal % 60;
+        return minutes + ":" + String.format("%02d", secs);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/properties/EnumType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumType.java	(date 1525606872000)
+++ src/main/java/net/hdt/neutronia/properties/EnumType.java	(date 1525606872000)
@@ -0,0 +1,38 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumType implements IStringSerializable {
+
+    NORMAL(0, "normal"),
+    HYDROUS(1, "hydrous"),
+    SALTY(2, "salty"),
+    STARRY(3, "starry"),
+    BARREN(4, "barren");
+
+    private int ID;
+    private String name;
+
+    EnumType(int ID, String name) {
+        this.ID = ID;
+        this.name = name;
+    }
+
+    public static EnumType fromMeta(int meta) {
+        if (meta < 0 || meta >= values().length) {
+            meta = 0;
+        }
+
+        return values()[meta];
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/generators/StoneInfoBasedGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/generators/StoneInfoBasedGenerator.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/world/gen/generators/StoneInfoBasedGenerator.java	(date 1525606899000)
@@ -0,0 +1,99 @@
+package net.hdt.neutronia.world.gen.generators;
+
+import net.hdt.neutronia.world.utils.StoneInfo;
+import net.hdt.neutronia.world.utils.handlers.BiomeTypeConfigHandler;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+
+import java.util.Random;
+import java.util.function.Supplier;
+
+public class StoneInfoBasedGenerator extends MultiChunkFeatureGenerator {
+
+    public Supplier<StoneInfo> infoSupplier;
+    public String name;
+
+    IBlockState state;
+    long seedXor;
+
+    public StoneInfoBasedGenerator(Supplier<StoneInfo> infoSupplier, IBlockState state, String name) {
+        this.infoSupplier = infoSupplier;
+        this.name = name;
+
+        this.state = state;
+        seedXor = name.hashCode();
+    }
+
+    @Override
+    public boolean canGenerate(World world, int chunkX, int chunkZ) {
+        StoneInfo info = infoSupplier.get();
+        return info.enabled && info.dims.canSpawnHere(world);
+    }
+
+    public boolean canGenerateInBiome(Biome b) {
+        return BiomeTypeConfigHandler.biomeTypeIntersectCheck(infoSupplier.get().allowedBiomes, b);
+    }
+
+    @Override
+    public boolean isSourceValid(World world, BlockPos pos) {
+        return canGenerateInBiome(world.getBiome(pos));
+    }
+
+    @Override
+    public long modifyWorldSeed(long seed) {
+        return seed ^ seedXor;
+    }
+
+    @Override
+    public int getFeatureRadius() {
+        StoneInfo info = infoSupplier.get();
+        return info.clusterSize;
+    }
+
+    @Override
+    public void generateChunkPart(BlockPos src, Random random, int chunkX, int chunkZ, World world) {
+        StoneInfo info = infoSupplier.get();
+        forEachChunkBlock(chunkX, chunkZ, info.lowerBound - info.clusterSize, info.upperBound + info.clusterSize, (pos) -> {
+            if (canPlaceBlock(world, pos) && pos.distanceSq(src) < (info.clusterSize * info.clusterSize))
+                world.setBlockState(pos, state, 0);
+        });
+    }
+
+    public boolean canPlaceBlock(World world, BlockPos pos) {
+        return world.getBlockState(pos).getBlock() == Blocks.STONE;
+    }
+
+    @Override
+    public BlockPos[] getSourcesInChunk(Random random, int chunkX, int chunkZ, World world) {
+        StoneInfo info = infoSupplier.get();
+        int chance = info.clusterRarity;
+        int amount = 1;
+
+        if (info.clustersRarityPerChunk) {
+            chance = 1;
+            amount = info.clusterRarity;
+        }
+
+        BlockPos[] sources;
+        if (chance > 0 && random.nextInt(chance) == 0) {
+            sources = new BlockPos[amount];
+            int lower = Math.abs(info.lowerBound);
+            int range = Math.abs(info.upperBound - info.lowerBound);
+
+            for (int i = 0; i < amount && range > 0; i++) {
+                int x = chunkX * 16 + random.nextInt(16) + 8;
+                int y = random.nextInt(range) + lower;
+                int z = chunkZ * 16 + random.nextInt(16) + 8;
+
+                BlockPos pos = new BlockPos(x, y, z);
+                sources[i] = pos;
+            }
+        } else sources = new BlockPos[0];
+
+        return sources;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedClayTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedClayTiles.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockStainedClayTiles.java	(date 1525606884000)
@@ -0,0 +1,50 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [19/03/2016, 01:43:43 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockStainedClayTiles extends BlockMetaVariants implements IModBlock {
+
+    public BlockStainedClayTiles() {
+        super("stained_clay_tiles", MOD_ID, Material.ROCK, Variants.class);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        STAINED_CLAY_TILES_WHITE,
+        STAINED_CLAY_TILES_ORANGE,
+        STAINED_CLAY_TILES_MAGENTA,
+        STAINED_CLAY_TILES_LIGHT_BLUE,
+        STAINED_CLAY_TILES_YELLOW,
+        STAINED_CLAY_TILES_LIME,
+        STAINED_CLAY_TILES_PINK,
+        STAINED_CLAY_TILES_GRAY,
+        STAINED_CLAY_TILES_SILVER,
+        STAINED_CLAY_TILES_CYAN,
+        STAINED_CLAY_TILES_PURPLE,
+        STAINED_CLAY_TILES_BLUE,
+        STAINED_CLAY_TILES_BROWN,
+        STAINED_CLAY_TILES_GREEN,
+        STAINED_CLAY_TILES_RED,
+        STAINED_CLAY_TILES_BLACK
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/ai/EntityAiShootTridentAtPlayer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/EntityAiShootTridentAtPlayer.java	(date 1523986193000)
+++ src/main/java/net/hdt/neutronia/entity/ai/EntityAiShootTridentAtPlayer.java	(date 1523986193000)
@@ -0,0 +1,4 @@
+package net.hdt.neutronia.entity.ai;
+
+public class EntityAiShootTridentAtPlayer {
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSoulSandstone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSoulSandstone.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSoulSandstone.java	(date 1525606886000)
@@ -0,0 +1,24 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockSoulSandstone extends BlockMetaVariants implements IModBlock {
+
+    public BlockSoulSandstone() {
+        super("soul_sandstone", MOD_ID, Material.ROCK, Variants.class);
+        setHardness(1F);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        SOUL_SANDSTONE,
+        CHISELED_SOUL_SANDSTONE,
+        SMOOTH_SOUL_SANDSTONE
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/EntityLostMiner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityLostMiner.java	(date 1525362241000)
+++ src/main/java/net/hdt/neutronia/entity/EntityLostMiner.java	(date 1525362241000)
@@ -0,0 +1,265 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.init.HMItems;
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EnumCreatureAttribute;
+import net.minecraft.entity.IEntityLivingData;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.EntityAIBreakDoor;
+import net.minecraft.entity.ai.EntityAIHurtByTarget;
+import net.minecraft.entity.ai.attributes.AttributeModifier;
+import net.minecraft.entity.monster.EntityCreeper;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNavigateGround;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Calendar;
+
+public class EntityLostMiner extends EntityUndeadBase {
+
+    public static final DataParameter<Boolean> ARMS_RAISED = EntityDataManager.createKey(EntityLostMiner.class, DataSerializers.BOOLEAN);
+    private final EntityAIBreakDoor breakDoor = new EntityAIBreakDoor(this);
+    private boolean isBreakDoorsTaskSet;
+
+    private float minerWidth = -1.0F;
+    private float minerHeight;
+
+    public EntityLostMiner(World worldIn) {
+        super(worldIn);
+        this.setSize(0.6F, 1.95F);
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.applyEntityAI();
+    }
+
+    protected void applyEntityAI() {
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+    }
+
+    @Override
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
+        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(2.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(10.0D);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.getDataManager().register(ARMS_RAISED, Boolean.FALSE);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean isArmsRaised() {
+        return this.getDataManager().get(ARMS_RAISED);
+    }
+
+    public void setArmsRaised(boolean armsRaised) {
+        this.getDataManager().set(ARMS_RAISED, armsRaised);
+    }
+
+    public boolean isBreakDoorsTaskSet() {
+        return this.isBreakDoorsTaskSet;
+    }
+
+    public void setBreakDoorAItask(boolean enabled) {
+        if (this.isBreakDoorsTaskSet != enabled) {
+            this.isBreakDoorsTaskSet = enabled;
+            ((PathNavigateGround) this.getNavigator()).setBreakDoors(enabled);
+
+            if (enabled)
+                this.tasks.addTask(1, this.breakDoor);
+            else
+                this.tasks.removeTask(this.breakDoor);
+        }
+    }
+
+    @Override
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        return super.attackEntityFrom(source, amount);
+    }
+
+    @Override
+    public boolean attackEntityAsMob(Entity entityIn) {
+        boolean flag = super.attackEntityAsMob(entityIn);
+
+        if (flag) {
+            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
+
+            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
+                entityIn.setFire(2 * (int) f);
+        }
+        return flag;
+    }
+
+    /**
+     * TODO: Change Sounds...
+     */
+    @Override
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_ZOMBIE_AMBIENT;
+    }
+
+    @Override
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_ZOMBIE_HURT;
+    }
+
+    @Override
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_ZOMBIE_DEATH;
+    }
+
+    // TODO ^
+
+    protected SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_STEP;
+    }
+
+    @Override
+    protected void playStepSound(BlockPos pos, Block blockIn) {
+        this.playSound(this.getStepSound(), 0.15F, 1.0F);
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.UNDEAD;
+    }
+
+    @Nullable
+    @Override
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.MUMMY;
+    }
+
+    @Override
+    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
+        super.setEquipmentBasedOnDifficulty(difficulty);
+
+        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
+            int i = this.rand.nextInt(3);
+
+            if (i == 0)
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(HMItems.ancientSword));
+            else
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(Item.getItemFromBlock(Blocks.SAND)));
+        }
+    }
+
+    @Override
+    public float getEyeHeight() {
+        float f = 1.74F;
+        if (this.isChild())
+            f = (float) ((double) f - 0.81D);
+        return f;
+    }
+
+    @Override
+    protected boolean canEquipItem(ItemStack stack) {
+        return stack.getItem() == HMItems.anchor;
+    }
+
+    @Override
+    public boolean getCanSpawnHere() {
+        return super.getCanSpawnHere() && this.world.getDifficulty() != EnumDifficulty.PEACEFUL && posY < 20;
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        if (!getCanSpawnHere())
+            despawnEntity();
+        else {
+            livingdata = super.onInitialSpawn(difficulty, livingdata);
+            float f = difficulty.getClampedAdditionalDifficulty();
+            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
+            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
+                Calendar calendar = this.world.getCurrentDate();
+                if (calendar.get(Calendar.MONTH) + 1 == 10 && calendar.get(Calendar.DATE) == 31 && this.rand.nextFloat() < 0.25F) {
+                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
+                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
+                }
+            }
+
+            this.setBreakDoorAItask(this.rand.nextFloat() < f * 0.1F);
+            this.setEquipmentBasedOnDifficulty(difficulty);
+            this.setEnchantmentBasedOnDifficulty(difficulty);
+
+            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
+            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
+
+            if (d0 > 1.0D)
+                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random miner-spawn bonus", d0, 2));
+
+            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader miner bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
+                this.setBreakDoorAItask(true);
+            }
+        }
+        return livingdata;
+    }
+
+    @Override
+    protected final void setSize(float width, float height) {
+        boolean flag = this.minerWidth > 0.0F && this.minerHeight > 0.0F;
+        this.minerWidth = width;
+        this.minerHeight = height;
+
+        if (!flag)
+            this.multiplySize(1.0f);
+    }
+
+    private void multiplySize(float size) {
+        super.setSize(this.minerWidth * size, this.minerHeight * size);
+    }
+
+    public double getYOffset() {
+        return this.isChild() ? 0.0D : -0.45D;
+    }
+
+    @Override
+    public void onDeath(DamageSource cause) {
+        super.onDeath(cause);
+
+        if (cause.getTrueSource() instanceof EntityCreeper) {
+            EntityCreeper entityCreeper = (EntityCreeper) cause.getTrueSource();
+
+            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
+                entityCreeper.incrementDroppedSkulls();
+                ItemStack itemStack = this.getSkullDrop();
+
+                if (!itemStack.isEmpty())
+                    this.entityDropItem(itemStack, 0.0F);
+            }
+        }
+    }
+
+    private ItemStack getSkullDrop() {
+        return new ItemStack(Items.SKULL, 1, 2);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSnowBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSnowBricks.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSnowBricks.java	(date 1525606884000)
@@ -0,0 +1,57 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [18/04/2016, 22:35:31 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.item.Item;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import java.util.Random;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockSnowBricks extends BlockMod implements IModBlock {
+
+    public BlockSnowBricks() {
+        super(Material.CRAFTED_SNOW, MOD_ID, "snow_bricks");
+        setHardness(0.2F);
+        setSoundType(SoundType.SNOW);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public boolean isToolEffective(String type, IBlockState state) {
+        return type.equals("shovel");
+    }
+
+    @Override
+    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player) {
+        return true;
+    }
+
+    @Override
+    public int quantityDropped(Random random) {
+        return 1;
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/base/armors/ArmorBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/armors/ArmorBase.java	(date 1523986180000)
+++ src/main/java/net/hdt/neutronia/items/base/armors/ArmorBase.java	(date 1523986180000)
@@ -0,0 +1,14 @@
+package net.hdt.neutronia.items.base.armors;
+
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.ItemArmor;
+
+public class ArmorBase extends ItemArmor {
+    public ArmorBase(String name, ArmorMaterial materialIn, int renderIndexIn, EntityEquipmentSlot equipmentSlotIn) {
+        super(materialIn, renderIndexIn, equipmentSlotIn);
+        setUnlocalizedName(name);
+        setRegistryName(name);
+        setCreativeTab(CreativeTabs.COMBAT);
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSandyBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSandyBricks.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockSandyBricks.java	(date 1525606885000)
@@ -0,0 +1,31 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:38:50 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockSandyBricks extends BlockMod implements IModBlock {
+
+    public BlockSandyBricks() {
+        super(Material.ROCK, MOD_ID, "sandy_bricks");
+        setHardness(2.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockReed.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockReed.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockReed.java	(date 1525606886000)
@@ -0,0 +1,27 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 23:35:53 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.blocks.base.BlockModPillar;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockReed extends BlockModPillar {
+
+    public BlockReed() {
+        super("reed_block", Material.WOOD);
+        setHardness(0.5F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeFrozenMesa.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeFrozenMesa.java	(date 1525606894000)
+++ src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeFrozenMesa.java	(date 1525606894000)
@@ -0,0 +1,285 @@
+package net.hdt.neutronia.world.biome.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.item.EnumDyeColor;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.BiomeDecorator;
+import net.minecraft.world.chunk.ChunkPrimer;
+import net.minecraft.world.gen.NoiseGeneratorPerlin;
+import net.minecraft.world.gen.feature.WorldGenAbstractTree;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import java.util.Arrays;
+import java.util.Random;
+
+public class BiomeFrozenMesa extends Biome {
+    protected static final IBlockState STONE = HMBlocks.frostedStones[0].getDefaultState();
+    protected static final IBlockState COARSE_DIRT = HMBlocks.frostedDirts[1].getDefaultState();
+    protected static final IBlockState GRASS = HMBlocks.frostedDirts[7].getDefaultState();
+    protected static final IBlockState HARDENED_CLAY = HMBlocks.frostedStones[5].getDefaultState();
+    protected static final IBlockState ORANGE_STAINED_HARDENED_CLAY = HMBlocks.frostedClay[EnumDyeColor.ORANGE.getMetadata()].getDefaultState();
+    protected static final IBlockState RED_SAND = HMBlocks.frostedDirts[9].getDefaultState();
+    private static Random rnd = new Random();
+    protected static final IBlockState STAINED_HARDENED_CLAY = HMBlocks.frostedClay[rnd.nextInt(16)].getDefaultState();
+    private final boolean brycePillars;
+    private final boolean hasForest;
+    private IBlockState[] clayBands;
+    private long worldSeed;
+    private NoiseGeneratorPerlin pillarNoise;
+    private NoiseGeneratorPerlin pillarRoofNoise;
+    private NoiseGeneratorPerlin clayBandsOffsetNoise;
+
+    public BiomeFrozenMesa(boolean p_i46704_1_, boolean p_i46704_2_, Biome.BiomeProperties properties) {
+        super(properties);
+        this.brycePillars = p_i46704_1_;
+        this.hasForest = p_i46704_2_;
+        this.spawnableCreatureList.clear();
+        this.topBlock = RED_SAND;
+        this.fillerBlock = STAINED_HARDENED_CLAY;
+        this.decorator.treesPerChunk = -999;
+        this.decorator.deadBushPerChunk = 20;
+        this.decorator.reedsPerChunk = 3;
+        this.decorator.cactiPerChunk = 5;
+        this.decorator.flowersPerChunk = 0;
+        this.spawnableCreatureList.clear();
+
+        if (p_i46704_2_) {
+            this.decorator.treesPerChunk = 5;
+        }
+    }
+
+    /**
+     * Allocate a new BiomeDecorator for this BiomeGenBase
+     */
+    public BiomeDecorator createBiomeDecorator() {
+        return new BiomeFrozenMesa.Decorator();
+    }
+
+    public WorldGenAbstractTree getRandomTreeFeature(Random rand) {
+        return TREE_FEATURE;
+    }
+
+    public void genTerrainBlocks(World worldIn, Random rand, ChunkPrimer chunkPrimerIn, int x, int z, double noiseVal) {
+        if (this.clayBands == null || this.worldSeed != worldIn.getSeed()) {
+            this.generateBands(worldIn.getSeed());
+        }
+
+        if (this.pillarNoise == null || this.pillarRoofNoise == null || this.worldSeed != worldIn.getSeed()) {
+            Random random = new Random(this.worldSeed);
+            this.pillarNoise = new NoiseGeneratorPerlin(random, 4);
+            this.pillarRoofNoise = new NoiseGeneratorPerlin(random, 1);
+        }
+
+        this.worldSeed = worldIn.getSeed();
+        double d4 = 0.0D;
+
+        if (this.brycePillars) {
+            int i = (x & -16) + (z & 15);
+            int j = (z & -16) + (x & 15);
+            double d0 = Math.min(Math.abs(noiseVal), this.pillarNoise.getValue((double) i * 0.25D, (double) j * 0.25D));
+
+            if (d0 > 0.0D) {
+                double d1 = 0.001953125D;
+                double d2 = Math.abs(this.pillarRoofNoise.getValue((double) i * 0.001953125D, (double) j * 0.001953125D));
+                d4 = d0 * d0 * 2.5D;
+                double d3 = Math.ceil(d2 * 50.0D) + 14.0D;
+
+                if (d4 > d3) {
+                    d4 = d3;
+                }
+
+                d4 = d4 + 64.0D;
+            }
+        }
+
+        int k1 = x & 15;
+        int l1 = z & 15;
+        int i2 = worldIn.getSeaLevel();
+        IBlockState iblockstate = STAINED_HARDENED_CLAY;
+        IBlockState iblockstate3 = this.fillerBlock;
+        int k = (int) (noiseVal / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
+        boolean flag = Math.cos(noiseVal / 3.0D * Math.PI) > 0.0D;
+        int l = -1;
+        boolean flag1 = false;
+        int i1 = 0;
+
+        for (int j1 = 255; j1 >= 0; --j1) {
+            if (chunkPrimerIn.getBlockState(l1, j1, k1).getMaterial() == Material.AIR && j1 < (int) d4) {
+                chunkPrimerIn.setBlockState(l1, j1, k1, STONE);
+            }
+
+            if (j1 <= rand.nextInt(5)) {
+                chunkPrimerIn.setBlockState(l1, j1, k1, BEDROCK);
+            } else if (i1 < 15 || this.brycePillars) {
+                IBlockState iblockstate1 = chunkPrimerIn.getBlockState(l1, j1, k1);
+
+                if (iblockstate1.getMaterial() == Material.AIR) {
+                    l = -1;
+                } else if (iblockstate1.getBlock() == STONE) {
+                    if (l == -1) {
+                        flag1 = false;
+
+                        if (k <= 0) {
+                            iblockstate = AIR;
+                            iblockstate3 = STONE;
+                        } else if (j1 >= i2 - 4 && j1 <= i2 + 1) {
+                            iblockstate = STAINED_HARDENED_CLAY;
+                            iblockstate3 = this.fillerBlock;
+                        }
+
+                        if (j1 < i2 && (iblockstate == null || iblockstate.getMaterial() == Material.AIR)) {
+                            iblockstate = WATER;
+                        }
+
+                        l = k + Math.max(0, j1 - i2);
+
+                        if (j1 >= i2 - 1) {
+                            if (this.hasForest && j1 > 86 + k * 2) {
+                                if (flag) {
+                                    chunkPrimerIn.setBlockState(l1, j1, k1, COARSE_DIRT);
+                                } else {
+                                    chunkPrimerIn.setBlockState(l1, j1, k1, GRASS);
+                                }
+                            } else if (j1 > i2 + 3 + k) {
+                                IBlockState iblockstate2;
+
+                                if (j1 >= 64 && j1 <= 127) {
+                                    if (flag) {
+                                        iblockstate2 = HARDENED_CLAY;
+                                    } else {
+                                        iblockstate2 = this.getBand(x, j1, z);
+                                    }
+                                } else {
+                                    iblockstate2 = ORANGE_STAINED_HARDENED_CLAY;
+                                }
+
+                                chunkPrimerIn.setBlockState(l1, j1, k1, iblockstate2);
+                            } else {
+                                chunkPrimerIn.setBlockState(l1, j1, k1, this.topBlock);
+                                flag1 = true;
+                            }
+                        } else {
+                            chunkPrimerIn.setBlockState(l1, j1, k1, iblockstate3);
+
+                            if (iblockstate3.getBlock() == HARDENED_CLAY) {
+                                chunkPrimerIn.setBlockState(l1, j1, k1, ORANGE_STAINED_HARDENED_CLAY);
+                            }
+                        }
+                    } else if (l > 0) {
+                        --l;
+
+                        if (flag1) {
+                            chunkPrimerIn.setBlockState(l1, j1, k1, ORANGE_STAINED_HARDENED_CLAY);
+                        } else {
+                            chunkPrimerIn.setBlockState(l1, j1, k1, this.getBand(x, j1, z));
+                        }
+                    }
+
+                    ++i1;
+                }
+            }
+        }
+    }
+
+    public void generateBands(long p_150619_1_) {
+        this.clayBands = new IBlockState[64];
+        Arrays.fill(this.clayBands, HARDENED_CLAY);
+        Random random = new Random(p_150619_1_);
+        this.clayBandsOffsetNoise = new NoiseGeneratorPerlin(random, 1);
+
+        for (int l1 = 0; l1 < 64; ++l1) {
+            l1 += random.nextInt(5) + 1;
+
+            if (l1 < 64) {
+                this.clayBands[l1] = ORANGE_STAINED_HARDENED_CLAY;
+            }
+        }
+
+        int i2 = random.nextInt(4) + 2;
+
+        for (int i = 0; i < i2; ++i) {
+            int j = random.nextInt(3) + 1;
+            int k = random.nextInt(64);
+
+            for (int l = 0; k + l < 64 && l < j; ++l) {
+                this.clayBands[k + l] = HMBlocks.frostedClay[EnumDyeColor.YELLOW.getMetadata()].getDefaultState();
+            }
+        }
+
+        int j2 = random.nextInt(4) + 2;
+
+        for (int k2 = 0; k2 < j2; ++k2) {
+            int i3 = random.nextInt(3) + 2;
+            int l3 = random.nextInt(64);
+
+            for (int i1 = 0; l3 + i1 < 64 && i1 < i3; ++i1) {
+                this.clayBands[l3 + i1] = HMBlocks.frostedClay[EnumDyeColor.BROWN.getMetadata()].getDefaultState();
+            }
+        }
+
+        int l2 = random.nextInt(4) + 2;
+
+        for (int j3 = 0; j3 < l2; ++j3) {
+            int i4 = random.nextInt(3) + 1;
+            int k4 = random.nextInt(64);
+
+            for (int j1 = 0; k4 + j1 < 64 && j1 < i4; ++j1) {
+                this.clayBands[k4 + j1] = HMBlocks.frostedClay[EnumDyeColor.RED.getMetadata()].getDefaultState();
+            }
+        }
+
+        int k3 = random.nextInt(3) + 3;
+        int j4 = 0;
+
+        for (int l4 = 0; l4 < k3; ++l4) {
+            int i5 = 1;
+            j4 += random.nextInt(16) + 4;
+
+            for (int k1 = 0; j4 + k1 < 64 && k1 < 1; ++k1) {
+                this.clayBands[j4 + k1] = HMBlocks.frostedClay[EnumDyeColor.WHITE.getMetadata()].getDefaultState();
+
+                if (j4 + k1 > 1 && random.nextBoolean()) {
+                    this.clayBands[j4 + k1 - 1] = HMBlocks.frostedClay[EnumDyeColor.SILVER.getMetadata()].getDefaultState();
+                }
+
+                if (j4 + k1 < 63 && random.nextBoolean()) {
+                    this.clayBands[j4 + k1 + 1] = HMBlocks.frostedClay[EnumDyeColor.SILVER.getMetadata()].getDefaultState();
+                }
+            }
+        }
+    }
+
+    public IBlockState getBand(int p_180629_1_, int p_180629_2_, int p_180629_3_) {
+        int i = (int) Math.round(this.clayBandsOffsetNoise.getValue((double) p_180629_1_ / 512.0D, (double) p_180629_1_ / 512.0D) * 2.0D);
+        return this.clayBands[(p_180629_2_ + i + 64) % 64];
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getFoliageColorAtPos(BlockPos pos) {
+        return 10387789;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getGrassColorAtPos(BlockPos pos) {
+        return 9470285;
+    }
+
+    class Decorator extends BiomeDecorator {
+        private Decorator() {
+        }
+
+        /**
+         * Generates ores in the current chunk
+         */
+        protected void generateOres(World worldIn, Random random) {
+            super.generateOres(worldIn, random);
+            if (net.minecraftforge.event.terraingen.TerrainGen.generateOre(worldIn, random, goldGen, chunkPos, net.minecraftforge.event.terraingen.OreGenEvent.GenerateMinable.EventType.GOLD))
+                this.genStandardOre1(worldIn, random, 20, this.goldGen, 32, 80);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModFenceGate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModFenceGate.java	(date 1523987842000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModFenceGate.java	(date 1523987842000)
@@ -0,0 +1,81 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockFenceGate;
+import net.minecraft.block.BlockPlanks;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.util.ResourceLocation;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class BlockModFenceGate extends BlockFenceGate implements IModBlock {
+
+    private final String[] variants;
+    private final String bareName;
+
+    public BlockModFenceGate(String name) {
+        super(BlockPlanks.EnumType.DARK_OAK);
+
+        setHardness(3.0F);
+        setSoundType(SoundType.WOOD);
+
+        variants = new String[]{name};
+        bareName = name;
+
+        setUnlocalizedName(name);
+    }
+
+    @Override
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(new ItemModBlock(this, new ResourceLocation(getPrefix(), name)));
+        return this;
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[]{POWERED};
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockQuiltedWool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockQuiltedWool.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockQuiltedWool.java	(date 1525606880000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockQuiltedWool extends BlockMetaVariants implements IModBlock {
+
+    public BlockQuiltedWool() {
+        super("quilted_wool", MOD_ID, Material.CLOTH, Variants.class);
+        setHardness(0.8F);
+        setSoundType(SoundType.CLOTH);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        WOOL_QUILTED_WHITE,
+        WOOL_QUILTED_ORANGE,
+        WOOL_QUILTED_MAGENTA,
+        WOOL_QUILTED_LIGHT_BLUE,
+        WOOL_QUILTED_YELLOW,
+        WOOL_QUILTED_LIME,
+        WOOL_QUILTED_PINK,
+        WOOL_QUILTED_GRAY,
+        WOOL_QUILTED_SILVER,
+        WOOL_QUILTED_CYAN,
+        WOOL_QUILTED_PURPLE,
+        WOOL_QUILTED_BLUE,
+        WOOL_QUILTED_BROWN,
+        WOOL_QUILTED_GREEN,
+        WOOL_QUILTED_RED,
+        WOOL_QUILTED_BLACK
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureScatter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureScatter.java	(date 1525606894000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureScatter.java	(date 1525606894000)
@@ -0,0 +1,66 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.minecraft.block.BlockBush;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Random;
+
+public class FeatureScatter extends Feature {
+    private IBlockState blockToSpawn;
+    private IBlockState blockToTarget;
+    private Placement placement;
+
+    public FeatureScatter(IConfig config) {
+        super(config);
+        blockToSpawn = config.getBlock("blockToSpawn", Blocks.BARRIER.getDefaultState());
+        blockToTarget = config.getBlock("blockToTarget", Blocks.BARRIER.getDefaultState());
+        placement = config.getEnum("placement", Placement.class, Placement.ON_GROUND);
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        if (blockToSpawn.getBlock() == Blocks.BARRIER || blockToTarget.getBlock() == Blocks.BARRIER) {
+            return false;
+        }
+
+        for (int i = 0; i < 64; ++i) {
+            BlockPos newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(4) - rand.nextInt(4), rand.nextInt(8) - rand.nextInt(8));
+
+            if (world.isAirBlock(newPos) && world.getBlockState(newPos.down()) == blockToTarget) {
+                if (blockToSpawn instanceof BlockBush) {
+                    if (((BlockBush) blockToSpawn).canBlockStay(world, placement.offsetPos(pos), blockToSpawn)) {
+                        world.setBlockState(placement.offsetPos(newPos), blockToSpawn, 2);
+                    }
+                } else {
+                    world.setBlockState(placement.offsetPos(newPos), blockToSpawn, 2);
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public enum Placement {
+        ON_GROUND(null),
+        IN_GROUND(EnumFacing.DOWN);
+
+        EnumFacing offset;
+
+        Placement(EnumFacing offsetIn) {
+            offset = offsetIn;
+        }
+
+        public BlockPos offsetPos(BlockPos pos) {
+            if (offset != null) {
+                return pos.offset(offset);
+            } else {
+                return pos;
+            }
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomFire.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomFire.java	(date 1523986169000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenRandomFire.java	(date 1523986169000)
@@ -0,0 +1,24 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenRandomFire extends WorldGenerator {
+    public WorldGenRandomFire() {
+        super(true);
+    }
+
+    public boolean generate(World worldIn, Random rand, BlockPos position) {
+        if (worldIn.getBlockState(position.down()).getBlock() == Blocks.DIRT) {
+            worldIn.setBlockState(position.down(), Blocks.NETHERRACK.getDefaultState());
+            worldIn.setBlockState(position, Blocks.FIRE.getDefaultState());
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedStone.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedStone.java	(date 1525606878000)
@@ -0,0 +1,31 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/03/2016, 18:21:37 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockPolishedStone extends BlockMod implements IModBlock {
+
+    public BlockPolishedStone() {
+        super(Material.ROCK, MOD_ID, "polished_stone");
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedNetherrack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedNetherrack.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockPolishedNetherrack.java	(date 1525606883000)
@@ -0,0 +1,28 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockPolishedNetherrack extends BlockMetaVariants implements IModBlock {
+
+    public BlockPolishedNetherrack() {
+        super("polished_netherrack", MOD_ID, Material.ROCK, Variants.class);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+
+        POLISHED_NETHERRACK,
+        POLISHED_NETHERRACK_BRICKS
+
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/VerticalWoodPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/VerticalWoodPlanks.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/VerticalWoodPlanks.java	(date 1525606902000)
@@ -0,0 +1,63 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockVerticalPlanks;
+import net.hdt.neutronia.modules.building.blocks.BlockVerticalStainedPlanks;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.oredict.OreDictionary;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.ModuleLoader;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class VerticalWoodPlanks extends Feature {
+
+    public static Block vertical_planks;
+    public static Block vertical_stained_planks;
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        vertical_planks = new BlockVerticalPlanks();
+
+		/*for(int i = 0; i < 6; i++) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(vertical_planks, 3, i),
+					"W", "W", "W",
+					'W', ProxyRegistry.newStack(Blocks.PLANKS, 1, i));
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(Blocks.PLANKS, 3, i),
+					"W", "W", "W",
+					'W', ProxyRegistry.newStack(vertical_planks, 1, i));		
+		}*/
+
+        if (ModuleLoader.isFeatureEnabled(StainedPlanks.class))
+            vertical_stained_planks = new BlockVerticalStainedPlanks();
+    }
+
+    @Override
+    public void postPreInit(FMLPreInitializationEvent event) {
+		/*if(ModuleLoader.isFeatureEnabled(StainedPlanks.class))
+			for(int i = 0; i < 16; i++) {
+				RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(vertical_stained_planks, 3, i),
+						"W", "W", "W",
+						'W', ProxyRegistry.newStack(StainedPlanks.stained_planks, 1, i));
+				RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(StainedPlanks.stained_planks, 3, i),
+						"W", "W", "W",
+						'W', ProxyRegistry.newStack(vertical_stained_planks, 1, i));		
+			}*/
+    }
+
+    @Override
+    public void init(FMLInitializationEvent event) {
+        OreDictionary.registerOre("plankWood", ProxyRegistry.newStack(vertical_planks, 1, OreDictionary.WILDCARD_VALUE));
+
+        if (ModuleLoader.isFeatureEnabled(StainedPlanks.class)) {
+            OreDictionary.registerOre("plankWood", ProxyRegistry.newStack(vertical_stained_planks, 1, OreDictionary.WILDCARD_VALUE));
+            OreDictionary.registerOre("plankStained", ProxyRegistry.newStack(vertical_stained_planks, 1, OreDictionary.WILDCARD_VALUE));
+        }
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/biome/BiomeWrapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/BiomeWrapper.java	(date 1525606903000)
+++ src/main/java/net/hdt/neutronia/world/biome/BiomeWrapper.java	(date 1525606903000)
@@ -0,0 +1,188 @@
+/*
+ * LibEx
+ * Copyright (c) 2017-2018 by MineEx
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package net.hdt.neutronia.world.biome;
+
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.hdt.neutronia.api.config.IConfig;
+import net.hdt.neutronia.api.world.biome.IBiomeWrapper;
+import net.hdt.neutronia.api.world.gen.feature.IFeature;
+import net.hdt.neutronia.world.gen.GenerationStage;
+import net.hdt.neutronia.world.gen.feature.FeatureRegistry;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.biome.Biome;
+import net.minecraftforge.fml.common.registry.EntityEntry;
+import net.minecraftforge.fml.common.registry.EntityRegistry;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+
+import java.util.*;
+
+public class BiomeWrapper implements IBiomeWrapper {
+    protected Biome biome;
+    protected int weight;
+    protected Map<String, IBlockState> blocks = new HashMap<>();
+    protected Map<GenerationStage, List<IFeature>> generationStageFeatures = new HashMap<>();
+    protected Map<EnumCreatureType, List<Biome.SpawnListEntry>> spawnableMobs = new HashMap<>();
+    protected boolean enabled;
+    protected boolean genDefaultFeatures;
+    protected IConfig config;
+
+    public BiomeWrapper(IConfig configIn) {
+        config = configIn;
+        parse();
+    }
+
+    private void parse() {
+        biome = ForgeRegistries.BIOMES.getValue(config.getResource("biome"));
+        weight = config.getInt("weight", 10);
+        IConfig blockConfig = config.getSubConfig("blocks", new JsonObject());
+        blockConfig.getBlock("topBlock", biome.topBlock);
+        blockConfig.getBlock("fillerBlock", biome.fillerBlock);
+
+        for (Map.Entry<String, JsonElement> entry : blockConfig.getElements().entrySet()) {
+            if (blockConfig.getBlock(entry.getKey()) != null) {
+                blocks.put(entry.getKey(), blockConfig.getBlock(entry.getKey()));
+            }
+        }
+
+        List<IConfig> entityConfigs = config.getSubConfigs("entities", new ArrayList<>());
+        List<JsonObject> entityObjects = new ArrayList<>();
+
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            entryLoop:
+            for (Biome.SpawnListEntry entry : biome.getSpawnableList(creatureType)) {
+                ResourceLocation entityName = ForgeRegistries.ENTITIES.getKey(EntityRegistry.getEntry(entry.entityClass));
+                boolean containsEntry = false;
+
+                Iterator<IConfig> configIter = entityConfigs.iterator();
+
+                while (configIter.hasNext()) {
+                    IConfig entityConfig = configIter.next();
+
+                    if (entityName != null && entityConfig.getString("entity").equals(entityName.toString())) {
+                        containsEntry = true;
+                    }
+
+                    entityObjects.add(entityConfig.compose().getAsJsonObject());
+                    configIter.remove();
+
+                    if (containsEntry) {
+                        continue entryLoop;
+                    }
+                }
+
+                JsonObject entityObject = new JsonObject();
+                entityObject.addProperty("entity", ForgeRegistries.ENTITIES.getKey(EntityRegistry.getEntry(entry.entityClass)).toString());
+                entityObject.addProperty("creatureType", creatureType.toString().toLowerCase());
+                entityObject.addProperty("weight", entry.itemWeight);
+                entityObject.addProperty("minGroupCount", entry.minGroupCount);
+                entityObject.addProperty("maxGroupCount", entry.maxGroupCount);
+                entityObject.addProperty("spawn", true);
+                entityObjects.add(entityObject);
+            }
+        }
+
+        config.remove("entities");
+        entityConfigs = config.getSubConfigs("entities", entityObjects);
+
+        for (IConfig entityConfig : entityConfigs) {
+            EntityEntry entry = ForgeRegistries.ENTITIES.getValue(entityConfig.getResource("entity"));
+
+            if (entry != null && entityConfig.getBoolean("spawn", true)) {
+                Class<? extends Entity> entityCls = entry.getEntityClass();
+                EnumCreatureType creatureType = entityConfig.getEnum("creatureType", EnumCreatureType.class);
+
+                if (EntityLiving.class.isAssignableFrom(entityCls)) {
+                    spawnableMobs.computeIfAbsent(creatureType, k -> new ArrayList<>()).add(new Biome.SpawnListEntry((Class<? extends EntityLiving>) entityCls, entityConfig.getInt("weight", 10), entityConfig.getInt("minGroupCount", 1), entityConfig.getInt("maxGroupCount", 4)));
+                }
+            }
+        }
+
+        List<IConfig> featureConfigs = config.getSubConfigs("features", new ArrayList<>());
+        List<JsonObject> featureObjects = new ArrayList<>();
+
+        for (IConfig featureConfig : featureConfigs) {
+            IFeature feature = FeatureRegistry.createFeature(featureConfig.getResource("feature"), featureConfig);
+            GenerationStage generationStage = featureConfig.getEnum("genStage", GenerationStage.class, GenerationStage.POST_DECORATE);
+
+            if (feature != null && featureConfig.getBoolean("generate", true)) {
+                generationStageFeatures.computeIfAbsent(generationStage, k -> new ArrayList<>()).add(feature);
+            }
+
+            featureObjects.add(featureConfig.compose().getAsJsonObject());
+        }
+
+        config.remove("features");
+        config.getSubConfigs("features", featureObjects);
+        enabled = config.getBoolean("enabled", true);
+        genDefaultFeatures = config.getBoolean("genDefaultFeatures", true);
+    }
+
+    @Override
+    public Biome getBiome() {
+        return biome;
+    }
+
+    @Override
+    public IBlockState getBlock(String key, IBlockState fallbackValue) {
+        IBlockState value = getBlock(key);
+
+        if (value == null) {
+            config.getSubConfig("blocks").getBlock(key, fallbackValue);
+            blocks.put(key, fallbackValue);
+            return fallbackValue;
+        }
+
+        return value;
+    }
+
+    @Override
+    public IBlockState getBlock(String key) {
+        return blocks.get(key);
+    }
+
+    @Override
+    public List<IBlockState> getBlocks() {
+        return ImmutableList.copyOf(blocks.values());
+    }
+
+    @Override
+    public List<IFeature> getFeatures(GenerationStage generationStage) {
+        return ImmutableList.copyOf(generationStageFeatures.computeIfAbsent(generationStage, k -> new ArrayList<>()));
+    }
+
+    @Override
+    public List<Biome.SpawnListEntry> getSpawnableMobs(EnumCreatureType creatureType) {
+        return ImmutableList.copyOf(spawnableMobs.computeIfAbsent(creatureType, k -> new ArrayList<>()));
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public boolean shouldGenDefaultFeatures() {
+        return genDefaultFeatures;
+    }
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumNaturalAquamarineVariants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumNaturalAquamarineVariants.java	(date 1524921447000)
+++ src/main/java/net/hdt/neutronia/properties/EnumNaturalAquamarineVariants.java	(date 1524921447000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumNaturalAquamarineVariants implements IStringSerializable {
+
+    BRICKS(0, "natural_aquamarine_bricks"),
+    CHISELED(0, "natural_chiseled_aquamarine"),
+    RAW(0, "raw_natural_aquamarine"),
+    SMALL_BRICKS(0, "small_natural_aquamarine_bricks"),
+    SMOOTH(0, "natural_smooth_aquamarine");
+
+    private String name;
+    private int ID;
+
+    EnumNaturalAquamarineVariants(int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+    }
+
+    public int getID() {
+        return ID;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/VanillaWalls.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/VanillaWalls.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/VanillaWalls.java	(date 1525606899000)
@@ -0,0 +1,81 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/03/2016, 15:37:23 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.blocks.base.BlockModWall;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+
+public class VanillaWalls extends Feature {
+
+    boolean stone, granite, diorite, andesite, sandstone, redSandstone, stoneBricks, bricks, quartz, prismarine, prismarineBricks, darkPrismarine, purpurBlock, endBricks;
+
+    public static void add(String name, Block block, int meta, boolean doit) {
+        add(name, block, meta, doit, (wallName, state) -> new BlockModWall(wallName, state));
+    }
+
+    public static void add(String name, Block block, int meta, boolean doit, WallSupplier supplier) {
+        if (!doit)
+            return;
+
+        IBlockState state = block.getStateFromMeta(meta);
+        String wallName = name + "_wall";
+        BlockModWall.initWall(block, meta, supplier.supply(wallName, state));
+    }
+
+    @Override
+    public void setupConfig() {
+        stone = loadPropBool("Stone", "", true);
+        granite = loadPropBool("Granite", "", true);
+        diorite = loadPropBool("Diorite", "", true);
+        andesite = loadPropBool("Andesite", "", true);
+        sandstone = loadPropBool("Sandstone", "", true);
+        redSandstone = loadPropBool("Red Sandstone", "", true);
+        stoneBricks = loadPropBool("Stone Bricks", "", true);
+        bricks = loadPropBool("Bricks", "", true);
+        quartz = loadPropBool("Quartz", "", true);
+        prismarine = loadPropBool("Prismarine", "", true);
+        prismarineBricks = loadPropBool("Prismarine Bricks", "", true);
+        darkPrismarine = loadPropBool("Dark Prismarine", "", true);
+        purpurBlock = loadPropBool("Purpur", "", true);
+        endBricks = loadPropBool("End Bricks", "", true);
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        add("stone", Blocks.STONE, 0, stone);
+        add("stone_granite", Blocks.STONE, 1, granite);
+        add("stone_diorite", Blocks.STONE, 3, diorite);
+        add("stone_andesite", Blocks.STONE, 5, andesite);
+        add("sandstone", Blocks.SANDSTONE, 0, sandstone);
+        add("red_sandstone", Blocks.RED_SANDSTONE, 0, redSandstone);
+        add("stonebrick", Blocks.STONEBRICK, 0, stoneBricks);
+        add("brick", Blocks.BRICK_BLOCK, 0, bricks);
+        add("quartz", Blocks.QUARTZ_BLOCK, 0, quartz);
+        add("prismarine_rough", Blocks.PRISMARINE, 0, prismarine);
+        add("prismarine_bricks", Blocks.PRISMARINE, 1, prismarineBricks);
+        add("dark_prismarine", Blocks.PRISMARINE, 2, darkPrismarine);
+        add("purpur_block", Blocks.PURPUR_BLOCK, 0, purpurBlock);
+        add("end_bricks", Blocks.END_BRICKS, 0, endBricks);
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+    public interface WallSupplier {
+        BlockModWall supply(String wallName, IBlockState state);
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/gen/OreGen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/OreGen.java	(date 1525606894000)
+++ src/main/java/net/hdt/neutronia/world/gen/OreGen.java	(date 1525606894000)
@@ -0,0 +1,65 @@
+package net.hdt.neutronia.world.gen;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.IChunkGenerator;
+import net.minecraft.world.gen.feature.WorldGenMinable;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraftforge.fml.common.IWorldGenerator;
+
+import java.util.Random;
+
+public class OreGen implements IWorldGenerator {
+
+    // World Generators
+    private WorldGenerator marble;
+    private WorldGenerator basalt;
+    private WorldGenerator limestone;
+    private WorldGenerator meteorite;
+    private WorldGenerator fieryStone;
+    private WorldGenerator volcanicGlowRock;
+    private WorldGenerator volcanicRock;
+
+    public OreGen() {
+        marble = new WorldGenMinable(HMBlocks.newStoneVariants[13].getDefaultState(), 18);
+        basalt = new WorldGenMinable(HMBlocks.newStoneVariants[6].getDefaultState(), 30);
+        limestone = new WorldGenMinable(HMBlocks.newStoneVariants[20].getDefaultState(), 18);
+        meteorite = new WorldGenMinable(HMBlocks.newStoneVariants[27].getDefaultState(), 18);
+        fieryStone = new WorldGenMinable(HMBlocks.netherBlocks[0].getDefaultState(), 6);
+        volcanicGlowRock = new WorldGenMinable(HMBlocks.netherBlocks[1].getDefaultState(), 12);
+        volcanicRock = new WorldGenMinable(HMBlocks.netherBlocks[1].getDefaultState(), 12);
+    }
+
+    private void runGenerator(WorldGenerator generator, World world, Random rand, int chunk_X, int chunk_Z,
+                              int chancesToSpawn, int minHeight, int maxHeight) {
+        if (minHeight < 0 || maxHeight > 256 || minHeight > maxHeight)
+            throw new IllegalArgumentException("Illegal Height Arguments for WorldGenerator");
+
+        int heightDiff = maxHeight - minHeight + 1;
+        for (int i = 0; i < chancesToSpawn; i++) {
+            int x = chunk_X * 16 + rand.nextInt(16);
+            int y = minHeight + rand.nextInt(heightDiff);
+            int z = chunk_Z * 16 + rand.nextInt(16);
+            generator.generate(world, rand, new BlockPos(x, y, z));
+        }
+    }
+
+    @Override
+    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator,
+                         IChunkProvider chunkProvider) {
+        if (world.provider.getDimension() == -1) {
+            this.runGenerator(basalt, world, random, chunkX, chunkZ, 1, 0, 128);
+            this.runGenerator(fieryStone, world, random, chunkX, chunkZ, 1, 0, 128);
+            this.runGenerator(volcanicGlowRock, world, random, chunkX, chunkZ, 1, 0, 128);
+            this.runGenerator(volcanicRock, world, random, chunkX, chunkZ, 1, 0, 128);
+        }
+        if (world.provider.getDimension() == 0) {
+            this.runGenerator(marble, world, random, chunkX, chunkZ, 1, 0, 128);
+            this.runGenerator(meteorite, world, random, chunkX, chunkZ, 1, 0, 128);
+            this.runGenerator(limestone, world, random, chunkX, chunkZ, 1, 0, 128);
+        }
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenCustomStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenCustomStructure.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/world/gen/generators/WorldGenCustomStructure.java	(date 1525606895000)
@@ -0,0 +1,52 @@
+package net.hdt.neutronia.world.gen.generators;
+
+import net.hdt.neutronia.util.Reference;
+import net.hdt.neutronia.util.interfaces.IStructure;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.gen.structure.template.TemplateManager;
+
+import java.util.Random;
+
+public class WorldGenCustomStructure extends WorldGenerator implements IStructure {
+
+    private static String structureName;
+    private boolean isRuined = true;
+
+    public WorldGenCustomStructure(String name, int ruinedStage) {
+        structureName = name;
+        if (ruinedStage == 0) {
+            isRuined = false;
+        }
+    }
+
+    private static void generateStructure(World world, BlockPos pos) {
+        MinecraftServer mcServer = world.getMinecraftServer();
+        TemplateManager manager = worldServer.getStructureTemplateManager();
+        ResourceLocation location = new ResourceLocation(Reference.MOD_ID, structureName);
+        Template template = manager.get(mcServer, location);
+
+        if (template != null) {
+            IBlockState state = world.getBlockState(pos);
+            world.notifyBlockUpdate(pos, state, state, 3);
+            template.addBlocksToWorldChunk(world, pos, settings);
+        }
+
+        if (template == null) {
+            System.out.println("NO STRUCTURE");
+        }
+
+    }
+
+    @Override
+    public boolean generate(World worldIn, Random rand, BlockPos position) {
+        generateStructure(worldIn, position);
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/FishType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/FishType.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/properties/FishType.java	(date 1525606900000)
@@ -0,0 +1,145 @@
+package net.hdt.neutronia.properties;
+
+import com.google.common.collect.Maps;
+import net.hdt.neutronia.items.ItemFishFood;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+
+import java.util.Map;
+
+public enum FishType implements IStringSerializable {
+    COD(0, "cod", 2, 0.1F, 5, 0.6F),
+    SALMON(1, "salmon", 2, 0.1F, 6, 0.8F),
+    CLOWNFISH(2, "clownfish", 1, 0.1F),
+    PUFFERFISH(3, "pufferfish", 1, 0.1F);
+
+    /**
+     * Maps an item damage value for an ItemStack to the corresponding FishType value.
+     */
+    private static final Map<Integer, FishType> META_LOOKUP = Maps.newHashMap();
+
+    static {
+        for (FishType itemfishfood$fishtype : values()) {
+            META_LOOKUP.put(itemfishfood$fishtype.getMetadata(), itemfishfood$fishtype);
+        }
+    }
+
+    /**
+     * The item damage value on an ItemStack that represents this fish type
+     */
+    private final int meta;
+    /**
+     * The value that this fish type uses to replace "XYZ" in: "fish.XYZ.raw" / "fish.XYZ.cooked" for the
+     * unlocalized name and "fish_XYZ_raw" / "fish_XYZ_cooked" for the icon string.
+     */
+    private final String unlocalizedName;
+    /**
+     * The amount that eating the uncooked version of this fish should heal the player.
+     */
+    private final int uncookedHealAmount;
+    /**
+     * The saturation modifier to apply to the heal amount when the player eats the uncooked version of this fish.
+     */
+    private final float uncookedSaturationModifier;
+    /**
+     * The amount that eating the cooked version of this fish should heal the player.
+     */
+    private final int cookedHealAmount;
+    /**
+     * The saturation modifier to apply to the heal amount when the player eats the cooked version of this fish.
+     */
+    private final float cookedSaturationModifier;
+    /**
+     * Indicates whether this type of fish has "raw" and "cooked" variants
+     */
+    private final boolean cookable;
+
+    FishType(int meta, String unlocalizedName, int uncookedHeal, float uncookedSaturation, int cookedHeal, float cookedSaturation) {
+        this.meta = meta;
+        this.unlocalizedName = unlocalizedName;
+        this.uncookedHealAmount = uncookedHeal;
+        this.uncookedSaturationModifier = uncookedSaturation;
+        this.cookedHealAmount = cookedHeal;
+        this.cookedSaturationModifier = cookedSaturation;
+        this.cookable = true;
+    }
+
+    FishType(int meta, String unlocalizedName, int uncookedHeal, float uncookedSaturation) {
+        this.meta = meta;
+        this.unlocalizedName = unlocalizedName;
+        this.uncookedHealAmount = uncookedHeal;
+        this.uncookedSaturationModifier = uncookedSaturation;
+        this.cookedHealAmount = 0;
+        this.cookedSaturationModifier = 0.0F;
+        this.cookable = false;
+    }
+
+    /**
+     * Gets the corresponding FishType value for the given item damage value of an ItemStack, defaulting to COD for
+     * unrecognized damage values.
+     */
+    public static FishType byMetadata(int meta) {
+        FishType itemfishfood$fishtype = META_LOOKUP.get(meta);
+        return itemfishfood$fishtype == null ? COD : itemfishfood$fishtype;
+    }
+
+    /**
+     * Gets the FishType that corresponds to the given ItemStack, defaulting to COD if the given ItemStack does not
+     * actually contain a fish.
+     */
+    public static FishType byItemStack(ItemStack stack) {
+        return stack.getItem() instanceof ItemFishFood ? byMetadata(stack.getMetadata()) : COD;
+    }
+
+    /**
+     * Gets the item damage value on an ItemStack that represents this fish type
+     */
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    /**
+     * Gets the value that this fish type uses to replace "XYZ" in: "fish.XYZ.raw" / "fish.XYZ.cooked" for the
+     * unlocalized name and "fish_XYZ_raw" / "fish_XYZ_cooked" for the icon string.
+     */
+    public String getName() {
+        return this.unlocalizedName;
+    }
+
+    /**
+     * Gets the amount that eating the uncooked version of this fish should heal the player.
+     */
+    public int getUncookedHealAmount() {
+        return this.uncookedHealAmount;
+    }
+
+    /**
+     * Gets the saturation modifier to apply to the heal amount when the player eats the uncooked version of this
+     * fish.
+     */
+    public float getUncookedSaturationModifier() {
+        return this.uncookedSaturationModifier;
+    }
+
+    /**
+     * Gets the amount that eating the cooked version of this fish should heal the player.
+     */
+    public int getCookedHealAmount() {
+        return this.cookedHealAmount;
+    }
+
+    /**
+     * Gets the saturation modifier to apply to the heal amount when the player eats the cooked version of this
+     * fish.
+     */
+    public float getCookedSaturationModifier() {
+        return this.cookedSaturationModifier;
+    }
+
+    /**
+     * Gets a value indicating whether this type of fish has "raw" and "cooked" variants.
+     */
+    public boolean canCook() {
+        return this.cookable;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Biome.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Biome.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Biome.java	(date 1525606895000)
@@ -0,0 +1,166 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+
+/* Biome-style determination class */
+class Biome {
+
+    /* Detect Biome.Style by given set of blocks */
+    static Style detect(short[] blocks) {
+
+        /* Counts [0..SIZE] of each vanilla blocks */
+        double[] counts = new double[256];
+        for (short blockID : blocks) {
+            if (blockID >= 0 && blockID < 256) {
+                counts[blockID] += 1.0;
+            }
+        }
+
+        /* Frequency [0..1] of each vanilla block, exclusive air */
+        double[] frequency = new double[256];
+        double notAir = 1 + blocks.length - counts[0];
+        frequency[0] /= counts[0] / blocks.length;
+        for (int i = 1; i < 256; ++i) {
+            frequency[i] = counts[i] / notAir;
+        }
+
+        /* Affective blocks for each Biome.Style, except COMMON */
+        Block[] snow = new Block[]{Blocks.SNOW_LAYER, Blocks.SNOW, Blocks.ICE};
+        Block[] nether = new Block[]{Blocks.NETHERRACK, Blocks.SOUL_SAND, Blocks.NETHER_BRICK, Blocks.NETHER_BRICK_FENCE, Blocks.NETHER_BRICK_STAIRS, Blocks.OBSIDIAN};
+        Block[] sand = new Block[]{Blocks.SAND, Blocks.SANDSTONE, Blocks.SANDSTONE_STAIRS};
+        Block[] mushroom = new Block[]{Blocks.RED_MUSHROOM_BLOCK, Blocks.BROWN_MUSHROOM_BLOCK};
+        Block[] mesa = new Block[]{Blocks.STAINED_HARDENED_CLAY, Blocks.HARDENED_CLAY, Blocks.CLAY};
+        Block[] end = new Block[]{Blocks.END_STONE};
+        if (accumulate(snow, counts) > 8.5) return Style.SNOW;
+        if (accumulate(end, frequency) > 0.25) return Style.END;
+        if (accumulate(nether, frequency) > 0.25) return Style.NETHER;
+        if (accumulate(sand, frequency) > 0.25) return Style.SAND;
+        if (accumulate(mesa, frequency) > 0.25) return Style.MESA;
+        if (accumulate(mushroom, frequency) > 0.1) return Style.MUSHROOM;
+        return Style.COMMON;
+
+    }
+
+    /* Sum of blocks array values */
+    private static double accumulate(Block[] blocks, double[] array) {
+        double sum = 0;
+        for (Block block : blocks) {
+            sum += array[Block.getIdFromBlock(block)];
+        }
+        return sum;
+    }
+
+    private static boolean isBiomeSnow(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biome.getEnableSnow() ||
+                biomeName.contains("Frozen".toLowerCase()) ||
+                biomeName.contains("Ice".toLowerCase()) ||
+                biomeName.contains("Cold".toLowerCase()) ||
+                biomeName.contains("Alps".toLowerCase()) ||
+                biomeName.contains("Arctic".toLowerCase()) ||
+                biomeName.contains("Frost".toLowerCase()) ||
+                biomeName.contains("Icy".toLowerCase()) ||
+                biomeName.contains("Snow".toLowerCase()) ||
+                biomeName.contains("Coniferous".toLowerCase()) ||
+                biomeName.contains("Tundra".toLowerCase()) ||
+                biomeName.contains("Glacier".toLowerCase());
+    }
+
+    private static boolean isBiomeSand(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("Desert".toLowerCase()) ||
+                biomeName.contains("Canyon".toLowerCase()) ||
+                biomeName.contains("Dune".toLowerCase()) ||
+                biomeName.contains("Beach".toLowerCase()) ||
+                biomeName.contains("Mangrove".toLowerCase()) ||
+                biomeName.contains("Oasis".toLowerCase()) ||
+                biomeName.contains("Xeric".toLowerCase());
+    }
+
+    private static boolean isBiomeMesa(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("Mesa".toLowerCase()) ||
+                biomeName.contains("Badlands".toLowerCase()) ||
+                biomeName.contains("LushDesert".toLowerCase());
+    }
+
+    private static boolean isBiomeMushroom(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("Roofed".toLowerCase()) ||
+                biomeName.contains("Mushroom".toLowerCase()) ||
+                biomeName.contains("Fungi".toLowerCase());
+    }
+
+    private static boolean isBiomeWater(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("Ocean".toLowerCase()) ||
+                biomeName.contains("Coral".toLowerCase()) ||
+                biomeName.contains("Pond".toLowerCase()) ||
+                biomeName.contains("Kelp".toLowerCase()) ||
+                biomeName.contains("River".toLowerCase());
+    }
+
+    private static boolean isBiomeNether(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("Hell".toLowerCase()) ||
+                biomeName.contains("Bloody".toLowerCase()) ||
+                biomeName.contains("Boneyard".toLowerCase()) ||
+                biomeName.contains("Corrupted".toLowerCase()) ||
+                biomeName.contains("Inferno".toLowerCase()) ||
+                biomeName.contains("Chasm".toLowerCase()) ||
+                biomeName.contains("Undergarden".toLowerCase()) ||
+                biomeName.contains("Nether".toLowerCase());
+    }
+
+    private static boolean isBiomeEnd(net.minecraft.world.biome.Biome biome) {
+        String biomeName = biome.getBiomeName().toLowerCase().replace(" ", "");
+        return biomeName.contains("TheEnd".toLowerCase());
+    }
+
+    /* Determine Biome.Style by given BiomeGenBase */
+    static Style determine(net.minecraft.world.biome.Biome biome) {
+        if (isBiomeEnd(biome)) return Style.END;
+        if (isBiomeNether(biome)) return Style.NETHER;
+        if (isBiomeMesa(biome)) return Style.MESA;
+        if (isBiomeMushroom(biome)) return Style.MUSHROOM;
+        if (isBiomeSand(biome)) return Style.SAND;
+        if (isBiomeSnow(biome)) return Style.SNOW;
+        if (isBiomeWater(biome)) return Style.WATER;
+        return Style.COMMON;
+    }
+
+    /* Possible biome styles. Must completely cover all biomes */
+    enum Style {
+
+        COMMON(0x00, "COMMON"),
+        SNOW(0x01, "SNOW"),
+        NETHER(0x02, "NETHER"),
+        SAND(0x03, "SAND"),
+        MUSHROOM(0x04, "MUSHROOM"),
+        MESA(0x05, "MESA"),
+        END(0x07, "END"),
+        WATER(0x08, "WATER");
+
+        public final int value;
+        public final String name;
+
+        Style(int value, String name) {
+            this.value = value;
+            this.name = name;
+        }
+
+        /* Biome ID to Biome.Style */
+        public static Style valueOf(int value) {
+            for (Style sample : Style.values()) {
+                if (sample.value == value) {
+                    return sample;
+                }
+            }
+            return COMMON;
+        }
+
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/util/handlers/DimensionConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/handlers/DimensionConfig.java	(date 1525606901000)
+++ src/main/java/net/hdt/neutronia/util/handlers/DimensionConfig.java	(date 1525606901000)
@@ -0,0 +1,40 @@
+package net.hdt.neutronia.util.handlers;
+
+import net.minecraft.world.World;
+import net.minecraftforge.common.config.Configuration;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class DimensionConfig {
+
+    private static Configuration config;
+    private final boolean blacklist;
+    private final List<Integer> dims;
+
+    public DimensionConfig(String parent) {
+        this(parent, false, "0");
+    }
+
+    public DimensionConfig(String parent, String dimStr) {
+        this(parent, false, dimStr.split(","));
+    }
+
+    public DimensionConfig(String parent, boolean blacklist, String... defaultStrs) {
+        String category = parent + ".dimensions";
+        this.blacklist = config.getBoolean("Is Blacklist", category, blacklist, "");
+
+        String[] dimStrs = config.getStringList("Dimensions", category, defaultStrs, "");
+        dims = new ArrayList();
+        for (String s : dimStrs)
+            try {
+                dims.add(Integer.parseInt(s));
+            } catch (NumberFormatException e) {
+            }
+    }
+
+    public boolean canSpawnHere(World world) {
+        return dims.contains(world.provider.getDimension()) != blacklist;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/EntityDrownedVillager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityDrownedVillager.java	(date 1523987836000)
+++ src/main/java/net/hdt/neutronia/entity/EntityDrownedVillager.java	(date 1523987836000)
@@ -0,0 +1,271 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.IEntityLivingData;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.MobEffects;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.potion.PotionEffect;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumHand;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+import net.minecraftforge.fml.common.registry.VillagerRegistry;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.UUID;
+
+
+/**
+ * TODO: Fix Texture and Model
+ */
+public class EntityDrownedVillager extends EntityMummy {
+
+    private static final DataParameter<Boolean> CONVERTING = EntityDataManager.createKey(EntityDrownedVillager.class, DataSerializers.BOOLEAN);
+    private static final DataParameter<Integer> PROFESSION = EntityDataManager.createKey(EntityDrownedVillager.class, DataSerializers.VARINT);
+
+    private int conversionTime;
+    private UUID converstionStarter;
+    @Nullable
+    private VillagerRegistry.VillagerProfession prof;
+
+    public EntityDrownedVillager(World worldIn) {
+        super(worldIn);
+    }
+
+    public static void registerFixesMummyVillager(DataFixer fixer) {
+        EntityLiving.registerFixesMob(fixer, EntityDrownedVillager.class);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.dataManager.register(CONVERTING, Boolean.valueOf(false));
+        this.dataManager.register(PROFESSION, Integer.valueOf(0));
+    }
+
+    public int getProfession() {
+        return Math.max(this.dataManager.get(PROFESSION).intValue(), 0);
+    }
+
+    public void setProfession(int profession) {
+        this.dataManager.set(PROFESSION, Integer.valueOf(profession));
+    }
+
+    @Override
+    public void writeEntityToNBT(NBTTagCompound compound) {
+        super.writeEntityToNBT(compound);
+        compound.setInteger("Profession", this.getProfession());
+        compound.setString("ProfessionName", this.getForgeProfession().getRegistryName().toString());
+        compound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);
+
+        if (this.converstionStarter != null) {
+            compound.setUniqueId("ConversionStarter", this.converstionStarter);
+        }
+    }
+
+    @Override
+    public void readEntityFromNBT(NBTTagCompound compound) {
+        super.readEntityFromNBT(compound);
+        this.setProfession(compound.getInteger("Profession"));
+        if (compound.hasKey("ProfessionName")) {
+            VillagerRegistry.VillagerProfession p = ForgeRegistries.VILLAGER_PROFESSIONS.getValue(new ResourceLocation(compound.getString("ProfessionName")));
+            if (p == null) p = VillagerRegistry.FARMER;
+            this.setForgeProfession(p);
+        }
+
+        if (compound.hasKey("ConversionTime", 99) && compound.getInteger("ConversionTime") > -1) {
+            this.startConverting(compound.hasUniqueId("ConversionPlayer") ? compound.getUniqueId("ConversionPlayer") : null, compound.getInteger("ConversionTime"));
+        }
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        this.setProfession(this.world.rand.nextInt(6));
+        return super.onInitialSpawn(difficulty, livingdata);
+    }
+
+    @Override
+    public void onUpdate() {
+        if (!this.world.isRemote && this.isConverting()) {
+            int i = this.getConversionProgress();
+            this.conversionTime -= i;
+
+            if (this.conversionTime <= 0) {
+                this.finishConversion();
+            }
+        }
+        super.onUpdate();
+    }
+
+    @Override
+    protected boolean processInteract(EntityPlayer player, EnumHand hand) {
+        ItemStack itemstack = player.getHeldItem(hand);
+
+        if (itemstack.getItem() == Items.GOLDEN_APPLE && itemstack.getMetadata() == 0 && this.isPotionActive(MobEffects.WEAKNESS)) {
+            if (!player.capabilities.isCreativeMode) {
+                itemstack.shrink(1);
+            }
+
+            if (!this.world.isRemote) {
+                this.startConverting(player.getUniqueID(), this.rand.nextInt(2401) + 3600);
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected boolean canDespawn() {
+        return !this.isConverting();
+    }
+
+    public boolean isConverting() {
+        return this.getDataManager().get(CONVERTING).booleanValue();
+    }
+
+    protected void startConverting(@Nullable UUID conversionStarterIn, int conversionTimeIn) {
+        this.converstionStarter = conversionStarterIn;
+        this.conversionTime = conversionTimeIn;
+        this.getDataManager().set(CONVERTING, Boolean.valueOf(true));
+        this.removePotionEffect(MobEffects.WEAKNESS);
+        this.addPotionEffect(new PotionEffect(MobEffects.STRENGTH, conversionTimeIn, Math.min(this.world.getDifficulty().getDifficultyId() - 1, 0)));
+        this.world.setEntityState(this, (byte) 16);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void handleStatusUpdate(byte id) {
+        if (id == 16) {
+            if (!this.isSilent()) {
+                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_ZOMBIE_VILLAGER_CURE, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
+            }
+        } else {
+            super.handleStatusUpdate(id);
+        }
+    }
+
+    protected void finishConversion() {
+        EntityVillager entityvillager = new EntityVillager(this.world);
+        entityvillager.copyLocationAndAnglesFrom(this);
+        entityvillager.setProfession(this.getForgeProfession());
+        entityvillager.finalizeMobSpawn(this.world.getDifficultyForLocation(new BlockPos(entityvillager)), null, false);
+        entityvillager.setLookingForHome();
+        this.world.removeEntity(this);
+        entityvillager.setNoAI(this.isAIDisabled());
+
+        if (this.hasCustomName()) {
+            entityvillager.setCustomNameTag(this.getCustomNameTag());
+            entityvillager.setAlwaysRenderNameTag(this.getAlwaysRenderNameTag());
+        }
+
+        this.world.spawnEntity(entityvillager);
+        entityvillager.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 200, 0));
+        this.world.playEvent(null, 1027, new BlockPos((int) this.posX, (int) this.posY, (int) this.posZ), 0);
+    }
+
+    protected int getConversionProgress() {
+        int i = 1;
+
+        if (this.rand.nextFloat() < 0.01F) {
+            int j = 0;
+            BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
+
+            for (int k = (int) this.posX - 4; k < (int) this.posX + 4 && j < 14; ++k) {
+                for (int l = (int) this.posY - 4; l < (int) this.posY + 4 && j < 14; ++l) {
+                    for (int i1 = (int) this.posZ - 4; i1 < (int) this.posZ + 4 && j < 14; ++i1) {
+                        Block block = this.world.getBlockState(blockpos$mutableblockpos.setPos(k, l, i1)).getBlock();
+
+                        if (block == Blocks.IRON_BARS || block == Blocks.BED) {
+                            if (this.rand.nextFloat() < 0.3F) {
+                                ++i;
+                            }
+
+                            ++j;
+                        }
+                    }
+                }
+            }
+        }
+
+        return i;
+    }
+
+    protected float getSoundPitch() {
+        return (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
+    }
+
+    /**
+     * TODO: FIX NEW SOUNDS
+     */
+
+    public SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_AMBIENT;
+    }
+
+    public SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_HURT;
+    }
+
+    public SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_DEATH;
+    }
+
+    //TODO: ^
+
+    public SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_STEP;
+    }
+
+    @Nullable
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.MUMMY_VILLAGER;
+    }
+
+
+    /* ======================================== FORGE START =====================================*/
+
+    protected ItemStack getSkullDrop() {
+        return ItemStack.EMPTY;
+    }
+
+    public VillagerRegistry.VillagerProfession getForgeProfession() {
+        if (this.prof == null) {
+            this.prof = VillagerRegistry.getById(this.getProfession());
+            if (this.prof == null)
+                return VillagerRegistry.FARMER;
+        }
+        return this.prof;
+    }
+
+    public void setForgeProfession(VillagerRegistry.VillagerProfession prof) {
+        this.prof = prof;
+        this.setProfession(VillagerRegistry.getId(prof));
+    }
+
+    @Override
+    public void notifyDataManagerChange(DataParameter<?> key) {
+        super.notifyDataManagerChange(key);
+    }
+
+    /* ======================================== FORGE END =====================================*/
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTiles.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTiles.java	(date 1523987837000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockStainedClayTiles extends BlockMetaVariants implements IModBlock {
+
+    public BlockStainedClayTiles() {
+        super("stained_clay_tiles", Reference.MOD_ID, Material.ROCK, Variants.class);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        STAINED_CLAY_TILES_WHITE,
+        STAINED_CLAY_TILES_ORANGE,
+        STAINED_CLAY_TILES_MAGENTA,
+        STAINED_CLAY_TILES_LIGHT_BLUE,
+        STAINED_CLAY_TILES_YELLOW,
+        STAINED_CLAY_TILES_LIME,
+        STAINED_CLAY_TILES_PINK,
+        STAINED_CLAY_TILES_GRAY,
+        STAINED_CLAY_TILES_SILVER,
+        STAINED_CLAY_TILES_CYAN,
+        STAINED_CLAY_TILES_PURPLE,
+        STAINED_CLAY_TILES_BLUE,
+        STAINED_CLAY_TILES_BROWN,
+        STAINED_CLAY_TILES_GREEN,
+        STAINED_CLAY_TILES_RED,
+        STAINED_CLAY_TILES_BLACK
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockNewSandstone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockNewSandstone.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockNewSandstone.java	(date 1525606886000)
@@ -0,0 +1,51 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [06/06/2016, 23:10:28 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.modules.building.features.SoulSandstone;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.module.ModuleLoader;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockNewSandstone extends BlockMetaVariants implements IModBlock {
+
+    public BlockNewSandstone() {
+        super("sandstone_new", MOD_ID, Material.ROCK, Variants.class);
+        setHardness(0.8F);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public boolean shouldDisplayVariant(int variant) {
+        return ModuleLoader.isFeatureEnabled(SoulSandstone.class) || variant < 4;
+    }
+
+    public enum Variants implements EnumBase {
+        SANDSTONE_SMOOTH(false, true),
+        SANDSTONE_BRICKS(true, true),
+        RED_SANDSTONE_SMOOTH(false, true),
+        RED_SANDSTONE_BRICKS(true, true),
+        SOUL_SANDSTONE_SMOOTH(false, true),
+        SOUL_SANDSTONE_BRICKS(true, true);
+
+        public final boolean stairs, slabs;
+
+        Variants(boolean stairs, boolean slabs) {
+            this.stairs = stairs;
+            this.slabs = slabs;
+        }
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesSlab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesSlab.java	(date 1525537564000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedClayTilesSlab.java	(date 1525537564000)
@@ -0,0 +1,33 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.modules.building.blocks.BlockStainedClayTiles;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.thegaminghuskymc.huskylib2.interf.IRecipeGrouped;
+
+public class BlockStainedClayTilesSlab extends BlockOverworldSlabBase implements IRecipeGrouped {
+
+    public BlockStainedClayTilesSlab(BlockStainedClayTiles.Variants variant, boolean doubleSlab) {
+        super(variant.getName() + "_slab", Material.ROCK, doubleSlab);
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+    @Override
+    public String getRecipeGroup() {
+        return "stained_clay_tiles_slab";
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/VanillaStairsAndSlabs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/VanillaStairsAndSlabs.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/VanillaStairsAndSlabs.java	(date 1525606899000)
@@ -0,0 +1,81 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 19:34:51 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldStairBase;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockVanillaSlab;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class VanillaStairsAndSlabs extends Feature {
+
+    boolean stone, granite, diorite, andesite, endBricks, prismarine, prismarineBricks, darkPrismarine, redNetherBricks;
+
+    @Override
+    public void setupConfig() {
+        stone = loadPropBool("Stone", "", true);
+        granite = loadPropBool("Granite", "", true);
+        diorite = loadPropBool("Diorite", "", true);
+        andesite = loadPropBool("Andesite", "", true);
+        endBricks = loadPropBool("End Bricks", "", true);
+        prismarine = loadPropBool("Prismarine", "", true);
+        prismarineBricks = loadPropBool("Prismarine Bricks", "", true);
+        darkPrismarine = loadPropBool("Dark Prismarine", "", true);
+        redNetherBricks = loadPropBool("Red Nether Brick", "", true);
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        if (!GlobalConfig.enableVariants)
+            return;
+
+        add("stone", Blocks.STONE, 0, false, true, stone);
+        add("stone_granite", Blocks.STONE, 1, granite);
+        add("stone_diorite", Blocks.STONE, 3, diorite);
+        add("stone_andesite", Blocks.STONE, 5, andesite);
+        add("end_bricks", Blocks.END_BRICKS, 0, endBricks);
+        add("prismarine", Blocks.PRISMARINE, 0, prismarine);
+        add("prismarine_bricks", Blocks.PRISMARINE, 1, prismarineBricks);
+        add("prismarine_dark", Blocks.PRISMARINE, 2, darkPrismarine);
+        add("red_nether_brick", Blocks.RED_NETHER_BRICK, 0, redNetherBricks);
+    }
+
+    public void add(String name, Block block, int meta, boolean doit) {
+        add(name, block, meta, true, true, doit);
+    }
+
+    public void add(String name, Block block, int meta, boolean slab, boolean stairs, boolean doit) {
+        if (!doit)
+            return;
+
+        IBlockState state = block.getStateFromMeta(meta);
+        String stairsName = name + "_stairs";
+        String slabName = name + "_slab";
+
+        if (stairs)
+            BlockModStairs.initStairs(block, meta, new BlockOverworldStairBase(stairsName, state));
+        if (slab)
+            BlockModSlab.initSlab(block, meta, new BlockVanillaSlab(slabName, state, false), new BlockVanillaSlab(slabName, state, true));
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
+
Index: src/main/java/net/hdt/neutronia/entity/EntityMummy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/EntityMummy.java	(date 1525606863000)
+++ src/main/java/net/hdt/neutronia/entity/EntityMummy.java	(date 1525606863000)
@@ -0,0 +1,384 @@
+package net.hdt.neutronia.entity;
+
+import net.hdt.neutronia.entity.ai.EntityAIMummyAttack;
+import net.hdt.neutronia.init.HMItems;
+import net.hdt.neutronia.util.handlers.LootTableHandler;
+import net.minecraft.block.Block;
+import net.minecraft.entity.*;
+import net.minecraft.entity.ai.EntityAIBreakDoor;
+import net.minecraft.entity.ai.EntityAIHurtByTarget;
+import net.minecraft.entity.ai.EntityAIMoveThroughVillage;
+import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
+import net.minecraft.entity.ai.attributes.AttributeModifier;
+import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.monster.EntityCreeper;
+import net.minecraft.entity.passive.EntityVillager;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.datasync.DataParameter;
+import net.minecraft.network.datasync.DataSerializers;
+import net.minecraft.network.datasync.EntityDataManager;
+import net.minecraft.pathfinding.PathNavigateGround;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.SoundEvent;
+import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+import javax.annotation.Nullable;
+import java.util.Calendar;
+import java.util.UUID;
+
+public class EntityMummy extends EntityUndeadBase {
+
+    public static final DataParameter<Boolean> ARMS_RAISED = EntityDataManager.createKey(EntityMummy.class, DataSerializers.BOOLEAN);
+    private static final UUID BABY_SPEED_BOOST_ID = UUID.fromString("B9766B59-9566-4402-BC1F-2EE2A276D836");
+    private static final AttributeModifier BABY_SPEED_BOOST = new AttributeModifier(BABY_SPEED_BOOST_ID, "Mummy Baby Speed Boost", 0.5D, 1);
+    private static final DataParameter<Boolean> IS_CHILD = EntityDataManager.createKey(EntityMummy.class, DataSerializers.BOOLEAN);
+    private static final DataParameter<Integer> VILLAGER_TYPE = EntityDataManager.createKey(EntityMummy.class, DataSerializers.VARINT);
+    private final EntityAIBreakDoor breakDoor = new EntityAIBreakDoor(this);
+    private boolean isBreakDoorsTaskSet;
+
+    private double mummyBabyChance = 0.05;
+    private float mummyWidth = -1.0F;
+    private float mummyHeight;
+
+    public EntityMummy(World worldIn) {
+        super(worldIn);
+        this.setSize(0.6F, 1.95F);
+    }
+
+    public static void registerFixesMummy(DataFixer fixer) {
+        registerFixesMob(fixer, EntityMummy.class);
+    }
+
+    @Override
+    protected void initEntityAI() {
+        this.tasks.addTask(2, new EntityAIMummyAttack(this, 1.0D, false));
+        this.tasks.addTask(6, new EntityAIMoveThroughVillage(this, 1.0D, false));
+        this.applyEntityAI();
+    }
+
+    protected void applyEntityAI() {
+        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
+        this.targetTasks.addTask(3, new EntityAINearestAttackableTarget<>(this, EntityVillager.class, true));
+    }
+
+    @Override
+    protected void applyEntityAttributes() {
+        super.applyEntityAttributes();
+        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
+        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(2.0D);
+        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(10.0D);
+    }
+
+    @Override
+    protected void entityInit() {
+        super.entityInit();
+        this.getDataManager().register(VILLAGER_TYPE, 0);
+        this.getDataManager().register(ARMS_RAISED, Boolean.FALSE);
+        this.getDataManager().register(IS_CHILD, Boolean.valueOf(false));
+    }
+
+    @SideOnly(Side.CLIENT)
+    public boolean isArmsRaised() {
+        return this.getDataManager().get(ARMS_RAISED);
+    }
+
+    public void setArmsRaised(boolean armsRaised) {
+        this.getDataManager().set(ARMS_RAISED, armsRaised);
+    }
+
+    public boolean isBreakDoorsTaskSet() {
+        return this.isBreakDoorsTaskSet;
+    }
+
+    public void setBreakDoorAItask(boolean enabled) {
+        if (this.isBreakDoorsTaskSet != enabled) {
+            this.isBreakDoorsTaskSet = enabled;
+            ((PathNavigateGround) this.getNavigator()).setBreakDoors(enabled);
+
+            if (enabled)
+                this.tasks.addTask(1, this.breakDoor);
+            else
+                this.tasks.removeTask(this.breakDoor);
+        }
+    }
+
+    public boolean isChild() {
+        return this.getDataManager().get(IS_CHILD);
+    }
+
+    public void setChild(boolean child) {
+        this.getDataManager().set(IS_CHILD, child);
+        if (this.world != null && !this.world.isRemote) {
+            IAttributeInstance attributeInstance = this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);
+            attributeInstance.removeModifier(BABY_SPEED_BOOST);
+
+            if (child)
+                attributeInstance.applyModifier(BABY_SPEED_BOOST);
+        }
+        this.setChildSize(child);
+    }
+
+    @Override
+    protected int getExperiencePoints(EntityPlayer player) {
+        if (this.isChild())
+            this.experienceValue = (int) ((float) this.experienceValue * 2.5F);
+        return super.getExperiencePoints(player);
+    }
+
+    @Override
+    public void notifyDataManagerChange(DataParameter<?> key) {
+        if (IS_CHILD.equals(key))
+            this.setChildSize(this.isChild());
+        super.notifyDataManagerChange(key);
+    }
+
+    @Override
+    public void onLivingUpdate() {
+        super.onLivingUpdate();
+    }
+
+    @Override
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        return super.attackEntityFrom(source, amount);
+    }
+
+    @Override
+    public boolean attackEntityAsMob(Entity entityIn) {
+        boolean flag = super.attackEntityAsMob(entityIn);
+
+        if (flag) {
+            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
+
+            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
+                entityIn.setFire(2 * (int) f);
+        }
+        return flag;
+    }
+
+    /**
+     * TODO: Change Sounds...
+     */
+    @Override
+    protected SoundEvent getAmbientSound() {
+        return SoundEvents.ENTITY_ZOMBIE_AMBIENT;
+    }
+
+    @Override
+    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
+        return SoundEvents.ENTITY_ZOMBIE_HURT;
+    }
+
+    @Override
+    protected SoundEvent getDeathSound() {
+        return SoundEvents.ENTITY_ZOMBIE_DEATH;
+    }
+
+    // TODO ^
+
+    protected SoundEvent getStepSound() {
+        return SoundEvents.ENTITY_ZOMBIE_STEP;
+    }
+
+    @Override
+    protected void playStepSound(BlockPos pos, Block blockIn) {
+        this.playSound(this.getStepSound(), 0.15F, 1.0F);
+    }
+
+    @Override
+    public EnumCreatureAttribute getCreatureAttribute() {
+        return EnumCreatureAttribute.UNDEAD;
+    }
+
+    @Nullable
+    @Override
+    protected ResourceLocation getLootTable() {
+        return LootTableHandler.MUMMY;
+    }
+
+    @Override
+    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
+        super.setEquipmentBasedOnDifficulty(difficulty);
+
+        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
+            int i = this.rand.nextInt(3);
+
+            if (i == 0)
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(HMItems.ancientSword));
+            else
+                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(Item.getItemFromBlock(Blocks.SAND)));
+        }
+    }
+
+    @Override
+    public void writeEntityToNBT(NBTTagCompound compound) {
+        super.writeEntityToNBT(compound);
+        if (this.isChild())
+            compound.setBoolean("IsBaby", true);
+        compound.setBoolean("CanBreakDoors", this.isBreakDoorsTaskSet());
+    }
+
+    @Override
+    public void readEntityFromNBT(NBTTagCompound compound) {
+        super.readEntityFromNBT(compound);
+        if (compound.getBoolean("IsBaby"))
+            this.setChild(true);
+        this.setBreakDoorAItask(compound.getBoolean("CanBreakDoors"));
+    }
+
+    @Override
+    public void onKillEntity(EntityLivingBase entityLivingIn) {
+        super.onKillEntity(entityLivingIn);
+
+        if ((this.world.getDifficulty() == EnumDifficulty.NORMAL || this.world.getDifficulty() == EnumDifficulty.HARD) && entityLivingIn instanceof EntityVillager) {
+            if (this.world.getDifficulty() != EnumDifficulty.HARD && this.rand.nextBoolean())
+                return;
+
+            EntityVillager entityVillager = (EntityVillager) entityLivingIn;
+            EntityMummyVillager entityMummyVillager = new EntityMummyVillager(this.world);
+            entityMummyVillager.copyLocationAndAnglesFrom(entityVillager);
+            this.world.removeEntity(entityVillager);
+            entityMummyVillager.onInitialSpawn(this.world.getDifficultyForLocation(new BlockPos(entityMummyVillager)), null);
+            entityMummyVillager.setProfession(entityVillager.getProfession());
+            entityMummyVillager.setNoAI(entityVillager.isAIDisabled());
+
+            if (entityVillager.hasCustomName()) {
+                entityMummyVillager.setCustomNameTag(entityVillager.getCustomNameTag());
+                entityMummyVillager.setAlwaysRenderNameTag(entityVillager.getAlwaysRenderNameTag());
+            }
+
+            this.world.spawnEntity(entityMummyVillager);
+            this.world.playEvent(null, 1026, new BlockPos(this), 0);
+        }
+    }
+
+    @Override
+    public float getEyeHeight() {
+        float f = 1.74F;
+        if (this.isChild())
+            f = (float) ((double) f - 0.81D);
+        return f;
+    }
+
+    @Override
+    protected boolean canEquipItem(ItemStack stack) {
+        return stack.getItem() == HMItems.ancientSword;
+    }
+
+    @Override
+    public boolean getCanSpawnHere() {
+        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
+    }
+
+    @Nullable
+    @Override
+    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
+        if (!getCanSpawnHere())
+            despawnEntity();
+        else {
+            livingdata = super.onInitialSpawn(difficulty, livingdata);
+            float f = difficulty.getClampedAdditionalDifficulty();
+            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
+            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
+                Calendar calendar = this.world.getCurrentDate();
+                if (calendar.get(Calendar.MONTH) + 1 == 10 && calendar.get(Calendar.DATE) == 31 && this.rand.nextFloat() < 0.25F) {
+                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
+                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
+                }
+            }
+            if (livingdata == null) {
+                livingdata = new EntityMummy.GroupData(this.world.rand.nextFloat() < mummyBabyChance);
+            }
+
+            if (livingdata instanceof EntityMummy.GroupData) {
+                EntityMummy.GroupData entitymummy$groupdata = (EntityMummy.GroupData) livingdata;
+                if (entitymummy$groupdata.isChild) {
+                    this.setChild(true);
+                }
+            }
+            this.setBreakDoorAItask(this.rand.nextFloat() < f * 0.1F);
+            this.setEquipmentBasedOnDifficulty(difficulty);
+            this.setEnchantmentBasedOnDifficulty(difficulty);
+
+            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
+            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
+
+            if (d0 > 1.0D)
+                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random mummy-spawn bonus", d0, 2));
+
+            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader mummy bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
+                this.setBreakDoorAItask(true);
+            }
+        }
+        return livingdata;
+    }
+
+    public void setChildSize(boolean isChild) {
+        this.multiplySize(isChild ? 0.5F : 1.0F);
+    }
+
+    @Override
+    protected final void setSize(float width, float height) {
+        boolean flag = this.mummyWidth > 0.0F && this.mummyHeight > 0.0F;
+        this.mummyWidth = width;
+        this.mummyHeight = height;
+
+        if (!flag)
+            this.multiplySize(1.0f);
+    }
+
+    protected final void multiplySize(float size) {
+        super.setSize(this.mummyWidth * size, this.mummyHeight * size);
+    }
+
+    public double getYOffset() {
+        return this.isChild() ? 0.0D : -0.45D;
+    }
+
+    @Override
+    public void onDeath(DamageSource cause) {
+        super.onDeath(cause);
+
+        if (cause.getTrueSource() instanceof EntityCreeper) {
+            EntityCreeper entityCreeper = (EntityCreeper) cause.getTrueSource();
+
+            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
+                entityCreeper.incrementDroppedSkulls();
+                ItemStack itemStack = this.getSkullDrop();
+
+                if (!itemStack.isEmpty())
+                    this.entityDropItem(itemStack, 0.0F);
+            }
+        }
+    }
+
+    protected ItemStack getSkullDrop() {
+        return new ItemStack(Items.SKULL, 1, 2);
+    }
+
+    class GroupData implements IEntityLivingData {
+        public boolean isChild;
+
+        private GroupData(boolean isChild) {
+            this.isChild = isChild;
+        }
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenCivilizationRuins.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenCivilizationRuins.java	(date 1523986180000)
+++ src/main/java/net/hdt/neutronia/world/gen/structure/WorldGenCivilizationRuins.java	(date 1523986180000)
@@ -0,0 +1,303 @@
+package net.hdt.neutronia.world.gen.structure;
+
+import net.minecraft.block.BlockStairs;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenCivilizationRuins extends WorldGenerator {
+
+    public boolean generate(World world, Random random, BlockPos pos) {
+        BlockPos upPos = pos.up();
+        int j1 = 0;
+        int k1 = 0;
+        boolean solidBottom = world.getBlockState(pos).getMaterial().isSolid() || world.getBlockState(pos.down()).getMaterial().isSolid();
+        boolean solidSides = world.getBlockState(pos.east(6)).getMaterial().isSolid() && world.getBlockState(pos.south(6)).getMaterial().isSolid() && world.getBlockState(pos.add(6, 0, 6)).getMaterial().isSolid();
+        boolean hasRoom = world.getBlockState(upPos).getMaterial().isSolid() && world.getBlockState(upPos.east(6)).getMaterial().isSolid() && world.getBlockState(upPos.south(6)).getMaterial().isSolid() && world.getBlockState(upPos.add(6, 0, 6)).getMaterial().isSolid();
+        if (solidBottom && solidSides && !hasRoom) {
+            int randomWallChance = random.nextInt(3);
+            int randomFloorChance = random.nextInt(2);
+            IBlockState wallState;
+            if (randomWallChance == 0) {
+                wallState = Blocks.COBBLESTONE.getDefaultState();
+            } else if (randomWallChance == 1) {
+                wallState = Blocks.MOSSY_COBBLESTONE.getDefaultState();
+            } else if (randomWallChance == 2) {
+                wallState = Blocks.PLANKS.getDefaultState();
+            } else {
+                wallState = Blocks.MOSSY_COBBLESTONE.getDefaultState();
+            }
+
+            IBlockState floorState;
+            if (randomFloorChance == 0) {
+                floorState = Blocks.COBBLESTONE.getDefaultState();
+            } else if (randomFloorChance == 1) {
+                floorState = Blocks.MOSSY_COBBLESTONE.getDefaultState();
+            } else {
+                floorState = Blocks.PLANKS.getDefaultState();
+            }
+
+            int i3;
+            int k3;
+            for (i3 = 1; i3 <= 3; ++i3) {
+                for (k3 = 0; k3 < 49; ++k3) {
+                    world.setBlockState(pos.add(k1, i3, j1), Blocks.AIR.getDefaultState());
+                    ++k1;
+                    if (k1 == 7) {
+                        ++j1;
+                        k1 = 0;
+                    }
+                }
+            }
+
+            i3 = 0;
+            k3 = 0;
+
+            int i4;
+            for (i4 = 0; i4 < 49; ++i4) {
+                world.setBlockState(pos.add(k3, 0, i3), floorState);
+                ++k3;
+                if (k3 == 7) {
+                    ++i3;
+                    k3 = 0;
+                }
+            }
+
+            i4 = 0;
+            int j4 = 0;
+            int k4 = random.nextInt(2);
+            int k5;
+            int k6;
+            int j8;
+            int i9;
+            int l9;
+            if (k4 == 0) {
+                for (k5 = 1; k5 < 4; ++k5) {
+                    for (k6 = 0; k6 < 25; ++k6) {
+                        world.setBlockState(pos.add(i4 + 1, k5, j4 + 1), Blocks.AIR.getDefaultState());
+                        ++i4;
+                        if (i4 == 5) {
+                            ++j4;
+                            i4 = 0;
+                        }
+                    }
+
+                    i4 = 0;
+                    j4 = 0;
+                }
+
+                world.setBlockState(pos.add(3, -3, 3), Blocks.TORCH.getDefaultState());
+                world.setBlockState(pos.add(2, -3, 3), Blocks.STONE_PRESSURE_PLATE.getDefaultState());
+                world.setBlockState(pos.add(2, -4, 3), Blocks.STONE.getDefaultState());
+                world.setBlockState(pos.add(2, -5, 3), Blocks.TNT.getDefaultState());
+                k5 = random.nextInt(2);
+                if (k5 == 0) {
+                    for (k6 = 0; k6 < 25; ++k6) {
+                        world.setBlockState(pos.add(i4 + 1, -3, j4 + 1), Blocks.WATER.getDefaultState());
+                        ++i4;
+                        if (i4 == 5) {
+                            ++j4;
+                            i4 = 0;
+                        }
+                    }
+                }
+
+                k6 = random.nextInt(26);
+                j8 = k6 / 5;
+                i9 = k6 % 5;
+                world.setBlockState(pos.add(j8, -3, i9), Blocks.CHEST.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.EAST));
+                TileEntityChest k9 = (TileEntityChest) world.getTileEntity(pos.add(j8, -3, i9));
+
+            }
+
+            boolean var33 = false;
+            boolean var34 = false;
+
+            int var35;
+            for (k5 = 0; k5 < 3; ++k5) {
+                k6 = 0;
+                j8 = 0;
+
+                for (i9 = 0; i9 < 28; ++i9) {
+                    var35 = random.nextInt(k5 + 1);
+                    Material var36;
+                    if (k6 == 0) {
+                        var36 = world.getBlockState(pos.add(0, k5, j8)).getMaterial();
+                        if (var36.isSolid() && var35 == 0) {
+                            if (k5 == 1) {
+                                if (random.nextInt(2) == 0) {
+                                    world.setBlockState(pos.add(0, 1 + k5, j8), Blocks.GLASS.getDefaultState());
+                                } else {
+                                    world.setBlockState(pos.add(0, 1 + k5, j8), wallState);
+                                }
+                            } else {
+                                world.setBlockState(pos.add(0, 1 + k5, j8), wallState);
+                            }
+                        }
+
+                        ++j8;
+                    }
+
+                    if (k6 == 1) {
+                        var36 = world.getBlockState(pos.add(6, k5, j8)).getMaterial();
+                        if (var36.isSolid() && var35 == 0) {
+                            if (k5 == 1) {
+                                if (random.nextInt(2) == 0) {
+                                    world.setBlockState(pos.add(6, 1 + k5, j8), Blocks.GLASS.getDefaultState());
+                                } else {
+                                    world.setBlockState(pos.add(6, 1 + k5, j8), wallState);
+                                }
+                            } else {
+                                world.setBlockState(pos.add(6, 1 + k5, j8), wallState);
+                            }
+                        }
+
+                        ++j8;
+                    }
+
+                    if (k6 == 2) {
+                        var36 = world.getBlockState(pos.add(j8, k5, 0)).getMaterial();
+                        if (var36.isSolid() && var35 == 0) {
+                            if (k5 == 1) {
+                                if (random.nextInt(2) == 0) {
+                                    world.setBlockState(pos.add(j8, 1 + k5, 0), Blocks.GLASS.getDefaultState());
+                                } else {
+                                    world.setBlockState(pos.add(j8, 1 + k5, 0), wallState);
+                                }
+                            } else {
+                                world.setBlockState(pos.add(7, 1 + k5, 0), wallState);
+                            }
+                        }
+
+                        ++j8;
+                    }
+
+                    if (k6 == 3) {
+                        var36 = world.getBlockState(pos.add(j8, k5, 6)).getMaterial();
+                        if (var36.isSolid() && var35 == 0) {
+                            if (k5 == 1) {
+                                if (random.nextInt(2) == 0) {
+                                    world.setBlockState(pos.add(j8, 1 + k5, 6), Blocks.GLASS.getDefaultState());
+                                } else {
+                                    world.setBlockState(pos.add(j8, 1 + k5, 6), wallState);
+                                }
+                            } else {
+                                world.setBlockState(pos.add(j8, 1 + k5, 6), wallState);
+                            }
+                        }
+
+                        ++j8;
+                    }
+
+                    if (j8 == 7) {
+                        ++k6;
+                        j8 = 0;
+                    }
+                }
+            }
+
+            k5 = random.nextInt(3);
+            k6 = random.nextInt(3);
+            if (k5 == 0) {
+                world.setBlockState(pos.add(0, 1, 2 + k6), Blocks.AIR.getDefaultState());
+                world.setBlockState(pos.add(0, 2, 2 + k6), Blocks.AIR.getDefaultState());
+            }
+
+            if (k5 == 1) {
+                world.setBlockState(pos.add(6, 1, 2 + k6), Blocks.AIR.getDefaultState());
+                world.setBlockState(pos.add(6, 2, 2 + k6), Blocks.AIR.getDefaultState());
+            }
+
+            if (k5 == 2) {
+                world.setBlockState(pos.add(2 + k6, 1, 0), Blocks.AIR.getDefaultState());
+                world.setBlockState(pos.add(2 + k6, 2, 0), Blocks.AIR.getDefaultState());
+            }
+
+            if (k5 == 3) {
+                world.setBlockState(pos.add(2 + k6, 1, 6), Blocks.AIR.getDefaultState());
+                world.setBlockState(pos.add(2 + k6, 2, 6), Blocks.AIR.getDefaultState());
+            }
+
+            j8 = random.nextInt(2);
+            i9 = random.nextInt(5) + 1;
+            var35 = 0;
+            l9 = 0;
+            if (j8 == 0) {
+                var35 = i9;
+                l9 = 1;
+            }
+
+            if (j8 == 1) {
+                var35 = 1;
+                l9 = i9;
+            }
+
+            if (j8 == 2) {
+                var35 = 1;
+                l9 = i9;
+            }
+
+            world.setBlockState(pos.add(var35, 1, l9), Blocks.CHEST.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.EAST));
+
+            int i10;
+
+            i10 = random.nextInt(2);
+            if (i10 == 0) {
+                int j10 = 0;
+                int k10 = 0;
+
+                int k11;
+                for (k11 = 0; k11 < 12; ++k11) {
+                    if (k10 == 0) {
+                        world.setBlockState(pos.add(2, 1, -1 - j10), Blocks.OAK_FENCE.getDefaultState());
+                    }
+
+                    if (k10 == 1) {
+                        world.setBlockState(pos.add(3 + j10, 1, -4), Blocks.OAK_FENCE.getDefaultState());
+                    }
+
+                    if (k10 == 2) {
+                        world.setBlockState(pos.add(6, 1, -1 - j10), Blocks.OAK_FENCE.getDefaultState());
+                    }
+
+                    ++j10;
+                    if (j10 == 4) {
+                        ++k10;
+                        j10 = 0;
+                    }
+                }
+
+                int chest2;
+                int treasureSize;
+                for (k11 = 0; k11 < 20; ++k11) {
+                    chest2 = k11 / 5;
+                    treasureSize = k11 % 5;
+                    world.setBlockState(pos.add(treasureSize + 2, 0, -chest2 - 1), Blocks.DIRT.getDefaultState());
+                }
+
+                for (k11 = 0; k11 < 9; ++k11) {
+                    chest2 = k11 / 3;
+                    treasureSize = k11 % 3;
+                    world.setBlockState(pos.add(treasureSize + 3, 1, -chest2 - 1), Blocks.AIR.getDefaultState());
+                }
+
+                k11 = random.nextInt(2);
+                if (k11 == 0) {
+                    world.setBlockState(pos.add(3, 1, -3), Blocks.CHEST.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.EAST));
+                    TileEntityChest var37 = (TileEntityChest) world.getTileEntity(pos.add(3, 1, -3));
+                }
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/feature/FeatureStructure.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/feature/FeatureStructure.java	(date 1525606897000)
+++ src/main/java/net/hdt/neutronia/world/gen/feature/FeatureStructure.java	(date 1525606897000)
@@ -0,0 +1,121 @@
+package net.hdt.neutronia.world.gen.feature;
+
+import net.hdt.neutronia.api.config.IConfig;
+import net.hdt.neutronia.util.StructureHelper;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityList;
+import net.minecraft.init.Blocks;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tileentity.MobSpawnerBaseLogic;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.util.Mirror;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.structure.template.PlacementSettings;
+import net.minecraft.world.gen.structure.template.Template;
+import net.minecraft.world.gen.structure.template.TemplateManager;
+
+import java.util.Map;
+import java.util.Random;
+
+public class FeatureStructure extends Feature {
+    private ResourceLocation structure;
+    private Type type;
+    private Mirror mirror;
+    private Rotation rotation;
+    private Block ignoredBlock;
+    private float clearancePercentage;
+
+    public FeatureStructure(IConfig config) {
+        super(config);
+        structure = config.getResource("structure");
+        type = config.getEnum("type", Type.class, Type.GROUNDED);
+        mirror = config.getEnum("mirror", Mirror.class, Mirror.NONE);
+        rotation = config.getEnum("rotation", Rotation.class, Rotation.NONE);
+        ignoredBlock = config.getBlock("ignoredBlock", Blocks.STRUCTURE_VOID.getDefaultState()).getBlock();
+        clearancePercentage = config.getFloat("clearancePercentage", 0.875F);
+    }
+
+    @Override
+    public boolean generate(World world, Random rand, BlockPos pos) {
+        MinecraftServer server = world.getMinecraftServer();
+        TemplateManager manager = world.getSaveHandler().getStructureTemplateManager();
+        Template template = manager.getTemplate(server, structure);
+        PlacementSettings placementSettings = new PlacementSettings().setMirror(mirror).setRotation(rotation).setReplacedBlock(ignoredBlock).setRandom(rand);
+        BlockPos structureSize = template.transformedSize(rotation);
+        BlockPos spawnPos = null;
+
+        if (type == Type.GROUNDED) {
+            spawnPos = StructureHelper.getGroundedPos(world, pos, structureSize, clearancePercentage);
+        } else if (type == Type.FLOATING) {
+            spawnPos = StructureHelper.getFloatingPos(world, pos, structureSize, clearancePercentage);
+        } else if (type == Type.HANGING) {
+            spawnPos = StructureHelper.getHangingPos(world, pos, structureSize, clearancePercentage);
+        } else if (type == Type.BURIED) {
+            spawnPos = StructureHelper.getBuriedPos(world, pos, structureSize, clearancePercentage);
+        }
+
+        if (spawnPos != null && spawnPos.getY() >= minHeight && spawnPos.getY() <= maxHeight) {
+            template.addBlocksToWorld(world, spawnPos, placementSettings);
+            handleDataBlocks(world, pos, template, placementSettings, rand);
+            return true;
+        }
+
+        return false;
+    }
+
+    private void handleDataBlocks(World world, BlockPos pos, Template template, PlacementSettings placementSettings, Random rand) {
+        Map<BlockPos, String> map = template.getDataBlocks(pos, placementSettings);
+
+        for (Map.Entry<BlockPos, String> entry : map.entrySet()) {
+            BlockPos dataPos = entry.getKey();
+            String[] data = entry.getValue().split("\\s+");
+
+            if (data[0].equals("chest") && data.length == 2) {
+                world.setBlockState(dataPos, Blocks.CHEST.correctFacing(world, dataPos, Blocks.CHEST.getDefaultState()));
+                TileEntityChest chest = (TileEntityChest) world.getTileEntity(dataPos);
+
+                if (chest != null) {
+                    chest.setLootTable(new ResourceLocation(data[1]), rand.nextLong());
+                }
+            } else if (data[0].equals("spawner") && data.length == 2) {
+                world.setBlockState(dataPos, Blocks.MOB_SPAWNER.getDefaultState());
+                TileEntityMobSpawner spawner = (TileEntityMobSpawner) world.getTileEntity(dataPos);
+
+                if (spawner != null) {
+                    MobSpawnerBaseLogic logic = spawner.getSpawnerBaseLogic();
+                    NBTTagCompound compound = new NBTTagCompound();
+                    logic.writeToNBT(compound);
+                    compound.removeTag("SpawnPotentials");
+                    logic.readFromNBT(compound);
+                    logic.setEntityId(new ResourceLocation(data[1]));
+                    spawner.markDirty();
+                    IBlockState state = world.getBlockState(dataPos);
+                    world.notifyBlockUpdate(pos, state, state, 3);
+                }
+            } else if (data[0].equals("entity") && data.length == 2) {
+                Entity entity = EntityList.newEntity(EntityList.getClassFromName(data[1]), world);
+
+                if (entity != null) {
+                    entity.setPosition(dataPos.getX() + 0.5F, dataPos.getY(), dataPos.getZ() + 0.5F);
+                    world.spawnEntity(entity);
+                }
+            } else {
+                world.setBlockToAir(dataPos);
+            }
+        }
+    }
+
+    public enum Type {
+        GROUNDED,
+        FLOATING,
+        HANGING,
+        BURIED
+    }
+}
Index: src/main/java/net/hdt/neutronia/tileentity/TileEntityFloorTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/tileentity/TileEntityFloorTile.java	(date 1524511959000)
+++ src/main/java/net/hdt/neutronia/tileentity/TileEntityFloorTile.java	(date 1524511959000)
@@ -0,0 +1,76 @@
+package net.hdt.neutronia.tileentity;
+
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.NetworkManager;
+import net.minecraft.network.play.server.SPacketUpdateTileEntity;
+import net.minecraft.tileentity.TileEntity;
+
+import java.util.Random;
+
+public class TileEntityFloorTile extends TileEntity {
+
+    private int color0, color1;
+
+    public TileEntityFloorTile(Random r) {
+        if (r != null) {
+            this.color0 = r.nextInt(0xFFFFFF);
+            this.color1 = r.nextInt(0xFFFFFF);
+        }
+    }
+
+    @Override
+    public NBTTagCompound writeToNBT(NBTTagCompound compound) {
+        compound = super.writeToNBT(compound);
+        this.writeColorsToNBT(compound);
+        return compound;
+    }
+
+    public NBTTagCompound writeColorsToNBT(NBTTagCompound compound) {
+        for (int i = 0; i < 2; i++) {
+            compound.setInteger("color" + i, this.getColor(i));
+        }
+        return compound;
+    }
+
+    @Override
+    public void readFromNBT(NBTTagCompound compound) {
+        super.readFromNBT(compound);
+        this.readColorsFromNBT(compound);
+    }
+
+    public void readColorsFromNBT(NBTTagCompound compound) {
+        for (int i = 0; i < 2; i++) {
+            if (compound.hasKey("color" + i)) {
+                this.setColor(i, compound.getInteger("color" + i));
+            }
+        }
+    }
+
+    @Override
+    public NBTTagCompound getUpdateTag() {
+        return this.writeColorsToNBT(new NBTTagCompound());
+    }
+
+    @Override
+    public SPacketUpdateTileEntity getUpdatePacket() {
+        return new SPacketUpdateTileEntity(this.pos, 0, this.getUpdateTag());
+    }
+
+    @Override
+    public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity pkt) {
+        this.readColorsFromNBT(pkt.getNbtCompound());
+    }
+
+    public int getColor(int index) {
+        return index == 0 ? color0 : (index == 1 ? color1 : 0xFFFFFF);
+    }
+
+    public void setColor(int index, int color) {
+        if (index == 0) {
+            this.color0 = color;
+        } else if (index == 1) {
+            this.color1 = color;
+        }
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/render/layer/LayerDrownedOuter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/layer/LayerDrownedOuter.java	(date 1525606863000)
+++ src/main/java/net/hdt/neutronia/entity/render/layer/LayerDrownedOuter.java	(date 1525606863000)
@@ -0,0 +1,35 @@
+package net.hdt.neutronia.entity.render.layer;
+
+import net.hdt.neutronia.entity.EntityDrowned;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.entity.RenderLivingBase;
+import net.minecraft.client.renderer.entity.layers.LayerRenderer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class LayerDrownedOuter implements LayerRenderer<EntityDrowned> {
+
+    private static final ResourceLocation STRAY_CLOTHES_TEXTURES = new ResourceLocation("neutronia:textures/entity/drowned/drowned_outer_layer.png");
+    private final RenderLivingBase<?> renderer;
+    private final ModelZombie layerModel = new ModelZombie(0.25F, false);
+
+    public LayerDrownedOuter(RenderLivingBase<?> p_i47183_1_) {
+        this.renderer = p_i47183_1_;
+    }
+
+    public void doRenderLayer(EntityDrowned entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
+        this.layerModel.setModelAttributes(this.renderer.getMainModel());
+        this.layerModel.setLivingAnimations(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks);
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+        this.renderer.bindTexture(STRAY_CLOTHES_TEXTURES);
+        this.layerModel.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+    }
+
+    public boolean shouldCombineTextures() {
+        return false;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/client/rendering/RenderTileCustomChest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/client/rendering/RenderTileCustomChest.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/client/rendering/RenderTileCustomChest.java	(date 1525606862000)
@@ -0,0 +1,141 @@
+package net.hdt.neutronia.client.rendering;
+
+import net.hdt.neutronia.init.HMBlocks;
+import net.hdt.neutronia.tileentity.TileCustomChest;
+import net.minecraft.client.model.ModelChest;
+import net.minecraft.client.model.ModelLargeChest;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
+import net.minecraft.util.ResourceLocation;
+import org.lwjgl.opengl.GL11;
+
+public class RenderTileCustomChest extends TileEntitySpecialRenderer<TileCustomChest> {
+
+    private static final ResourceLocation TEXTURE_CHRISTMAS_DOUBLE = new ResourceLocation("textures/entity/chests/christmas_double.png");
+    private static final ResourceLocation TEXTURE_CHRISTMAS = new ResourceLocation("textures/entity/chests/christmas.png");
+
+    private final ModelChest simpleChest = new ModelChest();
+    private final ModelChest largeChest = new ModelLargeChest();
+
+    @Override
+    public void render(TileCustomChest te, double x, double y, double z, float partialTicks, int destroyStage, float something) {
+        GlStateManager.enableDepth();
+        GlStateManager.depthFunc(GL11.GL_LEQUAL);
+        GlStateManager.depthMask(true);
+        int meta;
+
+        if (te.hasWorld()) {
+            meta = te.getBlockMetadata();
+            te.checkForAdjacentChests();
+        } else
+            meta = 0;
+
+        if (te.adjacentChestZNeg == null && te.adjacentChestXNeg == null) {
+            ModelChest model;
+
+            if (te.adjacentChestXPos == null && te.adjacentChestZPos == null) {
+                model = simpleChest;
+
+                if (destroyStage >= 0) {
+                    bindTexture(DESTROY_STAGES[destroyStage]);
+                    GlStateManager.matrixMode(GL11.GL_TEXTURE);
+                    GlStateManager.pushMatrix();
+                    GlStateManager.scale(4.0F, 4.0F, 1.0F);
+                    GlStateManager.translate(0.0625F, 0.0625F, 0.0625F);
+                    GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+                } else bindTexture(te.chestType.nrmTex);
+            } else {
+                model = largeChest;
+
+                if (destroyStage >= 0) {
+                    bindTexture(DESTROY_STAGES[destroyStage]);
+                    GlStateManager.matrixMode(GL11.GL_TEXTURE);
+                    GlStateManager.pushMatrix();
+                    GlStateManager.scale(8.0F, 4.0F, 1.0F);
+                    GlStateManager.translate(0.0625F, 0.0625F, 0.0625F);
+                    GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+                } else bindTexture(te.chestType.dblTex);
+            }
+
+            GlStateManager.pushMatrix();
+            GlStateManager.enableRescaleNormal();
+
+            if (destroyStage < 0)
+                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+
+            GlStateManager.translate(x, y + 1.0F, z + 1.0F);
+            GlStateManager.scale(1.0F, -1.0F, -1.0F);
+            GlStateManager.translate(0.5F, 0.5F, 0.5F);
+            int angle = 0;
+
+            if (meta == 2)
+                angle = 180;
+
+            if (meta == 3)
+                angle = 0;
+
+            if (meta == 4)
+                angle = 90;
+
+            if (meta == 5)
+                angle = -90;
+
+            if (meta == 2 && te.adjacentChestXPos != null) {
+                GlStateManager.translate(1.0F, 0.0F, 0.0F);
+            }
+
+            if (meta == 5 && te.adjacentChestZPos != null) {
+                GlStateManager.translate(0.0F, 0.0F, -1.0F);
+            }
+
+            GlStateManager.rotate(angle, 0.0F, 1.0F, 0.0F);
+            GlStateManager.translate(-0.5F, -0.5F, -0.5F);
+            float lidAngle = te.prevLidAngle + (te.lidAngle - te.prevLidAngle) * partialTicks;
+
+            if (te.adjacentChestZNeg != null) {
+                float adjLidAngle = te.adjacentChestZNeg.prevLidAngle + (te.adjacentChestZNeg.lidAngle - te.adjacentChestZNeg.prevLidAngle) * partialTicks;
+
+                if (adjLidAngle > lidAngle)
+                    lidAngle = adjLidAngle;
+            }
+
+            if (te.adjacentChestXNeg != null) {
+                float adjLidAngle = te.adjacentChestXNeg.prevLidAngle + (te.adjacentChestXNeg.lidAngle - te.adjacentChestXNeg.prevLidAngle) * partialTicks;
+
+                if (adjLidAngle > lidAngle)
+                    lidAngle = adjLidAngle;
+            }
+
+            lidAngle = 1.0F - lidAngle;
+            lidAngle = 1.0F - lidAngle * lidAngle * lidAngle;
+            model.chestLid.rotateAngleX = -(lidAngle * ((float) Math.PI / 2F));
+            model.renderAll();
+
+            if (te.getChestType() == HMBlocks.CUSTOM_TYPE_QUARK_TRAP) {
+                if (model == simpleChest)
+                    bindTexture(HMBlocks.TRAP_RESOURCE);
+                else bindTexture(HMBlocks.TRAP_DOUBLE_RESOURCE);
+
+                float scale = 1.002F;
+                GlStateManager.pushMatrix();
+                GlStateManager.enableBlend();
+                GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                GlStateManager.scale(scale, scale, scale);
+                GlStateManager.translate(model == largeChest ? -0.002F : -0.001F, -0.001F, -0.001F);
+                model.renderAll();
+                GlStateManager.disableBlend();
+                GlStateManager.popMatrix();
+            }
+
+            GlStateManager.disableRescaleNormal();
+            GlStateManager.popMatrix();
+            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+
+            if (destroyStage >= 0) {
+                GlStateManager.matrixMode(GL11.GL_TEXTURE);
+                GlStateManager.popMatrix();
+                GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/properties/EnumFrostedDirtVariants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumFrostedDirtVariants.java	(date 1525343869000)
+++ src/main/java/net/hdt/neutronia/properties/EnumFrostedDirtVariants.java	(date 1525343869000)
@@ -0,0 +1,53 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumFrostedDirtVariants implements IStringSerializable {
+
+    DIRT(0, "frosted_dirt"),
+    COARSE_DIRT(1, "frosted_coarse_dirt"),
+    DARK_DIRT(2, "dark_dirt"),
+    DARK_DIRT_FROSTED(3, "dark_frosted_dirt"),
+    DARK_COARSE_DIRT(4, "dark_coarse_dirt"),
+    DARK_COARSE_DIRT_FROSTED(5, "dark_frosted_coarse_dirt"),
+    GRAVEL(6, "frosted_gravel"),
+    GRASS(7, "frosted_grass"),
+    SAND(8, "frosted_sand"),
+    RED_SAND(9, "red_frosted_sand");
+
+    private static final EnumFrostedDirtVariants[] META_LOOKUP = new EnumFrostedDirtVariants[values().length];
+
+    static {
+        for (EnumFrostedDirtVariants enumdyecolor : values()) {
+            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumFrostedDirtVariants(int metaIn, String nameIn) {
+        this.meta = metaIn;
+        this.name = nameIn;
+    }
+
+    public static EnumFrostedDirtVariants byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpAttack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpAttack.java	(date 1525606862000)
+++ src/main/java/net/hdt/neutronia/entity/ai/EntityAIScorpAttack.java	(date 1525606862000)
@@ -0,0 +1,43 @@
+package net.hdt.neutronia.entity.ai;
+
+import net.hdt.neutronia.entity.EntityScorp;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.ai.EntityAIAttackMelee;
+
+public class EntityAIScorpAttack extends EntityAIAttackMelee {
+    private final EntityScorp scorp;
+    private int extendTailTicks;
+
+    public EntityAIScorpAttack(EntityScorp scorpIn, double speedIn, boolean useLongMemory) {
+        super(scorpIn, speedIn, useLongMemory);
+        this.scorp = scorpIn;
+    }
+
+    @Override
+    public void startExecuting() {
+        super.startExecuting();
+        this.extendTailTicks = 0;
+    }
+
+    @Override
+    public void resetTask() {
+        super.resetTask();
+        this.scorp.setTailOut(false);
+    }
+
+    @Override
+    public void updateTask() {
+        super.updateTask();
+        ++extendTailTicks;
+
+        if (this.extendTailTicks >= 5 && this.attackTick < 10) {
+            this.scorp.setTailOut(true);
+        } else {
+            this.scorp.setTailOut(false);
+        }
+    }
+
+    protected double getAttackReachSqr(EntityLivingBase attackTarget) {
+        return (double) (5.0F + attackTarget.width);
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesStairs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesStairs.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockHardenedClayTilesStairs.java	(date 1523987839000)
@@ -0,0 +1,11 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.init.HMBlocks;
+
+public class BlockHardenedClayTilesStairs extends BlockOverworldStairBase {
+
+    public BlockHardenedClayTilesStairs() {
+        super("hardened_clay_tiles_stairs", HMBlocks.hardened_clay_tiles.getDefaultState());
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidoriPillar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidoriPillar.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidoriPillar.java	(date 1525606884000)
@@ -0,0 +1,28 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [29/06/2016, 17:28:26 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.blocks.base.BlockModPillar;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+
+public class BlockMidoriPillar extends BlockModPillar {
+
+    public BlockMidoriPillar() {
+        super("midori_pillar", Material.ROCK);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/tileentity/TileCustomChest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/tileentity/TileCustomChest.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/tileentity/TileCustomChest.java	(date 1523987837000)
@@ -0,0 +1,164 @@
+package net.hdt.neutronia.tileentity;
+
+import net.hdt.neutronia.properties.ChestType;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockChest;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.NetworkManager;
+import net.minecraft.network.play.server.SPacketUpdateTileEntity;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraftforge.common.capabilities.Capability;
+import net.minecraftforge.items.CapabilityItemHandler;
+import net.minecraftforge.items.VanillaDoubleChestItemHandler;
+
+import javax.annotation.Nullable;
+
+public class TileCustomChest extends TileEntityChest {
+
+    public ChestType chestType = ChestType.NONE;
+
+    // Copied from VanillaDoubleChestItemHandler
+    @Nullable
+    public static VanillaDoubleChestItemHandler getDoubleChestHandler(TileCustomChest chest) {
+        World world = chest.getWorld();
+        BlockPos pos = chest.getPos();
+        if (!world.isBlockLoaded(pos))
+            return null; // Still loading
+
+        Block blockType = chest.getBlockType();
+
+        EnumFacing[] horizontals = EnumFacing.HORIZONTALS;
+        for (int i = horizontals.length - 1; i >= 0; i--) { // Use reverse order so we can return early
+            EnumFacing enumfacing = horizontals[i];
+            BlockPos blockpos = pos.offset(enumfacing);
+            Block block = world.getBlockState(blockpos).getBlock();
+
+            if (block == blockType) {
+                TileEntity otherTE = world.getTileEntity(blockpos);
+
+                if (otherTE instanceof TileCustomChest) {
+                    TileCustomChest otherChest = (TileCustomChest) otherTE;
+                    if (otherChest.chestType.equals(chest.chestType))
+                        return new VanillaDoubleChestItemHandler(chest, otherChest, enumfacing != EnumFacing.WEST && enumfacing != EnumFacing.NORTH);
+                }
+            }
+        }
+        return VanillaDoubleChestItemHandler.NO_ADJACENT_CHESTS_INSTANCE; // All alone
+    }
+
+    @Override
+    public NBTTagCompound writeToNBT(NBTTagCompound nbt) {
+        super.writeToNBT(nbt);
+        nbt.setString("type", chestType.name);
+        return nbt;
+    }
+
+    @Override
+    public NBTTagCompound getUpdateTag() {
+        NBTTagCompound nbt = super.getUpdateTag();
+        nbt.setString("type", chestType.name);
+        return nbt;
+    }
+
+    @Override
+    public void handleUpdateTag(NBTTagCompound tag) {
+        super.handleUpdateTag(tag);
+        chestType = ChestType.getType(tag.getString("type"));
+    }
+
+    @Override
+    public boolean shouldRefresh(World world, BlockPos pos, IBlockState oldState, IBlockState newState) {
+        return oldState.getBlock() != newState.getBlock();
+    }
+
+    @Nullable
+    @Override
+    public SPacketUpdateTileEntity getUpdatePacket() {
+        NBTTagCompound nbt = new NBTTagCompound();
+        nbt.setString("type", chestType.name);
+        return new SPacketUpdateTileEntity(pos, getBlockMetadata(), nbt);
+    }
+
+    @Override
+    public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity pkt) {
+        chestType = ChestType.getType(pkt.getNbtCompound().getString("type"));
+    }
+
+    @Override
+    public void readFromNBT(NBTTagCompound nbt) {
+        super.readFromNBT(nbt);
+        chestType = ChestType.getType(nbt.getString("type"));
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    private void setNeighbor(TileEntityChest chestTe, EnumFacing side) {
+        if (chestTe.isInvalid()) {
+            adjacentChestChecked = false;
+        } else if (adjacentChestChecked) {
+            switch (side) {
+                case NORTH:
+                    if (adjacentChestZNeg != chestTe)
+                        adjacentChestChecked = false;
+                    break;
+                case SOUTH:
+                    if (adjacentChestZPos != chestTe)
+                        adjacentChestChecked = false;
+                    break;
+                case EAST:
+                    if (adjacentChestXPos != chestTe)
+                        adjacentChestChecked = false;
+                    break;
+                case WEST:
+                    if (adjacentChestXNeg != chestTe)
+                        adjacentChestChecked = false;
+            }
+        }
+    }
+
+    @Nullable
+    @Override
+    protected TileEntityChest getAdjacentChest(EnumFacing side) {
+        BlockPos blockpos = pos.offset(side);
+
+        if (isChestAt(blockpos)) {
+            TileEntity tileentity = getWorld().getTileEntity(blockpos);
+
+            if (tileentity instanceof TileCustomChest) {
+                TileCustomChest tileentitychest = (TileCustomChest) tileentity;
+                tileentitychest.setNeighbor(this, side.getOpposite());
+                return tileentitychest;
+            }
+        }
+
+        return null;
+    }
+
+    private boolean isChestAt(BlockPos posIn) {
+        Block block = getWorld().getBlockState(posIn).getBlock();
+        TileEntity te = getWorld().getTileEntity(posIn);
+        return block instanceof BlockChest && ((BlockChest) block).chestType == getChestType() && te instanceof TileCustomChest && ((TileCustomChest) te).chestType == chestType;
+    }
+
+    @Override
+    public AxisAlignedBB getRenderBoundingBox() {
+        return new AxisAlignedBB(pos.getX() - 1, pos.getY(), pos.getZ() - 1, pos.getX() + 2, pos.getY() + 2, pos.getZ() + 2);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T getCapability(Capability<T> capability, @Nullable EnumFacing facing) {
+        if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {
+            if (doubleChestHandler == null || doubleChestHandler.needsRefresh())
+                doubleChestHandler = getDoubleChestHandler(this);
+            if (doubleChestHandler != null && doubleChestHandler != VanillaDoubleChestItemHandler.NO_ADJACENT_CHESTS_INSTANCE)
+                return (T) doubleChestHandler;
+        }
+        return super.getCapability(capability, facing);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanks.java	(date 1523987840000)
+++ src/main/java/net/hdt/neutronia/blocks/overworld/BlockStainedPlanks.java	(date 1523987840000)
@@ -0,0 +1,39 @@
+package net.hdt.neutronia.blocks.overworld;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockStainedPlanks extends BlockMetaVariants implements IModBlock {
+
+    public BlockStainedPlanks() {
+        super("dyed_planks", Reference.MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements EnumBase {
+        STAINED_PLANKS_WHITE,
+        STAINED_PLANKS_ORANGE,
+        STAINED_PLANKS_MAGENTA,
+        STAINED_PLANKS_LIGHT_BLUE,
+        STAINED_PLANKS_YELLOW,
+        STAINED_PLANKS_LIME,
+        STAINED_PLANKS_PINK,
+        STAINED_PLANKS_GRAY,
+        STAINED_PLANKS_SILVER,
+        STAINED_PLANKS_CYAN,
+        STAINED_PLANKS_PURPLE,
+        STAINED_PLANKS_BLUE,
+        STAINED_PLANKS_BROWN,
+        STAINED_PLANKS_GREEN,
+        STAINED_PLANKS_RED,
+        STAINED_PLANKS_BLACK
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidori.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidori.java	(date 1525606878000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMidori.java	(date 1525606878000)
@@ -0,0 +1,31 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [29/06/2016, 17:39:08 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockMidori extends BlockMod implements IModBlock {
+
+    public BlockMidori() {
+        super(Material.ROCK, MOD_ID, "midori_block");
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/utils/WorldGenerationTools.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/utils/WorldGenerationTools.java	(date 1523986190000)
+++ src/main/java/net/hdt/neutronia/world/utils/WorldGenerationTools.java	(date 1523986190000)
@@ -0,0 +1,76 @@
+package net.hdt.neutronia.world.utils;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+public class WorldGenerationTools {
+
+    public static int findUpsideDownEmptySpot(World world, int x, int z) {
+        for (int y = 90; y > 0; y--) {
+            if (world.isAirBlock(new BlockPos(x, y, z)) && world.isAirBlock(new BlockPos(x, y + 1, z)) && world.isAirBlock(new BlockPos(x, y + 2, z))
+                    && world.isAirBlock(new BlockPos(x, y + 3, z)) && world.isAirBlock(new BlockPos(x, y + 4, z))) {
+                return y;
+            }
+        }
+        return -1;
+    }
+
+
+    public static int findSuitableEmptySpot(World world, int x, int z) {
+        int y = world.getTopSolidOrLiquidBlock(new BlockPos(x, 0, z)).getY();
+        if (y == -1) {
+            return -1;
+        }
+
+        y--;            // y should now be at a solid or liquid animation.animations.blocks.
+
+        if (y > world.getHeight() - 5) {
+            y = world.getHeight() / 2;
+        }
+
+
+        IBlockState state = world.getBlockState(new BlockPos(x, y + 1, z));
+        Block block = state.getBlock();
+        while (block.getMaterial(state).isLiquid()) {
+            y++;
+            if (y > world.getHeight() - 10) {
+                return -1;
+            }
+            state = world.getBlockState(new BlockPos(x, y + 1, z));
+            block = state.getBlock();
+        }
+
+        return y;
+    }
+
+    // Return true if this animation.animations.blocks is solid.
+    public static boolean isSolid(World world, int x, int y, int z) {
+        if (world.isAirBlock(new BlockPos(x, y, z))) {
+            return false;
+        }
+        IBlockState state = world.getBlockState(new BlockPos(x, y, z));
+        Block block = state.getBlock();
+        return block.getMaterial(state).blocksMovement();
+    }
+
+    // Return true if this animation.animations.blocks is solid.
+    public static boolean isAir(World world, int x, int y, int z) {
+        if (world.isAirBlock(new BlockPos(x, y, z))) {
+            return true;
+        }
+        Block block = world.getBlockState(new BlockPos(x, y, z)).getBlock();
+        return block == null;
+    }
+
+    // Starting at the current height, go down and fill all air animations.blocks with stone until a
+    // non-air animation.animations.blocks is encountered.
+    public static void fillEmptyWithStone(World world, int x, int y, int z) {
+        while (y > 0 && !isSolid(world, x, y, z)) {
+            world.setBlockState(new BlockPos(x, y, z), Blocks.STONE.getDefaultState(), 2);
+            y--;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeRedDesert.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeRedDesert.java	(date 1523986190000)
+++ src/main/java/net/hdt/neutronia/world/biome/overworld/BiomeRedDesert.java	(date 1523986190000)
@@ -0,0 +1,54 @@
+package net.hdt.neutronia.world.biome.overworld;
+
+import net.minecraft.block.BlockSand;
+import net.minecraft.entity.monster.EntityHusk;
+import net.minecraft.entity.monster.EntityZombie;
+import net.minecraft.entity.monster.EntityZombieVillager;
+import net.minecraft.entity.passive.EntityRabbit;
+import net.minecraft.init.Biomes;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.gen.feature.WorldGenDesertWells;
+import net.minecraft.world.gen.feature.WorldGenFossils;
+
+import java.util.Random;
+
+public class BiomeRedDesert extends Biome {
+
+    public BiomeRedDesert() {
+        super((new Biome.BiomeProperties("Red Desert")).setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled().setBaseBiome(Biomes.DESERT.getBiomeName()));
+        this.spawnableCreatureList.clear();
+        this.topBlock = Blocks.SAND.getDefaultState().withProperty(BlockSand.VARIANT, BlockSand.EnumType.RED_SAND);
+        this.fillerBlock = Blocks.SAND.getDefaultState().withProperty(BlockSand.VARIANT, BlockSand.EnumType.RED_SAND);
+        this.decorator.treesPerChunk = -999;
+        this.decorator.deadBushPerChunk = 2;
+        this.decorator.reedsPerChunk = 50;
+        this.decorator.cactiPerChunk = 10;
+        this.spawnableCreatureList.clear();
+        this.spawnableCreatureList.add(new Biome.SpawnListEntry(EntityRabbit.class, 4, 2, 3));
+
+        this.spawnableMonsterList.removeIf(biome$spawnlistentry -> biome$spawnlistentry.entityClass == EntityZombie.class || biome$spawnlistentry.entityClass == EntityZombieVillager.class);
+
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombie.class, 19, 4, 4));
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombieVillager.class, 1, 1, 1));
+        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityHusk.class, 80, 4, 4));
+    }
+
+    public void decorate(World worldIn, Random rand, BlockPos pos) {
+        super.decorate(worldIn, rand, pos);
+        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.DESERT_WELL))
+            if (rand.nextInt(1000) == 0) {
+                int i = rand.nextInt(16) + 8;
+                int j = rand.nextInt(16) + 8;
+                BlockPos blockpos = worldIn.getHeight(pos.add(i, 0, j)).up();
+                (new WorldGenDesertWells()).generate(worldIn, rand, blockpos);
+            }
+
+        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.FOSSIL))
+            if (rand.nextInt(64) == 0) {
+                (new WorldGenFossils()).generate(worldIn, rand, pos);
+            }
+    }
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockEndLog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockEndLog.java	(date 1524853001000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockEndLog.java	(date 1524853001000)
@@ -0,0 +1,116 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockEndLog extends BlockLogEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class, type -> type.ordinal() < 4);
+
+    public BlockEndLog()
+    {
+        super("end_log", Material.WOOD);
+        setDefaultState(blockState.getBaseState().withProperty(AXIS, EnumAxis.Y));
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected ItemStack getSilkTouchDrop(IBlockState state)
+    {
+        return new ItemStack(Item.getItemFromBlock(this), 1, state.getValue(TYPE).ordinal());
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        IBlockState state = getDefaultState().withProperty(TYPE, EnumType.fromMeta((meta & 3) % 4));
+
+        switch(meta & 12)
+        {
+            case 0:
+                state = state.withProperty(AXIS, EnumAxis.Y);
+                break;
+            case 4:
+                state = state.withProperty(AXIS, EnumAxis.X);
+                break;
+            case 8:
+                state = state.withProperty(AXIS, EnumAxis.Z);
+                break;
+            default:
+                state = state.withProperty(AXIS, EnumAxis.NONE);
+        }
+
+        return state;
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        int i = 0;
+        i = i | state.getValue(TYPE).ordinal();
+
+        switch(state.getValue(AXIS))
+        {
+            case X:
+                i |= 4;
+                break;
+            case Z:
+                i |= 8;
+                break;
+            case NONE:
+                i |= 12;
+        }
+
+        return i;
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE, AXIS);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        ENDPALM;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherBase.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherBase.java	(date 1523987837000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+public class BlockNetherBase extends BlockMod {
+
+    public BlockNetherBase(Material material, String name) {
+        super(material, Reference.MOD_ID, name);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModTrapdoor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModTrapdoor.java	(date 1523987837000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModTrapdoor.java	(date 1523987837000)
@@ -0,0 +1,85 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockTrapDoor;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class BlockModTrapdoor extends BlockTrapDoor implements IModBlock {
+
+    private final String[] variants;
+    private final String bareName;
+
+    public BlockModTrapdoor(String name) {
+        super(Material.WOOD);
+
+        setHardness(3.0F);
+        setSoundType(SoundType.WOOD);
+
+        variants = new String[]{name};
+        bareName = name;
+
+        setUnlocalizedName(name);
+        useNeighborBrightness = true;
+    }
+
+    @Override
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(new ItemModBlock(this, new ResourceLocation(getPrefix(), name)));
+        return this;
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public String getPrefix() {
+        return Reference.MOD_ID;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[0];
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockColoredAlt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockColoredAlt.java	(date 1524922826000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockColoredAlt.java	(date 1524922826000)
@@ -0,0 +1,85 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.client.renderer.color.IBlockColor;
+import net.minecraft.client.renderer.color.IItemColor;
+import net.minecraft.item.EnumDyeColor;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IBlockColorProvider;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockColoredAlt extends BlockMod implements IBlockColorProvider, IModBlock {
+
+    public final EnumDyeColor color;
+    private String modid;
+
+    public BlockColoredAlt(String modid, String name, EnumDyeColor color) {
+        super(Material.ROCK, modid, color.getName() + "_" + name);
+        this.color = color;
+        this.modid = modid;
+    }
+
+    /*private static TextFormatting getFromColor(EnumDyeColor color) {
+        switch (color) {
+            case ORANGE:
+                return TextFormatting.GOLD;
+            case MAGENTA:
+                return TextFormatting.LIGHT_PURPLE;
+            case LIGHT_BLUE:
+                return TextFormatting.BLUE;
+            case YELLOW:
+                return TextFormatting.YELLOW;
+            case LIME:
+                return TextFormatting.GREEN;
+            case PINK:
+                return TextFormatting.LIGHT_PURPLE;
+            case GRAY:
+                return TextFormatting.DARK_GRAY;
+            case SILVER:
+                return TextFormatting.GRAY;
+            case CYAN:
+                return TextFormatting.DARK_AQUA;
+            case PURPLE:
+                return TextFormatting.DARK_PURPLE;
+            case BLUE:
+                return TextFormatting.DARK_BLUE;
+            case BROWN:
+                return TextFormatting.GOLD;
+            case GREEN:
+                return TextFormatting.DARK_GREEN;
+            case RED:
+                return TextFormatting.DARK_RED;
+            case BLACK:
+                return TextFormatting.BLACK;
+            default:
+                return TextFormatting.WHITE;
+        }
+    }
+
+    @Override
+    public String getModNamespace() {
+        return modid;
+    }
+
+    @Override
+    public void addInformation(ItemStack stack, @Nullable World player, List<String> tooltip, ITooltipFlag advanced) {
+        if (!GuiScreen.isShiftKeyDown()) {
+            tooltip.add("Hold " + TextFormatting.BOLD + getFromColor(color) + "SHIFT " + TextFormatting.GRAY + "for more information");
+        } else {
+            String colorName = color.getName().replace("_", " ");
+            colorName = WordUtils.capitalize(colorName);
+            tooltip.add("Color: " + TextFormatting.BOLD.toString() + getFromColor(color).toString() + colorName);
+        }
+    }*/
+
+    @Override
+    public IBlockColor getBlockColor() {
+        return (state, worldIn, pos, tintIndex) -> EnumDyeColor.values()[tintIndex].getColorValue();
+    }
+
+    @Override
+    public IItemColor getItemColor() {
+        return (stack, tintIndex) -> EnumDyeColor.values()[tintIndex].getColorValue();
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/features/Thatch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/Thatch.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/Thatch.java	(date 1525606900000)
@@ -0,0 +1,55 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [20/03/2016, 22:49:30 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockThatch;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockThatchSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockThatchStairs;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class Thatch extends Feature {
+
+    public static Block thatch;
+    public static float fallDamageMultiplier;
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        fallDamageMultiplier = (float) loadPropDouble("Fall damage multiplier", "", 0.5);
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        thatch = new BlockThatch();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(thatch, 0, new BlockThatchStairs());
+            BlockModSlab.initSlab(thatch, 0, new BlockThatchSlab(false), new BlockThatchSlab(true));
+        }
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(thatch),
+				"WW", "WW",
+				'W', ProxyRegistry.newStack(Items.WHEAT));
+		RecipeHandler.addShapelessOreDictRecipe(ProxyRegistry.newStack(Items.WHEAT, 4), ProxyRegistry.newStack(thatch));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMagmaBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMagmaBricks.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockMagmaBricks.java	(date 1525606884000)
@@ -0,0 +1,45 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockMagmaBricks extends BlockMod implements IModBlock {
+
+    public BlockMagmaBricks() {
+        super(Material.ROCK, MOD_ID, "magma_bricks");
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+        setLightLevel(0.2F);
+    }
+
+    @Override
+    public boolean isFireSource(World world, BlockPos pos, EnumFacing side) {
+        return true;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+    @Override
+    public boolean canEntitySpawn(IBlockState state, Entity entityIn) {
+        return entityIn.isImmuneToFire();
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockIronPlate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockIronPlate.java	(date 1525606885000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockIronPlate.java	(date 1525606885000)
@@ -0,0 +1,36 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [30/06/2016, 14:42:34 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockIronPlate extends BlockMetaVariants implements IModBlock {
+
+    public BlockIronPlate() {
+        super("iron_plate", MOD_ID, Material.IRON, Variants.class);
+        setHardness(5.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.METAL);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+        IRON_PLATE,
+        RUSTY_IRON_PLATE
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockHardenedClayTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockHardenedClayTiles.java	(date 1525606886000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockHardenedClayTiles.java	(date 1525606886000)
@@ -0,0 +1,40 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [19/03/2016, 01:27:27 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.MapColor;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockHardenedClayTiles extends BlockMod implements IModBlock {
+
+    public BlockHardenedClayTiles() {
+        super(Material.ROCK, MOD_ID, "hardened_clay_tiles");
+        setHardness(1.25F);
+        setResistance(7.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    @Override
+    public MapColor getMapColor(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return MapColor.ADOBE;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskboundLantern.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskboundLantern.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskboundLantern.java	(date 1525606882000)
@@ -0,0 +1,20 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockDuskboundLantern extends BlockOverworldBase implements IModBlock {
+
+    public BlockDuskboundLantern() {
+        super(Material.ROCK, "duskbound_lantern");
+        setLightLevel(1.0F);
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/idk/InvalidConfigException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/idk/InvalidConfigException.java	(date 1525606898000)
+++ src/main/java/net/hdt/neutronia/util/idk/InvalidConfigException.java	(date 1525606898000)
@@ -0,0 +1,26 @@
+package net.hdt.neutronia.util.idk;
+
+import net.hdt.neutronia.Main;
+
+public class InvalidConfigException extends Exception {
+
+    public InvalidConfigException(String cause) {
+        super(cause);
+    }
+
+    public void printException() {
+        Main.LOGGER.error(this.getMessage());
+        for (int i = 0; i < this.getStackTrace().length; i++) {
+            StackTraceElement element = this.getStackTrace()[i];
+            Main.LOGGER.error(element.toString());
+
+            if (i >= 10) {
+                Main.LOGGER.error((this.getStackTrace().length - 10) + " more...");
+                break;
+            }
+        }
+
+        Main.LOGGER.info("");
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskbound.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskbound.java	(date 1525606880000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockDuskbound.java	(date 1525606880000)
@@ -0,0 +1,21 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockDuskbound extends BlockMod implements IModBlock {
+
+    public BlockDuskbound() {
+        super(Material.ROCK, MOD_ID, "duskbound_block");
+        setHardness(1.5F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Cluster.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Cluster.java	(date 1525606871000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Cluster.java	(date 1525606871000)
@@ -0,0 +1,56 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import java.util.ArrayList;
+
+/* Cluster is spawn unit. All structures must be spawned simultaneously. */
+class Cluster {
+
+    private double chance = 0;
+    private String name = "";
+    private ArrayList<Structure> structures = new ArrayList<Structure>();
+
+    /* Construct empty cluster with given name */
+    public Cluster(String name) {
+        this.name = name;
+    }
+
+    /* Construct new cluster as copy of another */
+    public Cluster(Cluster cluster) {
+        this.chance = cluster.getChance();
+        this.name = cluster.getName();
+        this.structures.addAll(cluster.getStructures());
+    }
+
+    /* Add given structure to cluster */
+    public Cluster add(Structure structure) {
+        structures.add(structure);
+        return this;
+    }
+
+    /* Add all structures to cluster */
+    public Cluster add(ArrayList<Structure> structures) {
+        this.structures.addAll(structures);
+        return this;
+    }
+
+    double getChance() {
+        return chance;
+    }
+
+    void setChance(double chance) {
+        this.chance = chance;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getSign() {
+        return structures.size() == 1 ? structures.get(0).schematicFile.getPath() : name;
+    }
+
+    ArrayList<Structure> getStructures() {
+        return structures;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/entity/render/model/ModelScorp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/model/ModelScorp.java	(date 1523986170000)
+++ src/main/java/net/hdt/neutronia/entity/render/model/ModelScorp.java	(date 1523986170000)
@@ -0,0 +1,94 @@
+package net.hdt.neutronia.entity.render.model;
+
+import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelRenderer;
+import net.minecraft.entity.Entity;
+
+/**
+ * ModelSpider - Either Mojang or a mod author
+ * Created using Tabula 7.0.0
+ */
+public class ModelScorp extends ModelBase {
+
+    public ModelRenderer field_78210_j;
+    public ModelRenderer field_78209_a;
+    public ModelRenderer field_78208_c;
+    public ModelRenderer field_78206_e;
+    public ModelRenderer field_78204_g;
+    public ModelRenderer field_78213_i;
+    public ModelRenderer field_78211_k;
+    public ModelRenderer field_78203_f;
+    private ModelRenderer field_78207_b;
+    private ModelRenderer field_78205_d;
+    private ModelRenderer field_78212_h;
+
+    public ModelScorp() {
+        this.textureWidth = 64;
+        this.textureHeight = 32;
+        this.field_78210_j = new ModelRenderer(this, 18, 0);
+        this.field_78210_j.setRotationPoint(-4.0F, 15.0F, -1.0F);
+        this.field_78210_j.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78210_j, 0.0F, -0.7853981852531433F, -0.7853981852531433F);
+        this.field_78209_a = new ModelRenderer(this, 32, 4);
+        this.field_78209_a.setRotationPoint(0.0F, 15.0F, -3.0F);
+        this.field_78209_a.addBox(-4.0F, -4.0F, -8.0F, 8, 8, 8, 0.0F);
+        this.field_78211_k = new ModelRenderer(this, 18, 0);
+        this.field_78211_k.setRotationPoint(4.0F, 15.0F, -1.0F);
+        this.field_78211_k.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78211_k, 0.0F, 0.7853981852531433F, 0.7853981852531433F);
+        this.field_78213_i = new ModelRenderer(this, 18, 0);
+        this.field_78213_i.setRotationPoint(4.0F, 15.0F, 0.0F);
+        this.field_78213_i.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78213_i, 0.0F, 0.39269909262657166F, 0.5811946392059326F);
+        this.field_78205_d = new ModelRenderer(this, 18, 0);
+        this.field_78205_d.setRotationPoint(-4.0F, 15.0F, 2.0F);
+        this.field_78205_d.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78205_d, 0.0F, 0.7853981852531433F, -0.7853981852531433F);
+        this.field_78203_f = new ModelRenderer(this, 18, 0);
+        this.field_78203_f.setRotationPoint(-4.0F, 15.0F, 1.0F);
+        this.field_78203_f.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78203_f, 0.0F, 0.39269909262657166F, -0.5811946392059326F);
+        this.field_78212_h = new ModelRenderer(this, 18, 0);
+        this.field_78212_h.setRotationPoint(-4.0F, 15.0F, 0.0F);
+        this.field_78212_h.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78212_h, 0.0F, -0.39269909262657166F, -0.5811946392059326F);
+        this.field_78206_e = new ModelRenderer(this, 18, 0);
+        this.field_78206_e.setRotationPoint(4.0F, 15.0F, 2.0F);
+        this.field_78206_e.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78206_e, 0.0F, -0.7853981852531433F, 0.7853981852531433F);
+        this.field_78207_b = new ModelRenderer(this, 0, 0);
+        this.field_78207_b.setRotationPoint(0.0F, 15.0F, 0.0F);
+        this.field_78207_b.addBox(-3.0F, -3.0F, -3.0F, 6, 6, 6, 0.0F);
+        this.field_78208_c = new ModelRenderer(this, 0, 12);
+        this.field_78208_c.setRotationPoint(0.0F, 15.0F, 9.0F);
+        this.field_78208_c.addBox(-5.0F, -4.0F, -6.0F, 10, 8, 12, 0.0F);
+        this.field_78204_g = new ModelRenderer(this, 18, 0);
+        this.field_78204_g.setRotationPoint(4.0F, 15.0F, 1.0F);
+        this.field_78204_g.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
+        this.setRotateAngle(field_78204_g, 0.0F, -0.39269909262657166F, 0.5811946392059326F);
+    }
+
+    @Override
+    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
+        this.field_78210_j.render(f5);
+        this.field_78209_a.render(f5);
+        this.field_78211_k.render(f5);
+        this.field_78213_i.render(f5);
+        this.field_78205_d.render(f5);
+        this.field_78203_f.render(f5);
+        this.field_78212_h.render(f5);
+        this.field_78206_e.render(f5);
+        this.field_78207_b.render(f5);
+        this.field_78208_c.render(f5);
+        this.field_78204_g.render(f5);
+    }
+
+    /**
+     * This is a helper function from Tabula to set the rotation of model parts
+     */
+    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
+        modelRenderer.rotateAngleX = x;
+        modelRenderer.rotateAngleY = y;
+        modelRenderer.rotateAngleZ = z;
+    }
+}
Index: src/main/java/net/hdt/neutronia/world/gen/ChunkGeneratorHellBOP.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/ChunkGeneratorHellBOP.java	(date 1525606895000)
+++ src/main/java/net/hdt/neutronia/world/gen/ChunkGeneratorHellBOP.java	(date 1525606895000)
@@ -0,0 +1,512 @@
+/*******************************************************************************
+ * Copyright 2014-2017, the Biomes O' Plenty Team
+ *
+ * This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License.
+ *
+ * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.
+ ******************************************************************************/
+package net.hdt.neutronia.world.gen;
+
+import net.minecraft.block.BlockFalling;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.block.state.pattern.BlockMatcher;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkPrimer;
+import net.minecraft.world.gen.*;
+import net.minecraft.world.gen.feature.*;
+import net.minecraft.world.gen.structure.MapGenNetherBridge;
+import net.minecraftforge.common.ForgeModContainer;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.ForgeEventFactory;
+import net.minecraftforge.event.terraingen.*;
+import net.minecraftforge.fml.common.eventhandler.Event;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Random;
+
+public class ChunkGeneratorHellBOP implements IChunkGenerator {
+    protected static final IBlockState AIR = Blocks.AIR.getDefaultState();
+    protected static final IBlockState NETHERRACK = Blocks.NETHERRACK.getDefaultState();
+    protected static final IBlockState BEDROCK = Blocks.BEDROCK.getDefaultState();
+    protected static final IBlockState LAVA = Blocks.LAVA.getDefaultState();
+    protected static final IBlockState GRAVEL = Blocks.GRAVEL.getDefaultState();
+    protected static final IBlockState SOUL_SAND = Blocks.SOUL_SAND.getDefaultState();
+    private final World world;
+    private final boolean generateStructures;
+    private final Random rand;
+    private final WorldGenFire fireFeature = new WorldGenFire();
+    private final WorldGenGlowStone1 lightGemGen = new WorldGenGlowStone1();
+    private final WorldGenGlowStone2 hellPortalGen = new WorldGenGlowStone2();
+    private final WorldGenerator quartzGen = new WorldGenMinable(Blocks.QUARTZ_ORE.getDefaultState(), 14, BlockMatcher.forBlock(Blocks.NETHERRACK));
+    private final WorldGenerator magmaGen = new WorldGenMinable(Blocks.MAGMA.getDefaultState(), 33, BlockMatcher.forBlock(Blocks.NETHERRACK));
+    private final WorldGenHellLava lavaTrapGen = new WorldGenHellLava(Blocks.FLOWING_LAVA, true);
+    private final WorldGenHellLava hellSpringGen = new WorldGenHellLava(Blocks.FLOWING_LAVA, false);
+    private final WorldGenBush brownMushroomFeature = new WorldGenBush(Blocks.BROWN_MUSHROOM);
+    private final WorldGenBush redMushroomFeature = new WorldGenBush(Blocks.RED_MUSHROOM);
+    public NoiseGeneratorOctaves scaleNoise;
+    public NoiseGeneratorOctaves depthNoise;
+    private double[] slowsandNoise = new double[256];
+    private double[] gravelNoise = new double[256];
+    private double[] depthBuffer = new double[256];
+    private double[] noiseArray;
+    private NoiseGeneratorOctaves lperlinNoise1;
+    private NoiseGeneratorOctaves lperlinNoise2;
+    private NoiseGeneratorOctaves perlinNoise1;
+    private NoiseGeneratorOctaves slowsandGravelNoiseGen;
+    private NoiseGeneratorOctaves netherrackExculsivityNoiseGen;
+    private NoiseGeneratorPerlin stoneNoiseGen;
+    private MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
+    private MapGenBase genNetherCaves = new MapGenCavesHell();
+    private double[] xyzBalanceNoiseArray;
+    private double[] xyzNoiseArrayA;
+    private double[] xyzNoiseArrayB;
+    private double[] noiseData4;
+    private double[] depthRegion;
+    private double[] stoneNoiseArray;
+
+    public ChunkGeneratorHellBOP(World worldIn, boolean p_i45637_2_, long seed) {
+        this.world = worldIn;
+        this.generateStructures = p_i45637_2_;
+        this.rand = new Random(seed);
+        this.lperlinNoise1 = new NoiseGeneratorOctaves(this.rand, 16);
+        this.lperlinNoise2 = new NoiseGeneratorOctaves(this.rand, 16);
+        this.perlinNoise1 = new NoiseGeneratorOctaves(this.rand, 8);
+        this.slowsandGravelNoiseGen = new NoiseGeneratorOctaves(this.rand, 4);
+        this.netherrackExculsivityNoiseGen = new NoiseGeneratorOctaves(this.rand, 4);
+        this.scaleNoise = new NoiseGeneratorOctaves(this.rand, 10);
+        this.depthNoise = new NoiseGeneratorOctaves(this.rand, 16);
+        this.stoneNoiseGen = new NoiseGeneratorPerlin(this.rand, 4);
+        worldIn.setSeaLevel(63);
+
+        net.minecraftforge.event.terraingen.InitNoiseGensEvent.ContextHell ctx =
+                new net.minecraftforge.event.terraingen.InitNoiseGensEvent.ContextHell(lperlinNoise1, lperlinNoise2, perlinNoise1, slowsandGravelNoiseGen, netherrackExculsivityNoiseGen, scaleNoise, depthNoise);
+        ctx = net.minecraftforge.event.terraingen.TerrainGen.getModdedNoiseGenerators(worldIn, this.rand, ctx);
+        this.lperlinNoise1 = ctx.getLPerlin1();
+        this.lperlinNoise2 = ctx.getLPerlin2();
+        this.perlinNoise1 = ctx.getPerlin();
+        this.slowsandGravelNoiseGen = ctx.getPerlin2();
+        this.netherrackExculsivityNoiseGen = ctx.getPerlin3();
+        this.scaleNoise = ctx.getScale();
+        this.depthNoise = ctx.getDepth();
+
+        this.stoneNoiseArray = new double[256];
+
+        this.genNetherBridge = (MapGenNetherBridge) net.minecraftforge.event.terraingen.TerrainGen.getModdedMapGen(genNetherBridge, net.minecraftforge.event.terraingen.InitMapGenEvent.EventType.NETHER_BRIDGE);
+        this.genNetherCaves = net.minecraftforge.event.terraingen.TerrainGen.getModdedMapGen(genNetherCaves, net.minecraftforge.event.terraingen.InitMapGenEvent.EventType.NETHER_CAVE);
+    }
+
+    public void setChunkLavaNetherrack(int chunkX, int chunkZ, ChunkPrimer primer) {
+        int seaLevel = this.world.getSeaLevel() / 2 + 1;
+        this.noiseArray = this.getHeights(this.noiseArray, chunkX * 4, 0, chunkZ * 4, 5, 17, 5);
+
+        double oneEighth = 0.125D;
+        double oneQuarter = 0.25D;
+
+        // entire chunk is 16x128x16
+        // process chunk in subchunks, each one 4x8x4 blocks in size
+        // 4 subchunks in x direction, each 4 blocks long
+        // 16 subchunks in y direction, each 8 blocks long
+        // 4 subchunks in z direction, each 4 blocks long
+        // for a total of 256 subchunks
+
+        // divide chunk into 4 subchunks in x direction, index as ix
+        for (int ix = 0; ix < 4; ++ix) {
+            int k_x0 = ix * 5;
+            int k_x1 = (ix + 1) * 5;
+
+            // divide chunk into 4 subchunks in z direction, index as iz
+            for (int iz = 0; iz < 4; ++iz) {
+                int k_x0z0 = (k_x0 + iz) * 17;
+                int k_x0z1 = (k_x0 + iz + 1) * 17;
+                int k_x1z0 = (k_x1 + iz) * 17;
+                int k_x1z1 = (k_x1 + iz + 1) * 17;
+
+                // divide chunk into 16 subchunks in y direction, index as iy
+                for (int iy = 0; iy < 16; ++iy) {
+                    // get the noise values from the noise array
+                    // these are the values at the corners of the subchunk
+                    double n_x0y0z0 = this.noiseArray[k_x0z0 + iy];
+                    double n_x0y0z1 = this.noiseArray[k_x0z1 + iy];
+                    double n_x1y0z0 = this.noiseArray[k_x1z0 + iy];
+                    double n_x1y0z1 = this.noiseArray[k_x1z1 + iy];
+                    double n_x0y1z0 = this.noiseArray[k_x0z0 + iy + 1];
+                    double n_x0y1z1 = this.noiseArray[k_x0z1 + iy + 1];
+                    double n_x1y1z0 = this.noiseArray[k_x1z0 + iy + 1];
+                    double n_x1y1z1 = this.noiseArray[k_x1z1 + iy + 1];
+
+                    // linearly interpolate between the noise points to get a noise value for each block in the subchunk
+
+                    double noiseStepY00 = (n_x0y1z0 - n_x0y0z0) * oneEighth;
+                    double noiseStepY01 = (n_x0y1z1 - n_x0y0z1) * oneEighth;
+                    double noiseStepY10 = (n_x1y1z0 - n_x1y0z0) * oneEighth;
+                    double noiseStepY11 = (n_x1y1z1 - n_x1y0z1) * oneEighth;
+
+                    double noiseStartX0 = n_x0y0z0;
+                    double noiseStartX1 = n_x0y0z1;
+                    double noiseEndX0 = n_x1y0z0;
+                    double noiseEndX1 = n_x1y0z1;
+
+                    // subchunk is 8 blocks high in y direction, index as jy
+                    for (int jy = 0; jy < 8; ++jy) {
+                        double noiseStartZ = noiseStartX0;
+                        double noiseEndZ = noiseStartX1;
+
+                        double noiseStepX0 = (noiseEndX0 - noiseStartX0) * oneQuarter;
+                        double noiseStepX1 = (noiseEndX1 - noiseStartX1) * oneQuarter;
+
+                        // subchunk is 4 blocks long in x direction, index as jx
+                        for (int jx = 0; jx < 4; ++jx) {
+                            double noiseStepZ = (noiseEndZ - noiseStartZ) * oneQuarter;
+                            double noiseVal = noiseStartZ;
+
+                            // subchunk is 4 blocks long in x direction, index as jz
+                            for (int jz = 0; jz < 4; ++jz) {
+                                // If the noise value is above zero, this block starts as netherrack
+                                // Otherwise it's 'empty' - air above sealevel and lava below it
+                                if (noiseVal > 0.0D) {
+                                    primer.setBlockState(ix * 4 + jx, iy * 8 + jy, iz * 4 + jz, NETHERRACK);
+                                } else if (iy * 8 + jy < seaLevel) {
+                                    primer.setBlockState(ix * 4 + jx, iy * 8 + jy, iz * 4 + jz, LAVA);
+                                }
+                                noiseVal += noiseStepZ;
+                            }
+
+                            noiseStartZ += noiseStepX0;
+                            noiseEndZ += noiseStepX1;
+                        }
+
+                        noiseStartX0 += noiseStepY00;
+                        noiseStartX1 += noiseStepY01;
+                        noiseEndX0 += noiseStepY10;
+                        noiseEndX1 += noiseStepY11;
+                    }
+                }
+            }
+        }
+    }
+
+    // Biomes add their top blocks and filler blocks to the primer here
+    public void replaceBlocksForBiome(int chunkX, int chunkZ, ChunkPrimer primer, Biome[] biomes) {
+        if (!ForgeEventFactory.onReplaceBiomeBlocks(this, chunkX, chunkZ, primer, this.world)) return;
+
+        double d0 = 0.03125D;
+        this.stoneNoiseArray = this.stoneNoiseGen.getRegion(this.stoneNoiseArray, (double) (chunkX * 16), (double) (chunkZ * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int localX = 0; localX < 16; ++localX) {
+            for (int localZ = 0; localZ < 16; ++localZ) {
+                Biome biome = biomes[localZ + localX * 16];
+                biome.genTerrainBlocks(this.world, this.rand, primer, chunkX * 16 + localX, chunkZ * 16 + localZ, this.stoneNoiseArray[localZ + localX * 16]);
+            }
+        }
+    }
+
+    public void buildSurfaces(int chunkX, int chunkZ, ChunkPrimer primer) {
+        if (!ForgeEventFactory.onReplaceBiomeBlocks(this, chunkX, chunkZ, primer, this.world)) return;
+        int i = this.world.getSeaLevel() + 1;
+        double d0 = 0.03125D;
+        this.slowsandNoise = this.slowsandGravelNoiseGen.generateNoiseOctaves(this.slowsandNoise, chunkX * 16, chunkZ * 16, 0, 16, 16, 1, 0.03125D, 0.03125D, 1.0D);
+        this.gravelNoise = this.slowsandGravelNoiseGen.generateNoiseOctaves(this.gravelNoise, chunkX * 16, 109, chunkZ * 16, 16, 1, 16, 0.03125D, 1.0D, 0.03125D);
+        this.depthBuffer = this.netherrackExculsivityNoiseGen.generateNoiseOctaves(this.depthBuffer, chunkX * 16, chunkZ * 16, 0, 16, 16, 1, 0.0625D, 0.0625D, 0.0625D);
+
+        for (int ix = 0; ix < 16; ++ix) {
+            for (int iz = 0; iz < 16; ++iz) {
+                boolean flag = this.slowsandNoise[ix + iz * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
+                boolean flag1 = this.gravelNoise[ix + iz * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
+                int l = (int) (this.depthBuffer[ix + iz * 16] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
+                int i1 = -1;
+                IBlockState iblockstate = NETHERRACK;
+                IBlockState iblockstate1 = NETHERRACK;
+
+                for (int iy = 127; iy >= 0; --iy) {
+                    if (iy < 127 - this.rand.nextInt(5) && iy > this.rand.nextInt(5)) {
+                        IBlockState iblockstate2 = primer.getBlockState(iz, iy, ix);
+
+                        if (iblockstate2.getBlock() != null && iblockstate2.getMaterial() != Material.AIR) {
+                            if (iblockstate2.getBlock() == Blocks.NETHERRACK) {
+                                if (i1 == -1) {
+                                    if (l <= 0) {
+                                        iblockstate = AIR;
+                                        iblockstate1 = NETHERRACK;
+                                    } else if (iy >= i - 4 && iy <= i + 1) {
+                                        iblockstate = NETHERRACK;
+                                        iblockstate1 = NETHERRACK;
+
+                                        if (flag1) {
+                                            iblockstate = GRAVEL;
+                                            iblockstate1 = NETHERRACK;
+                                        }
+
+                                        if (flag) {
+                                            iblockstate = SOUL_SAND;
+                                            iblockstate1 = SOUL_SAND;
+                                        }
+                                    }
+
+                                    if (iy < i && (iblockstate == null || iblockstate.getMaterial() == Material.AIR)) {
+                                        iblockstate = LAVA;
+                                    }
+
+                                    i1 = l;
+
+                                    if (iy >= i - 1) {
+                                        primer.setBlockState(iz, iy, ix, iblockstate);
+                                    } else {
+                                        primer.setBlockState(iz, iy, ix, iblockstate1);
+                                    }
+                                } else if (i1 > 0) {
+                                    --i1;
+                                    primer.setBlockState(iz, iy, ix, iblockstate1);
+                                }
+                            }
+                        } else {
+                            i1 = -1;
+                        }
+                    } else {
+                        primer.setBlockState(iz, iy, ix, BEDROCK);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public Chunk generateChunk(int chunkX, int chunkZ) {
+        // initialize the random generator using the chunk coordinates
+        this.rand.setSeed((long) chunkX * 341873128712L + (long) chunkZ * 132897987541L);
+
+        // create the primer
+        ChunkPrimer chunkprimer = new ChunkPrimer();
+
+        // start off by adding the basic terrain shape with air netherrack and lava blocks
+        this.setChunkLavaNetherrack(chunkX, chunkZ, chunkprimer);
+
+        this.buildSurfaces(chunkX, chunkZ, chunkprimer);
+        this.genNetherCaves.generate(this.world, chunkX, chunkZ, chunkprimer);
+
+        if (this.generateStructures) {
+            this.genNetherBridge.generate(this.world, chunkX, chunkZ, chunkprimer);
+        }
+
+        Biome[] biomes = this.world.getBiomeProvider().getBiomes(null, chunkX * 16, chunkZ * 16, 16, 16);
+        this.replaceBlocksForBiome(chunkX, chunkZ, chunkprimer, biomes);
+
+        Chunk chunk = new Chunk(this.world, chunkprimer, chunkX, chunkZ);
+        byte[] chunkBiomes = chunk.getBiomeArray();
+
+        for (int i = 0; i < chunkBiomes.length; ++i) {
+            chunkBiomes[i] = (byte) Biome.getIdForBiome(biomes[i]);
+        }
+
+        chunk.resetRelightChecks();
+        return chunk;
+    }
+
+    // by default, sizeX = 5, sizeY = 17 and sizeZ = 5
+    private double[] getHeights(double[] noiseArray, int subchunkX, int subchunkY, int subchunkZ, int sizeX, int sizeY, int sizeZ) {
+        if (noiseArray == null) {
+            noiseArray = new double[sizeX * sizeY * sizeZ];
+        }
+
+        ChunkGeneratorEvent.InitNoiseField event = new ChunkGeneratorEvent.InitNoiseField(this, noiseArray, subchunkX, subchunkY, subchunkZ, sizeX, sizeY, sizeZ);
+        MinecraftForge.EVENT_BUS.post(event);
+        if (event.getResult() == Event.Result.DENY) return event.getNoisefield();
+
+        this.depthRegion = this.depthNoise.generateNoiseOctaves(this.depthRegion, subchunkX, subchunkY, subchunkZ, sizeX, 1, sizeZ, 100.0D, 0.0D, 100.0D);
+
+        // terrain settings
+        double coordinateScale = 684.412;
+        double heightScale = 2053.236D;
+        double mainNoiseScaleX = 80.0;
+        double mainNoiseScaleY = 60.0;
+        double mainNoiseScaleZ = 80.0;
+
+        // generate the xyz noise for the chunk
+        this.xyzBalanceNoiseArray = this.perlinNoise1.generateNoiseOctaves(this.xyzBalanceNoiseArray, subchunkX, subchunkY, subchunkZ, sizeX, sizeY, sizeZ, coordinateScale / mainNoiseScaleX, heightScale / mainNoiseScaleY, coordinateScale / mainNoiseScaleZ);
+        this.xyzNoiseArrayA = this.lperlinNoise1.generateNoiseOctaves(this.xyzNoiseArrayA, subchunkX, subchunkY, subchunkZ, sizeX, sizeY, sizeZ, coordinateScale, heightScale, coordinateScale);
+        this.xyzNoiseArrayB = this.lperlinNoise2.generateNoiseOctaves(this.xyzNoiseArrayB, subchunkX, subchunkY, subchunkZ, sizeX, sizeY, sizeZ, coordinateScale, heightScale, coordinateScale);
+
+        // loop over the subchunks and calculate the overall noise value
+        int xyzCounter = 0;
+        // adjustments made to the noise based on the y position of the subchunk
+        double[] yBalanceArray = new double[sizeY];
+
+        // generate noise adjustment values based on the y position
+        for (int iy = 0; iy < sizeY; ++iy) {
+            // slightly bias towards a platform in the centre of the y axis with air above and below
+            yBalanceArray[iy] = Math.cos((double) iy * Math.PI * 6.0D / (double) sizeY) * 2.0D;
+            double jy = (double) iy;
+
+            // jy should reach a max of 8 at the centre subchunk, and decreases above and below that
+            if (iy > sizeY / 2) {
+                jy = (double) (sizeY - 1 - iy);
+            }
+
+            if (jy < 4.0D) {
+                jy = 4.0D - jy;
+
+                // drastically increase netherrack at the roof and floor of the nether
+                yBalanceArray[iy] -= jy * jy * jy * 10.0D;
+            }
+        }
+
+        // loop over the subchunks and calculate the overall noise value
+        for (int ix = 0; ix < sizeX; ++ix) {
+            for (int iz = 0; iz < sizeZ; ++iz) {
+                for (int iy = 0; iy < sizeY; ++iy) {
+                    double yBalance = yBalanceArray[iy];
+
+                    // calculate the xzy noise value
+                    double xyzNoiseA = this.xyzNoiseArrayA[xyzCounter] / 512.0D;
+                    double xyzNoiseB = this.xyzNoiseArrayB[xyzCounter] / 512.0D;
+                    double balance = (this.xyzBalanceNoiseArray[xyzCounter] / 10.0D + 1.0D) / 2.0D;
+                    double xyzNoiseValue;
+
+                    if (balance < 0.0D) {
+                        xyzNoiseValue = xyzNoiseA;
+                    } else if (balance > 1.0D) {
+                        xyzNoiseValue = xyzNoiseB;
+                    } else {
+                        xyzNoiseValue = xyzNoiseA + (xyzNoiseB - xyzNoiseA) * balance;
+                    }
+
+                    xyzNoiseValue = xyzNoiseValue - yBalance;
+
+                    // make the noiseVal decrease sharply when we're close to the top of the chunk
+                    // guarantees value of -10 at iy=16, so that there is always some air at the top
+                    if (iy > sizeY - 4) {
+                        double closeToTopOfChunkFactor = (double) ((float) (iy - (sizeY - 4)) / 3.0F); // 1/3, 2/3, or 1
+                        xyzNoiseValue = xyzNoiseValue * (1.0D - closeToTopOfChunkFactor) + -10.0D * closeToTopOfChunkFactor;
+                    }
+
+                    noiseArray[xyzCounter] = xyzNoiseValue;
+                    ++xyzCounter;
+                }
+            }
+        }
+
+        return noiseArray;
+    }
+
+    @Override
+    public void populate(int chunkX, int chunkZ) {
+        boolean prevLogging = ForgeModContainer.logCascadingWorldGeneration;
+        ForgeModContainer.logCascadingWorldGeneration = false;
+
+        BlockFalling.fallInstantly = true;
+        net.minecraftforge.event.ForgeEventFactory.onChunkPopulate(true, this, this.world, this.rand, chunkX, chunkZ, false);
+        int x = chunkX * 16;
+        int z = chunkZ * 16;
+        BlockPos blockpos = new BlockPos(x, 0, z);
+        Biome biome = this.world.getBiome(blockpos.add(16, 0, 16));
+        ChunkPos chunkpos = new ChunkPos(chunkX, chunkZ);
+        this.genNetherBridge.generateStructure(this.world, this.rand, chunkpos);
+
+        if (TerrainGen.populate(this, this.world, this.rand, chunkX, chunkZ, false, PopulateChunkEvent.Populate.EventType.NETHER_LAVA))
+            for (int k = 0; k < 8; ++k) {
+                this.hellSpringGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(120) + 4, this.rand.nextInt(16) + 8));
+            }
+
+        // don't do this to prevent double-ups
+        //MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Pre(this.world, this.rand, blockpos));
+
+        // note: this was moved earlier to be more similar to overworld biome decoration, however
+        // it's possible that this may cause issues with other mods
+        biome.decorate(this.world, this.rand, new BlockPos(x, 0, z));
+
+        if (TerrainGen.populate(this, this.world, this.rand, chunkX, chunkZ, false, PopulateChunkEvent.Populate.EventType.FIRE))
+            for (int i1 = 0; i1 < this.rand.nextInt(this.rand.nextInt(10) + 1) + 1; ++i1) {
+                this.fireFeature.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(120) + 4, this.rand.nextInt(16) + 8));
+            }
+
+        if (TerrainGen.populate(this, this.world, this.rand, chunkX, chunkZ, false, PopulateChunkEvent.Populate.EventType.GLOWSTONE)) {
+            for (int j1 = 0; j1 < this.rand.nextInt(this.rand.nextInt(10) + 1); ++j1) {
+                this.lightGemGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(120) + 4, this.rand.nextInt(16) + 8));
+            }
+
+            for (int k1 = 0; k1 < 10; ++k1) {
+                this.hellPortalGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(128), this.rand.nextInt(16) + 8));
+            }
+        }//Forge: End doGLowstone
+
+        ForgeEventFactory.onChunkPopulate(false, this, this.world, this.rand, chunkX, chunkZ, false);
+
+        if (TerrainGen.decorate(this.world, this.rand, blockpos, DecorateBiomeEvent.Decorate.EventType.SHROOM)) {
+            if (this.rand.nextBoolean()) {
+                this.brownMushroomFeature.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(128), this.rand.nextInt(16) + 8));
+            }
+
+            if (this.rand.nextBoolean()) {
+                this.redMushroomFeature.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16) + 8, this.rand.nextInt(128), this.rand.nextInt(16) + 8));
+            }
+        }
+
+        if (TerrainGen.generateOre(this.world, this.rand, quartzGen, blockpos, OreGenEvent.GenerateMinable.EventType.QUARTZ))
+            for (int l1 = 0; l1 < 16; ++l1) {
+                this.quartzGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16), this.rand.nextInt(108) + 10, this.rand.nextInt(16)));
+            }
+
+        int i2 = this.world.getSeaLevel() / 2 + 1;
+
+        if (TerrainGen.populate(this, this.world, this.rand, chunkX, chunkZ, false, PopulateChunkEvent.Populate.EventType.NETHER_MAGMA))
+            for (int l = 0; l < 4; ++l) {
+                this.magmaGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16), i2 - 5 + this.rand.nextInt(10), this.rand.nextInt(16)));
+            }
+
+        if (TerrainGen.populate(this, this.world, this.rand, chunkX, chunkZ, false, PopulateChunkEvent.Populate.EventType.NETHER_LAVA2))
+            for (int j2 = 0; j2 < 16; ++j2) {
+                this.lavaTrapGen.generate(this.world, this.rand, blockpos.add(this.rand.nextInt(16), this.rand.nextInt(108) + 10, this.rand.nextInt(16)));
+            }
+
+        // this should already be called during biome decoration (Vanilla doesn't usually call this for the Nether
+        // though, since the decoration method is empty)
+        //MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Post(this.world, this.rand, blockpos));
+
+        BlockFalling.fallInstantly = false;
+        ForgeModContainer.logCascadingWorldGeneration = prevLogging;
+    }
+
+    @Override
+    public boolean generateStructures(Chunk chunkIn, int x, int z) {
+        return false;
+    }
+
+    @Override
+    public List<Biome.SpawnListEntry> getPossibleCreatures(EnumCreatureType creatureType, BlockPos pos) {
+        if (creatureType == EnumCreatureType.MONSTER) {
+            if (this.genNetherBridge.isInsideStructure(pos)) {
+                return this.genNetherBridge.getSpawnList();
+            }
+
+            if (this.genNetherBridge.isPositionInStructure(this.world, pos) && this.world.getBlockState(pos.down()).getBlock() == Blocks.NETHER_BRICK) {
+                return this.genNetherBridge.getSpawnList();
+            }
+        }
+
+        Biome biome = this.world.getBiome(pos);
+        return biome.getSpawnableList(creatureType);
+    }
+
+    @Override
+    @Nullable
+    public BlockPos getNearestStructurePos(World worldIn, String structureName, BlockPos position, boolean p_180513_4_) {
+        return "Fortress".equals(structureName) && this.genNetherBridge != null ? this.genNetherBridge.getNearestStructurePos(worldIn, position, p_180513_4_) : null;
+    }
+
+    @Override
+    public boolean isInsideStructure(World world, String structureName, BlockPos pos) {
+        return ("Fortress".equals(structureName) && this.genNetherBridge != null) && this.genNetherBridge.isInsideStructure(pos);
+    }
+
+    @Override
+    public void recreateStructures(Chunk chunkIn, int x, int z) {
+        this.genNetherBridge.generate(this.world, x, z, null);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/world/gen/misc/Directions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/world/gen/misc/Directions.java	(date 1525606899000)
+++ src/main/java/net/hdt/neutronia/world/gen/misc/Directions.java	(date 1525606899000)
@@ -0,0 +1,294 @@
+package net.hdt.neutronia.world.gen.misc;
+
+import net.minecraft.block.*;
+import net.minecraft.init.Blocks;
+
+import java.util.HashMap;
+import java.util.Map;
+
+
+/**
+ * This class transforms block metadata (rotate n times and flip)
+ *
+ * @author Ternsip (ternsip@gmail.com)
+ */
+public class Directions {
+
+    public static final int UNKNOWN = 0x00;
+    public static final int SOUTH = 0x01;
+    public static final int WEST = 0x02;
+    public static final int EAST = 0x04;
+    public static final int NORTH = 0x08;
+    public static final int UP = 0x10;
+    public static final int DOWN = 0x20;
+
+    private static final Map<BlockType, HashMap<Integer, Integer>> metaToDirection = new HashMap<BlockType, HashMap<Integer, Integer>>();
+    private static final Map<BlockType, HashMap<Integer, Integer>> directionToMeta = new HashMap<BlockType, HashMap<Integer, Integer>>();
+    private static final Map<BlockType, Integer> masks = new HashMap<BlockType, Integer>();
+
+    static {
+        HashMap<Integer, Integer> metaToDir;
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, UP);
+        metaToDir.put(0x4, EAST);
+        metaToDir.put(0x8, SOUTH);
+        addMappings(metaToDir, BlockType.LOG, 0xC);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, DOWN);
+        metaToDir.put(0x1, UP);
+        metaToDir.put(0x2, NORTH);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, WEST);
+        metaToDir.put(0x5, EAST);
+        addMappings(metaToDir, BlockType.CHEST, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, DOWN);
+        metaToDir.put(0x1, UP);
+        metaToDir.put(0x2, NORTH);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, WEST);
+        metaToDir.put(0x5, EAST);
+        addMappings(metaToDir, BlockType.SKULL, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, DOWN);
+        metaToDir.put(0x1, UP);
+        metaToDir.put(0x2, NORTH);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, WEST);
+        metaToDir.put(0x5, EAST);
+        addMappings(metaToDir, BlockType.DISPENSER, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, WEST);
+        metaToDir.put(0x1, SOUTH);
+        metaToDir.put(0x2, EAST);
+        metaToDir.put(0x3, NORTH);
+        addMappings(metaToDir, BlockType.TRAPDOOR, 0x3);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, SOUTH);
+        metaToDir.put(0x1, WEST);
+        metaToDir.put(0x2, NORTH);
+        metaToDir.put(0x3, EAST);
+        addMappings(metaToDir, BlockType.BED, 0x3);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x1, SOUTH);
+        metaToDir.put(0x2, WEST);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x8, EAST);
+        addMappings(metaToDir, BlockType.VINE, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, NORTH);
+        metaToDir.put(0x1, EAST);
+        addMappings(metaToDir, BlockType.RAIL_NORMAL, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x2, EAST);
+        metaToDir.put(0x3, WEST);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x5, SOUTH);
+        addMappings(metaToDir, BlockType.RAIL_ASC, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x6, EAST);
+        metaToDir.put(0x7, SOUTH);
+        metaToDir.put(0x8, WEST);
+        metaToDir.put(0x9, NORTH);
+        addMappings(metaToDir, BlockType.RAIL_CURVE, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, NORTH);
+        metaToDir.put(0x1, EAST);
+        addMappings(metaToDir, BlockType.RAIL_POWERED, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x2, EAST);
+        metaToDir.put(0x3, WEST);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x5, SOUTH);
+        addMappings(metaToDir, BlockType.RAIL_POWERED_ASC, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, EAST);
+        metaToDir.put(0x1, WEST);
+        metaToDir.put(0x2, SOUTH);
+        metaToDir.put(0x3, NORTH);
+        addMappings(metaToDir, BlockType.STAIR, 0x3);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x1, EAST);
+        metaToDir.put(0x2, WEST);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x5, UP);
+        addMappings(metaToDir, BlockType.TORCH, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, DOWN);
+        metaToDir.put(0x1, EAST);
+        metaToDir.put(0x2, WEST);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x5, UP);
+        addMappings(metaToDir, BlockType.BUTTON, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, DOWN);
+        metaToDir.put(0x1, EAST);
+        metaToDir.put(0x2, WEST);
+        metaToDir.put(0x3, SOUTH);
+        metaToDir.put(0x4, NORTH);
+        metaToDir.put(0x5, UP);
+        metaToDir.put(0x6, UP);
+        metaToDir.put(0x7, DOWN);
+        addMappings(metaToDir, BlockType.LEVER, 0x7);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, WEST);
+        metaToDir.put(0x1, NORTH);
+        metaToDir.put(0x2, EAST);
+        metaToDir.put(0x3, SOUTH);
+        addMappings(metaToDir, BlockType.DOOR, 0x3);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, NORTH);
+        metaToDir.put(0x1, EAST);
+        metaToDir.put(0x2, SOUTH);
+        metaToDir.put(0x3, WEST);
+        addMappings(metaToDir, BlockType.REDSTONE_REPEATER, 0x3);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x0, SOUTH);
+        metaToDir.put(0x1, EAST);
+        addMappings(metaToDir, BlockType.ANVIL, 0x1);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        addMappings(metaToDir, BlockType.MUSHROOM, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x1, WEST);
+        metaToDir.put(0x3, NORTH);
+        metaToDir.put(0x7, SOUTH);
+        metaToDir.put(0x9, EAST);
+        addMappings(metaToDir, BlockType.MUSHROOM_CAP_CORNER, 0xF);
+
+        metaToDir = new HashMap<Integer, Integer>();
+        metaToDir.put(0x2, NORTH);
+        metaToDir.put(0x4, WEST);
+        metaToDir.put(0x6, EAST);
+        metaToDir.put(0x8, SOUTH);
+        addMappings(metaToDir, BlockType.MUSHROOM_CAP_SIDE, 0xF);
+
+
+    }
+
+    public static BlockType getBlockType(Block block, int meta) {
+        if (block instanceof BlockBed || block instanceof BlockPumpkin || block instanceof BlockFenceGate || block instanceof BlockEndPortalFrame || block instanceof BlockTripWireHook || block instanceof BlockCocoa) {
+            return BlockType.BED;
+        }
+        if (block instanceof BlockRail) {
+            return (meta < 0x2) ? BlockType.RAIL_NORMAL : (meta < 0x6) ? BlockType.RAIL_ASC : BlockType.RAIL_CURVE;
+        }
+        if (block instanceof BlockRailPowered || block instanceof BlockRailDetector) {
+            return (meta < 0x2) ? BlockType.RAIL_POWERED : BlockType.RAIL_POWERED_ASC;
+        }
+        if (block instanceof BlockStairs) {
+            return BlockType.STAIR;
+        }
+        if (block instanceof BlockChest || block instanceof BlockEnderChest || block instanceof BlockFurnace || block instanceof BlockLadder || Block.getIdFromBlock(block) == Block.getIdFromBlock(Blocks.WALL_SIGN)) {
+            return BlockType.CHEST;
+        }
+        if (Block.getIdFromBlock(block) == Block.getIdFromBlock(Blocks.STANDING_SIGN)) {
+            return BlockType.SIGNPOST;
+        }
+        if (block instanceof BlockDoor) {
+            return BlockType.DOOR;
+        }
+        if (block instanceof BlockButton) {
+            return BlockType.BUTTON;
+        }
+        if (block instanceof BlockRedstoneRepeater || block instanceof BlockRedstoneComparator) {
+            return BlockType.REDSTONE_REPEATER;
+        }
+        if (block instanceof BlockTrapDoor) {
+            return BlockType.TRAPDOOR;
+        }
+        if (block instanceof BlockVine) {
+            return BlockType.VINE;
+        }
+        if (block instanceof BlockSkull) {
+            return BlockType.SKULL;
+        }
+        if (block instanceof BlockAnvil) {
+            return BlockType.ANVIL;
+        }
+        if (block instanceof BlockLog) {
+            return BlockType.LOG;
+        }
+        if (block instanceof BlockDispenser || block instanceof BlockPistonBase || block instanceof BlockPistonExtension || block instanceof BlockHopper) {
+            return BlockType.DISPENSER;
+        }
+        if (block instanceof BlockTorch) {
+            return BlockType.TORCH;
+        }
+        if (block instanceof BlockLever) {
+            return BlockType.LEVER;
+        }
+        if (block instanceof BlockHugeMushroom) {
+            return (meta == 0x0 || meta > 0x9 || meta == 0x5) ? BlockType.MUSHROOM : (meta % 0x2 == 0 ? BlockType.MUSHROOM_CAP_SIDE : BlockType.MUSHROOM_CAP_CORNER);
+        }
+        return BlockType.IDLE;
+    }
+
+    static boolean isDoubleDirected(BlockType blockType) {
+        return blockType == BlockType.MUSHROOM_CAP_CORNER || blockType == BlockType.RAIL_CURVE;
+    }
+
+    static Integer getDirection(int meta, BlockType blockType) {
+        if (metaToDirection.containsKey(blockType)) {
+            HashMap<Integer, Integer> metaToDir = metaToDirection.get(blockType);
+            if (metaToDir.containsKey(meta)) {
+                return metaToDir.get(meta);
+            }
+        }
+        return UNKNOWN;
+    }
+
+    static Integer getMeta(int defaultMeta, int direction, BlockType blockType) {
+        if (directionToMeta.containsKey(blockType)) {
+            HashMap<Integer, Integer> biMap = directionToMeta.get(blockType);
+            if (biMap.containsKey(direction)) {
+                return biMap.get(direction);
+            }
+        }
+        return defaultMeta;
+    }
+
+    static int getMask(BlockType blockType) {
+        return masks.containsKey(blockType) ? masks.get(blockType) : 0;
+    }
+
+    private static void addMappings(HashMap<Integer, Integer> metaToDir, BlockType blockType, int mask) {
+        HashMap<Integer, Integer> dirToMeta = new HashMap<Integer, Integer>();
+        for (Map.Entry<Integer, Integer> entry : metaToDir.entrySet()) {
+            dirToMeta.put(entry.getValue(), entry.getKey());
+        }
+        metaToDirection.put(blockType, metaToDir);
+        directionToMeta.put(blockType, dirToMeta);
+        masks.put(blockType, mask);
+    }
+
+    public enum BlockType {
+        LOG, DISPENSER, BED, RAIL_NORMAL, RAIL_CURVE, RAIL_ASC, RAIL_POWERED, RAIL_POWERED_ASC, TORCH, STAIR, CHEST, SIGNPOST,
+        DOOR, LEVER, BUTTON, REDSTONE_REPEATER, TRAPDOOR, VINE, SKULL, ANVIL,
+        MUSHROOM, MUSHROOM_CAP_CORNER, MUSHROOM_CAP_SIDE, IDLE
+    }
+
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockModFence.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockModFence.java	(date 1524937186000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockModFence.java	(date 1524937186000)
@@ -0,0 +1,130 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockFence;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import java.util.Random;
+
+public class BlockModFence extends BlockFence implements IModBlock {
+
+    private final String[] variants;
+    private String bareName, modid;
+
+    public BlockModFence(Material material, String modid, String name, String... variants) {
+        super(material, material.getMaterialMapColor());
+
+        useNeighborBrightness = true;
+
+        if (variants.length == 0)
+            variants = new String[]{name};
+
+        bareName = name;
+        this.variants = variants;
+        this.modid = modid;
+
+        setUnlocalizedName(name + "_fence");
+
+        setHardness(1.5F);
+        setResistance(30F);
+        setHarvestLevel("pickaxe", 1);
+    }
+
+    @Override
+    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
+        return Item.getItemFromBlock(this);
+    }
+
+    @Override
+    public boolean hasCustomBreakingProgress(IBlockState state) {
+        return true;
+    }
+
+    public Block setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        this.setRegistryName(getPrefix(), name);
+        ProxyRegistry.register(this);
+        ProxyRegistry.register(this.createItemBlock(new ResourceLocation(getPrefix(), name)));
+        return this;
+    }
+
+    protected ItemBlock createItemBlock(ResourceLocation res) {
+        return new ItemModBlock(this, res);
+    }
+
+    @Override
+    public boolean canPlaceTorchOnTop(IBlockState state, IBlockAccess world, BlockPos pos) {
+        return true;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    @Override
+    public String getBareName() {
+        return bareName;
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
+        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.SOLID || layer == BlockRenderLayer.TRANSLUCENT;
+    }
+
+    @Override
+    public boolean isOpaqueCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    public boolean isFullCube(IBlockState state) {
+        return false;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+    @Override
+    public IProperty[] getIgnoredProperties() {
+        return new IProperty[0];
+    }
+
+    @Override
+    public IProperty getVariantProp() {
+        return null;
+    }
+
+    @Override
+    public Class getVariantEnum() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCharredNetherBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCharredNetherBricks.java	(date 1525606884000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCharredNetherBricks.java	(date 1525606884000)
@@ -0,0 +1,20 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.hdt.neutronia.blocks.overworld.BlockOverworldBase;
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+public class BlockCharredNetherBricks extends BlockOverworldBase implements IModBlock {
+
+    public BlockCharredNetherBricks() {
+        super(Material.ROCK, "charred_nether_bricks");
+        setHardness(2.0F);
+        setResistance(10.0F);
+        setSoundType(SoundType.STONE);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStone.java	(date 1524853000000)
+++ src/main/java/net/hdt/neutronia/blocks/end/BlockFilamentEndStone.java	(date 1524853000000)
@@ -0,0 +1,82 @@
+/*
+package net.hdt.neutronia.blocks.end;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IStringSerializable;
+import net.minecraft.util.NonNullList;
+
+public class BlockFilamentEndStone extends BlockEndEx
+{
+    public static final PropertyEnum<EnumType> TYPE = PropertyEnum.create("type", EnumType.class);
+
+    public BlockFilamentEndStone()
+    {
+        super("end_stone_filament", Material.ROCK);
+        setHardness(3.0F);
+        setResistance(15.0F);
+    }
+
+    @Override
+    public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list)
+    {
+        for(EnumType type : EnumType.values())
+        {
+            list.add(new ItemStack(this, 1, type.ordinal()));
+        }
+    }
+
+    @Override
+    public int damageDropped(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return getDefaultState().withProperty(TYPE, EnumType.fromMeta(meta));
+    }
+
+    @Override
+    public int getMetaFromState(IBlockState state)
+    {
+        return state.getValue(TYPE).ordinal();
+    }
+
+    @Override
+    protected BlockStateContainer createBlockState()
+    {
+        return new BlockStateContainer(this, TYPE);
+    }
+
+    public enum EnumType implements IStringSerializable
+    {
+        NORMAL,
+        HYDROUS,
+        SALTY,
+        STARRY,
+        BARREN;
+
+        @Override
+        public String getName()
+        {
+            return toString().toLowerCase();
+        }
+
+        public static EnumType fromMeta(int meta)
+        {
+            if(meta < 0 || meta >= values().length)
+            {
+                meta = 0;
+            }
+
+            return values()[meta];
+        }
+    }
+}
+*/
Index: src/main/java/net/hdt/neutronia/modules/building/features/SturdyStone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/SturdyStone.java	(date 1525606894000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/SturdyStone.java	(date 1525606894000)
@@ -0,0 +1,31 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockSturdyStone;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+
+public class SturdyStone extends Feature {
+
+    public static Block sturdy_stone;
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        sturdy_stone = new BlockSturdyStone();
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sturdy_stone, 4),
+				"SCS", "C C", "SCS",
+				'S', "stone",
+				'C', "cobblestone");
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(sturdy_stone, 4), 
+				"CSC", "S S", "CSC",
+				'S', "stone",
+				'C', "cobblestone");*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/StainedPlanks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/StainedPlanks.java	(date 1525606900000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/StainedPlanks.java	(date 1525606900000)
@@ -0,0 +1,57 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.blocks.overworld.BlockStainedPlanksSlab;
+import net.hdt.neutronia.modules.building.blocks.BlockStainedPlanks;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockStainedPlanksStairs;
+import net.minecraftforge.fml.common.event.FMLInitializationEvent;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.oredict.OreDictionary;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+public class StainedPlanks extends Feature {
+
+    public static BlockMod stained_planks;
+
+    boolean enableStairsAndSlabs;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        stained_planks = new BlockStainedPlanks();
+
+        if (enableStairsAndSlabs) {
+            for (BlockStainedPlanks.Variants variant : BlockStainedPlanks.Variants.class.getEnumConstants())
+                BlockModStairs.initStairs(stained_planks, variant.ordinal(), new BlockStainedPlanksStairs(variant));
+            for (BlockStainedPlanks.Variants variant : BlockStainedPlanks.Variants.class.getEnumConstants())
+                BlockModSlab.initSlab(stained_planks, variant.ordinal(), new BlockStainedPlanksSlab(variant, false), new BlockStainedPlanksSlab(variant, true));
+        }
+		
+		/*for(int i = 0; i < 16; i++) {
+			RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(stained_planks, 8, i),
+					"BBB", "BDB", "BBB",
+					'B', "plankWood",
+					'D', LibMisc.OREDICT_DYES.get(15 - i));
+		}*/
+    }
+
+    @Override
+    public void init(FMLInitializationEvent event) {
+        OreDictionary.registerOre("plankWood", ProxyRegistry.newStack(stained_planks, 1, OreDictionary.WILDCARD_VALUE));
+        OreDictionary.registerOre("plankStained", ProxyRegistry.newStack(stained_planks, 1, OreDictionary.WILDCARD_VALUE));
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/properties/EnumSoulStoneTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/properties/EnumSoulStoneTypes.java	(date 1524947218000)
+++ src/main/java/net/hdt/neutronia/properties/EnumSoulStoneTypes.java	(date 1524947218000)
@@ -0,0 +1,48 @@
+package net.hdt.neutronia.properties;
+
+import net.minecraft.util.IStringSerializable;
+
+public enum EnumSoulStoneTypes implements IStringSerializable {
+
+    HAUNTED_SANDSTONE(0, "soulstone_normal"),
+    CHISELED_HAUNTED_SANDSTONE(1, "chiseled_soulstone"),
+    SMOOTH_HAUNTED_SANDSTONE(2, "smooth_soulstone"),
+    HAUNTED_SANDSTONE_BRICKS(3, "soulstone_bricks");
+
+    private static final EnumSoulStoneTypes[] META_LOOKUP = new EnumSoulStoneTypes[values().length];
+
+    static {
+        for (EnumSoulStoneTypes blockstone$enumtype : values()) {
+            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
+        }
+    }
+
+    private final int meta;
+    private final String name;
+
+    EnumSoulStoneTypes(int p_i46384_3_, String p_i46384_5_) {
+        this.meta = p_i46384_3_;
+        this.name = p_i46384_5_;
+    }
+
+    public static EnumSoulStoneTypes byMetadata(int meta) {
+        if (meta < 0 || meta >= META_LOOKUP.length) {
+            meta = 0;
+        }
+
+        return META_LOOKUP[meta];
+    }
+
+    public int getMetadata() {
+        return this.meta;
+    }
+
+    public String toString() {
+        return this.name;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/SoulSandstone.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/SoulSandstone.java	(date 1525606897000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/SoulSandstone.java	(date 1525606897000)
@@ -0,0 +1,63 @@
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.blocks.nether.BlockNetherSlabBase;
+import net.hdt.neutronia.modules.building.blocks.BlockSoulSandstone;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockSoulSandstoneSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockSoulSandstoneStairs;
+import net.minecraft.block.state.IBlockState;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.minecraftforge.oredict.OreDictionary;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class SoulSandstone extends Feature {
+
+    public static BlockMod soul_sandstone;
+
+    boolean enableStairs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairs = loadPropBool("Enable stairs", "", true);
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        soul_sandstone = new BlockSoulSandstone();
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(soul_sandstone),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(Blocks.SOUL_SAND));
+		RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(soul_sandstone, 4, 2),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(soul_sandstone, 1, 0));*/
+
+        IBlockState defaultState = soul_sandstone.getDefaultState();
+
+        String slabName = "_slab";
+        BlockNetherSlabBase halfSlab = new BlockSoulSandstoneSlab(false);
+        BlockModSlab.initSlab(soul_sandstone, OreDictionary.WILDCARD_VALUE, halfSlab, new BlockSoulSandstoneSlab(true));
+		
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(soul_sandstone, 1, 1),
+				"S", "S",
+				'S', ProxyRegistry.newStack(halfSlab, 1, 0));*/
+
+        if (enableStairs)
+            BlockModStairs.initStairs(soul_sandstone, 0, new BlockSoulSandstoneStairs());
+
+        VanillaWalls.add("soul_sandstone", soul_sandstone, 0, enableWalls);
+
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+
+}
Index: src/main/java/net/hdt/neutronia/entity/render/RenderSeaTurtle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/RenderSeaTurtle.java	(date 1523987839000)
+++ src/main/java/net/hdt/neutronia/entity/render/RenderSeaTurtle.java	(date 1523987839000)
@@ -0,0 +1,27 @@
+package net.hdt.neutronia.entity.render;
+
+import net.hdt.neutronia.entity.EntitySeaTurtle;
+import net.hdt.neutronia.entity.render.model.ModelSeaTurtle;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.client.renderer.entity.RenderLiving;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.util.ResourceLocation;
+
+public class RenderSeaTurtle extends RenderLiving<EntitySeaTurtle> {
+
+    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/sea_turtle.png");
+
+    public RenderSeaTurtle(RenderManager manager) {
+        super(manager, new ModelSeaTurtle(), 0.5F);
+    }
+
+    @Override
+    protected ResourceLocation getEntityTexture(EntitySeaTurtle entity) {
+        return SCORP_TEXTURE;
+    }
+
+    @Override
+    protected void applyRotations(EntitySeaTurtle entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
+    }
+}
Index: src/main/java/net/hdt/neutronia/items/ItemModFood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/ItemModFood.java	(date 1523986178000)
+++ src/main/java/net/hdt/neutronia/items/ItemModFood.java	(date 1523986178000)
@@ -0,0 +1,89 @@
+package net.hdt.neutronia.items;
+
+import net.minecraft.client.renderer.ItemMeshDefinition;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemFood;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.NonNullList;
+import net.minecraft.util.ResourceLocation;
+import net.thegaminghuskymc.huskylib2.interf.IVariantHolder;
+import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
+
+import java.util.ArrayList;
+
+public class ItemModFood extends ItemFood implements IVariantHolder {
+
+    public static final ArrayList<IVariantHolder> variantHolders = new ArrayList<>();
+
+    private final String[] variants;
+    private final String bareName, modid;
+
+    public ItemModFood(String modid, String name, CreativeTabs creativeTabs, int amount, float saturation, boolean isWolfFood, String... variants) {
+        super(amount, saturation, isWolfFood);
+        setCreativeTab(creativeTabs);
+        if (variants.length > 1)
+            setHasSubtypes(true);
+
+        if (variants.length == 0)
+            variants = new String[]{name};
+
+        bareName = name;
+        this.variants = variants;
+        this.modid = modid;
+        setUnlocalizedName(name);
+        variantHolders.add(this);
+    }
+
+    public ItemModFood(String modid, String name, CreativeTabs creativeTabs, int amount, boolean isWolfFood, String... variants) {
+        this(modid, name, creativeTabs, amount, 0.6F, isWolfFood, variants);
+    }
+
+    public Item setUnlocalizedName(String name) {
+        super.setUnlocalizedName(name);
+        this.setRegistryName(new ResourceLocation(getPrefix(), name));
+        ProxyRegistry.register(this);
+        return this;
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack par1ItemStack) {
+        int dmg = par1ItemStack.getItemDamage();
+        String[] variants = getVariants();
+
+        String name;
+        if (dmg >= variants.length)
+            name = bareName;
+        else name = variants[dmg];
+
+        return "item." + name;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.modid;
+    }
+
+    @Override
+    public String getModNamespace() {
+        return this.modid;
+    }
+
+    @Override
+    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> subItems) {
+        if (isInCreativeTab(tab))
+            for (int i = 0; i < getVariants().length; i++)
+                subItems.add(new ItemStack(this, 1, i));
+    }
+
+    @Override
+    public String[] getVariants() {
+        return variants;
+    }
+
+    @Override
+    public ItemMeshDefinition getCustomMeshDefinition() {
+        return null;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCarvedWood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCarvedWood.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/modules/building/blocks/BlockCarvedWood.java	(date 1525606883000)
@@ -0,0 +1,30 @@
+package net.hdt.neutronia.modules.building.blocks;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.creativetab.CreativeTabs;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMetaVariants;
+import net.thegaminghuskymc.huskylib2.interf.IModBlock;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockCarvedWood extends BlockMetaVariants implements IModBlock {
+
+    public BlockCarvedWood() {
+        super("carved_wood", MOD_ID, Material.WOOD, Variants.class);
+        setHardness(2.0F);
+        setResistance(5.0F);
+        setSoundType(SoundType.WOOD);
+        setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
+    }
+
+    public enum Variants implements BlockMetaVariants.EnumBase {
+        CARVED_OAK_WOOD,
+        CARVED_SPRUCE_WOOD,
+        CARVED_BIRCH_WOOD,
+        CARVED_JUNGLE_WOOD,
+        CARVED_ACACIA_WOOD,
+        CARVED_DARK_OAK_WOOD
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/blocks/base/BlockDirectional.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/base/BlockDirectional.java	(date 1525281895000)
+++ src/main/java/net/hdt/neutronia/blocks/base/BlockDirectional.java	(date 1525281895000)
@@ -0,0 +1,15 @@
+package net.hdt.neutronia.blocks.base;
+
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyDirection;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public abstract class BlockDirectional extends BlockMod {
+    public static final PropertyDirection FACING = PropertyDirection.create("facing");
+
+    protected BlockDirectional(Material materialIn, String name) {
+        super(materialIn, MOD_ID, name);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/IExtendedReach.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/IExtendedReach.java	(date 1523986187000)
+++ src/main/java/net/hdt/neutronia/items/IExtendedReach.java	(date 1523986187000)
@@ -0,0 +1,8 @@
+package net.hdt.neutronia.items;
+
+public interface IExtendedReach {
+    /**
+     * @return The reach, in blocks, that the item allows. This replaces your player's reach, instead of adding to it.
+     */
+    float getReach();
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/items/AnimaniaItem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/AnimaniaItem.java	(date 1525606881000)
+++ src/main/java/net/hdt/neutronia/items/AnimaniaItem.java	(date 1525606881000)
@@ -0,0 +1,9 @@
+package net.hdt.neutronia.items;
+
+import net.hdt.neutronia.Main;
+
+public class AnimaniaItem extends ItemBase {
+    public AnimaniaItem(String name) {
+        super(name, Main.ITEM_EXPANSION_TAB);
+    }
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockBurnedBones.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockBurnedBones.java	(date 1525606882000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockBurnedBones.java	(date 1525606882000)
@@ -0,0 +1,112 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.minecraft.block.SoundType;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.PropertyEnum;
+import net.minecraft.block.state.BlockStateContainer;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.EnumFacing;
+import net.minecraft.util.Rotation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import static net.hdt.neutronia.util.Reference.MOD_ID;
+
+public class BlockBurnedBones extends BlockMod {
+
+    public static final PropertyEnum<EnumFacing.Axis> AXIS = PropertyEnum.create("axis", EnumFacing.Axis.class);
+
+    public BlockBurnedBones() {
+        super(Material.SAND, MOD_ID, "burned_bones");
+        this.setHardness(2.0F);
+        this.setSoundType(SoundType.STONE);
+    }
+
+    @Override
+    public boolean rotateBlock(net.minecraft.world.World world, BlockPos pos, EnumFacing axis) {
+        net.minecraft.block.state.IBlockState state = world.getBlockState(pos);
+        for (net.minecraft.block.properties.IProperty<?> prop : state.getProperties().keySet()) {
+            if (prop.getName().equals("axis")) {
+                world.setBlockState(pos, state.cycleProperty(prop));
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
+     * blockstate.
+     */
+    public IBlockState withRotation(IBlockState state, Rotation rot) {
+        switch (rot) {
+            case COUNTERCLOCKWISE_90:
+            case CLOCKWISE_90:
+
+                switch (state.getValue(AXIS)) {
+                    case X:
+                        return state.withProperty(AXIS, EnumFacing.Axis.Z);
+                    case Z:
+                        return state.withProperty(AXIS, EnumFacing.Axis.X);
+                    default:
+                        return state;
+                }
+
+            default:
+                return state;
+        }
+    }
+
+    /**
+     * Convert the given metadata into a BlockState for this Block
+     */
+    public IBlockState getStateFromMeta(int meta) {
+        EnumFacing.Axis enumfacing$axis = EnumFacing.Axis.Y;
+        int i = meta & 12;
+
+        if (i == 4) {
+            enumfacing$axis = EnumFacing.Axis.X;
+        } else if (i == 8) {
+            enumfacing$axis = EnumFacing.Axis.Z;
+        }
+
+        return this.getDefaultState().withProperty(AXIS, enumfacing$axis);
+    }
+
+    /**
+     * Convert the BlockState into the correct metadata value
+     */
+    public int getMetaFromState(IBlockState state) {
+        int i = 0;
+        EnumFacing.Axis enumfacing$axis = state.getValue(AXIS);
+
+        if (enumfacing$axis == EnumFacing.Axis.X) {
+            i |= 4;
+        } else if (enumfacing$axis == EnumFacing.Axis.Z) {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, AXIS);
+    }
+
+    protected ItemStack getSilkTouchDrop(IBlockState state) {
+        return new ItemStack(Item.getItemFromBlock(this));
+    }
+
+    /**
+     * Called by ItemBlocks just before a block is actually set in the world, to allow for adjustments to the
+     * IBlockstate
+     */
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer) {
+        return super.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, meta, placer).withProperty(AXIS, facing.getAxis());
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/items/base/tools/BasePickaxe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/items/base/tools/BasePickaxe.java	(date 1523988243000)
+++ src/main/java/net/hdt/neutronia/items/base/tools/BasePickaxe.java	(date 1523988243000)
@@ -0,0 +1,12 @@
+package net.hdt.neutronia.items.base.tools;
+
+import net.hdt.neutronia.util.Reference;
+import net.thegaminghuskymc.huskylib2.items.ItemModPickaxe;
+
+public class BasePickaxe extends ItemModPickaxe {
+
+    public BasePickaxe(String name, ToolMaterial material) {
+        super(material, name, Reference.MOD_ID);
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/modules/building/features/SnowBricks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/modules/building/features/SnowBricks.java	(date 1525606902000)
+++ src/main/java/net/hdt/neutronia/modules/building/features/SnowBricks.java	(date 1525606902000)
@@ -0,0 +1,57 @@
+/**
+ * This class was created by <Vazkii>. It's distributed as
+ * part of the Quark Mod. Get the Source Code in github:
+ * https://github.com/Vazkii/Quark
+ * <p>
+ * Quark is Open Source and distributed under the
+ * CC-BY-NC-SA 3.0 License: https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_GB
+ * <p>
+ * File Created @ [18/04/2016, 22:43:48 (GMT)]
+ */
+package net.hdt.neutronia.modules.building.features;
+
+import net.hdt.neutronia.modules.building.blocks.BlockSnowBricks;
+import net.hdt.neutronia.modules.building.blocks.slab.BlockSnowBricksSlab;
+import net.hdt.neutronia.modules.building.blocks.stairs.BlockSnowBricksStairs;
+import net.hdt.neutronia.modules.building.blocks.wall.BlockSnowBricksWall;
+import net.minecraft.block.Block;
+import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
+import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
+import net.thegaminghuskymc.huskylib2.module.Feature;
+import net.thegaminghuskymc.huskylib2.module.GlobalConfig;
+
+public class SnowBricks extends Feature {
+
+    public static Block snow_bricks;
+
+    boolean enableStairsAndSlabs;
+    boolean enableWalls;
+
+    @Override
+    public void setupConfig() {
+        enableStairsAndSlabs = loadPropBool("Enable stairs and slabs", "", true) && GlobalConfig.enableVariants;
+        enableWalls = loadPropBool("Enable walls", "", true) && GlobalConfig.enableVariants;
+    }
+
+    @Override
+    public void preInit(FMLPreInitializationEvent event) {
+        snow_bricks = new BlockSnowBricks();
+
+        if (enableStairsAndSlabs) {
+            BlockModStairs.initStairs(snow_bricks, 0, new BlockSnowBricksStairs());
+            BlockModSlab.initSlab(snow_bricks, 0, new BlockSnowBricksSlab(false), new BlockSnowBricksSlab(true));
+        }
+        VanillaWalls.add("snow_bricks", snow_bricks, 0, enableWalls, (name, state) -> new BlockSnowBricksWall(name, state));
+
+		/*RecipeHandler.addOreDictRecipe(ProxyRegistry.newStack(snow_bricks, 4),
+				"SS", "SS",
+				'S', ProxyRegistry.newStack(Blocks.SNOW));*/
+    }
+
+    @Override
+    public boolean requiresMinecraftRestartToEnable() {
+        return true;
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/entity/render/layer/LayerDiverSuit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/entity/render/layer/LayerDiverSuit.java	(date 1525606861000)
+++ src/main/java/net/hdt/neutronia/entity/render/layer/LayerDiverSuit.java	(date 1525606861000)
@@ -0,0 +1,35 @@
+package net.hdt.neutronia.entity.render.layer;
+
+import net.hdt.neutronia.entity.EntityAnchored;
+import net.minecraft.client.model.ModelZombie;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.entity.RenderLivingBase;
+import net.minecraft.client.renderer.entity.layers.LayerRenderer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
+@SideOnly(Side.CLIENT)
+public class LayerDiverSuit implements LayerRenderer<EntityAnchored> {
+
+    private static final ResourceLocation STRAY_CLOTHES_TEXTURES = new ResourceLocation("neutronia:textures/entity/diver/diver_suit.png");
+    private final RenderLivingBase<?> renderer;
+    private final ModelZombie layerModel = new ModelZombie(0.25F, false);
+
+    public LayerDiverSuit(RenderLivingBase<?> p_i47183_1_) {
+        this.renderer = p_i47183_1_;
+    }
+
+    public void doRenderLayer(EntityAnchored entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
+        this.layerModel.setModelAttributes(this.renderer.getMainModel());
+        this.layerModel.setLivingAnimations(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks);
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+        this.renderer.bindTexture(STRAY_CLOTHES_TEXTURES);
+        this.layerModel.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+    }
+
+    public boolean shouldCombineTextures() {
+        return false;
+    }
+
+}
\ No newline at end of file
Index: src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingBase.java	(date 1525606883000)
+++ src/main/java/net/hdt/neutronia/blocks/nether/BlockNetherGlowingBase.java	(date 1525606883000)
@@ -0,0 +1,68 @@
+package net.hdt.neutronia.blocks.nether;
+
+import net.hdt.neutronia.Main;
+import net.hdt.neutronia.util.Reference;
+import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.enchantment.EnchantmentHelper;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.init.SoundEvents;
+import net.minecraft.util.DamageSource;
+import net.minecraft.util.EnumParticleTypes;
+import net.minecraft.util.SoundCategory;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
+
+import java.util.Random;
+
+public class BlockNetherGlowingBase extends BlockMod {
+
+    public BlockNetherGlowingBase(Material material, String name) {
+        super(material, Reference.MOD_ID, name);
+        setCreativeTab(Main.NETHER_EXPANSION_TAB);
+        this.setLightLevel(0.2F);
+        this.setTickRandomly(true);
+    }
+
+    /**
+     * Called when the given entity walks on this Block
+     */
+    public void onEntityWalk(World worldIn, BlockPos pos, Entity entityIn) {
+        if (!entityIn.isImmuneToFire() && entityIn instanceof EntityLivingBase && !EnchantmentHelper.hasFrostWalkerEnchantment((EntityLivingBase) entityIn)) {
+            entityIn.attackEntityFrom(DamageSource.HOT_FLOOR, 1.0F);
+        }
+
+        super.onEntityWalk(worldIn, pos, entityIn);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
+        return 15728880;
+    }
+
+    public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
+        BlockPos blockpos = pos.up();
+        IBlockState iblockstate = worldIn.getBlockState(blockpos);
+
+        if (iblockstate.getBlock() == Blocks.WATER || iblockstate.getBlock() == Blocks.FLOWING_WATER) {
+            worldIn.setBlockToAir(blockpos);
+            worldIn.playSound(null, pos, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (worldIn.rand.nextFloat() - worldIn.rand.nextFloat()) * 0.8F);
+
+            if (worldIn instanceof WorldServer) {
+                ((WorldServer) worldIn).spawnParticle(EnumParticleTypes.SMOKE_LARGE, (double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.25D, (double) blockpos.getZ() + 0.5D, 8, 0.5D, 0.25D, 0.5D, 0.0D);
+            }
+        }
+    }
+
+    public boolean canEntitySpawn(IBlockState state, Entity entityIn) {
+        return entityIn.isImmuneToFire();
+    }
+
+}
Index: src/main/java/net/hdt/neutronia/util/FileUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/hdt/neutronia/util/FileUtil.java	(date 1523988244000)
+++ src/main/java/net/hdt/neutronia/util/FileUtil.java	(date 1523988244000)
@@ -0,0 +1,58 @@
+package net.hdt.neutronia.util;
+
+import net.hdt.neutronia.Main;
+
+import java.io.*;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+public class FileUtil {
+
+    public static void extractFromJar(String sourcePath, String destinationPath) {
+        URL sourceURL = Main.class.getResource(sourcePath);
+        String fromPath = sourcePath.substring(1);
+
+        if (sourceURL != null && sourceURL.getProtocol().equals("jar")) {
+            try {
+                JarURLConnection jarURLConnection = (JarURLConnection) sourceURL.openConnection();
+                ZipFile zipFile = jarURLConnection.getJarFile();
+                Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
+
+                while (zipEntries.hasMoreElements()) {
+                    ZipEntry zipEntry = zipEntries.nextElement();
+                    String zipName = zipEntry.getName();
+
+                    if (!zipName.startsWith(fromPath)) {
+                        continue;
+                    }
+
+                    String pathTail = zipName.substring(fromPath.length());
+                    File file = new File(destinationPath + File.separator + pathTail);
+
+                    if (!file.exists()) {
+                        if (zipEntry.isDirectory()) {
+                            file.mkdir();
+                        } else {
+                            InputStream inputStream = zipFile.getInputStream(zipEntry);
+                            OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file));
+                            byte buffer[] = new byte[4096];
+                            int count;
+
+                            while ((count = inputStream.read(buffer)) > 0) {
+                                outputStream.write(buffer, 0, count);
+                            }
+
+                            inputStream.close();
+                            outputStream.close();
+                        }
+                    }
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntitySeaTurtle.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntitySeaTurtle.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntitySeaTurtle.java	(date 1525605768000)
@@ -1,242 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.MoverType;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.EntityAIBase;
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-
-public class EntitySeaTurtle extends EntityWaterMob {
-
-    public float squidPitch;
-    public float prevSquidPitch;
-    public float squidYaw;
-    public float prevSquidYaw;
-    /**
-     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
-     */
-    public float squidRotation;
-    /**
-     * previous squidRotation in radians
-     */
-    public float prevSquidRotation;
-    /**
-     * angle of the tentacles in radians
-     */
-    public float tentacleAngle;
-    /**
-     * the last calculated angle of the tentacles in radians
-     */
-    public float lastTentacleAngle;
-    private float randomMotionSpeed;
-    /**
-     * change in squidRotation in radians.
-     */
-    private float rotationVelocity;
-    private float rotateSpeed;
-    private float randomMotionVecX;
-    private float randomMotionVecY;
-    private float randomMotionVecZ;
-
-    public EntitySeaTurtle(World worldIn) {
-        super(worldIn);
-        setSize(0.5F, 0.5F);
-        this.rand.setSeed((long) (1 + this.getEntityId()));
-        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(0, new EntitySeaTurtle.AIMoveRandom(this));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
-    }
-
-    public float getEyeHeight() {
-        return this.height;
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_SQUID_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_SQUID_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_SQUID_DEATH;
-    }
-
-    /**
-     * Returns the volume for the sounds this mob makes.
-     */
-    protected float getSoundVolume() {
-        return 0.4F;
-    }
-
-    /**
-     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
-     * prevent them from trampling crops
-     */
-    protected boolean canTriggerWalking() {
-        return false;
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_SQUID;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        super.onLivingUpdate();
-        this.prevSquidPitch = this.squidPitch;
-        this.prevSquidYaw = this.squidYaw;
-        this.prevSquidRotation = this.squidRotation;
-        this.lastTentacleAngle = this.tentacleAngle;
-        this.squidRotation += this.rotationVelocity;
-
-        if ((double) this.squidRotation > (Math.PI * 2D)) {
-            if (this.world.isRemote) {
-                this.squidRotation = ((float) Math.PI * 2F);
-            } else {
-                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
-
-                if (this.rand.nextInt(10) == 0) {
-                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-                }
-
-                this.world.setEntityState(this, (byte) 19);
-            }
-        }
-
-        if (this.inWater) {
-            if (this.squidRotation < (float) Math.PI) {
-                float f = this.squidRotation / (float) Math.PI;
-                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
-
-                if ((double) f > 0.75D) {
-                    this.randomMotionSpeed = 1.0F;
-                    this.rotateSpeed = 1.0F;
-                } else {
-                    this.rotateSpeed *= 0.8F;
-                }
-            } else {
-                this.tentacleAngle = 0.0F;
-                this.randomMotionSpeed *= 0.9F;
-                this.rotateSpeed *= 0.99F;
-            }
-
-            if (!this.world.isRemote) {
-                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
-                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
-                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
-            }
-
-            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
-            this.rotationYaw = this.renderYawOffset;
-            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
-            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
-        } else {
-            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
-
-            if (!this.world.isRemote) {
-                this.motionX = 0.0D;
-                this.motionZ = 0.0D;
-
-                if (this.isPotionActive(MobEffects.LEVITATION)) {
-                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
-                } else if (!this.hasNoGravity()) {
-                    this.motionY -= 0.08D;
-                }
-
-                this.motionY *= 0.9800000190734863D;
-            }
-
-            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
-        }
-    }
-
-    public void travel(float strafe, float vertical, float forward) {
-        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
-    }
-
-    /**
-     * Checks if the entity's current position is a valid location to spawn this entity.
-     */
-    public boolean getCanSpawnHere() {
-        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
-    }
-
-    /**
-     * Handler for {@link World#setEntityState}
-     */
-    @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id) {
-        if (id == 19) {
-            this.squidRotation = 0.0F;
-        } else {
-            super.handleStatusUpdate(id);
-        }
-    }
-
-    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
-        this.randomMotionVecX = randomMotionVecXIn;
-        this.randomMotionVecY = randomMotionVecYIn;
-        this.randomMotionVecZ = randomMotionVecZIn;
-    }
-
-    public boolean hasMovementVector() {
-        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
-    }
-
-    static class AIMoveRandom extends EntityAIBase {
-        private final EntitySeaTurtle squid;
-
-        public AIMoveRandom(EntitySeaTurtle p_i45859_1_) {
-            this.squid = p_i45859_1_;
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            return true;
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            int i = this.squid.getIdleTime();
-
-            if (i > 100) {
-                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
-            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
-                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
-                float f1 = MathHelper.cos(f) * 0.2F;
-                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
-                float f3 = MathHelper.sin(f) * 0.2F;
-                this.squid.setMovementVector(f1, f2, f3);
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelCustomArmor.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelCustomArmor.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelCustomArmor.java	(date 1525605768000)
@@ -1,67 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.models;
-
-import net.minecraft.client.model.ModelBiped;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-public class ModelCustomArmor extends ModelBiped
-{
-    ModelRenderer basehorn;
-    ModelRenderer horn1;
-    ModelRenderer rightshoulder;
-    ModelRenderer leftshoulder;
-  
-  public ModelCustomArmor(float expand) {
-	  
-	  super(expand, 0, 64, 64);
- 
-      basehorn = new ModelRenderer(this, 38, 0);
-      basehorn.addBox(-1F, -9F, -4.5F, 2, 2, 2, expand);
-      basehorn.setRotationPoint(0F, 0F, 0F);
-      basehorn.setTextureSize(64, 32);
-      basehorn.mirror = true;
-      setRotation(basehorn, 0F, 0F, 0F);
-      
-      horn1 = new ModelRenderer(this, 33, 0);
-      horn1.addBox(-0.5F, -14.5F, 0.7666667F, 1, 5, 1, expand/3);
-      horn1.setRotationPoint(0F, 0F, 0F);
-      horn1.setTextureSize(64, 32);
-      horn1.mirror = true;
-      setRotation(horn1, 0.5576792F, 0F, 0F);
-      
-      rightshoulder = new ModelRenderer(this, 0, 33);
-      rightshoulder.addBox(-3.5F, -3F, -2.5F, 5, 5, 5, expand/1.2F);
-      rightshoulder.setRotationPoint(0F, 0F, 0F);
-      rightshoulder.setTextureSize(64, 32);
-      rightshoulder.mirror = true;
-      setRotation(rightshoulder, 0F, 0F, 0F);
-      
-      leftshoulder = new ModelRenderer(this, 0, 33);
-      leftshoulder.addBox(-1.5F, -3F, -2.5F, 5, 5, 5, expand/1.2F);
-      leftshoulder.setRotationPoint(0F, 0F, 0F);
-      leftshoulder.setTextureSize(64, 32);
-      leftshoulder.mirror = true;
-      setRotation(leftshoulder, 0F, 0F, 0F);
-      
-      basehorn.addChild(horn1);
-      this.bipedHead.addChild(basehorn);
-      
-      this.bipedRightArm.addChild(rightshoulder);
-      this.bipedLeftArm.addChild(leftshoulder);
-      
-  }
-  
-  public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
-    super.render(entity, f, f1, f2, f3, f4, f5);
-    setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-  }
-  
-  private void setRotation(ModelRenderer model, float x, float y, float z)
-  {
-    model.rotateAngleX = x;
-    model.rotateAngleY = y;
-    model.rotateAngleZ = z;
-  }
-  
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/commands/TPDimensionCommand.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/commands/TPDimensionCommand.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/commands/TPDimensionCommand.java	(date 1525605768000)
@@ -1,63 +0,0 @@
-package net.thegaminghuskymc.mcaddon.commands;
-
-import com.google.common.collect.Lists;
-import net.minecraft.command.CommandBase;
-import net.minecraft.command.ICommandSender;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.text.TextComponentString;
-import net.minecraft.util.text.TextFormatting;
-
-import java.util.Collections;
-import java.util.List;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class TPDimensionCommand extends CommandBase {
-    private final List<String> aliases = Lists.newArrayList(MOD_ID, "TP", "tp", "tpdim", "tpdimension", "teleport");
-
-    @Override
-    public void execute(MinecraftServer server, ICommandSender sender, String[] args) {
-        if (args.length < 1) return;
-
-        String s = args[0];
-        int dimension;
-
-        try {
-            dimension = Integer.parseInt(s);
-        } catch (NumberFormatException e) {
-            sender.sendMessage(new TextComponentString(TextFormatting.RED + "Dimension not found"));
-            return;
-        }
-
-        if (sender instanceof EntityPlayer) {
-            CustomTeleporter.teleportToDimension((EntityPlayer) sender, dimension, 0, 100, 0);
-        }
-    }
-
-    @Override
-    public String getName() {
-        return "tpdimension";
-    }
-
-    @Override
-    public String getUsage(ICommandSender sender) {
-        return "tpdimension <id>";
-    }
-
-    @Override
-    public List<String> getAliases() {
-        return aliases;
-    }
-
-    @Override
-    public boolean checkPermission(MinecraftServer server, ICommandSender sender) {
-        return true;
-    }
-
-    @Override
-    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos targetPos) {
-        return Collections.emptyList();
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/WorldUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/WorldUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/WorldUtil.java	(date 1525605768000)
@@ -1,44 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.player.EntityPlayerMP;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.World;
-
-public class WorldUtil
-{
-    public static RayTraceResult rayTraceFromEntity(World world, Entity entity, boolean countNonSolidBlock, double range)
-    {
-        float f = 1.0F;
-        float f1 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * f;
-        float f2 = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * f;
-        double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double) f;
-        double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double) f;
-
-        if(!world.isRemote && entity instanceof EntityPlayer)
-        {
-            d1 += 1.62D;
-        }
-
-        double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double) f;
-        Vec3d vec3 = new Vec3d(d0, d1, d2);
-        float f3 = MathHelper.cos(-f2 * 0.017453292F - (float) Math.PI);
-        float f4 = MathHelper.sin(-f2 * 0.017453292F - (float) Math.PI);
-        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
-        float f6 = MathHelper.sin(-f1 * 0.017453292F);
-        float f7 = f4 * f5;
-        float f8 = f3 * f5;
-        double d3 = range;
-
-        if(entity instanceof EntityPlayerMP)
-        {
-            d3 = ((EntityPlayerMP) entity).interactionManager.getBlockReachDistance();
-        }
-
-        Vec3d vec31 = vec3.addVector((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
-        return world.rayTraceBlocks(vec3, vec31, countNonSolidBlock, !countNonSolidBlock, countNonSolidBlock);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModFood.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModFood.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModFood.java	(date 1525605768000)
@@ -1,89 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemFood;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.NonNullList;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.huskylib2.interf.IVariantHolder;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-
-import java.util.ArrayList;
-
-public class ItemModFood extends ItemFood implements IVariantHolder {
-
-    public static final ArrayList<IVariantHolder> variantHolders = new ArrayList<>();
-
-    private final String[] variants;
-    private final String bareName, modid;
-
-    public ItemModFood(String modid, String name, CreativeTabs creativeTabs, int amount, float saturation, boolean isWolfFood, String... variants) {
-        super(amount, saturation, isWolfFood);
-        setCreativeTab(creativeTabs);
-        if (variants.length > 1)
-            setHasSubtypes(true);
-
-        if (variants.length == 0)
-            variants = new String[]{name};
-
-        bareName = name;
-        this.variants = variants;
-        this.modid = modid;
-        setUnlocalizedName(name);
-        variantHolders.add(this);
-    }
-
-    public ItemModFood(String modid, String name, CreativeTabs creativeTabs, int amount, boolean isWolfFood, String... variants) {
-        this(modid, name, creativeTabs, amount, 0.6F, isWolfFood, variants);
-    }
-
-    public Item setUnlocalizedName(String name) {
-        super.setUnlocalizedName(name);
-        this.setRegistryName(new ResourceLocation(getPrefix(), name));
-        ProxyRegistry.register(this);
-        return this;
-    }
-
-    @Override
-    public String getUnlocalizedName(ItemStack par1ItemStack) {
-        int dmg = par1ItemStack.getItemDamage();
-        String[] variants = getVariants();
-
-        String name;
-        if (dmg >= variants.length)
-            name = bareName;
-        else name = variants[dmg];
-
-        return "item." + name;
-    }
-
-    @Override
-    public String getPrefix() {
-        return this.modid;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return this.modid;
-    }
-
-    @Override
-    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> subItems) {
-        if (isInCreativeTab(tab))
-            for (int i = 0; i < getVariants().length; i++)
-                subItems.add(new ItemStack(this, 1, i));
-    }
-
-    @Override
-    public String[] getVariants() {
-        return variants;
-    }
-
-    @Override
-    public ItemMeshDefinition getCustomMeshDefinition() {
-        return null;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityArrow.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityArrow.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityArrow.java	(date 1525605768000)
@@ -1,719 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import java.util.List;
-import javax.annotation.Nullable;
-import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.IProjectile;
-import net.minecraft.entity.MoverType;
-import net.minecraft.entity.monster.EntityEnderman;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.player.EntityPlayerMP;
-import net.minecraft.init.Enchantments;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.network.play.server.SPacketChangeGameState;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EntitySelectors;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-public abstract class EntityArrow extends Entity implements IProjectile
-{
-    private static final Predicate<Entity> ARROW_TARGETS = Predicates.and(EntitySelectors.NOT_SPECTATING, EntitySelectors.IS_ALIVE, new Predicate<Entity>()
-    {
-        public boolean apply(@Nullable Entity p_apply_1_)
-        {
-            return p_apply_1_.canBeCollidedWith();
-        }
-    });
-    private static final DataParameter<Byte> CRITICAL = EntityDataManager.<Byte>createKey(EntityArrow.class, DataSerializers.BYTE);
-    private int xTile;
-    private int yTile;
-    private int zTile;
-    private Block inTile;
-    private int inData;
-    protected boolean inGround;
-    protected int timeInGround;
-    /** 1 if the player can pick up the arrow */
-    public EntityArrow.PickupStatus pickupStatus;
-    /** Seems to be some sort of timer for animating an arrow. */
-    public int arrowShake;
-    /** The owner of this arrow. */
-    public Entity shootingEntity;
-    private int ticksInGround;
-    private int ticksInAir;
-    private double damage;
-    /** The amount of knockback an arrow applies when it hits a mob. */
-    private int knockbackStrength;
-
-    public EntityArrow(World worldIn)
-    {
-        super(worldIn);
-        this.xTile = -1;
-        this.yTile = -1;
-        this.zTile = -1;
-        this.pickupStatus = EntityArrow.PickupStatus.DISALLOWED;
-        this.damage = 2.0D;
-        this.setSize(0.5F, 0.5F);
-    }
-
-    public EntityArrow(World worldIn, double x, double y, double z)
-    {
-        this(worldIn);
-        this.setPosition(x, y, z);
-    }
-
-    public EntityArrow(World worldIn, EntityLivingBase shooter)
-    {
-        this(worldIn, shooter.posX, shooter.posY + (double)shooter.getEyeHeight() - 0.10000000149011612D, shooter.posZ);
-        this.shootingEntity = shooter;
-
-        if (shooter instanceof EntityPlayer)
-        {
-            this.pickupStatus = EntityArrow.PickupStatus.ALLOWED;
-        }
-    }
-
-    /**
-     * Checks if the entity is in range to render.
-     */
-    @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRenderDist(double distance)
-    {
-        double d0 = this.getEntityBoundingBox().getAverageEdgeLength() * 10.0D;
-
-        if (Double.isNaN(d0))
-        {
-            d0 = 1.0D;
-        }
-
-        d0 = d0 * 64.0D * getRenderDistanceWeight();
-        return distance < d0 * d0;
-    }
-
-    protected void entityInit()
-    {
-        this.dataManager.register(CRITICAL, Byte.valueOf((byte)0));
-    }
-
-    public void shoot(Entity shooter, float pitch, float yaw, float p_184547_4_, float velocity, float inaccuracy)
-    {
-        float f = -MathHelper.sin(yaw * 0.017453292F) * MathHelper.cos(pitch * 0.017453292F);
-        float f1 = -MathHelper.sin(pitch * 0.017453292F);
-        float f2 = MathHelper.cos(yaw * 0.017453292F) * MathHelper.cos(pitch * 0.017453292F);
-        this.shoot((double)f, (double)f1, (double)f2, velocity, inaccuracy);
-        this.motionX += shooter.motionX;
-        this.motionZ += shooter.motionZ;
-
-        if (!shooter.onGround)
-        {
-            this.motionY += shooter.motionY;
-        }
-    }
-
-    /**
-     * Similar to setArrowHeading, it's point the throwable entity to a x, y, z direction.
-     */
-    public void shoot(double x, double y, double z, float velocity, float inaccuracy)
-    {
-        float f = MathHelper.sqrt(x * x + y * y + z * z);
-        x = x / (double)f;
-        y = y / (double)f;
-        z = z / (double)f;
-        x = x + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        y = y + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        z = z + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        x = x * (double)velocity;
-        y = y * (double)velocity;
-        z = z * (double)velocity;
-        this.motionX = x;
-        this.motionY = y;
-        this.motionZ = z;
-        float f1 = MathHelper.sqrt(x * x + z * z);
-        this.rotationYaw = (float)(MathHelper.atan2(x, z) * (180D / Math.PI));
-        this.rotationPitch = (float)(MathHelper.atan2(y, (double)f1) * (180D / Math.PI));
-        this.prevRotationYaw = this.rotationYaw;
-        this.prevRotationPitch = this.rotationPitch;
-        this.ticksInGround = 0;
-    }
-
-    /**
-     * Sets a target for the client to interpolate towards over the next few ticks
-     */
-    @SideOnly(Side.CLIENT)
-    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
-    {
-        this.setPosition(x, y, z);
-        this.setRotation(yaw, pitch);
-    }
-
-    /**
-     * Updates the entity motion clientside, called by packets from the server
-     */
-    @SideOnly(Side.CLIENT)
-    public void setVelocity(double x, double y, double z)
-    {
-        this.motionX = x;
-        this.motionY = y;
-        this.motionZ = z;
-
-        if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F)
-        {
-            float f = MathHelper.sqrt(x * x + z * z);
-            this.rotationPitch = (float)(MathHelper.atan2(y, (double)f) * (180D / Math.PI));
-            this.rotationYaw = (float)(MathHelper.atan2(x, z) * (180D / Math.PI));
-            this.prevRotationPitch = this.rotationPitch;
-            this.prevRotationYaw = this.rotationYaw;
-            this.setLocationAndAngles(this.posX, this.posY, this.posZ, this.rotationYaw, this.rotationPitch);
-            this.ticksInGround = 0;
-        }
-    }
-
-    /**
-     * Called to update the entity's position/logic.
-     */
-    public void onUpdate()
-    {
-        super.onUpdate();
-
-        if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F)
-        {
-            float f = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-            this.rotationYaw = (float)(MathHelper.atan2(this.motionX, this.motionZ) * (180D / Math.PI));
-            this.rotationPitch = (float)(MathHelper.atan2(this.motionY, (double)f) * (180D / Math.PI));
-            this.prevRotationYaw = this.rotationYaw;
-            this.prevRotationPitch = this.rotationPitch;
-        }
-
-        BlockPos blockpos = new BlockPos(this.xTile, this.yTile, this.zTile);
-        IBlockState iblockstate = this.world.getBlockState(blockpos);
-        Block block = iblockstate.getBlock();
-
-        if (iblockstate.getMaterial() != Material.AIR)
-        {
-            AxisAlignedBB axisalignedbb = iblockstate.getCollisionBoundingBox(this.world, blockpos);
-
-            if (axisalignedbb != Block.NULL_AABB && axisalignedbb.offset(blockpos).contains(new Vec3d(this.posX, this.posY, this.posZ)))
-            {
-                this.inGround = true;
-            }
-        }
-
-        if (this.arrowShake > 0)
-        {
-            --this.arrowShake;
-        }
-
-        if (this.inGround)
-        {
-            int j = block.getMetaFromState(iblockstate);
-
-            if ((block != this.inTile || j != this.inData) && !this.world.collidesWithAnyBlock(this.getEntityBoundingBox().grow(0.05D)))
-            {
-                this.inGround = false;
-                this.motionX *= (double)(this.rand.nextFloat() * 0.2F);
-                this.motionY *= (double)(this.rand.nextFloat() * 0.2F);
-                this.motionZ *= (double)(this.rand.nextFloat() * 0.2F);
-                this.ticksInGround = 0;
-                this.ticksInAir = 0;
-            }
-            else
-            {
-                ++this.ticksInGround;
-
-                if (this.ticksInGround >= 1200)
-                {
-                    this.setDead();
-                }
-            }
-
-            ++this.timeInGround;
-        }
-        else
-        {
-            this.timeInGround = 0;
-            ++this.ticksInAir;
-            Vec3d vec3d1 = new Vec3d(this.posX, this.posY, this.posZ);
-            Vec3d vec3d = new Vec3d(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
-            RayTraceResult raytraceresult = this.world.rayTraceBlocks(vec3d1, vec3d, false, true, false);
-            vec3d1 = new Vec3d(this.posX, this.posY, this.posZ);
-            vec3d = new Vec3d(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
-
-            if (raytraceresult != null)
-            {
-                vec3d = new Vec3d(raytraceresult.hitVec.x, raytraceresult.hitVec.y, raytraceresult.hitVec.z);
-            }
-
-            Entity entity = this.findEntityOnPath(vec3d1, vec3d);
-
-            if (entity != null)
-            {
-                raytraceresult = new RayTraceResult(entity);
-            }
-
-            if (raytraceresult != null && raytraceresult.entityHit instanceof EntityPlayer)
-            {
-                EntityPlayer entityplayer = (EntityPlayer)raytraceresult.entityHit;
-
-                if (this.shootingEntity instanceof EntityPlayer && !((EntityPlayer)this.shootingEntity).canAttackPlayer(entityplayer))
-                {
-                    raytraceresult = null;
-                }
-            }
-
-            if (raytraceresult != null && !net.minecraftforge.event.ForgeEventFactory.onProjectileImpact(this, raytraceresult))
-            {
-                this.onHit(raytraceresult);
-            }
-
-            if (this.getIsCritical())
-            {
-                for (int k = 0; k < 4; ++k)
-                {
-                    this.world.spawnParticle(EnumParticleTypes.CRIT, this.posX + this.motionX * (double)k / 4.0D, this.posY + this.motionY * (double)k / 4.0D, this.posZ + this.motionZ * (double)k / 4.0D, -this.motionX, -this.motionY + 0.2D, -this.motionZ);
-                }
-            }
-
-            this.posX += this.motionX;
-            this.posY += this.motionY;
-            this.posZ += this.motionZ;
-            float f4 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-            this.rotationYaw = (float)(MathHelper.atan2(this.motionX, this.motionZ) * (180D / Math.PI));
-
-            for (this.rotationPitch = (float)(MathHelper.atan2(this.motionY, (double)f4) * (180D / Math.PI)); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
-            {
-                ;
-            }
-
-            while (this.rotationPitch - this.prevRotationPitch >= 180.0F)
-            {
-                this.prevRotationPitch += 360.0F;
-            }
-
-            while (this.rotationYaw - this.prevRotationYaw < -180.0F)
-            {
-                this.prevRotationYaw -= 360.0F;
-            }
-
-            while (this.rotationYaw - this.prevRotationYaw >= 180.0F)
-            {
-                this.prevRotationYaw += 360.0F;
-            }
-
-            this.rotationPitch = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
-            this.rotationYaw = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
-            float f1 = 0.99F;
-            float f2 = 0.05F;
-
-            if (this.isInWater())
-            {
-                for (int i = 0; i < 4; ++i)
-                {
-                    float f3 = 0.25F;
-                    this.world.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX - this.motionX * 0.25D, this.posY - this.motionY * 0.25D, this.posZ - this.motionZ * 0.25D, this.motionX, this.motionY, this.motionZ);
-                }
-
-                f1 = 0.6F;
-            }
-
-            if (this.isWet())
-            {
-                this.extinguish();
-            }
-
-            this.motionX *= (double)f1;
-            this.motionY *= (double)f1;
-            this.motionZ *= (double)f1;
-
-            if (!this.hasNoGravity())
-            {
-                this.motionY -= 0.05000000074505806D;
-            }
-
-            this.setPosition(this.posX, this.posY, this.posZ);
-            this.doBlockCollisions();
-        }
-    }
-
-    /**
-     * Called when the arrow hits a animation.animations.blocks or an entity
-     */
-    protected void onHit(RayTraceResult raytraceResultIn)
-    {
-        Entity entity = raytraceResultIn.entityHit;
-
-        if (entity != null)
-        {
-            float f = MathHelper.sqrt(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-            int i = MathHelper.ceil((double)f * this.damage);
-
-            if (this.getIsCritical())
-            {
-                i += this.rand.nextInt(i / 2 + 2);
-            }
-
-            DamageSource damagesource = DamageSource.GENERIC;
-
-            if (this.isBurning() && !(entity instanceof EntityEnderman))
-            {
-                entity.setFire(5);
-            }
-
-            if (entity.attackEntityFrom(damagesource, (float)i))
-            {
-                if (entity instanceof EntityLivingBase)
-                {
-                    EntityLivingBase entitylivingbase = (EntityLivingBase)entity;
-
-                    if (!this.world.isRemote)
-                    {
-                        entitylivingbase.setArrowCountInEntity(entitylivingbase.getArrowCountInEntity() + 1);
-                    }
-
-                    if (this.knockbackStrength > 0)
-                    {
-                        float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-
-                        if (f1 > 0.0F)
-                        {
-                            entitylivingbase.addVelocity(this.motionX * (double)this.knockbackStrength * 0.6000000238418579D / (double)f1, 0.1D, this.motionZ * (double)this.knockbackStrength * 0.6000000238418579D / (double)f1);
-                        }
-                    }
-
-                    if (this.shootingEntity instanceof EntityLivingBase)
-                    {
-                        EnchantmentHelper.applyThornEnchantments(entitylivingbase, this.shootingEntity);
-                        EnchantmentHelper.applyArthropodEnchantments((EntityLivingBase)this.shootingEntity, entitylivingbase);
-                    }
-
-                    this.arrowHit(entitylivingbase);
-
-                    if (this.shootingEntity != null && entitylivingbase != this.shootingEntity && entitylivingbase instanceof EntityPlayer && this.shootingEntity instanceof EntityPlayerMP)
-                    {
-                        ((EntityPlayerMP)this.shootingEntity).connection.sendPacket(new SPacketChangeGameState(6, 0.0F));
-                    }
-                }
-
-                this.playSound(SoundEvents.ENTITY_ARROW_HIT, 1.0F, 1.2F / (this.rand.nextFloat() * 0.2F + 0.9F));
-
-                if (!(entity instanceof EntityEnderman))
-                {
-                    this.setDead();
-                }
-            }
-            else
-            {
-                this.motionX *= -0.10000000149011612D;
-                this.motionY *= -0.10000000149011612D;
-                this.motionZ *= -0.10000000149011612D;
-                this.rotationYaw += 180.0F;
-                this.prevRotationYaw += 180.0F;
-                this.ticksInAir = 0;
-
-                if (!this.world.isRemote && this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ < 0.0010000000474974513D)
-                {
-                    if (this.pickupStatus == EntityArrow.PickupStatus.ALLOWED)
-                    {
-                        this.entityDropItem(this.getArrowStack(), 0.1F);
-                    }
-
-                    this.setDead();
-                }
-            }
-        }
-        else
-        {
-            BlockPos blockpos = raytraceResultIn.getBlockPos();
-            this.xTile = blockpos.getX();
-            this.yTile = blockpos.getY();
-            this.zTile = blockpos.getZ();
-            IBlockState iblockstate = this.world.getBlockState(blockpos);
-            this.inTile = iblockstate.getBlock();
-            this.inData = this.inTile.getMetaFromState(iblockstate);
-            this.motionX = (double)((float)(raytraceResultIn.hitVec.x - this.posX));
-            this.motionY = (double)((float)(raytraceResultIn.hitVec.y - this.posY));
-            this.motionZ = (double)((float)(raytraceResultIn.hitVec.z - this.posZ));
-            float f2 = MathHelper.sqrt(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-            this.posX -= this.motionX / (double)f2 * 0.05000000074505806D;
-            this.posY -= this.motionY / (double)f2 * 0.05000000074505806D;
-            this.posZ -= this.motionZ / (double)f2 * 0.05000000074505806D;
-            this.playSound(SoundEvents.ENTITY_ARROW_HIT, 1.0F, 1.2F / (this.rand.nextFloat() * 0.2F + 0.9F));
-            this.inGround = true;
-            this.arrowShake = 7;
-            this.setIsCritical(false);
-
-            if (iblockstate.getMaterial() != Material.AIR)
-            {
-                this.inTile.onEntityCollidedWithBlock(this.world, blockpos, iblockstate, this);
-            }
-        }
-    }
-
-    /**
-     * Tries to move the entity towards the specified location.
-     */
-    public void move(MoverType type, double x, double y, double z)
-    {
-        super.move(type, x, y, z);
-
-        if (this.inGround)
-        {
-            this.xTile = MathHelper.floor(this.posX);
-            this.yTile = MathHelper.floor(this.posY);
-            this.zTile = MathHelper.floor(this.posZ);
-        }
-    }
-
-    protected void arrowHit(EntityLivingBase living)
-    {
-    }
-
-    @Nullable
-    protected Entity findEntityOnPath(Vec3d start, Vec3d end)
-    {
-        Entity entity = null;
-        List<Entity> list = this.world.getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().expand(this.motionX, this.motionY, this.motionZ).grow(1.0D), ARROW_TARGETS);
-        double d0 = 0.0D;
-
-        for (int i = 0; i < list.size(); ++i)
-        {
-            Entity entity1 = list.get(i);
-
-            if (entity1 != this.shootingEntity || this.ticksInAir >= 5)
-            {
-                AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().grow(0.30000001192092896D);
-                RayTraceResult raytraceresult = axisalignedbb.calculateIntercept(start, end);
-
-                if (raytraceresult != null)
-                {
-                    double d1 = start.squareDistanceTo(raytraceresult.hitVec);
-
-                    if (d1 < d0 || d0 == 0.0D)
-                    {
-                        entity = entity1;
-                        d0 = d1;
-                    }
-                }
-            }
-        }
-
-        return entity;
-    }
-
-    public static void registerFixesArrow(DataFixer fixer, String name)
-    {
-    }
-
-    public static void registerFixesArrow(DataFixer fixer)
-    {
-        registerFixesArrow(fixer, "Arrow");
-    }
-
-    /**
-     * (abstract) Protected helper method to write subclass entity data to NBT.
-     */
-    public void writeEntityToNBT(NBTTagCompound compound)
-    {
-        compound.setInteger("xTile", this.xTile);
-        compound.setInteger("yTile", this.yTile);
-        compound.setInteger("zTile", this.zTile);
-        compound.setShort("life", (short)this.ticksInGround);
-        ResourceLocation resourcelocation = Block.REGISTRY.getNameForObject(this.inTile);
-        compound.setString("inTile", resourcelocation == null ? "" : resourcelocation.toString());
-        compound.setByte("inData", (byte)this.inData);
-        compound.setByte("shake", (byte)this.arrowShake);
-        compound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
-        compound.setByte("pickup", (byte)this.pickupStatus.ordinal());
-        compound.setDouble("damage", this.damage);
-        compound.setBoolean("crit", this.getIsCritical());
-    }
-
-    /**
-     * (abstract) Protected helper method to read subclass entity data from NBT.
-     */
-    public void readEntityFromNBT(NBTTagCompound compound)
-    {
-        this.xTile = compound.getInteger("xTile");
-        this.yTile = compound.getInteger("yTile");
-        this.zTile = compound.getInteger("zTile");
-        this.ticksInGround = compound.getShort("life");
-
-        if (compound.hasKey("inTile", 8))
-        {
-            this.inTile = Block.getBlockFromName(compound.getString("inTile"));
-        }
-        else
-        {
-            this.inTile = Block.getBlockById(compound.getByte("inTile") & 255);
-        }
-
-        this.inData = compound.getByte("inData") & 255;
-        this.arrowShake = compound.getByte("shake") & 255;
-        this.inGround = compound.getByte("inGround") == 1;
-
-        if (compound.hasKey("damage", 99))
-        {
-            this.damage = compound.getDouble("damage");
-        }
-
-        if (compound.hasKey("pickup", 99))
-        {
-            this.pickupStatus = EntityArrow.PickupStatus.getByOrdinal(compound.getByte("pickup"));
-        }
-        else if (compound.hasKey("player", 99))
-        {
-            this.pickupStatus = compound.getBoolean("player") ? EntityArrow.PickupStatus.ALLOWED : EntityArrow.PickupStatus.DISALLOWED;
-        }
-
-        this.setIsCritical(compound.getBoolean("crit"));
-    }
-
-    /**
-     * Called by a player entity when they collide with an entity
-     */
-    public void onCollideWithPlayer(EntityPlayer entityIn)
-    {
-        if (!this.world.isRemote && this.inGround && this.arrowShake <= 0)
-        {
-            boolean flag = this.pickupStatus == EntityArrow.PickupStatus.ALLOWED || this.pickupStatus == EntityArrow.PickupStatus.CREATIVE_ONLY && entityIn.capabilities.isCreativeMode;
-
-            if (this.pickupStatus == EntityArrow.PickupStatus.ALLOWED && !entityIn.inventory.addItemStackToInventory(this.getArrowStack()))
-            {
-                flag = false;
-            }
-
-            if (flag)
-            {
-                entityIn.onItemPickup(this, 1);
-                this.setDead();
-            }
-        }
-    }
-
-    protected abstract ItemStack getArrowStack();
-
-    /**
-     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
-     * prevent them from trampling crops
-     */
-    protected boolean canTriggerWalking()
-    {
-        return false;
-    }
-
-    public void setDamage(double damageIn)
-    {
-        this.damage = damageIn;
-    }
-
-    public double getDamage()
-    {
-        return this.damage;
-    }
-
-    /**
-     * Sets the amount of knockback the arrow applies when it hits a mob.
-     */
-    public void setKnockbackStrength(int knockbackStrengthIn)
-    {
-        this.knockbackStrength = knockbackStrengthIn;
-    }
-
-    /**
-     * Returns true if it's possible to attack this entity with an item.
-     */
-    public boolean canBeAttackedWithItem()
-    {
-        return false;
-    }
-
-    public float getEyeHeight()
-    {
-        return 0.0F;
-    }
-
-    /**
-     * Whether the arrow has a stream of critical hit particles flying behind it.
-     */
-    public void setIsCritical(boolean critical)
-    {
-        byte b0 = ((Byte)this.dataManager.get(CRITICAL)).byteValue();
-
-        if (critical)
-        {
-            this.dataManager.set(CRITICAL, Byte.valueOf((byte)(b0 | 1)));
-        }
-        else
-        {
-            this.dataManager.set(CRITICAL, Byte.valueOf((byte)(b0 & -2)));
-        }
-    }
-
-    /**
-     * Whether the arrow has a stream of critical hit particles flying behind it.
-     */
-    public boolean getIsCritical()
-    {
-        byte b0 = ((Byte)this.dataManager.get(CRITICAL)).byteValue();
-        return (b0 & 1) != 0;
-    }
-
-    public void setEnchantmentEffectsFromEntity(EntityLivingBase p_190547_1_, float p_190547_2_)
-    {
-        int i = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.POWER, p_190547_1_);
-        int j = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.PUNCH, p_190547_1_);
-        this.setDamage((double)(p_190547_2_ * 2.0F) + this.rand.nextGaussian() * 0.25D + (double)((float)this.world.getDifficulty().getDifficultyId() * 0.11F));
-
-        if (i > 0)
-        {
-            this.setDamage(this.getDamage() + (double)i * 0.5D + 0.5D);
-        }
-
-        if (j > 0)
-        {
-            this.setKnockbackStrength(j);
-        }
-
-        if (EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.FLAME, p_190547_1_) > 0)
-        {
-            this.setFire(100);
-        }
-    }
-
-    public static enum PickupStatus
-    {
-        DISALLOWED,
-        ALLOWED,
-        CREATIVE_ONLY;
-
-        public static EntityArrow.PickupStatus getByOrdinal(int ordinal)
-        {
-            if (ordinal < 0 || ordinal > values().length)
-            {
-                ordinal = 0;
-            }
-
-            return values()[ordinal];
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderScorp.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderScorp.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderScorp.java	(date 1525605768000)
@@ -1,31 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelScorpion;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-import net.thegaminghuskymc.mcaddon.entity.EntityScorp;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelScorp;
-
-public class RenderScorp extends RenderLiving<EntityScorp>
-{
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/scorpion.png");
-
-    public  RenderScorp(RenderManager manager)
-    {
-        super(manager, new ModelScorpion(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityScorp entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntityScorp entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/proxy/CommonProxy.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/proxy/CommonProxy.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/proxy/CommonProxy.java	(date 1525605768000)
@@ -1,21 +0,0 @@
-package net.thegaminghuskymc.mcaddon.proxy;
-
-import net.minecraftforge.fml.common.event.FMLInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
-
-public class CommonProxy {
-
-    public void preInit(FMLPreInitializationEvent event) {
-
-    }
-
-    public void init(FMLInitializationEvent event) {
-
-    }
-
-    public void postInit(FMLPostInitializationEvent event) {
-
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ArmorTM.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ArmorTM.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ArmorTM.java	(date 1525605768000)
@@ -1,76 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.client.model.ModelBiped;
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.ItemStack;
-import net.thegaminghuskymc.huskylib2.items.ItemModArmor;
-import net.thegaminghuskymc.mcaddon.proxy.ClientProxy;
-
-import javax.annotation.Nullable;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class ArmorTM extends ItemModArmor {
-
-	public ArmorTM(String name, ArmorMaterial material, int renderindex, EntityEquipmentSlot type) {
-		super(name, MOD_ID, material, renderindex, type);
-		
-		this.setMaxStackSize(1);
-		this.setCreativeTab(CreativeTabs.COMBAT);
-		
-	}
-	
-	@Override
-	public String getUnlocalizedName(){
-		return String.format("item.%s%s", MOD_ID, getUnwrappedUnlocalizedName(super.getUnlocalizedName()));
-	}
-	
-	@Override
-	public String getUnlocalizedName(ItemStack itemstack){
-		return String.format("item.%s%s", MOD_ID, getUnwrappedUnlocalizedName(super.getUnlocalizedName()));
-	}
-	
-	protected String getUnwrappedUnlocalizedName(String unlocalizedName){		
-		return unlocalizedName.substring(unlocalizedName.indexOf('.') + 1);
-	}
-
-	@Nullable
-	@Override
-	public ModelBiped getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, ModelBiped _default) {
-
-		ModelBiped armorModel = ClientProxy.armorModels.get(this);
-
-        if(armorModel != null){
-            armorModel.bipedHead.showModel = armorSlot == EntityEquipmentSlot.HEAD;
-            armorModel.bipedHeadwear.showModel = false;
-            armorModel.bipedBody.showModel = armorSlot == EntityEquipmentSlot.FEET || armorSlot == EntityEquipmentSlot.LEGS;
-            armorModel.bipedRightArm.showModel = armorSlot == EntityEquipmentSlot.FEET;
-            armorModel.bipedLeftArm.showModel = armorSlot == EntityEquipmentSlot.FEET;
-            armorModel.bipedRightLeg.showModel = armorSlot == EntityEquipmentSlot.LEGS || armorSlot == EntityEquipmentSlot.CHEST;
-            armorModel.bipedLeftLeg.showModel = armorSlot == EntityEquipmentSlot.LEGS || armorSlot == EntityEquipmentSlot.CHEST;
-
-            armorModel.isSneak = entityLiving.isSneaking();
-            armorModel.isRiding = entityLiving.isRiding();
-            armorModel.isChild = entityLiving.isChild();
-
-        }
-
-
-        return armorModel;
-	}
-
-    @Nullable
-    @Override
-    public String getArmorTexture(ItemStack stack, Entity entity, EntityEquipmentSlot slot, String type) {
-        String name = this.getUnwrappedUnlocalizedName(super.getUnlocalizedName());
-        name = name.substring(0, name.indexOf('_'));
-
-        return String.format("%s:textures/models/armor/%s_layer_%d.png", MOD_ID, name, slot == EntityEquipmentSlot.LEGS ? 2 : 1);
-    }
-	
-	
-	
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonItems.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonItems.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonItems.java	(date 1525605768000)
@@ -1,70 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.init.SoundEvents;
-import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemArmor;
-import net.minecraftforge.common.util.EnumHelper;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.items.*;
-import net.thegaminghuskymc.mcaddon.items.base.tools.*;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@Mod.EventBusSubscriber(modid = MOD_ID)
-public class MCAddonItems
-{
-    public static final Item.ToolMaterial CAXE = EnumHelper.addToolMaterial("caxe", 3, 350, 7.0F, 4.0F, 12);
-    public static final Item.ToolMaterial CPICK = EnumHelper.addToolMaterial("cpick", 3, 350, 7.0F, 4.0F, 12);
-    public static final Item.ToolMaterial CHOE = EnumHelper.addToolMaterial("choe", 3, 325, 7.0F, 4.0F, 12);
-    public static final Item.ToolMaterial CSHOVEL = EnumHelper.addToolMaterial("cshovel", 3, 325, 7.0F, 4.0F, 12);
-    public static final Item.ToolMaterial CSWORD = EnumHelper.addToolMaterial("csword", 3, 325, 7.0F, 8.0F, 12);
-    public static final ItemArmor.ArmorMaterial TEST = EnumHelper.addArmorMaterial("test", "test", 100, new int[] {10, 10, 10, 10}, 10, SoundEvents.ITEM_ARMOR_EQUIP_LEATHER, 3F);
-
-    public static final Item ANCIENT_SWORD;
-    public static final Item BANDAGE;
-    public static final Item witherBone, witherBonemeal;
-    public static final Item driedKelp;
-    public static final Item STINGER;
-    public static final Item CHITIN;
-
-    public static final Item AXE_CHITIN;
-    public static final Item PICKAXE_CHITIN;
-    public static final Item HOE_CHITIN;
-    public static final Item SHOVEL_CHITIN;
-    public static final Item SWORD_CHITIN;
-
-    public static final ArmorTM healmet;
-    public static final ArmorTM chestplate;
-    public static final ArmorTM leggings;
-    public static final ArmorTM boots;
-
-    static {
-        ANCIENT_SWORD = new ItemAncientSword();
-        BANDAGE = new ItemBandage();
-        witherBone = new ItemBase("wither_bone", Main.NETHER_EXPANSION_TAB);
-        witherBonemeal = new ItemBase("wither_bonemeal", Main.NETHER_EXPANSION_TAB);
-        driedKelp = new ItemFood("dried_kelp", Main.OVERWORLD_EXPANSION_TAB);
-        STINGER = new ItemBase("stinger", Main.OVERWORLD_EXPANSION_TAB);
-        CHITIN = new ItemBase("chitin", Main.OVERWORLD_EXPANSION_TAB);
-
-        AXE_CHITIN = new BaseAxe("axe_chitin", CAXE);
-        PICKAXE_CHITIN = new BasePickaxe("pickaxe_chitin", CPICK);
-        HOE_CHITIN = new BaseHoe("hoe_chitin", CHOE);
-        SHOVEL_CHITIN = new BaseShovel("shovel_chitin", CSHOVEL);
-        SWORD_CHITIN = new BaseSword("sword_chitin", CSWORD);
-        healmet = new ArmorTM("test_helmet", TEST, 0, EntityEquipmentSlot.HEAD);
-        chestplate = new ArmorTM("test_chestplate", TEST, 0, EntityEquipmentSlot.CHEST);
-        leggings = new ArmorTM("test_leggings", TEST, 0, EntityEquipmentSlot.LEGS);
-        boots = new ArmorTM("test_boots", TEST, 0, EntityEquipmentSlot.FEET);
-    }
-
-    @SubscribeEvent
-    public static void registerItems(RegistryEvent.Register<Item> event) {
-
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonBlocks.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonBlocks.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonBlocks.java	(date 1525605768000)
@@ -1,169 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.blocks.base.BlockModFence;
-import net.thegaminghuskymc.mcaddon.blocks.nether.BlockNetherBase;
-import net.thegaminghuskymc.mcaddon.blocks.nether.BlockNetherSlabBase;
-import net.thegaminghuskymc.mcaddon.blocks.overworld.BlockCoral;
-import net.thegaminghuskymc.mcaddon.blocks.overworld.BlockCoralPlant;
-import net.thegaminghuskymc.mcaddon.blocks.overworld.BlockOverworldBase;
-import net.thegaminghuskymc.mcaddon.blocks.overworld.BlockOverworldSlabBase;
-import net.thegaminghuskymc.mcaddon.properties.EnumAquamarineVariants;
-import net.thegaminghuskymc.mcaddon.properties.EnumCoralColor;
-import net.thegaminghuskymc.mcaddon.properties.EnumNetherBlocks;
-import net.thegaminghuskymc.mcaddon.properties.EnumNewStoneVariants;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@Mod.EventBusSubscriber(modid = MOD_ID)
-public class MCAddonBlocks {
-
-    public static Block[] brain_coral = new Block[5];
-    public static Block[] dead_brain_coral = new Block[5];
-    public static Block[] normal_coral = new Block[5];
-    public static Block[] dead_normal_coral = new Block[5];
-    public static Block[] coral_fan = new Block[5];
-    public static Block[] dead_coral_fan = new Block[5];
-    public static Block[] pipe_coral = new Block[5];
-    public static Block[] dead_pipe_coral = new Block[5];
-    public static Block[] sea_fan = new Block[5];
-    public static Block[] dead_sea_fan = new Block[5];
-    public static final Block dried_kelp_block;
-    public static final Block blackSand;
-
-    public static Block[] brainCoralStair = new Block[5];
-    public static Block[] deadBrainCoralStair = new Block[5];
-    public static Block[] coralStair = new Block[5];
-    public static Block[] deadCoralStair = new Block[5];
-
-    public static Block[] brainCoralFence = new Block[5];
-
-    public static Block[] brainCoralSlab = new Block[5];
-    public static Block[] deadBrainCoralSlab = new Block[5];
-    public static Block[] coralSlab = new Block[5];
-    public static Block[] deadCoralSlab = new Block[5];
-
-    public static Block[] brainCoralSlabDouble = new Block[5];
-    public static Block[] deadBrainCoralSlabDouble = new Block[5];
-    public static Block[] coralSlabDouble = new Block[5];
-    public static Block[] deadCoralSlabDouble = new Block[5];
-
-    public static Block[] naturalAquamarine = new Block[6];
-    public static Block[] aquamarine = new Block[6];
-    public static Block[] naturalAquamarineStairs = new Block[6];
-    public static Block[] aquamarineStairs = new Block[6];
-    public static Block[] naturalAquamarineSlabs = new Block[6];
-    public static Block[] naturalAquamarineSlabsVertical = new Block[6];
-    public static Block[] aquamarineSlabs = new Block[6];
-    public static Block[] aquamarineSlabsVertical = new Block[6];
-    public static Block[] naturalAquamarineSlabsDouble = new Block[6];
-    public static Block[] aquamarineSlabsDouble = new Block[6];
-    public static Block[] aquamarineSlabsDoubleVertical = new Block[6];
-
-    public static Block[] newStoneVariants = new Block[25];
-    public static Block[] newStoneVariantStairs = new Block[25];
-    public static Block[] newStoneVariantSlabs = new Block[25];
-    public static Block[] newStoneVariantSlabsVertical = new Block[25];
-    public static Block[] newStoneVariantSlabsDouble = new Block[25];
-
-    public static Block[] netherBlocks = new Block[6];
-    public static Block[] netherBlocksStairs = new Block[6];
-    public static Block[] netherBlocksSlabs = new Block[6];
-    public static Block[] netherBlocksSlabsVertical = new Block[6];
-    public static Block[] netherBlocksSlabsDouble = new Block[6];
-    public static Block[] netherBlocksFences = new Block[6];
-    public static Block[] netherBlocksFenceGates = new Block[6];
-
-    static {
-        for(EnumCoralColor coralColor : EnumCoralColor.values()) {
-            brain_coral[coralColor.getMetadata()] = new BlockCoral(coralColor, "brain_coral");
-            dead_brain_coral[coralColor.getMetadata()] = new BlockCoral(coralColor, "dead_brain_coral");
-            normal_coral[coralColor.getMetadata()] = new BlockCoral(coralColor, "coral");
-            dead_normal_coral[coralColor.getMetadata()] = new BlockCoral(coralColor, "dead_coral");
-            coral_fan[coralColor.getMetadata()] = new BlockCoralPlant(coralColor, "coral_fan");
-            /*dead_coral_fan[coralColor.getMetadata()] = new BlockCoralPlant(coralColor, "dead_coral_fan");
-            pipe_coral[coralColor.getMetadata()] = new BlockDoubleCoralPlant(coralColor, "pipe_coral");
-            dead_pipe_coral[coralColor.getMetadata()] = new BlockDoubleCoralPlant(coralColor, "dead_coral_plant");
-            sea_fan[coralColor.getMetadata()] = new BlockDoubleCoralPlant(coralColor, "sea_fan");
-            dead_sea_fan[coralColor.getMetadata()] = new BlockDoubleCoralPlant(coralColor, "dead_sea_fan");*/
-
-            brainCoralFence[coralColor.getMetadata()] = new BlockModFence(Material.CORAL, MOD_ID, coralColor.getName() + "_brain_coral_fence").setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-
-            /*brainCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_brain_coral_stairs", brain_coral[coralColor.getMetadata()].getDefaultState());
-            deadBrainCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_dead_brain_coral_stairs", dead_brain_coral[coralColor.getMetadata()].getDefaultState());
-            coralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_coral_stairs", normal_coral[coralColor.getMetadata()].getDefaultState());
-            deadCoralStair[coralColor.getMetadata()] = new BlockOverworldStairBase(coralColor.getName() + "_dead_coral_stairs", dead_normal_coral[coralColor.getMetadata()].getDefaultState());
-
-            BlockModStairs.initStairs(brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) brainCoralStair[coralColor.getMetadata()]);
-            BlockModStairs.initStairs(dead_brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) deadBrainCoralStair[coralColor.getMetadata()]);
-            BlockModStairs.initStairs(normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) coralStair[coralColor.getMetadata()]);
-            BlockModStairs.initStairs(dead_normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModStairs) deadCoralStair[coralColor.getMetadata()]);*/
-
-            brainCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_brain_coral_slab", false);
-            deadBrainCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_brain_coral_slab", false);
-            coralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_coral_slab", false);
-            deadCoralSlab[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_coral_slab", false);
-
-            brainCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_brain_coral_slab", true);
-            deadBrainCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_brain_coral_slab", true);
-            coralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_coral_slab", true);
-            deadCoralSlabDouble[coralColor.getMetadata()] = new BlockOverworldSlabBase(coralColor.getName() + "_dead_coral_slab", true);
-
-            BlockModSlab.initSlab(brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) brainCoralSlab[coralColor.getMetadata()], (BlockModSlab) brainCoralSlabDouble[coralColor.getMetadata()]);
-            BlockModSlab.initSlab(dead_brain_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) deadBrainCoralSlab[coralColor.getMetadata()], (BlockModSlab) deadBrainCoralSlabDouble[coralColor.getMetadata()]);
-            BlockModSlab.initSlab(normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) coralSlab[coralColor.getMetadata()], (BlockModSlab) coralSlabDouble[coralColor.getMetadata()]);
-            BlockModSlab.initSlab(dead_normal_coral[coralColor.getMetadata()], coralColor.getMetadata(), (BlockModSlab) deadCoralSlab[coralColor.getMetadata()], (BlockModSlab) deadCoralSlabDouble[coralColor.getMetadata()]);
-        }
-
-        for(EnumAquamarineVariants aquamarineVariants : EnumAquamarineVariants.values()) {
-            naturalAquamarine[aquamarineVariants.ordinal()] = new BlockOverworldBase(Material.ROCK, aquamarineVariants.getName() + "_natural_aquamarine");
-            aquamarine[aquamarineVariants.ordinal()] = new BlockOverworldBase(Material.ROCK, aquamarineVariants.getName() + "_aquamarine");
-            /*naturalAquamarineStairs[aquamarineVariants.ordinal()] = new BlockOverworldStairBase(aquamarineVariants.getName() + "_natural_aquamarine_stairs", naturalAquamarine[aquamarineVariants.ordinal()].getDefaultState());
-            BlockModStairs.initStairs(naturalAquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModStairs) naturalAquamarineStairs[aquamarineVariants.ordinal()]);
-            aquamarineStairs[aquamarineVariants.ordinal()] = new BlockOverworldStairBase(aquamarineVariants.getName() + "_aquamarine_stairs", aquamarine[aquamarineVariants.ordinal()].getDefaultState());
-            BlockModStairs.initStairs(aquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModStairs) aquamarineStairs[aquamarineVariants.ordinal()]);*/
-            naturalAquamarineSlabs[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_natural_aquamarine_slab", false);
-            naturalAquamarineSlabsDouble[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_natural_aquamarine_slab", true);
-            BlockModSlab.initSlab(naturalAquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModSlab) naturalAquamarineSlabs[aquamarineVariants.ordinal()], (BlockModSlab) naturalAquamarineSlabsDouble[aquamarineVariants.ordinal()]);
-            aquamarineSlabs[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_aquamarine_vertical_slab", false);
-            aquamarineSlabsVertical[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_aquamarine_slab", false);
-            aquamarineSlabsDouble[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_aquamarine_slab", true);
-            aquamarineSlabsDoubleVertical[aquamarineVariants.ordinal()] = new BlockOverworldSlabBase(aquamarineVariants.getName() + "_aquamarine_vertical_slab", true);
-            BlockModSlab.initSlab(aquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModSlab) aquamarineSlabs[aquamarineVariants.ordinal()], (BlockModSlab) aquamarineSlabsDouble[aquamarineVariants.ordinal()]);
-            BlockModSlab.initSlab(aquamarine[aquamarineVariants.ordinal()], aquamarineVariants.ordinal(), (BlockModSlab) aquamarineSlabsVertical[aquamarineVariants.ordinal()], (BlockModSlab) aquamarineSlabsDoubleVertical[aquamarineVariants.ordinal()]);
-        }
-        dried_kelp_block = new BlockOverworldBase(Material.LEAVES, "dried_kelp_block");
-        blackSand = new BlockOverworldBase(Material.SAND, "black_sand");
-
-        for(EnumNetherBlocks netherBlockTypes : EnumNetherBlocks.values()) {
-            netherBlocks[netherBlockTypes.getMetadata()] = new BlockNetherBase(Material.ROCK, netherBlockTypes.getName());
-            /*netherBlocksStairs[netherBlockTypes.getMetadata()] = new BlockNetherStairBase(netherBlockTypes.getName() + "_stairs", netherBlocks[netherBlockTypes.getMetadata()].getDefaultState());
-            BlockModStairs.initStairs(netherBlocks[netherBlockTypes.getMetadata()], netherBlockTypes.getMetadata(), (BlockModStairs) netherBlocksStairs[netherBlockTypes.getMetadata()]);*/
-            netherBlocksSlabs[netherBlockTypes.getMetadata()] = new BlockNetherSlabBase(netherBlockTypes.getName() + "_slab", false);
-            netherBlocksSlabsVertical[netherBlockTypes.getMetadata()] = new BlockNetherSlabBase(netherBlockTypes.getName() + "_slab_vertical", false);
-            netherBlocksSlabsDouble[netherBlockTypes.getMetadata()] = new BlockNetherSlabBase(netherBlockTypes.getName() + "_slab", true);
-            BlockModSlab.initSlab(netherBlocks[netherBlockTypes.getMetadata()], netherBlockTypes.getMetadata(), (BlockModSlab) netherBlocksSlabs[netherBlockTypes.getMetadata()], (BlockModSlab) netherBlocksSlabsDouble[netherBlockTypes.getMetadata()]);
-        }
-
-        for(EnumNewStoneVariants newStoneVariant : EnumNewStoneVariants.values()) {
-            newStoneVariants[newStoneVariant.getMetadata()] = new BlockOverworldBase(Material.ROCK, newStoneVariant.getName());
-            /*newStoneVariantStairs[newStoneVariant.getMetadata()] = new BlockOverworldStairBase(newStoneVariant.getName() + "_stairs", newStoneVariants[newStoneVariant.getMetadata()].getDefaultState());
-            BlockModStairs.initStairs(newStoneVariants[newStoneVariant.getMetadata()], newStoneVariant.getMetadata(), (BlockModStairs) newStoneVariantStairs[newStoneVariant.getMetadata()]);*/
-            newStoneVariantSlabs[newStoneVariant.getMetadata()] = new BlockOverworldSlabBase(newStoneVariant.getName() + "_slab", false);
-            newStoneVariantSlabsDouble[newStoneVariant.getMetadata()] = new BlockOverworldSlabBase(newStoneVariant.getName() + "_slab", true);
-            BlockModSlab.initSlab(newStoneVariants[newStoneVariant.getMetadata()], newStoneVariant.getMetadata(), (BlockModSlab) newStoneVariantSlabs[newStoneVariant.getMetadata()], (BlockModSlab) newStoneVariantSlabsDouble[newStoneVariant.getMetadata()]);
-        }
-    }
-
-    @SubscribeEvent
-    public static void registerBlocks(RegistryEvent.Register<Block> event) {
-
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScorp.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScorp.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScorp.java	(date 1525605768000)
@@ -1,211 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.block.Block;
-import net.minecraft.entity.*;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.monster.EntitySpider;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNavigate;
-import net.minecraft.pathfinding.PathNavigateClimber;
-import net.minecraft.potion.Potion;
-import net.minecraft.potion.PotionEffect;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.EnumDifficulty;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.ai.EntityAIScorpAttack;
-import net.thegaminghuskymc.mcaddon.entity.ai.EntityAIScorpTarget;
-import net.thegaminghuskymc.mcaddon.util.handlers.LootTableHandler;
-
-import java.util.Objects;
-
-/*
- *TODO:Optimize Mob, Add Custom Sounds, Add Animations
- */
-
-public class EntityScorp extends EntitySpider {
-
-    public static final DataParameter<Boolean> TAIL_OUT = EntityDataManager.createKey(EntityScorp.class, DataSerializers.BOOLEAN);
-    private static final DataParameter<Byte> CLIMBING = EntityDataManager.createKey(EntityScorp.class, DataSerializers.BYTE);
-
-    public EntityScorp(World worldIn)
-    {
-        super(worldIn);
-    }
-
-    protected ResourceLocation getLootTable() {
-        return LootTableHandler.SCORPION;
-    }
-
-    @Override
-    protected void initEntityAI()
-    {
-        this.tasks.addTask(0, new EntityAISwimming(this));
-        this.tasks.addTask(2, new EntityAIScorpAttack(this, 1.0D, false));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this,0.8D));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 7.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.targetTasks.addTask(2, new EntityAIScorpTarget<>(this, EntityPlayer.class));
-    }
-
-    protected PathNavigate createNavigator(World worldIn)
-    {
-        return new PathNavigateClimber(this, worldIn);
-    }
-
-    protected void applyEntityAI()
-    {
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-        this.targetTasks.addTask(3, new EntityAINearestAttackableTarget<>(this, EntityVillager.class, true));
-    }
-
-    public void onUpdate()
-    {
-        super.onUpdate();
-
-        if (!this.world.isRemote)
-        {
-            this.setBesideClimbableBlock(this.collidedHorizontally);
-        }
-    }
-
-    public void setBesideClimbableBlock(boolean climbing)
-    {
-        byte b0 = this.dataManager.get(CLIMBING);
-
-        if (climbing)
-        {
-            b0 = (byte)(b0 | 1);
-        }
-        else
-        {
-            b0 = (byte)(b0 & -2);
-        }
-
-        this.dataManager.set(CLIMBING, b0);
-    }
-
-    public float getEyeHeight()
-    {
-        return 0.65F;
-    }
-
-    @Override
-    protected void applyEntityAttributes()
-    {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(30.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(1.5D);
-        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
-    }
-
-    public static void registerFixesScorp(DataFixer fixer)
-    {
-        EntityLiving.registerFixesMob(fixer, EntityScorp.class);
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-        this.getDataManager().register(TAIL_OUT, Boolean.valueOf(false));
-        this.dataManager.register(CLIMBING, Byte.valueOf((byte)0));
-    }
-
-    public void setTailOut(boolean tailOut)
-    {
-        this.getDataManager().set(TAIL_OUT, tailOut);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean isTailOut(){ return this.getDataManager().get(TAIL_OUT);}
-
-    @Override
-    protected int getExperiencePoints(EntityPlayer player)
-    {
-        return super.getExperiencePoints(player);
-    }
-
-    @Override
-    public void notifyDataManagerChange(DataParameter<?> key)
-    {
-        super.notifyDataManagerChange(key);
-    }
-
-    @Override
-    public void onLivingUpdate()
-    {
-        super.onLivingUpdate();
-    }
-
-    @Override
-    public boolean attackEntityAsMob(Entity entityIn)
-    {
-        if (super.attackEntityAsMob(entityIn))
-        {
-            if (entityIn instanceof EntityLivingBase)
-            {
-                ((EntityLivingBase)entityIn).addPotionEffect(new PotionEffect(Objects.requireNonNull(Potion.getPotionById(19)), 12 * 20, 0));
-            }
-            return true;
-        } else
-            return false;
-    }
-
-    @Override
-    protected SoundEvent getAmbientSound()
-    {
-        return SoundEvents.ENTITY_SPIDER_AMBIENT;
-    }
-
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn)
-    {
-        return SoundEvents.ENTITY_SPIDER_HURT;
-    }
-
-    @Override
-    protected SoundEvent getDeathSound()
-    {
-        return SoundEvents.ENTITY_SPIDER_DEATH;
-    }
-
-    protected SoundEvent getStepSound()
-    {
-        return SoundEvents.ENTITY_SPIDER_STEP;
-    }
-
-    @Override
-    protected void playStepSound(BlockPos pos, Block blockIn)
-    {
-        this.playSound(this.getStepSound(), 0.15F, 1.0F);
-    }
-
-    @Override
-    public EnumCreatureAttribute getCreatureAttribute()
-    {
-        return EnumCreatureAttribute.ARTHROPOD;
-    }
-    
-
-    @Override
-    public boolean getCanSpawnHere()
-    {
-        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNetherBiome.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNetherBiome.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNetherBiome.java	(date 1525605768000)
@@ -1,30 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.layer;
-
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.layer.IntCache;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiomeManager;
-
-public class GenLayerNetherBiome extends GenLayerNether
-{
-    public GenLayerNetherBiome(long seed)
-    {
-        super(seed);
-    }
-
-    @Override
-    public int[] getInts(int areaX, int areaZ, int areaWidth, int areaHeight)
-    {
-        int[] outputs = IntCache.getIntCache(areaWidth * areaHeight);
-
-        for(int z = 0; z < areaHeight; z++)
-        {
-            for(int x = 0; x < areaWidth; x++)
-            {
-                initChunkSeed(x + areaX, z + areaZ);
-                outputs[x + z * areaWidth] = Biome.getIdForBiome(NetherBiomeManager.getRandomBiome(NetherBiomeManager.getAllBiomeEntries(), this));
-            }
-        }
-
-        return outputs;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/interfaces/IStructure.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/interfaces/IStructure.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/interfaces/IStructure.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.interfaces;
-
-import net.minecraft.util.Mirror;
-import net.minecraft.util.Rotation;
-import net.minecraft.world.WorldServer;
-import net.minecraft.world.gen.structure.template.PlacementSettings;
-import net.minecraftforge.fml.common.FMLCommonHandler;
-
-public interface IStructure 
-{
-	public static final WorldServer worldServer = FMLCommonHandler.instance().getMinecraftServerInstance().getWorld(0);
-	public static final PlacementSettings settings = (new PlacementSettings()).setChunk(null).setIgnoreEntities(false).setIgnoreStructureBlock(false).setMirror(Mirror.NONE).setRotation(Rotation.NONE);
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosSwordFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosSwordFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosSwordFish.java	(date 1525605768000)
@@ -1,92 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosSwordFish.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.world.World;
-
-import java.util.List;
-
-public class EntityAtmosSwordFish extends EntityAtmosWater {
-
-    public EntityAtmosSwordFish(World world)
-    {
-        super(world);
-        setSize(0.8F, 0.5F);
-        setMaxHealth(20);
-        setTamed(false);
-        caught = false;
-    }
-
-    public EntityPlayer getClosestPlayer(double par1, double par3, double par5, double par7)
-    {
-        double d = -1D;
-        EntityPlayer entityplayer = null;
-        for(int i = 0; i < playerEntities.size(); i++)
-        {
-            EntityPlayer entityplayer1 = (EntityPlayer)playerEntities.get(i);
-            double d1 = entityplayer1.getDistanceSq(par1, par3, par5);
-            if((par7 < 0.0D || d1 < par7 * par7) && (d == -1D || d1 < d))
-            {
-                d = d1;
-                entityplayer = entityplayer1;
-            }
-        }
-
-        return entityplayer;
-    }
-
-    public EntityPlayer getClosestVulnerablePlayerToEntity(EntityPlayer par1Entity, double par2)
-    {
-        return getClosestPlayer(par1Entity.posX, par1Entity.posY, par1Entity.posZ, par2);
-    }
-
-    public boolean getIsTamed()
-    {
-        return isTamed;
-    }
-
-    public void setTamed(boolean flag)
-    {
-        isTamed = flag;
-    }
-
-    public boolean bj()
-    {
-        return !getIsTamed();
-    }
-
-    public boolean a(EntityPlayer entityplayer)
-    {
-        ItemStack itemstack = entityplayer.getActiveItemStack();
-        if(itemstack != null && outOfWater != 0)
-        {
-            caught = true;
-            itemstack.damageItem(4, entityplayer);
-            return true;
-        } else
-        {
-            return true;
-        }
-    }
-
-    public void b(NBTTagCompound nbttagcompound)
-    {
-        super.writeToNBT(nbttagcompound);
-        nbttagcompound.setBoolean("Tamed", getIsTamed());
-    }
-
-    public void a(NBTTagCompound nbttagcompound)
-    {
-        super.readFromNBT(nbttagcompound);
-        setTamed(nbttagcompound.getBoolean("Tamed"));
-    }
-
-    public List playerEntities;
-    private boolean caught;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BasePickaxe.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BasePickaxe.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BasePickaxe.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.tools;
-
-import net.thegaminghuskymc.huskylib2.items.ItemModPickaxe;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BasePickaxe extends ItemModPickaxe {
-
-    public BasePickaxe(String name, ToolMaterial material)  {
-        super(material, name, MOD_ID);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderShadowPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderShadowPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderShadowPhantom.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityEnderPhantom;
-import net.thegaminghuskymc.mcaddon.entity.EntityShadowPhantom;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelPhantom;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderShadowPhantom extends RenderLiving<EntityShadowPhantom> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/shadow_phantom.png");
-
-    public RenderShadowPhantom(RenderManager manager) {
-        super(manager, new ModelPhantom(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityShadowPhantom entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNetherBlocks.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNetherBlocks.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNetherBlocks.java	(date 1525605768000)
@@ -1,50 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-
-public enum EnumNetherBlocks implements IStringSerializable {
-
-    FIERY_STONE(0, "fiery_stone"),
-    VOLCANIC_GLOW_ROCK(1, "volcanic_glow_rock"),
-    VOLCANIC_ROCK(2, "volcanic_rock"),
-    HOT_COBBLESTONE(3, "hot_cobblestone"),
-    BURNED_BONES(4, "burned_bones"),
-    ASH(5, "ash_block");
-
-    private static final EnumNetherBlocks[] META_LOOKUP = new EnumNetherBlocks[values().length];
-
-    static {
-        for (EnumNetherBlocks blockstone$enumtype : values()) {
-            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
-        }
-    }
-
-    private final int meta;
-    private final String name;
-
-    EnumNetherBlocks(int p_i46384_3_, String p_i46384_5_) {
-        this.meta = p_i46384_3_;
-        this.name = p_i46384_5_;
-    }
-
-    public static EnumNetherBlocks byMetadata(int meta) {
-        if (meta < 0 || meta >= META_LOOKUP.length) {
-            meta = 0;
-        }
-
-        return META_LOOKUP[meta];
-    }
-
-    public int getMetadata() {
-        return this.meta;
-    }
-
-    public String toString() {
-        return this.name;
-    }
-
-    public String getName() {
-        return this.name;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureClumped.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureClumped.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureClumped.java	(date 1525605768000)
@@ -1,83 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public class FeatureClumped extends Feature
-{
-    private final IBlockState blockToSpawn;
-
-    public FeatureClumped(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        blockToSpawn = BlockUtil.getBlock(feature.getBlockToSpawn(), "minecraft:air");
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        if(!world.isAirBlock(pos))
-        {
-            return false;
-        }
-        else if(!world.getBlockState(pos.up()).isSideSolid(world, pos.up(), EnumFacing.DOWN))
-        {
-            return false;
-        }
-        else
-        {
-            world.setBlockState(pos, blockToSpawn, 3);
-
-            for(int i = 0; i < 1500; ++i)
-            {
-                BlockPos newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), -rand.nextInt(12), rand.nextInt(8) - rand.nextInt(8));
-
-                if(world.isAirBlock(newPos))
-                {
-                    int j = 0;
-
-                    for(EnumFacing enumfacing : EnumFacing.values())
-                    {
-                        if(world.getBlockState(newPos.offset(enumfacing)).getBlock() == blockToSpawn.getBlock())
-                        {
-                            ++j;
-                        }
-
-                        if(j > 1)
-                        {
-                            break;
-                        }
-                    }
-
-                    if(j == 1)
-                    {
-                        world.setBlockState(newPos, blockToSpawn, 3);
-                    }
-                }
-            }
-
-            return true;
-        }
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return blockToSpawn != Blocks.AIR.getDefaultState();
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.CLUMPED;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderSeaTurtle.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderSeaTurtle.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderSeaTurtle.java	(date 1525605768000)
@@ -1,32 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosCrow;
-import net.thegaminghuskymc.mcaddon.entity.EntitySeaTurtle;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelAtmosCrow;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelSeaTurtle;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderSeaTurtle extends RenderLiving<EntitySeaTurtle> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/sea_turtle.png");
-
-    public RenderSeaTurtle(RenderManager manager)
-    {
-        super(manager, new ModelSeaTurtle(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntitySeaTurtle entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntitySeaTurtle entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/utils/FormationCaveGenerator.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/utils/FormationCaveGenerator.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/utils/FormationCaveGenerator.java	(date 1525605768000)
@@ -1,160 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.utils;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraftforge.fml.common.IWorldGenerator;
-import net.thegaminghuskymc.mcaddon.init.MCAddonBlocks;
-
-public class FormationCaveGenerator implements IWorldGenerator {
-
-	public FormationCaveGenerator() {
-
-	}
-	
-	@Override
-	public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-		int x = chunkX * 16 + random.nextInt(16);
-		int z = chunkZ * 16 + random.nextInt(16);
-
-		for(int i = 15; i < 50; i++) {
-			BlockPos pos = new BlockPos(x, i, z);
-			BlockPos belowPos = pos.down();
-			IBlockState state = world.getBlockState(pos);
-			IBlockState stateBelow = world.getBlockState(belowPos);
-			if(state.getBlock().isAir(state, world, pos) && stateBelow.getBlock() == Blocks.STONE) {
-                makeFormationCaveAt(world, pos, random);
-				return;
-			}
-		}
-	}
-
-	public void makeFormationCaveAt(World world, BlockPos source, Random rand) {
-		double expandX = (rand.nextDouble() - 0.5) * 2;
-		double expandY = (rand.nextDouble() - 0.5) * 0.1F;
-		double expandZ = (rand.nextDouble() - 0.5) * 2;
-		
-		double curveAngle = rand.nextDouble() *  Math.PI * 2;
-		double curveRatio = rand.nextDouble() * 0.25 + 0.1;
-		double curveX = Math.cos(curveAngle) * curveRatio;
-		double curveY = (rand.nextFloat() - 0.5F) * 0.05F;
-		double curveZ = Math.sin(curveAngle) * curveRatio;
-
-		BlockPos hollowingCenter = source;
-		Vec3d expansion = new Vec3d(expandX, expandY, expandZ).normalize();
-		Vec3d curvature = new Vec3d(curveX, curveY, curveZ);
-
-		int color1 = rand.nextInt(5);
-		int color2;
-		do {
-			color2 = rand.nextInt(5);
-		} while(color2 == color1);
-
-		IBlockState crystal1 = MCAddonBlocks.brain_coral[color1].getDefaultState();
-		IBlockState crystal2 = MCAddonBlocks.brain_coral[color2].getDefaultState();
-
-		int length = 12 + rand.nextInt(10);
-		int size = 4 + rand.nextInt(3);
-		for(int i = 0; i < length; i++) {
-			hollowOut(world, hollowingCenter, rand, size, crystal1, crystal2);
-			
-			BlockPos currentCenter = hollowingCenter;
-			hollowingCenter = currentCenter.add(expansion.x * size * 0.5, expansion.y * size * 0.5, expansion.z * size * 0.5);
-			
-			if(hollowingCenter.getY() < 10) {
-				expansion = new Vec3d(expansion.x, -expansion.y, expansion.z);
-				curvature = new Vec3d(curvature.x, -curvature.y, curvature.z);
-				currentCenter = hollowingCenter.add(expansion.x * size * 0.5, expansion.y * size * 0.5, expansion.z * size * 0.5);
-			}
-			
-			expansion = expansion.add(curvature).normalize();
-		}
-	}
-
-	private void hollowOut(World world, BlockPos source, Random rand, int width, IBlockState block1, IBlockState block2) {
-		List<BlockPos> blocks = new ArrayList<>();
-		
-		int max = width * width;
-		for(int i = -width; i <= width; i++)
-			for(int j = -width; j <= width; j++)
-				for(int k = -width; k <= width; k++) {
-					BlockPos pos = source.add(i, j, k);
-					int dist = i * i + j * j + k * k;
-
-					if(dist < max) {
-						IBlockState state = world.getBlockState(pos);
-						Block block = state.getBlock();
-
-						if(block.getBlockHardness(state, world, pos) != -1)
-							world.setBlockToAir(pos);
-					} else if(dist - 1 < max)
-                        blocks.add(pos);
-				}
-		
-		for(BlockPos pos : blocks) {
-			if(rand.nextInt(3) == 0)
-				makeFormation(world, pos, rand, rand.nextBoolean() ? block1 : block2);
-			else if(rand.nextInt(2) == 0) {
-				IBlockState stateAt = world.getBlockState(pos);
-				Block blockAt = stateAt.getBlock();
-				if(blockAt.isAir(stateAt, world, pos) || blockAt == block1.getBlock() || blockAt == block2.getBlock() || blockAt.getBlockHardness(stateAt, world, pos) == -1)
-					continue;
-				
-				IBlockState oreState = Blocks.GOLD_ORE.getDefaultState();
-				if(rand.nextInt(3) == 0) {
-					if(rand.nextInt(3) == 0)
-						oreState = Blocks.DIAMOND_ORE.getDefaultState();
-					else oreState = Blocks.EMERALD_ORE.getDefaultState();
-				}
-				
-				world.setBlockState(pos, oreState);
-			}
-		}
-			
-	}
-
-	private void makeFormation(World world, BlockPos source, Random rand, IBlockState formationBlock) {
-		boolean up = rand.nextBoolean();
-		EnumFacing shift = up ? EnumFacing.UP : EnumFacing.DOWN;
-		
-		BlockPos startPos = source;
-		IBlockState state = world.getBlockState(startPos);
-		if(state.getBlock() == formationBlock.getBlock())
-			return;
-		
-		int tests = 0;
-		
-		while(state.getBlock().isAir(state, world, startPos)) {
-			startPos = startPos.offset(shift.getOpposite());
-			state = world.getBlockState(startPos);
-
-			tests++;
-			if(tests >= 10)
-				return;
-		}
-
-		int size = 3 + rand.nextInt(4);
-		
-		BlockPos pos = startPos;
-		for(int i = 0; i < size; i++) {
-			IBlockState stateAt = world.getBlockState(pos);
-			Block block = stateAt.getBlock();
-			if(block.getBlockHardness(stateAt, world, pos) == -1)
-				break;
-			
-			world.setBlockState(pos, formationBlock);
-			pos = pos.offset(shift);
-		}
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorp.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorp.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorp.java	(date 1525605768000)
@@ -1,94 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-/**
- * ModelSpider - Either Mojang or a mod author
- * Created using Tabula 7.0.0
- */
-public class ModelScorp extends ModelBase {
-
-    private ModelRenderer field_78207_b;
-    private ModelRenderer field_78205_d;
-    private ModelRenderer field_78212_h;
-    public ModelRenderer field_78210_j;
-    public ModelRenderer field_78209_a;
-    public ModelRenderer field_78208_c;
-    public ModelRenderer field_78206_e;
-    public ModelRenderer field_78204_g;
-    public ModelRenderer field_78213_i;
-    public ModelRenderer field_78211_k;
-    public ModelRenderer field_78203_f;
-
-    public ModelScorp() {
-        this.textureWidth = 64;
-        this.textureHeight = 32;
-        this.field_78210_j = new ModelRenderer(this, 18, 0);
-        this.field_78210_j.setRotationPoint(-4.0F, 15.0F, -1.0F);
-        this.field_78210_j.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78210_j, 0.0F, -0.7853981852531433F, -0.7853981852531433F);
-        this.field_78209_a = new ModelRenderer(this, 32, 4);
-        this.field_78209_a.setRotationPoint(0.0F, 15.0F, -3.0F);
-        this.field_78209_a.addBox(-4.0F, -4.0F, -8.0F, 8, 8, 8, 0.0F);
-        this.field_78211_k = new ModelRenderer(this, 18, 0);
-        this.field_78211_k.setRotationPoint(4.0F, 15.0F, -1.0F);
-        this.field_78211_k.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78211_k, 0.0F, 0.7853981852531433F, 0.7853981852531433F);
-        this.field_78213_i = new ModelRenderer(this, 18, 0);
-        this.field_78213_i.setRotationPoint(4.0F, 15.0F, 0.0F);
-        this.field_78213_i.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78213_i, 0.0F, 0.39269909262657166F, 0.5811946392059326F);
-        this.field_78205_d = new ModelRenderer(this, 18, 0);
-        this.field_78205_d.setRotationPoint(-4.0F, 15.0F, 2.0F);
-        this.field_78205_d.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78205_d, 0.0F, 0.7853981852531433F, -0.7853981852531433F);
-        this.field_78203_f = new ModelRenderer(this, 18, 0);
-        this.field_78203_f.setRotationPoint(-4.0F, 15.0F, 1.0F);
-        this.field_78203_f.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78203_f, 0.0F, 0.39269909262657166F, -0.5811946392059326F);
-        this.field_78212_h = new ModelRenderer(this, 18, 0);
-        this.field_78212_h.setRotationPoint(-4.0F, 15.0F, 0.0F);
-        this.field_78212_h.addBox(-15.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78212_h, 0.0F, -0.39269909262657166F, -0.5811946392059326F);
-        this.field_78206_e = new ModelRenderer(this, 18, 0);
-        this.field_78206_e.setRotationPoint(4.0F, 15.0F, 2.0F);
-        this.field_78206_e.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78206_e, 0.0F, -0.7853981852531433F, 0.7853981852531433F);
-        this.field_78207_b = new ModelRenderer(this, 0, 0);
-        this.field_78207_b.setRotationPoint(0.0F, 15.0F, 0.0F);
-        this.field_78207_b.addBox(-3.0F, -3.0F, -3.0F, 6, 6, 6, 0.0F);
-        this.field_78208_c = new ModelRenderer(this, 0, 12);
-        this.field_78208_c.setRotationPoint(0.0F, 15.0F, 9.0F);
-        this.field_78208_c.addBox(-5.0F, -4.0F, -6.0F, 10, 8, 12, 0.0F);
-        this.field_78204_g = new ModelRenderer(this, 18, 0);
-        this.field_78204_g.setRotationPoint(4.0F, 15.0F, 1.0F);
-        this.field_78204_g.addBox(-1.0F, -1.0F, -1.0F, 16, 2, 2, 0.0F);
-        this.setRotateAngle(field_78204_g, 0.0F, -0.39269909262657166F, 0.5811946392059326F);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) { 
-        this.field_78210_j.render(f5);
-        this.field_78209_a.render(f5);
-        this.field_78211_k.render(f5);
-        this.field_78213_i.render(f5);
-        this.field_78205_d.render(f5);
-        this.field_78203_f.render(f5);
-        this.field_78212_h.render(f5);
-        this.field_78206_e.render(f5);
-        this.field_78207_b.render(f5);
-        this.field_78208_c.render(f5);
-        this.field_78204_g.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBase.java	(date 1525605768000)
@@ -1,15 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.creativetab.CreativeTabs;
-import net.thegaminghuskymc.huskylib2.items.ItemMod;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class ItemBase extends ItemMod {
-
-    public ItemBase(String name, CreativeTabs creativeTabs) {
-        super(name, MOD_ID);
-        setCreativeTab(creativeTabs);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/StructureRegistry.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/StructureRegistry.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/StructureRegistry.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class StructureRegistry {
-    public static Map<String, IGeneratable> structures = new HashMap<>();
-
-    public StructureRegistry() {
-    }
-
-    public static String addStructure(String name, IGeneratable data) {
-        structures.put(name, data);
-        return name;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityUndeadBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityUndeadBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityUndeadBase.java	(date 1525605768000)
@@ -1,40 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EnumCreatureAttribute;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-
-public class EntityUndeadBase extends EntityMob {
-
-    public EntityUndeadBase(World world) {
-        super(world);
-    }
-
-    @Override
-    protected void initEntityAI() {
-        this.tasks.addTask(0, new EntityAISwimming(this));
-        this.tasks.addTask(2, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(2, new EntityAIWander(this, 1.0D));
-        this.tasks.addTask(3, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
-        this.tasks.addTask(3, new EntityAILookIdle(this));
-        this.targetTasks.addTask(1, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-    }
-
-    @Override
-    public EnumCreatureAttribute getCreatureAttribute() {
-        return EnumCreatureAttribute.UNDEAD;
-    }
-
-    @Override
-    public boolean getCanSpawnHere() {
-        int i = MathHelper.floor(this.getEntityBoundingBox().minY);
-        if (i <= 62) {
-            return false;
-        } else {
-            return super.getCanSpawnHere();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/RandomUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/RandomUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/RandomUtil.java	(date 1525605768000)
@@ -1,11 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import java.util.Random;
-
-public class RandomUtil
-{
-    public static int getNumberInRange(int min, int max, Random rand)
-    {
-        return rand.nextInt(max - min + 1) + min;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWaterMob.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWaterMob.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWaterMob.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosWaterMob.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.monster.IMob;
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.world.World;
-
-public class EntityAtmosWaterMob extends EntityWaterMob implements IMob {
-
-    public EntityAtmosWaterMob(World par1World)
-    {
-        super(par1World);
-    }
-
-    public int aT()
-    {
-        return 0;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityHoveringInferno.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityHoveringInferno.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityHoveringInferno.java	(date 1525605768000)
@@ -1,277 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntitySmallFireball;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNodeType;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-
-public class EntityHoveringInferno extends EntityMob {
-
-    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityHoveringInferno.class, DataSerializers.BYTE);
-    /**
-     * Random offset used in floating behaviour
-     */
-    private float heightOffset = 0.5F;
-    /**
-     * ticks until heightOffset is randomized
-     */
-    private int heightOffsetUpdateTime;
-
-    public EntityHoveringInferno(World worldIn) {
-        super(worldIn);
-        this.setPathPriority(PathNodeType.WATER, -1.0F);
-        this.setPathPriority(PathNodeType.LAVA, 8.0F);
-        this.setPathPriority(PathNodeType.DANGER_FIRE, 0.0F);
-        this.setPathPriority(PathNodeType.DAMAGE_FIRE, 0.0F);
-        this.isImmuneToFire = true;
-        this.experienceValue = 10;
-    }
-
-    public static void registerFixesBlaze(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityHoveringInferno.class);
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(4, new EntityHoveringInferno.AIFireballAttack(this));
-        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(ON_FIRE, (byte) 0);
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_BLAZE_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_BLAZE_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_BLAZE_DEATH;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender() {
-        return 15728880;
-    }
-
-    /**
-     * Gets how bright this entity is.
-     */
-    public float getBrightness() {
-        return 1.0F;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        if (!this.onGround && this.motionY < 0.0D) {
-            this.motionY *= 0.6D;
-        }
-
-        if (this.world.isRemote) {
-            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-
-            for (int i = 0; i < 2; ++i) {
-                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
-            }
-        }
-
-        super.onLivingUpdate();
-    }
-
-    protected void updateAITasks() {
-        if (this.isWet()) {
-            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
-        }
-
-        --this.heightOffsetUpdateTime;
-
-        if (this.heightOffsetUpdateTime <= 0) {
-            this.heightOffsetUpdateTime = 100;
-            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
-        }
-
-        EntityLivingBase entitylivingbase = this.getAttackTarget();
-
-        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
-            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
-            this.isAirBorne = true;
-        }
-
-        super.updateAITasks();
-    }
-
-    public void fall(float distance, float damageMultiplier) {
-    }
-
-    /**
-     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
-     */
-    public boolean isBurning() {
-        return this.isCharged();
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_BLAZE;
-    }
-
-    private boolean isCharged() {
-        return (this.dataManager.get(ON_FIRE) & 1) != 0;
-    }
-
-    private void setOnFire(boolean onFire) {
-        byte b0 = this.dataManager.get(ON_FIRE);
-
-        if (onFire) {
-            b0 = (byte) (b0 | 1);
-        } else {
-            b0 = (byte) (b0 & -2);
-        }
-
-        this.dataManager.set(ON_FIRE, b0);
-    }
-
-    /**
-     * Checks to make sure the light is not too bright where the mob is spawning
-     */
-    protected boolean isValidLightLevel() {
-        return true;
-    }
-
-    static class AIFireballAttack extends EntityAIBase {
-        private final EntityHoveringInferno blaze;
-        private int attackStep;
-        private int attackTime;
-
-        AIFireballAttack(EntityHoveringInferno blazeIn) {
-            this.blaze = blazeIn;
-            this.setMutexBits(3);
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            return entitylivingbase != null && entitylivingbase.isEntityAlive();
-        }
-
-        /**
-         * Execute a one shot task or start executing a continuous task
-         */
-        public void startExecuting() {
-            this.attackStep = 0;
-        }
-
-        /**
-         * Reset the task's internal state. Called when this task is interrupted by another one
-         */
-        public void resetTask() {
-            this.blaze.setOnFire(false);
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            --this.attackTime;
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
-
-            if (d0 < 4.0D) {
-                if (this.attackTime <= 0) {
-                    this.attackTime = 20;
-                    this.blaze.attackEntityAsMob(entitylivingbase);
-                }
-
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
-                double d1 = entitylivingbase.posX - this.blaze.posX;
-                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
-                double d3 = entitylivingbase.posZ - this.blaze.posZ;
-
-                if (this.attackTime <= 0) {
-                    ++this.attackStep;
-
-                    if (this.attackStep == 1) {
-                        this.attackTime = 60;
-                        this.blaze.setOnFire(true);
-                    } else if (this.attackStep <= 4) {
-                        this.attackTime = 6;
-                    } else {
-                        this.attackTime = 100;
-                        this.attackStep = 0;
-                        this.blaze.setOnFire(false);
-                    }
-
-                    if (this.attackStep > 1) {
-                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
-                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
-
-                        for (int i = 0; i < 1; ++i) {
-                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
-                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
-                            this.blaze.world.spawnEntity(entitysmallfireball);
-                        }
-                    }
-                }
-
-                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
-            } else {
-                this.blaze.getNavigator().clearPath();
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            }
-
-            super.updateTask();
-        }
-
-        private double getFollowDistance() {
-            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
-            return iattributeinstance.getAttributeValue();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAnimal.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAnimal.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAnimal.java	(date 1525605768000)
@@ -1,28 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosAnimal.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityAgeable;
-import net.minecraft.entity.passive.EntityAnimal;
-import net.minecraft.entity.passive.IAnimals;
-import net.minecraft.world.World;
-
-import javax.annotation.Nullable;
-
-public class EntityAtmosAnimal extends EntityAnimal implements IAnimals {
-
-    public EntityAtmosAnimal(World par1World) {
-        super(par1World);
-    }
-
-
-    @Nullable
-    @Override
-    public EntityAgeable createChild(EntityAgeable ageable) {
-        return null;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpTarget.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpTarget.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpTarget.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.ai;
-
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
-import net.thegaminghuskymc.mcaddon.entity.EntityScorp;
-
-public class EntityAIScorpTarget<T extends EntityLivingBase> extends EntityAINearestAttackableTarget<T>
-{
-    public EntityAIScorpTarget(EntityScorp scorp, Class<T> classTarget)
-    {
-        super(scorp, classTarget, true);
-    }
-
-    public boolean shouldExecute()
-    {
-        return super.shouldExecute();
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderArrow.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderArrow.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderArrow.java	(date 1525605768000)
@@ -1,103 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.BufferBuilder;
-import net.minecraft.client.renderer.GlStateManager;
-import net.minecraft.client.renderer.Tessellator;
-import net.minecraft.client.renderer.entity.Render;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
-import net.minecraft.entity.projectile.EntityArrow;
-import net.minecraft.util.math.MathHelper;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-@SideOnly(Side.CLIENT)
-public abstract class RenderArrow<T extends EntityArrow> extends Render<T>
-{
-    public RenderArrow(RenderManager renderManagerIn)
-    {
-        super(renderManagerIn);
-    }
-
-    /**
-     * Renders the desired {@code T} type Entity.
-     */
-    public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks)
-    {
-        this.bindEntityTexture(entity);
-        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-        GlStateManager.pushMatrix();
-        GlStateManager.disableLighting();
-        GlStateManager.translate((float)x, (float)y, (float)z);
-        GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks - 90.0F, 0.0F, 1.0F, 0.0F);
-        GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, 0.0F, 0.0F, 1.0F);
-        Tessellator tessellator = Tessellator.getInstance();
-        BufferBuilder bufferbuilder = tessellator.getBuffer();
-        int i = 0;
-        float f = 0.0F;
-        float f1 = 0.5F;
-        float f2 = 0.0F;
-        float f3 = 0.15625F;
-        float f4 = 0.0F;
-        float f5 = 0.15625F;
-        float f6 = 0.15625F;
-        float f7 = 0.3125F;
-        float f8 = 0.05625F;
-        GlStateManager.enableRescaleNormal();
-        float f9 = (float)entity.arrowShake - partialTicks;
-
-        if (f9 > 0.0F)
-        {
-            float f10 = -MathHelper.sin(f9 * 3.0F) * f9;
-            GlStateManager.rotate(f10, 0.0F, 0.0F, 1.0F);
-        }
-
-        GlStateManager.rotate(45.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.scale(0.05625F, 0.05625F, 0.05625F);
-        GlStateManager.translate(-4.0F, 0.0F, 0.0F);
-
-        if (this.renderOutlines)
-        {
-            GlStateManager.enableColorMaterial();
-            GlStateManager.enableOutlineMode(this.getTeamColor(entity));
-        }
-
-        GlStateManager.glNormal3f(0.05625F, 0.0F, 0.0F);
-        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-        bufferbuilder.pos(-7.0D, -2.0D, -2.0D).tex(0.0D, 0.15625D).endVertex();
-        bufferbuilder.pos(-7.0D, -2.0D, 2.0D).tex(0.15625D, 0.15625D).endVertex();
-        bufferbuilder.pos(-7.0D, 2.0D, 2.0D).tex(0.15625D, 0.3125D).endVertex();
-        bufferbuilder.pos(-7.0D, 2.0D, -2.0D).tex(0.0D, 0.3125D).endVertex();
-        tessellator.draw();
-        GlStateManager.glNormal3f(-0.05625F, 0.0F, 0.0F);
-        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-        bufferbuilder.pos(-7.0D, 2.0D, -2.0D).tex(0.0D, 0.15625D).endVertex();
-        bufferbuilder.pos(-7.0D, 2.0D, 2.0D).tex(0.15625D, 0.15625D).endVertex();
-        bufferbuilder.pos(-7.0D, -2.0D, 2.0D).tex(0.15625D, 0.3125D).endVertex();
-        bufferbuilder.pos(-7.0D, -2.0D, -2.0D).tex(0.0D, 0.3125D).endVertex();
-        tessellator.draw();
-
-        for (int j = 0; j < 4; ++j)
-        {
-            GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
-            GlStateManager.glNormal3f(0.0F, 0.0F, 0.05625F);
-            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-            bufferbuilder.pos(-8.0D, -2.0D, 0.0D).tex(0.0D, 0.0D).endVertex();
-            bufferbuilder.pos(8.0D, -2.0D, 0.0D).tex(0.5D, 0.0D).endVertex();
-            bufferbuilder.pos(8.0D, 2.0D, 0.0D).tex(0.5D, 0.15625D).endVertex();
-            bufferbuilder.pos(-8.0D, 2.0D, 0.0D).tex(0.0D, 0.15625D).endVertex();
-            tessellator.draw();
-        }
-
-        if (this.renderOutlines)
-        {
-            GlStateManager.disableOutlineMode();
-            GlStateManager.disableColorMaterial();
-        }
-
-        GlStateManager.disableRescaleNormal();
-        GlStateManager.enableLighting();
-        GlStateManager.popMatrix();
-        super.doRender(entity, x, y, z, entityYaw, partialTicks);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSoulsand.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSoulsand.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSoulsand.java	(date 1525605768000)
@@ -1,4 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-public class BiomeSoulsand {
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/IBOPBlock.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/IBOPBlock.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/IBOPBlock.java	(date 1525605768000)
@@ -1,22 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.renderer.color.IBlockColor;
-import net.minecraft.client.renderer.color.IItemColor;
-import net.minecraft.item.ItemBlock;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-public interface IBOPBlock {
-    
-    Class<? extends ItemBlock> getItemClass();
-    IProperty[] getPresetProperties();
-    IProperty[] getNonRenderingProperties();
-    String getStateName(IBlockState state);
-
-	@SideOnly(Side.CLIENT)
-    IBlockColor getBlockColor();
-	@SideOnly(Side.CLIENT)
-    IItemColor getItemColor();
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeRedDesert.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeRedDesert.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeRedDesert.java	(date 1525605768000)
@@ -1,54 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.block.BlockSand;
-import net.minecraft.entity.monster.EntityHusk;
-import net.minecraft.entity.monster.EntityZombie;
-import net.minecraft.entity.monster.EntityZombieVillager;
-import net.minecraft.entity.passive.EntityRabbit;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.feature.WorldGenDesertWells;
-import net.minecraft.world.gen.feature.WorldGenFossils;
-
-import java.util.Random;
-
-public class BiomeRedDesert extends Biome {
-
-    public BiomeRedDesert() {
-        super((new Biome.BiomeProperties("red_desert")).setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled().setBaseBiome(Biomes.DESERT.getBiomeName()));
-        this.spawnableCreatureList.clear();
-        this.topBlock = Blocks.SAND.getDefaultState().withProperty(BlockSand.VARIANT, BlockSand.EnumType.RED_SAND);
-        this.fillerBlock = Blocks.SAND.getDefaultState().withProperty(BlockSand.VARIANT, BlockSand.EnumType.RED_SAND);
-        this.decorator.treesPerChunk = -999;
-        this.decorator.deadBushPerChunk = 2;
-        this.decorator.reedsPerChunk = 50;
-        this.decorator.cactiPerChunk = 10;
-        this.spawnableCreatureList.clear();
-        this.spawnableCreatureList.add(new Biome.SpawnListEntry(EntityRabbit.class, 4, 2, 3));
-
-        this.spawnableMonsterList.removeIf(biome$spawnlistentry -> biome$spawnlistentry.entityClass == EntityZombie.class || biome$spawnlistentry.entityClass == EntityZombieVillager.class);
-
-        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombie.class, 19, 4, 4));
-        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityZombieVillager.class, 1, 1, 1));
-        this.spawnableMonsterList.add(new Biome.SpawnListEntry(EntityHusk.class, 80, 4, 4));
-    }
-
-    public void decorate(World worldIn, Random rand, BlockPos pos) {
-        super.decorate(worldIn, rand, pos);
-        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.DESERT_WELL))
-            if (rand.nextInt(1000) == 0) {
-                int i = rand.nextInt(16) + 8;
-                int j = rand.nextInt(16) + 8;
-                BlockPos blockpos = worldIn.getHeight(pos.add(i, 0, j)).up();
-                (new WorldGenDesertWells()).generate(worldIn, rand, blockpos);
-            }
-
-        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.FOSSIL))
-            if (rand.nextInt(64) == 0) {
-                (new WorldGenFossils()).generate(worldIn, rand, pos);
-            }
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/WorldGenUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/WorldGenUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/WorldGenUtil.java	(date 1525605768000)
@@ -1,449 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockChest;
-import net.minecraft.block.BlockMobSpawner;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityList;
-import net.minecraft.init.Blocks;
-import net.minecraft.inventory.IInventory;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagDouble;
-import net.minecraft.nbt.NBTTagList;
-import net.minecraft.tileentity.MobSpawnerBaseLogic;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityChest;
-import net.minecraft.tileentity.TileEntityMobSpawner;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.structure.StructureBoundingBox;
-import net.minecraft.world.gen.structure.template.BlockRotationProcessor;
-import net.minecraft.world.gen.structure.template.PlacementSettings;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraftforge.fml.relauncher.ReflectionHelper;
-
-import java.lang.reflect.Field;
-import java.util.List;
-import java.util.Random;
-import java.util.UUID;
-
-@SuppressWarnings("ConstantConditions")
-public class WorldGenUtil
-{
-    private static final Field FIELD_BLOCKS = ReflectionHelper.findField(Template.class, "field_186270_a", "blocks");
-    private static final Field FIELD_ENTITIES = ReflectionHelper.findField(Template.class, "field_186271_b", "entities");
-
-    public static BlockPos getSuitableGroundPos(World world, BlockPos pos, BlockPos structureSize, float percentage)
-    {
-        label_while:
-        while(pos.getY() > 32)
-        {
-            float sizeX = structureSize.getX();
-            float sizeY = structureSize.getY();
-            float sizeZ = structureSize.getZ();
-
-            int topBlocks = 0;
-
-            for(int x = 0; x <= MathHelper.abs(sizeX); x++)
-            {
-                for(int z = 0; z <= MathHelper.abs(sizeZ); z++)
-                {
-                    int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
-                    int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
-
-                    BlockPos newPos = pos.add(posX, 0, posZ);
-                    IBlockState state = world.getBlockState(newPos);
-
-                    if(!world.getBlockState(newPos).getMaterial().isReplaceable() && !world.getBlockState(newPos.down()).getMaterial().isReplaceable() && world.getBlockState(newPos.up()).getMaterial().isReplaceable())
-                    {
-                        topBlocks++;
-                    }
-                    else if(state != Blocks.AIR.getDefaultState())
-                    {
-                        pos = pos.down();
-                        continue label_while;
-                    }
-                }
-            }
-
-            int replaceableBlocks = 0;
-
-            if(topBlocks >= MathHelper.abs(sizeX * sizeZ) * percentage)
-            {
-                for(int y = 1; y < sizeY; y++)
-                {
-                    for(int x = 0; x <= MathHelper.abs(sizeX); x++)
-                    {
-                        for(int z = 0; z <= MathHelper.abs(sizeZ); z++)
-                        {
-                            int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
-                            int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
-
-                            BlockPos newPos = pos.add(posX, y, posZ);
-                            IBlockState state = world.getBlockState(newPos);
-
-                            if(world.getBlockState(newPos).getMaterial().isReplaceable())
-                            {
-                                replaceableBlocks++;
-                            }
-                            else if(state != Blocks.AIR.getDefaultState())
-                            {
-                                pos = pos.down();
-                                continue label_while;
-                            }
-                        }
-                    }
-                }
-            }
-
-            if(replaceableBlocks > MathHelper.abs(sizeX * sizeY * sizeZ) * 0.875F)
-            {
-                return pos;
-            }
-
-            pos = pos.down();
-        }
-
-        return BlockPos.ORIGIN;
-    }
-
-    public static BlockPos getSuitableWallPos(World world, BlockPos pos, BlockPos structureSize, float percentage)
-    {
-        while(pos.getY() > 32)
-        {
-            float sizeX = structureSize.getX();
-            float sizeZ = structureSize.getZ();
-            float sizeY = structureSize.getY();
-
-            int wallBlocks = 0;
-
-            for(int x = 0; x <= MathHelper.abs(sizeX); x++)
-            {
-                for(int z = 0; z <= MathHelper.abs(sizeZ); z++)
-                {
-                    for(int y = 0; y <= sizeY; y++)
-                    {
-                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
-                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
-
-                        BlockPos newPos = pos.add(posX, y, posZ);
-
-                        if(!world.getBlockState(newPos).getMaterial().isReplaceable())
-                        {
-                            wallBlocks++;
-                        }
-                    }
-                }
-            }
-
-            if(wallBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ) * percentage)
-            {
-                return pos;
-            }
-
-            pos = pos.down();
-        }
-
-        return BlockPos.ORIGIN;
-    }
-
-    public static BlockPos getSuitableCeilingPos(World world, BlockPos pos, BlockPos structureSize)
-    {
-        label_while:
-        while(pos.getY() < 128)
-        {
-            float sizeX = structureSize.getX();
-            float sizeZ = structureSize.getZ();
-            float sizeY = structureSize.getY();
-
-            int ceilingBlocks = 0;
-            int replaceableBlocks = 0;
-
-            for(int x = 0; x <= MathHelper.abs(sizeX); x++)
-            {
-                for(int z = 0; z <= MathHelper.abs(sizeZ); z++)
-                {
-                    for(int y = 0; y <= sizeY; y++)
-                    {
-                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
-                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
-
-                        BlockPos newPos = pos.add(posX, -y, posZ);
-
-                        if(y == 0)
-                        {
-                            if(world.getBlockState(newPos).isSideSolid(world, newPos, EnumFacing.DOWN))
-                            {
-                                ceilingBlocks++;
-                            }
-                            else
-                            {
-                                pos = pos.up();
-                                continue label_while;
-                            }
-                        }
-                        else
-                        {
-                            if(world.getBlockState(newPos).getBlock().isReplaceable(world, newPos))
-                            {
-                                replaceableBlocks++;
-                            }
-                            else
-                            {
-                                pos = pos.up();
-                                continue label_while;
-                            }
-
-                        }
-                    }
-                }
-            }
-
-            if(replaceableBlocks >= MathHelper.abs(sizeX * (sizeY - 1) * sizeZ) && ceilingBlocks >= MathHelper.abs(sizeX * sizeZ))
-            {
-                return pos.add(0, -sizeY, 0);
-            }
-
-            pos = pos.up();
-        }
-
-        return BlockPos.ORIGIN;
-    }
-
-    public static BlockPos getSuitableAirPos(World world, BlockPos pos, BlockPos structureSize)
-    {
-        label_while:
-        while(pos.getY() > 32)
-        {
-            float sizeX = structureSize.getX();
-            float sizeZ = structureSize.getZ();
-            float sizeY = structureSize.getY();
-
-            int replaceableBlocks = 0;
-
-            for(int x = 0; x <= MathHelper.abs(sizeX); x++)
-            {
-                for(int z = 0; z <= MathHelper.abs(sizeZ); z++)
-                {
-                    for(int y = 0; y <= sizeY; y++)
-                    {
-                        int posX = (int) (sizeX > 0 ? sizeX - x : sizeX + x);
-                        int posZ = (int) (sizeZ > 0 ? sizeZ - z : sizeZ + z);
-
-                        BlockPos newPos = pos.add(posX, y, posZ);
-
-                        if(world.getBlockState(newPos).getMaterial().isReplaceable())
-                        {
-                            replaceableBlocks++;
-                        }
-                        else
-                        {
-                            pos = pos.down();
-                            continue label_while;
-                        }
-                    }
-                }
-            }
-
-            if(replaceableBlocks >= MathHelper.abs(sizeX * sizeY * sizeZ))
-            {
-                return pos;
-            }
-
-            pos = pos.down();
-        }
-
-        return BlockPos.ORIGIN;
-    }
-
-    public static void generateStructure(World world, BlockPos pos, Random rand, Template template, PlacementSettings placementSettings, List<ResourceLocation> lootTables, List<ResourceLocation> spawnerMobs)
-    {
-        try
-        {
-            List<Template.BlockInfo> blocks = (List<Template.BlockInfo>) FIELD_BLOCKS.get(template);
-            List<Template.EntityInfo> entities = (List<Template.EntityInfo>) FIELD_ENTITIES.get(template);
-
-            if((!blocks.isEmpty() || !placementSettings.getIgnoreEntities() && !entities.isEmpty()) && template.getSize().getX() >= 1 && template.getSize().getY() >= 1 && template.getSize().getZ() >= 1)
-            {
-                BlockRotationProcessor processor = new BlockRotationProcessor(pos, placementSettings);
-                Block block = placementSettings.getReplacedBlock();
-                StructureBoundingBox boundingBox = placementSettings.getBoundingBox();
-
-                for(Template.BlockInfo blockInfo : blocks)
-                {
-                    BlockPos blockPos = Template.transformedBlockPos(placementSettings, blockInfo.pos).add(pos);
-                    Template.BlockInfo blockInfo1 = processor != null ? processor.processBlock(world, blockPos, blockInfo) : blockInfo;
-
-                    if(blockInfo1 != null)
-                    {
-                        Block block1 = blockInfo1.blockState.getBlock();
-
-                        if((block == null || block != block1) && (!placementSettings.getIgnoreStructureBlock() || block1 != Blocks.STRUCTURE_BLOCK) && (boundingBox == null || boundingBox.isVecInside(blockPos)))
-                        {
-                            IBlockState state = blockInfo1.blockState.withMirror(placementSettings.getMirror()).withRotation(placementSettings.getRotation());
-
-                            if(blockInfo1.tileentityData != null)
-                            {
-                                TileEntity tileEntity = world.getTileEntity(blockPos);
-
-                                if(tileEntity != null)
-                                {
-                                    if(tileEntity instanceof IInventory)
-                                    {
-                                        ((IInventory) tileEntity).clear();
-                                    }
-
-                                    world.setBlockState(blockPos, Blocks.BARRIER.getDefaultState(), 4);
-                                }
-                            }
-
-                            if(world.setBlockState(blockPos, state, 3) && blockInfo1.tileentityData != null)
-                            {
-                                TileEntity tileEntity = world.getTileEntity(blockPos);
-
-                                if(tileEntity != null)
-                                {
-                                    blockInfo1.tileentityData.setInteger("x", blockPos.getX());
-                                    blockInfo1.tileentityData.setInteger("y", blockPos.getY());
-                                    blockInfo1.tileentityData.setInteger("z", blockPos.getZ());
-                                    tileEntity.readFromNBT(blockInfo1.tileentityData);
-                                    tileEntity.mirror(placementSettings.getMirror());
-                                    tileEntity.rotate(placementSettings.getRotation());
-
-                                    if(state.getBlock() instanceof BlockChest)
-                                    {
-                                        ((TileEntityChest) tileEntity).setLootTable(lootTables.get(rand.nextInt(lootTables.size())), rand.nextLong());
-
-                                    }
-                                    else if(state.getBlock() instanceof BlockMobSpawner)
-                                    {
-                                        MobSpawnerBaseLogic logic = ((TileEntityMobSpawner) tileEntity).getSpawnerBaseLogic();
-                                        NBTTagCompound compound = new NBTTagCompound();
-
-                                        logic.writeToNBT(compound);
-                                        compound.removeTag("SpawnPotentials");
-                                        logic.readFromNBT(compound);
-                                        logic.setEntityId(spawnerMobs.get(rand.nextInt(spawnerMobs.size())));
-                                        tileEntity.markDirty();
-
-                                        world.notifyBlockUpdate(pos, state, state, 3);
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-
-                for(Template.BlockInfo blockInfo2 : blocks)
-                {
-                    if(block == null || block != blockInfo2.blockState.getBlock())
-                    {
-                        BlockPos blockPos1 = Template.transformedBlockPos(placementSettings, blockInfo2.pos).add(pos);
-
-                        if(boundingBox == null || boundingBox.isVecInside(blockPos1))
-                        {
-                            world.notifyNeighborsRespectDebug(blockPos1, blockInfo2.blockState.getBlock(), false);
-
-                            if(blockInfo2.tileentityData != null)
-                            {
-                                TileEntity tileEntity = world.getTileEntity(blockPos1);
-
-                                if(tileEntity != null)
-                                {
-                                    tileEntity.markDirty();
-                                }
-                            }
-                        }
-                    }
-                }
-
-                if(!placementSettings.getIgnoreEntities())
-                {
-                    addEntitiesToWorld(world, pos, placementSettings, entities, boundingBox);
-                }
-            }
-        }
-        catch(IllegalAccessException e)
-        {
-            e.printStackTrace();
-        }
-    }
-
-    private static void addEntitiesToWorld(World world, BlockPos pos, PlacementSettings placementSettings, List<Template.EntityInfo> entities, StructureBoundingBox boundingBox)
-    {
-        for(Template.EntityInfo entityInfo : entities)
-        {
-            BlockPos blockPos = Template.transformedBlockPos(placementSettings, entityInfo.blockPos).add(pos);
-
-            if(boundingBox == null || boundingBox.isVecInside(blockPos))
-            {
-                NBTTagCompound compound = entityInfo.entityData;
-                Vec3d vec3d = transformedVec3d(entityInfo.pos, placementSettings.getMirror(), placementSettings.getRotation());
-                Vec3d vec3d1 = vec3d.addVector((double) pos.getX(), (double) pos.getY(), (double) pos.getZ());
-                NBTTagList tagList = new NBTTagList();
-                tagList.appendTag(new NBTTagDouble(vec3d1.x));
-                tagList.appendTag(new NBTTagDouble(vec3d1.y));
-                tagList.appendTag(new NBTTagDouble(vec3d1.z));
-                compound.setTag("Pos", tagList);
-                compound.setUniqueId("UUID", UUID.randomUUID());
-                Entity entity;
-
-                try
-                {
-                    entity = EntityList.createEntityFromNBT(compound, world);
-                }
-                catch(Exception var15)
-                {
-                    entity = null;
-                }
-
-                if(entity != null)
-                {
-                    float f = entity.getMirroredYaw(placementSettings.getMirror());
-                    f = f + (entity.rotationYaw - entity.getRotatedYaw(placementSettings.getRotation()));
-                    entity.setLocationAndAngles(vec3d1.x, vec3d1.y, vec3d1.z, f, entity.rotationPitch);
-                    world.spawnEntity(entity);
-                }
-            }
-        }
-    }
-
-    private static Vec3d transformedVec3d(Vec3d vec, Mirror mirror, Rotation rotation)
-    {
-        double xCoord = vec.x;
-        double yCoord = vec.y;
-        double zCoord = vec.z;
-        boolean flag = true;
-
-        switch(mirror)
-        {
-            case LEFT_RIGHT:
-                zCoord = 1.0D - zCoord;
-                break;
-            case FRONT_BACK:
-                xCoord = 1.0D - xCoord;
-                break;
-            default:
-                flag = false;
-        }
-
-        switch(rotation)
-        {
-            case COUNTERCLOCKWISE_90:
-                return new Vec3d(zCoord, yCoord, 1.0D - xCoord);
-            case CLOCKWISE_90:
-                return new Vec3d(1.0D - zCoord, yCoord, xCoord);
-            case CLOCKWISE_180:
-                return new Vec3d(1.0D - xCoord, yCoord, 1.0D - zCoord);
-            default:
-                return flag ? new Vec3d(xCoord, yCoord, zCoord) : vec;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiome.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiome.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiome.java	(date 1525605768000)
@@ -1,224 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import java.util.List;
-
-public class NetherBiome {
-    private String biomeId;
-    private int weight;
-    private String climateType;
-    private BiomeBlock topBlock;
-    private BiomeBlock fillerBlock;
-    private BiomeBlock oceanBlock;
-    private List<BiomeEntity> entitySpawnList;
-    private List<BiomeFeature> featureList;
-
-    public String getId() {
-        return biomeId;
-    }
-
-    public int getWeight() {
-        return weight;
-    }
-
-    public String getClimateType() {
-        return climateType;
-    }
-
-    public BiomeBlock getTopBlock() {
-        return topBlock;
-    }
-
-    public BiomeBlock getFillerBlock() {
-        return fillerBlock;
-    }
-
-    public BiomeBlock getOceanBlock() {
-        return oceanBlock;
-    }
-
-    public List<BiomeEntity> getEntitySpawnList() {
-        return entitySpawnList;
-    }
-
-    public List<BiomeFeature> getFeatureList() {
-        return featureList;
-    }
-
-    public static class BiomeList {
-        private String name;
-        private List<Mod> mods;
-
-        public String getName() {
-            return name;
-        }
-
-        public List<Mod> getMods() {
-            return mods;
-        }
-    }
-
-    public static class Mod {
-        private String modId;
-        private List<NetherBiome> biomes;
-
-        public String getId() {
-            return modId;
-        }
-
-        public List<NetherBiome> getBiomes() {
-            return biomes;
-        }
-    }
-
-    public static class BiomeBlock {
-        private String blockId;
-        private int meta;
-
-        public BiomeBlock() {
-            blockId = "";
-            meta = 0;
-        }
-
-        public String getId() {
-            return blockId;
-        }
-
-        public int getMeta() {
-            return meta;
-        }
-    }
-
-    public static class BiomeEntity {
-        private String entityId;
-        private String creatureType;
-        private int weight;
-        private int minGroupCount;
-        private int maxGroupCount;
-
-        public String getId() {
-            return entityId;
-        }
-
-        public String getCreatureType() {
-            return creatureType;
-        }
-
-        public int getWeight() {
-            return weight;
-        }
-
-        public int getMinGroupCount() {
-            return minGroupCount;
-        }
-
-        public int getMaxGroupCount() {
-            return maxGroupCount;
-        }
-    }
-
-    public static class BiomeFeature {
-        private String featureType;
-        private BiomeBlock blockToSpawn;
-        private BiomeBlock targetBlock;
-        private BiomeBlock surroundingBlock;
-        private int minHeight;
-        private int maxHeight;
-        private int size;
-        private int rarity;
-        private boolean randomRarity;
-        private boolean superRare;
-        private List<BiomeStructure> structureList;
-        private boolean hidden;
-
-        public String getFeatureType() {
-            return featureType;
-        }
-
-        public BiomeBlock getBlockToSpawn() {
-            return blockToSpawn;
-        }
-
-        public BiomeBlock getTargetBlock() {
-            return targetBlock;
-        }
-
-        public BiomeBlock getSurroundingBlock() {
-            return surroundingBlock;
-        }
-
-        public int getMinHeight() {
-            return minHeight;
-        }
-
-        public int getMaxHeight() {
-            return maxHeight;
-        }
-
-        public int getSize() {
-            return size;
-        }
-
-        public int getRarity() {
-            return rarity;
-        }
-
-        public boolean useRandomRarity() {
-            return randomRarity;
-        }
-
-        public boolean isSuperRare() {
-            return superRare;
-        }
-
-        public List<BiomeStructure> getStructureList() {
-            return structureList;
-        }
-
-        public boolean isHidden() {
-            return hidden;
-        }
-    }
-
-    public static class BiomeStructure {
-        private String structureType;
-        private String structureId;
-        private String replacedBlock;
-        private List<String> lootTables;
-        private List<String> spawnerMobs;
-        private boolean rotate;
-        private boolean mirror;
-        private int weight;
-
-        public String getStructureType() {
-            return structureType;
-        }
-
-        public String getStructureId() {
-            return structureId;
-        }
-
-        public String getReplacedBlock() {
-            return replacedBlock;
-        }
-
-        public List<String> getLootTables() {
-            return lootTables;
-        }
-
-        public List<String> getSpawnerMobs() {
-            return spawnerMobs;
-        }
-
-        public boolean rotate() {
-            return rotate;
-        }
-
-        public boolean mirror() {
-            return mirror;
-        }
-
-        public int getWeight() {
-            return weight;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelHoveringInferno.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelHoveringInferno.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelHoveringInferno.java	(date 1525605768000)
@@ -1,119 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-/**
- * ModelHoveringInferno - Created By: Dion/Trikzon
- * Created using Tabula 7.0.0
- */
-public class ModelHoveringInferno extends ModelBase {
-    public ModelRenderer head;
-    public ModelRenderer rod;
-    public ModelRenderer helmetFront1;
-    public ModelRenderer helmetFront2;
-    public ModelRenderer helmetFront3;
-    public ModelRenderer helmetFront4;
-    public ModelRenderer helmetFront5;
-    public ModelRenderer helmetFront6;
-    public ModelRenderer helmetFront7;
-    public ModelRenderer helmetLeft1;
-    public ModelRenderer helmetRight1;
-    public ModelRenderer helmetBack1;
-    public ModelRenderer helmetFrontGold;
-    public ModelRenderer shield1;
-    public ModelRenderer shield2;
-    public ModelRenderer shield3;
-    public ModelRenderer shield4;
-
-    public ModelHoveringInferno() {
-        this.textureWidth = 128;
-        this.textureHeight = 64;
-        this.helmetFrontGold = new ModelRenderer(this, 27, 6);
-        this.helmetFrontGold.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFrontGold.addBox(-1.0F, -7.5F, -4.5F, 2, 2, 1, 0.0F);
-        this.helmetRight1 = new ModelRenderer(this, 1, 14);
-        this.helmetRight1.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetRight1.addBox(-4.0F, -8.0F, -3.0F, 1, 8, 6, 0.0F);
-        this.helmetFront3 = new ModelRenderer(this, 35, 23);
-        this.helmetFront3.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront3.addBox(2.0F, -4.0F, -4.0F, 2, 4, 1, 0.0F);
-        this.shield2 = new ModelRenderer(this, 16, 44);
-        this.shield2.setRotationPoint(6.0F, 0.0F, -6.0F);
-        this.shield2.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
-        this.setRotateAngle(shield2, -0.2617993877991494F, -0.7853981633974483F, 0.0F);
-        this.helmetLeft1 = new ModelRenderer(this, 45, 14);
-        this.helmetLeft1.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetLeft1.addBox(3.0F, -8.0F, -3.0F, 1, 8, 6, 0.0F);
-        this.helmetFront2 = new ModelRenderer(this, 18, 17);
-        this.helmetFront2.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront2.addBox(-4.0F, -8.0F, -4.0F, 1, 4, 1, 0.0F);
-        this.helmetBack1 = new ModelRenderer(this, 21, 29);
-        this.helmetBack1.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetBack1.addBox(-4.0F, -8.0F, 3.0F, 8, 8, 1, 0.0F);
-        this.helmetFront4 = new ModelRenderer(this, 38, 17);
-        this.helmetFront4.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront4.addBox(3.0F, -8.0F, -4.0F, 1, 4, 1, 0.0F);
-        this.head = new ModelRenderer(this, 46, 50);
-        this.head.setRotationPoint(0.0F, -2.0F, 0.0F);
-        this.head.addBox(-3.0F, -8.0F, -3.0F, 6, 8, 6, 0.0F);
-        this.helmetFront7 = new ModelRenderer(this, 27, 10);
-        this.helmetFront7.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront7.addBox(-1.0F, -9.0F, -4.0F, 2, 1, 1, 0.0F);
-        this.rod = new ModelRenderer(this, 0, 38);
-        this.rod.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.rod.addBox(-2.0F, 0.0F, -2.0F, 4, 22, 4, 0.0F);
-        this.shield4 = new ModelRenderer(this, 16, 44);
-        this.shield4.setRotationPoint(-6.0F, 0.0F, 6.0F);
-        this.shield4.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
-        this.setRotateAngle(shield4, 0.2617993877991494F, -0.7853981633974483F, 0.0F);
-        this.helmetFront6 = new ModelRenderer(this, 25, 13);
-        this.helmetFront6.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront6.addBox(-2.0F, -8.0F, -4.0F, 4, 1, 1, 0.0F);
-        this.shield1 = new ModelRenderer(this, 16, 44);
-        this.shield1.setRotationPoint(-6.0F, 0.0F, -6.0F);
-        this.shield1.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
-        this.setRotateAngle(shield1, -0.2617993877991494F, 0.7853981633974483F, 0.0F);
-        this.shield3 = new ModelRenderer(this, 16, 44);
-        this.shield3.setRotationPoint(6.0F, 0.0F, 6.0F);
-        this.shield3.addBox(-5.0F, 0.0F, -1.0F, 10, 18, 2, 0.0F);
-        this.setRotateAngle(shield3, 0.2617993877991494F, 0.7853981633974483F, 0.0F);
-        this.helmetFront1 = new ModelRenderer(this, 19, 23);
-        this.helmetFront1.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront1.addBox(-4.0F, -4.0F, -4.0F, 2, 4, 1, 0.0F);
-        this.helmetFront5 = new ModelRenderer(this, 23, 16);
-        this.helmetFront5.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.helmetFront5.addBox(-3.0F, -7.0F, -4.0F, 6, 2, 1, 0.0F);
-        this.head.addChild(this.helmetFrontGold);
-        this.head.addChild(this.helmetRight1);
-        this.head.addChild(this.helmetFront3);
-        this.rod.addChild(this.shield2);
-        this.head.addChild(this.helmetLeft1);
-        this.head.addChild(this.helmetFront2);
-        this.head.addChild(this.helmetBack1);
-        this.head.addChild(this.helmetFront4);
-        this.head.addChild(this.helmetFront7);
-        this.rod.addChild(this.shield4);
-        this.head.addChild(this.helmetFront6);
-        this.rod.addChild(this.shield1);
-        this.rod.addChild(this.shield3);
-        this.head.addChild(this.helmetFront1);
-        this.head.addChild(this.helmetFront5);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) { 
-        this.head.render(f5);
-        this.rod.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCrow.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCrow.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCrow.java	(date 1525605768000)
@@ -1,19 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.world.World;
-
-public class EntityAtmosCrow extends EntityLiving {
-
-    public EntityAtmosCrow(World world1) {
-        super(world1);
-        setSize(0.5F, 0.5F);
-        setCustomNameTag("Crow");
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/HallwayStructure.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/HallwayStructure.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/HallwayStructure.java	(date 1525605768000)
@@ -1,52 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.dungeons.generator;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.thegaminghuskymc.mcaddon.util.interfaces.IStructure;
-
-import java.util.Random;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class HallwayStructure extends WorldGenerator implements IStructure {
-
-    private static String structureName;
-
-    public HallwayStructure(String name)
-    {
-        structureName = name;
-    }
-
-    @Override
-    public boolean generate(World worldIn, Random rand, BlockPos position) {
-        generateStructure(worldIn, position);
-        return true;
-    }
-
-    private static void generateStructure(World world, BlockPos pos)
-    {
-        MinecraftServer mcServer = world.getMinecraftServer();
-        TemplateManager manager = worldServer.getStructureTemplateManager();
-        ResourceLocation location = new ResourceLocation(MOD_ID, structureName);
-        Template template = manager.get(mcServer, location);
-
-        if(template != null)
-        {
-            IBlockState state = world.getBlockState(pos);
-            world.notifyBlockUpdate(pos, state, state, 3);
-            template.addBlocksToWorldChunk(world, pos, settings);
-        }
-
-        if(template == null)
-        {
-            System.out.println("NO STRUCTURE");
-        }
-
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityGreatHunger.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityGreatHunger.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityGreatHunger.java	(date 1525605768000)
@@ -1,277 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntitySmallFireball;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNodeType;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-
-public class EntityGreatHunger extends EntityMob {
-
-    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityGreatHunger.class, DataSerializers.BYTE);
-    /**
-     * Random offset used in floating behaviour
-     */
-    private float heightOffset = 0.5F;
-    /**
-     * ticks until heightOffset is randomized
-     */
-    private int heightOffsetUpdateTime;
-
-    public EntityGreatHunger(World worldIn) {
-        super(worldIn);
-        this.setPathPriority(PathNodeType.WATER, -1.0F);
-        this.setPathPriority(PathNodeType.LAVA, 8.0F);
-        this.setPathPriority(PathNodeType.DANGER_FIRE, 0.0F);
-        this.setPathPriority(PathNodeType.DAMAGE_FIRE, 0.0F);
-        this.isImmuneToFire = true;
-        this.experienceValue = 10;
-    }
-
-    public static void registerFixesBlaze(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityGreatHunger.class);
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(4, new EntityGreatHunger.AIFireballAttack(this));
-        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(ON_FIRE, (byte) 0);
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_BLAZE_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_BLAZE_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_BLAZE_DEATH;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender() {
-        return 15728880;
-    }
-
-    /**
-     * Gets how bright this entity is.
-     */
-    public float getBrightness() {
-        return 1.0F;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        if (!this.onGround && this.motionY < 0.0D) {
-            this.motionY *= 0.6D;
-        }
-
-        if (this.world.isRemote) {
-            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-
-            for (int i = 0; i < 2; ++i) {
-                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
-            }
-        }
-
-        super.onLivingUpdate();
-    }
-
-    protected void updateAITasks() {
-        if (this.isWet()) {
-            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
-        }
-
-        --this.heightOffsetUpdateTime;
-
-        if (this.heightOffsetUpdateTime <= 0) {
-            this.heightOffsetUpdateTime = 100;
-            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
-        }
-
-        EntityLivingBase entitylivingbase = this.getAttackTarget();
-
-        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
-            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
-            this.isAirBorne = true;
-        }
-
-        super.updateAITasks();
-    }
-
-    public void fall(float distance, float damageMultiplier) {
-    }
-
-    /**
-     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
-     */
-    public boolean isBurning() {
-        return this.isCharged();
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_BLAZE;
-    }
-
-    private boolean isCharged() {
-        return (this.dataManager.get(ON_FIRE) & 1) != 0;
-    }
-
-    private void setOnFire(boolean onFire) {
-        byte b0 = this.dataManager.get(ON_FIRE);
-
-        if (onFire) {
-            b0 = (byte) (b0 | 1);
-        } else {
-            b0 = (byte) (b0 & -2);
-        }
-
-        this.dataManager.set(ON_FIRE, b0);
-    }
-
-    /**
-     * Checks to make sure the light is not too bright where the mob is spawning
-     */
-    protected boolean isValidLightLevel() {
-        return true;
-    }
-
-    static class AIFireballAttack extends EntityAIBase {
-        private final EntityGreatHunger blaze;
-        private int attackStep;
-        private int attackTime;
-
-        AIFireballAttack(EntityGreatHunger blazeIn) {
-            this.blaze = blazeIn;
-            this.setMutexBits(3);
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            return entitylivingbase != null && entitylivingbase.isEntityAlive();
-        }
-
-        /**
-         * Execute a one shot task or start executing a continuous task
-         */
-        public void startExecuting() {
-            this.attackStep = 0;
-        }
-
-        /**
-         * Reset the task's internal state. Called when this task is interrupted by another one
-         */
-        public void resetTask() {
-            this.blaze.setOnFire(false);
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            --this.attackTime;
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
-
-            if (d0 < 4.0D) {
-                if (this.attackTime <= 0) {
-                    this.attackTime = 20;
-                    this.blaze.attackEntityAsMob(entitylivingbase);
-                }
-
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
-                double d1 = entitylivingbase.posX - this.blaze.posX;
-                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
-                double d3 = entitylivingbase.posZ - this.blaze.posZ;
-
-                if (this.attackTime <= 0) {
-                    ++this.attackStep;
-
-                    if (this.attackStep == 1) {
-                        this.attackTime = 60;
-                        this.blaze.setOnFire(true);
-                    } else if (this.attackStep <= 4) {
-                        this.attackTime = 6;
-                    } else {
-                        this.attackTime = 100;
-                        this.attackStep = 0;
-                        this.blaze.setOnFire(false);
-                    }
-
-                    if (this.attackStep > 1) {
-                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
-                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
-
-                        for (int i = 0; i < 1; ++i) {
-                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
-                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
-                            this.blaze.world.spawnEntity(entitysmallfireball);
-                        }
-                    }
-                }
-
-                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
-            } else {
-                this.blaze.getNavigator().clearPath();
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            }
-
-            super.updateTask();
-        }
-
-        private double getFollowDistance() {
-            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
-            return iattributeinstance.getAttributeValue();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosStarFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosStarFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosStarFish.java	(date 1525605768000)
@@ -1,42 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosStarFish.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosSeaTurtle, EntityAtmosSwordFish, EntityAtmosReefManta, EntityAtmosColourfulFish, 
-//            EntityAtmosMcFish, EntityAtmosPiranha, EntityAtmosBlowfish, EntityAtmosAngler
-
-public class EntityAtmosStarFish extends EntityAtmosCreature
-{
-
-    public EntityAtmosStarFish(World world)
-    {
-        super(world);
-        setSize(0.3F, 0.3F);
-        caught = false;
-        fish1 = false;
-        fish2 = false;
-        fish3 = false;
-        fish4 = false;
-        fish5 = false;
-        fish6 = false;
-        fish7 = false;
-        fish8 = false;
-    }
-
-    public boolean isTamed;
-    public boolean caught;
-    public boolean fish1;
-    public boolean fish2;
-    public boolean fish3;
-    public boolean fish4;
-    public boolean fish5;
-    public boolean fish6;
-    public boolean fish7;
-    public boolean fish8;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/LootTableHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/LootTableHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/LootTableHandler.java	(date 1525605768000)
@@ -1,15 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class LootTableHandler {
-
-    public static final ResourceLocation MUMMY = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "mummy"));
-    public static final ResourceLocation MUMMY_VILLAGER = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "mummy_villager"));
-    public static final ResourceLocation SCORPION = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "scorpion"));
-    public static final ResourceLocation PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "phantom"));
-    public static final ResourceLocation RED_PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "red_phantom"));
-    public static final ResourceLocation ENDER_PHANTOM = LootTableList.register(new ResourceLocation(Reference.MOD_ID, "ender_phantom"));
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenCustomStructures.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenCustomStructures.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenCustomStructures.java	(date 1525605768000)
@@ -1,164 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen;
-
-import net.minecraft.block.Block;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldType;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraftforge.fml.common.IWorldGenerator;
-import net.thegaminghuskymc.mcaddon.world.gen.generators.WorldGenStructure;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Random;
-
-public class WorldGenCustomStructures implements IWorldGenerator {
-	public static final WorldGenStructure LIVING_CORAL_REEF = new WorldGenStructure("living_coral_reef");
-	public static final WorldGenStructure DEAD_CORAL_REEF = new WorldGenStructure("dead_coral_reef");
-	public static final WorldGenStructure VOLCANO = new WorldGenStructure("volcano");
-	public static final WorldGenStructure DESERT_HOUSE_1 = new WorldGenStructure("desert_house_1");
-	public static final WorldGenStructure DESERT_HOUSE_2 = new WorldGenStructure("desert_house_2");
-	public static final WorldGenStructure JUNGLE_VILLAGER_TOTEM = new WorldGenStructure("jungle_villager_totem");
-
-    public static final WorldGenStructure CORAL_PINK = new WorldGenStructure("coral_pink");
-    public static final WorldGenStructure CORAL_YELLOW = new WorldGenStructure("coral_yellow");
-    public static final WorldGenStructure CORAL_PURPLE = new WorldGenStructure("coral_purple");
-    public static final WorldGenStructure CORAL_BLUE = new WorldGenStructure("coral_blue");
-    public static final WorldGenStructure CORAL_RED = new WorldGenStructure("coral_red");
-
-	public WorldGenCustomStructures() {
-		super();
-	}
-
-	@Override
-    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-		switch(world.provider.getDimension()) {
-			case 1:
-				break;
-			case 0:
-                generateCoral(CORAL_PINK, world, random, chunkX, chunkZ, 20);
-                generateCoral(CORAL_YELLOW, world, random, chunkX, chunkZ, 20);
-                generateCoral(CORAL_PURPLE, world, random, chunkX, chunkZ, 20);
-                generateCoral(CORAL_BLUE, world, random, chunkX, chunkZ, 20);
-                generateCoral(CORAL_RED, world, random, chunkX, chunkZ, 20);
-				break;
-			case -1:
-                break;
-		}
-	}
-
-	private void generateStructure(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance, Block topBlock, Class<?>... classes) {
-		ArrayList<Class<?>> classesList = new ArrayList<>(Arrays.asList(classes));
-		
-		int x = (chunkX * 16) + random.nextInt(15);
-		int z = (chunkZ * 16) + random.nextInt(15);
-		int y = calculateGenerationHeight(world, x, z, topBlock);
-		BlockPos pos = new BlockPos(x,y,z);
-		
-		Class<?> biome = world.provider.getBiomeForCoords(pos).getClass();
-		
-		if(world.getWorldType() != WorldType.FLAT)
-		{
-			if(classesList.contains(biome))
-			{
-				if(random.nextInt(chance) == 0)
-				{
-					generator.generate(world, random, pos);
-				}
-			}
-		}
-	}
-
-    private void generateCoral(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance) {
-
-        int x = (chunkX * 16) + random.nextInt(15);
-        int z = (chunkZ * 16) + random.nextInt(15);
-        int y = calculateGenerationHeight(world, x, z, Blocks.GRAVEL);
-        BlockPos pos = new BlockPos(x,y,z);
-
-        Biome biome = world.provider.getBiomeForCoords(pos);
-
-        if(world.getWorldType() != WorldType.FLAT)
-        {
-            if(biome == Biomes.DEEP_OCEAN || biome == Biomes.OCEAN || biome == Biomes.FROZEN_OCEAN)
-            {
-                if(random.nextInt(chance) == 0)
-                {
-                    if(y + 19 < world.getSeaLevel()) {
-                        generator.generate(world, random, pos);
-                    }
-                }
-            }
-        }
-    }
-
-	private static int calculateGenerationHeight(World world, int x, int z, Block topBlock)
-	{
-		int y = world.getHeight();
-		boolean foundGround = false;
-		
-		while(!foundGround && y-- >= 0)
-		{
-			Block block = world.getBlockState(new BlockPos(x,y,z)).getBlock();
-			foundGround = block == topBlock;
-		}
-		
-		return y;
-	}
-
-    public static int getGroundFromAbove(World world, int x, int z)
-    {
-        int y = 255;
-        boolean foundGround = false;
-        while(!foundGround && y-- >= 31)
-        {
-            Block blockAt = world.getBlockState(new BlockPos(x,y,z)).getBlock();
-            foundGround =  blockAt == Blocks.WATER||blockAt == Blocks.FLOWING_WATER||blockAt == Blocks.GRASS || blockAt == Blocks.SAND || blockAt == Blocks.SNOW || blockAt == Blocks.SNOW_LAYER || blockAt == Blocks.GLASS||blockAt == Blocks.MYCELIUM;
-        }
-
-        return y;
-    }
-    public static int getLakeFromAbove(World world, int x, int z)
-    {
-        int y = 255;
-        boolean foundGround = false;
-        while(!foundGround && y-- >= 31)
-        {
-            Block blockAt = world.getBlockState(new BlockPos(x,y,z)).getBlock();
-            foundGround =  blockAt == Blocks.WATER||blockAt == Blocks.FLOWING_WATER;
-        }
-
-        return y;
-    }
-
-    public static boolean canSpawnHere(Template template, World world, BlockPos posAboveGround)
-    {
-        int zwidth = template.getSize().getZ();
-        int xwidth = template.getSize().getX();
-
-        // check all the corners to see which ones are replaceable
-        boolean corner1 = isCornerValid(world, posAboveGround);
-        boolean corner2 = isCornerValid(world, posAboveGround.add(xwidth, 0, zwidth));
-
-        // if Y > 20 and all corners pass the test, it's okay to spawn the structure
-        return posAboveGround.getY() > 31 && corner1 && corner2;
-    }
-
-    public static boolean isCornerValid(World world, BlockPos pos)
-    {
-        int variation = 3;
-        int highestBlock = getGroundFromAbove(world, pos.getX(), pos.getZ());
-
-        if (highestBlock > pos.getY() - variation && highestBlock < pos.getY() + variation)
-            return true;
-
-        return false;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/BlockModBush.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/BlockModBush.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/BlockModBush.java	(date 1525605768000)
@@ -1,82 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockBush;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.huskylib2.interf.IModBlock;
-import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-
-public class BlockModBush extends BlockBush implements IModBlock {
-
-	private final String[] variants;
-	private final String bareName, modid;
-
-	public BlockModBush(Material material, String name, String modid) {
-	    super(material);
-		variants = new String[] { name };
-		bareName = name;
-		this.modid = modid;
-
-		setUnlocalizedName(name);
-		setCreativeTab(CreativeTabs.SEARCH);
-	}
-
-	public Block setUnlocalizedName(String name) {
-		super.setUnlocalizedName(name);
-		this.setRegistryName(getPrefix(), name);
-		ProxyRegistry.register(this);
-		ProxyRegistry.register(createItemBlock(new ResourceLocation(getPrefix(), name)));
-		return this;
-	}
-
-	private ItemBlock createItemBlock(ResourceLocation res) {
-		return new ItemModBlock(this, res);
-	}
-
-	@Override
-	public String getBareName() {
-		return bareName;
-	}
-
-	@Override
-	public String[] getVariants() {
-		return variants;
-	}
-
-	@Override
-	public String getPrefix() {
-		return this.modid;
-	}
-
-	@Override
-	public String getModNamespace() {
-		return this.modid;
-	}
-
-	@Override
-	public ItemMeshDefinition getCustomMeshDefinition() {
-		return null;
-	}
-
-	@Override
-	public IProperty[] getIgnoredProperties() {
-		return new IProperty[0];
-	}
-
-	@Override
-	public IProperty getVariantProp() {
-		return null;
-	}
-
-	@Override
-	public Class getVariantEnum() {
-		return null;
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonEntities.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonEntities.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/MCAddonEntities.java	(date 1525605768000)
@@ -1,98 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EnumCreatureType;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.world.biome.Biome;
-import net.minecraftforge.common.BiomeDictionary;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.minecraftforge.fml.common.registry.*;
-import net.thegaminghuskymc.mcaddon.entity.*;
-import net.minecraftforge.fml.common.registry.EntityEntry;
-import net.minecraftforge.fml.common.registry.EntityEntryBuilder;
-import net.minecraftforge.fml.common.registry.EntityRegistry;
-import net.minecraftforge.fml.common.registry.ForgeRegistries;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummy;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummyVillager;
-import net.thegaminghuskymc.mcaddon.entity.EntityScorp;
-import net.thegaminghuskymc.mcaddon.util.handlers.RenderHandler;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@Mod.EventBusSubscriber(modid = MOD_ID)
-public class MCAddonEntities {
-
-    @SubscribeEvent
-    public static void RegisterEntitys(RegistryEvent.Register<EntityEntry> event) {
-        final EntityEntry[] entries = {
-            createBuilder("mummy").entity(EntityMummy.class).tracker(80, 3, true).egg(0xC9CE92, 0x444444).build(),
-            createBuilder("mummy_villager").entity(EntityMummyVillager.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
-            createBuilder("scorpion").entity(EntityScorp.class).tracker(30,3,true).egg(0x65401,0x6201209).build(),
-            createBuilder("phantom").entity(EntityPhantom.class).tracker(80, 3, true).egg(0x2d3f56, 0x958c79).build(),
-            createBuilder("red_phantom").entity(EntityRedPhantom.class).tracker(80, 3, true).egg(0x4A2929, 0x799591).build(),
-            createBuilder("ender_phantom").entity(EntityEnderPhantom.class).tracker(80, 3, true).egg(0x352D56, 0x8C9579).build(),
-            createBuilder("shadow_phantom").entity(EntityShadowPhantom.class).tracker(80, 3, true).egg(0x101010, 0x101010).build(),
-            createBuilder("hovering_inferno").entity(EntityHoveringInferno.class).tracker(80, 3, true).egg(0x864500, 0xd36d00).build(),
-            createBuilder("ravenous_killer_squid").entity(EntityMonsterOfTheOceanDepths.class).tracker(80, 3, true).egg(0x03002e, 0x060081).build(),
-            createBuilder("turtle").entity(EntitySeaTurtle.class).tracker(80, 3, true).egg(0xFFFFFF, 0x13232B).build(),
-            createBuilder("drowned").entity(EntityDrowned.class).tracker(80, 3, true).egg(0x86e2ca, 0x617d51).build(),
-            createBuilder("scuba_divers").entity(EntityScubaDivers.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
-            createBuilder("drowned_villager").entity(EntityDrownedVillager.class).tracker(80, 3, true).egg(0xC9CE92, 0x442f00).build(),
-            createBuilder("great_hunger").entity(EntityGreatHunger.class).tracker(80, 3, true).egg(0x876949, 0xce9252).build(),
-            createBuilder("cod").entity(EntityCod.class).tracker(30, 3, true).egg(0xb89e70, 0x786749).build(),
-            createBuilder("crow").entity(EntityAtmosCrow.class).tracker(30, 3, true).egg(0x2C2A2F, 0x353339).build(),
-            createBuilder("angler").entity(EntityAtmosAngler.class).tracker(30, 3, true).egg(0x636E36, 0x234A33).build(),
-            createBuilder("reef_manta").entity(EntityAtmosReefManta.class).tracker(30, 3, true).egg(0x0E0F21, 0xC5C5C5).build(),
-            createBuilder("whale").entity(EntityWhale.class).tracker(30, 3, true).egg(0x603D8A, 0x261839).build()
-        };
-        event.getRegistry().registerAll(entries);
-        RenderHandler.registerEntityRenders();
-        addSpawns();
-    }
-
-    @SubscribeEvent
-    public static void registerNewVillagerProffesions(RegistryEvent.Register<VillagerRegistry.VillagerProfession> event) {
-        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "miner").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/miner").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/miner").toString()));
-        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "scuba_diver").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/scuba_diver").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/scuba_diver").toString()));
-        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "explorer").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/explorer").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/explorer").toString()));
-        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "magician").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/magician").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/magician").toString()));
-        event.getRegistry().register(new VillagerRegistry.VillagerProfession(new ResourceLocation(MOD_ID, "guard").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/guard").toString(), new ResourceLocation(MOD_ID, "textures/entities/villagers/zombie/guard").toString()));
-    }
-
-    private static void addSpawns() {
-        EntityRegistry.addSpawn(EntityMummy.class, 10, 1, 3, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
-        EntityRegistry.addSpawn(EntityScorp.class, 9,2,8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
-        EntityRegistry.addSpawn(EntityDrowned.class, 9,2,8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.OCEAN));
-        EntityRegistry.addSpawn(EntityHoveringInferno.class, 9,2,8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.NETHER));
-        EntityRegistry.addSpawn(EntityGreatHunger.class, 9,2,8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.SANDY));
-        EntityRegistry.addSpawn(EntityTurtle.class, 9,2,8, EnumCreatureType.MONSTER, getBiomes(BiomeDictionary.Type.BEACH));
-    }
-
-    private static int entityID = 0;
-
-    private static <E extends Entity> EntityEntryBuilder<E> createBuilder(final String name) {
-        final EntityEntryBuilder<E> builder = EntityEntryBuilder.create();
-        final ResourceLocation registryName = new ResourceLocation(MOD_ID, name);
-        return builder.id(registryName, entityID++).name(registryName.toString());
-    }
-
-    private static Biome[] getBiomes(final BiomeDictionary.Type type) {
-        return BiomeDictionary.getBiomes(type).toArray(new Biome[0]);
-    }
-
-    //for use later...
-    private static void copySpawns(final Class<? extends EntityLiving> classToAdd, final EnumCreatureType creatureTypeToAdd, final Class<? extends EntityLiving> classToCopy, final EnumCreatureType creatureTypeToCopy) {
-        for (final Biome biome : ForgeRegistries.BIOMES) {
-            biome.getSpawnableList(creatureTypeToCopy).stream()
-                    .filter(entry -> entry.entityClass == classToCopy)
-                    .findFirst()
-                    .ifPresent(spawnListEntry ->
-                            biome.getSpawnableList(creatureTypeToAdd).add(new Biome.SpawnListEntry(classToAdd, spawnListEntry.itemWeight, spawnListEntry.minGroupCount, spawnListEntry.maxGroupCount))
-                    );
-        }
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenNetherBridge.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenNetherBridge.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenNetherBridge.java	(date 1525605768000)
@@ -1,122 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.structure;
-
-import com.google.common.collect.Lists;
-import net.minecraft.entity.monster.*;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.structure.MapGenStructure;
-import net.minecraft.world.gen.structure.StructureComponent;
-import net.minecraft.world.gen.structure.StructureStart;
-
-import java.util.List;
-import java.util.Random;
-
-public class MapGenNetherBridge extends MapGenStructure
-{
-    private final List<Biome.SpawnListEntry> spawnList = Lists.<Biome.SpawnListEntry>newArrayList();
-
-    public MapGenNetherBridge()
-    {
-        this.spawnList.add(new Biome.SpawnListEntry(EntityBlaze.class, 10, 2, 3));
-        this.spawnList.add(new Biome.SpawnListEntry(EntityPigZombie.class, 5, 4, 4));
-        this.spawnList.add(new Biome.SpawnListEntry(EntityWitherSkeleton.class, 8, 5, 5));
-        this.spawnList.add(new Biome.SpawnListEntry(EntitySkeleton.class, 2, 5, 5));
-        this.spawnList.add(new Biome.SpawnListEntry(EntityMagmaCube.class, 3, 4, 4));
-    }
-
-    public String getStructureName()
-    {
-        return "Fortress";
-    }
-
-    public List<Biome.SpawnListEntry> getSpawnList()
-    {
-        return this.spawnList;
-    }
-
-    protected boolean canSpawnStructureAtCoords(int chunkX, int chunkZ)
-    {
-        int i = chunkX >> 4;
-        int j = chunkZ >> 4;
-        this.rand.setSeed((long)(i ^ j << 4) ^ this.world.getSeed());
-        this.rand.nextInt();
-
-        if (this.rand.nextInt(3) != 0)
-        {
-            return false;
-        }
-        else if (chunkX != (i << 4) + 4 + this.rand.nextInt(8))
-        {
-            return false;
-        }
-        else
-        {
-            return chunkZ == (j << 4) + 4 + this.rand.nextInt(8);
-        }
-    }
-
-    protected StructureStart getStructureStart(int chunkX, int chunkZ)
-    {
-        return new MapGenNetherBridge.Start(this.world, this.rand, chunkX, chunkZ);
-    }
-
-    public BlockPos getNearestStructurePos(World worldIn, BlockPos pos, boolean findUnexplored)
-    {
-        int i = 1000;
-        int j = pos.getX() >> 4;
-        int k = pos.getZ() >> 4;
-
-        for (int l = 0; l <= 1000; ++l)
-        {
-            for (int i1 = -l; i1 <= l; ++i1)
-            {
-                boolean flag = i1 == -l || i1 == l;
-
-                for (int j1 = -l; j1 <= l; ++j1)
-                {
-                    boolean flag1 = j1 == -l || j1 == l;
-
-                    if (flag || flag1)
-                    {
-                        int k1 = j + i1;
-                        int l1 = k + j1;
-
-                        if (this.canSpawnStructureAtCoords(k1, l1) && (!findUnexplored || !worldIn.isChunkGeneratedAt(k1, l1)))
-                        {
-                            return new BlockPos((k1 << 4) + 8, 64, (l1 << 4) + 8);
-                        }
-                    }
-                }
-            }
-        }
-
-        return null;
-    }
-
-    public static class Start extends StructureStart
-        {
-            public Start()
-            {
-            }
-
-            public Start(World worldIn, Random random, int chunkX, int chunkZ)
-            {
-                super(chunkX, chunkZ);
-                StructureNetherBridgePieces.Start structurenetherbridgepieces$start = new StructureNetherBridgePieces.Start(random, (chunkX << 4) + 2, (chunkZ << 4) + 2);
-                this.components.add(structurenetherbridgepieces$start);
-                structurenetherbridgepieces$start.buildComponent(structurenetherbridgepieces$start, this.components, random);
-                List<StructureComponent> list = structurenetherbridgepieces$start.pendingChildren;
-
-                while (!list.isEmpty())
-                {
-                    int i = random.nextInt(list.size());
-                    StructureComponent structurecomponent = list.remove(i);
-                    structurecomponent.buildComponent(structurenetherbridgepieces$start, this.components, random);
-                }
-
-                this.updateBoundingBox();
-                this.setRandomHeight(worldIn, random, 48, 70);
-            }
-        }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/RenderUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/RenderUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/RenderUtil.java	(date 1525605768000)
@@ -1,440 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.renderer.BufferBuilder;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-
-public class RenderUtil
-{
-
-    public RenderUtil()
-    {
-    }
-
-    public static void renderBeam(BufferBuilder buf, double x1, double y1, double z1, double x2, double y2, double z2, float r1, float g1, 
-            float b1, float a1, float r2, float g2, float b2, float a2, double width)
-    {
-        float yaw = (float)Math.atan2(x2 - x1, z2 - z1);
-        float pitch = (float)Math.atan2(y2 - y1, MathHelper.sqrt(Math.pow(x2 - x1, 2D) + Math.pow(z2 - z1, 2D)));
-        double tX1 = width * (double)MathHelper.cos(yaw);
-        double tY1 = 0.0D;
-        double tZ1 = -width * (double)MathHelper.sin(yaw);
-        double tX2 = width * (double)MathHelper.sin(yaw) * -(double)MathHelper.sin(pitch);
-        double tY2 = width * (double)MathHelper.cos(pitch);
-        double tZ2 = width * (double)MathHelper.cos(yaw) * -(double)MathHelper.sin(pitch);
-        buf.pos(x1 - tX1, y1 - tY1, z1 - tZ1).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tX1, y2 - tY1, z2 - tZ1).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tX1, y2 + tY1, z2 + tZ1).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tX1, y1 + tY1, z1 + tZ1).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x1 - tX2, y1 - tY2, z1 - tZ2).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tX2, y2 - tY2, z2 - tZ2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tX2, y2 + tY2, z2 + tZ2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tX2, y1 + tY2, z1 + tZ2).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-    }
-
-    public static void renderBeam(BufferBuilder buf, double x1, double y1, double z1, double x2, double y2, double z2, float r1, float g1, 
-            float b1, float a1, float r2, float g2, float b2, float a2, double width1, double width2, double angle)
-    {
-        float rads = (float)Math.toRadians(angle);
-        double ac = MathHelper.cos(rads);
-        double as = MathHelper.sin(rads);
-        float yaw = (float)Math.atan2(x2 - x1, z2 - z1);
-        float pitch = (float)Math.atan2(y2 - y1, MathHelper.sqrt(Math.pow(x2 - x1, 2D) + Math.pow(z2 - z1, 2D)));
-        double tX1 = MathHelper.cos(yaw);
-        double tY1 = 0.0D;
-        double tZ1 = -(double)MathHelper.sin(yaw);
-        double tX2 = (double)MathHelper.sin(yaw) * -(double)MathHelper.sin(pitch);
-        double tY2 = MathHelper.cos(pitch);
-        double tZ2 = (double)MathHelper.cos(yaw) * -(double)MathHelper.sin(pitch);
-        double tXc1 = width1 * (tX1 * ac + tX2 * as);
-        double tYc1 = width1 * (tY1 * ac + tY2 * as);
-        double tZc1 = width1 * (tZ1 * ac + tZ2 * as);
-        double tXs1 = width1 * (tX1 * -as + tX2 * ac);
-        double tYs1 = width1 * (tY1 * -as + tY2 * ac);
-        double tZs1 = width1 * (tZ1 * -as + tZ2 * ac);
-        double tXc2 = width2 * (tX1 * ac + tX2 * as);
-        double tYc2 = width2 * (tY1 * ac + tY2 * as);
-        double tZc2 = width2 * (tZ1 * ac + tZ2 * as);
-        double tXs2 = width2 * (tX1 * -as + tX2 * ac);
-        double tYs2 = width2 * (tY1 * -as + tY2 * ac);
-        double tZs2 = width2 * (tZ1 * -as + tZ2 * ac);
-        buf.pos(x1 - tXs1, y1 - tYs1, z1 - tZs1).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tXs2, y2 - tYs2, z2 - tZs2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tXs2, y2 + tYs2, z2 + tZs2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tXs1, y1 + tYs1, z1 + tZs1).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x1 - tXc1, y1 - tYc1, z1 - tZc1).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tXc2, y2 - tYc2, z2 - tZc2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tXc2, y2 + tYc2, z2 + tZc2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tXc1, y1 + tYc1, z1 + tZc1).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-    }
-
-    public static void renderBeam(BufferBuilder buf, double x1, double y1, double z1, double x2, double y2, double z2, float r1, float g1, 
-            float b1, float a1, float r2, float g2, float b2, float a2, double width, double angle)
-    {
-        float rads = (float)Math.toRadians(angle);
-        double ac = MathHelper.cos(rads);
-        double as = MathHelper.sin(rads);
-        float yaw = (float)Math.atan2(x2 - x1, z2 - z1);
-        float pitch = (float)Math.atan2(y2 - y1, MathHelper.sqrt(Math.pow(x2 - x1, 2D) + Math.pow(z2 - z1, 2D)));
-        double tX1 = width * (double)MathHelper.cos(yaw);
-        double tY1 = 0.0D;
-        double tZ1 = -width * (double)MathHelper.sin(yaw);
-        double tX2 = width * (double)MathHelper.sin(yaw) * -(double)MathHelper.sin(pitch);
-        double tY2 = width * (double)MathHelper.cos(pitch);
-        double tZ2 = width * (double)MathHelper.cos(yaw) * -(double)MathHelper.sin(pitch);
-        double tXc = tX1 * ac + tX2 * as;
-        double tYc = tY1 * ac + tY2 * as;
-        double tZc = tZ1 * ac + tZ2 * as;
-        double tXs = tX1 * -as + tX2 * ac;
-        double tYs = tY1 * -as + tY2 * ac;
-        double tZs = tZ1 * -as + tZ2 * ac;
-        buf.pos(x1 - tXs, y1 - tYs, z1 - tZs).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tXs, y2 - tYs, z2 - tZs).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tXs, y2 + tYs, z2 + tZs).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tXs, y1 + tYs, z1 + tZs).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x1 - tXc, y1 - tYc, z1 - tZc).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tXc, y2 - tYc, z2 - tZc).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tXc, y2 + tYc, z2 + tZc).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tXc, y1 + tYc, z1 + tZc).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-    }
-
-    public static void renderBeamGui(BufferBuilder buf, double x1, double y1, double x2, double y2, float r1, float g1, float b1, float a1, float r2, float g2, 
-            float b2, float a2, double width)
-    {
-        float yaw = (float)Math.atan2(y2 - y1, x2 - x1);
-        double tX1 = -width * (double)MathHelper.sin(yaw);
-        double tY1 = width * (double)MathHelper.cos(yaw);
-        buf.pos(x1 - tX1, y1 - tY1, 0.0D).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x2 - tX1, y2 - tY1, 0.0D).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x2 + tX1, y2 + tY1, 0.0D).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        buf.pos(x1 + tX1, y1 + tY1, 0.0D).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-    }
-
-    public static void renderBeamSeriesGui(BufferBuilder buf, double x1, double y1, double x2, double y2, float r1, float g1, float b1, float a1, double width, 
-            boolean horiz)
-    {
-        float yaw2 = (float)Math.atan2(y2 - y1, x2 - x1);
-        double tX1 = width * (double)MathHelper.cos(yaw2);
-        double tY1 = -width * (double)MathHelper.sin(yaw2);
-        buf.pos(x1 - tX1, y1 - tY1, 0.0D).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        buf.pos(x1 + tX1, y1 + tY1, 0.0D).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-    }
-
-    public static void renderBeamSeries(BufferBuilder buf, double x1, double y1, double z1, double x2, double y2, double z2, float r1, float g1, 
-            float b1, float a1, double width, boolean horiz)
-    {
-        float yaw2 = (float)Math.atan2(x2 - x1, z2 - z1);
-        float pitch2 = (float)Math.atan2(y2 - y1, MathHelper.sqrt(Math.pow(x2 - x1, 2D) + Math.pow(z2 - z1, 2D)));
-        double tX1 = width * (double)MathHelper.cos(yaw2);
-        double tY1 = 0.0D;
-        double tZ1 = -width * (double)MathHelper.sin(yaw2);
-        double tX2 = width * (double)MathHelper.sin(yaw2) * -(double)MathHelper.sin(pitch2);
-        double tY2 = width * (double)MathHelper.cos(pitch2);
-        double tZ2 = width * (double)MathHelper.cos(yaw2) * -(double)MathHelper.sin(pitch2);
-        if(horiz)
-        {
-            buf.pos(x1 - tX1, y1 - tY1, z1 - tZ1).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x1 + tX1, y1 + tY1, z1 + tZ1).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        } else
-        {
-            buf.pos(x1 - tX2, y1 - tY2, z1 - tZ2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x1 + tX2, y1 + tY2, z1 + tZ2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        }
-    }
-
-    public static void renderSlash(BufferBuilder buf, double x0, double y0, double z0, float r, 
-            float g, float b, float a, float radius, float width, float angleRange)
-    {
-        for(float i = -angleRange / 2.0F; i < angleRange / 2.0F; i += angleRange / 16F)
-        {
-            float coeff1 = 1.0F - Math.abs(i) / (angleRange / 2.0F);
-            float coeff2 = 1.0F - Math.abs(i + angleRange / 16F) / (angleRange / 2.0F);
-            double x1 = x0 + (double)radius * Math.sin(Math.toRadians(i));
-            double z1 = z0 + (double)radius * Math.cos(Math.toRadians(i));
-            double x2 = x0 + (double)(radius + 0.5F * coeff1 * width) * Math.sin(Math.toRadians(i));
-            double z2 = z0 + (double)(radius + 0.5F * coeff1 * width) * Math.cos(Math.toRadians(i));
-            double x3 = x0 + (double)(radius + 0.5F * coeff2 * width) * Math.sin(Math.toRadians(i + angleRange / 16F));
-            double z3 = z0 + (double)(radius + 0.5F * coeff2 * width) * Math.cos(Math.toRadians(i + angleRange / 16F));
-            double x4 = x0 + (double)radius * Math.sin(Math.toRadians(i + angleRange / 16F));
-            double z4 = z0 + (double)radius * Math.cos(Math.toRadians(i + angleRange / 16F));
-            buf.pos(x1, y0, z1 - (double)(radius / 2.0F)).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x2, y0, z2 - (double)(radius / 2.0F)).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x3, y0, z3 - (double)(radius / 2.0F)).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x4, y0, z4 - (double)(radius / 2.0F)).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            x1 = x0 + (double)radius * Math.sin(Math.toRadians(i));
-            z1 = z0 + (double)radius * Math.cos(Math.toRadians(i));
-            x2 = x0 + (double)(radius - 0.5F * coeff1 * width) * Math.sin(Math.toRadians(i));
-            z2 = z0 + (double)(radius - 0.5F * coeff1 * width) * Math.cos(Math.toRadians(i));
-            x3 = x0 + (double)(radius - 0.5F * coeff2 * width) * Math.sin(Math.toRadians(i + angleRange / 16F));
-            z3 = z0 + (double)(radius - 0.5F * coeff2 * width) * Math.cos(Math.toRadians(i + angleRange / 16F));
-            x4 = x0 + (double)radius * Math.sin(Math.toRadians(i + angleRange / 16F));
-            z4 = z0 + (double)radius * Math.cos(Math.toRadians(i + angleRange / 16F));
-            buf.pos(x1, y0, z1 - (double)(radius / 2.0F)).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x2, y0, z2 - (double)(radius / 2.0F)).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x3, y0, z3 - (double)(radius / 2.0F)).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x4, y0, z4 - (double)(radius / 2.0F)).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x1, y0, z1 - (double)(radius / 2.0F)).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x2, y0, z2 - (double)(radius / 2.0F)).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x3, y0, z3 - (double)(radius / 2.0F)).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x4, y0, z4 - (double)(radius / 2.0F)).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            x1 = x0 + (double)radius * Math.sin(Math.toRadians(i));
-            z1 = z0 + (double)radius * Math.cos(Math.toRadians(i));
-            x2 = x0 + (double)radius * Math.sin(Math.toRadians(i));
-            z2 = z0 + (double)radius * Math.cos(Math.toRadians(i));
-            x3 = x0 + (double)radius * Math.sin(Math.toRadians(i + angleRange / 16F));
-            z3 = z0 + (double)radius * Math.cos(Math.toRadians(i + angleRange / 16F));
-            x4 = x0 + (double)radius * Math.sin(Math.toRadians(i + angleRange / 16F));
-            z4 = z0 + (double)radius * Math.cos(Math.toRadians(i + angleRange / 16F));
-            buf.pos(x1, y0, z1 - (double)(radius / 2.0F)).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x2, y0 - (double)(width * 0.5F * coeff1), z2 - (double)(radius / 2.0F)).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x3, y0 - (double)(width * 0.5F * coeff2), z3 - (double)(radius / 2.0F)).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x4, y0, z4 - (double)(radius / 2.0F)).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x1, y0, z1 - (double)(radius / 2.0F)).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x2, y0 + (double)(width * 0.5F * coeff1), z2 - (double)(radius / 2.0F)).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff1).endVertex();
-            buf.pos(x3, y0 + (double)(width * 0.5F * coeff2), z3 - (double)(radius / 2.0F)).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-            buf.pos(x4, y0, z4 - (double)(radius / 2.0F)).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r, g, b, a * coeff2).endVertex();
-        }
-
-    }
-
-    public static void renderBeamSeries(BufferBuilder buf, double x0, double y0, double z0, double x1, double y1, double z1, double x2, 
-            double y2, double z2, float r1, float g1, float b1, 
-            float a1, float r2, float g2, float b2, float a2)
-    {
-        float yaw1 = (float)Math.atan2(x1 - x0, z1 - z0);
-        float pitch1 = (float)Math.atan2(y1 - y0, MathHelper.sqrt(Math.pow(x1 - x0, 2D) + Math.pow(z1 - z0, 2D)));
-        float yaw2 = (float)Math.atan2(x2 - x1, z2 - z1);
-        float pitch2 = (float)Math.atan2(y2 - y1, MathHelper.sqrt(Math.pow(x2 - x1, 2D) + Math.pow(z2 - z1, 2D)));
-        double iX1 = 0.20000000000000001D * (double)MathHelper.cos(yaw1);
-        double iY1 = 0.0D;
-        double iZ1 = -0.20000000000000001D * (double)MathHelper.sin(yaw1);
-        double iX2 = 0.20000000000000001D * (double)MathHelper.sin(yaw1) * -(double)MathHelper.sin(pitch1);
-        double iY2 = 0.20000000000000001D * (double)MathHelper.cos(pitch1);
-        double iZ2 = 0.20000000000000001D * (double)MathHelper.cos(yaw1) * -(double)MathHelper.sin(pitch1);
-        double tX1 = 0.20000000000000001D * (double)MathHelper.cos(yaw2);
-        double tY1 = 0.0D;
-        double tZ1 = -0.20000000000000001D * (double)MathHelper.sin(yaw2);
-        double tX2 = 0.20000000000000001D * (double)MathHelper.sin(yaw2) * -(double)MathHelper.sin(pitch2);
-        double tY2 = 0.20000000000000001D * (double)MathHelper.cos(pitch2);
-        double tZ2 = 0.20000000000000001D * (double)MathHelper.cos(yaw2) * -(double)MathHelper.sin(pitch2);
-        if(Math.signum(tX1) != Math.signum(iX1) || Math.signum(tY1) != Math.signum(iY1) || Math.signum(tZ1) != Math.signum(iZ1))
-        {
-            buf.pos(x2 - tX1, y2 - tY1, z2 - tZ1).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x1 + iX1, y1 + iY1, z1 + iZ1).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x1 - iX1, y1 - iY1, z1 - iZ1).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x2 + tX1, y2 + tY1, z2 + tZ1).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        } else
-        {
-            buf.pos(x1 - iX1, y1 - iY1, z1 - iZ1).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x2 - tX1, y2 - tY1, z2 - tZ1).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x2 + tX1, y2 + tY1, z2 + tZ1).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x1 + iX1, y1 + iY1, z1 + iZ1).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        }
-        if(Math.signum(tX2) != Math.signum(iX2) || Math.signum(tY2) != Math.signum(iY2) || Math.signum(tZ2) != Math.signum(iZ2))
-        {
-            buf.pos(x2 - tX2, y2 - tY2, z2 - tZ2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x1 + iX2, y1 + iY2, z1 + iZ2).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x1 - iX2, y1 - iY2, z1 - iZ2).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x2 + tX2, y2 + tY2, z2 + tZ2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-        } else
-        {
-            buf.pos(x1 - iX2, y1 - iY2, z1 - iZ2).tex(0.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-            buf.pos(x2 - tX2, y2 - tY2, z2 - tZ2).tex(1.0D, 0.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x2 + tX2, y2 + tY2, z2 + tZ2).tex(1.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r2, g2, b2, a2).endVertex();
-            buf.pos(x1 + iX2, y1 + iY2, z1 + iZ2).tex(0.0D, 1.0D).lightmap(maxLightX, maxLightY).color(r1, g1, b1, a1).endVertex();
-        }
-    }
-
-    public static void drawTextRGBA(FontRenderer font, String s, int x, int y, int r, int g, int b, int a)
-    {
-        font.drawString(s, x, y, (a << 24) + (r << 16) + (g << 8) + b);
-    }
-
-    public static void renderStarBurst(BufferBuilder buf, double x, double y, double z, float r, 
-            float g, float b, float a, double width, double radius)
-    {
-        for(double i = -1.5707963267948966D; i <= 1.5707963267948966D; i += 0.39269908169872414D)
-        {
-            for(double j = 0.0D; j < 6.2831853071795862D; j += 3.1415926535897931D * (0.75D * Math.abs(i / 1.5707963267948966D) + 0.25D))
-            {
-                double si = (double)((float)80F) * (0.375D + (0.77300000000000002D * j) / 6.2831853071795862D) * (0.25D + (1.2250000000000001D * i) / 3.1415926535897931D) * 3.1415926535897931D * 2D;
-                double sj = (double)((float)57F) * (0.25D + (1.6299999999999999D * i) / 1.5707963267948966D) * (0.375D + (0.24099999999999999D * j) / 3.1415926535897931D) * 3.1415926535897931D * 2D;
-                double dx = radius * Math.sin(sj) * Math.cos(si);
-                double dy = radius * Math.sin(si);
-                double dz = radius * Math.cos(sj) * Math.cos(si);
-                renderBeam(buf, x + dx * 0.25D, y + dy * 0.25D, z + dz * 0.25D, x + dx * 0.375D, y + dy * 0.375D, z + dz * 0.375D, r, g, b, 0.0F, r, g, b, a, width);
-                renderBeam(buf, x + dx * 0.375D, y + dy * 0.375D, z + dz * 0.375D, x + dx, y + dy, z + dz, r, g, b, a, r, g, b, 0.0F, width);
-            }
-
-        }
-
-    }
-
-    public static void renderBeamCircle(BufferBuilder buf, double x, double y, double z, float r, 
-            float g, float b, float a, double width, double radius, 
-            int steps, boolean horiz)
-    {
-        for(double i = 0.0D; i <= 6.2831853071795862D; i += 3.1415926535897931D * (2D / (double)steps))
-        {
-            double x1 = x + Math.sin(i) * radius;
-            double z1 = z + Math.cos(i) * radius;
-            double x2 = x + Math.sin(i + 3.1415926535897931D * (2D / (double)steps)) * radius;
-            double z2 = z + Math.cos(i + 3.1415926535897931D * (2D / (double)steps)) * radius;
-            renderBeamSeries(buf, x1, y, z1, x2, y, z2, r, g, b, a, width, horiz);
-        }
-
-    }
-
-    public static void drawCrystal(BufferBuilder buf, float x, float y, float z, float r, float g, float b, float a, 
-            float rotation, float hsize, float ysize, float minU, float minV, float maxU, float maxV)
-    {
-        float offX1 = hsize * 0.5F * (float)Math.sin(Math.toRadians(rotation));
-        float offZ1 = hsize * 0.5F * (float)Math.cos(Math.toRadians(rotation));
-        float offX2 = hsize * 0.5F * (float)Math.sin(Math.toRadians(rotation + 90F));
-        float offZ2 = hsize * 0.5F * (float)Math.cos(Math.toRadians(rotation + 90F));
-        float pos1X = x;
-        double pos1Y = y - ysize * 0.5F;
-        double pos1Z = z;
-        double pos2X = x + offX1;
-        double pos2Y = y;
-        double pos2Z = z + offZ1;
-        double pos3X = x + offX2;
-        double pos3Y = y;
-        double pos3Z = z + offZ2;
-        double pos4X = x - offX1;
-        double pos4Y = y;
-        double pos4Z = z - offZ1;
-        double pos5X = x - offX2;
-        double pos5Y = y;
-        double pos5Z = z - offZ2;
-        double pos6X = x;
-        double pos6Y = y + ysize * 0.5F;
-        double pos6Z = z;
-        Vec3d diff1 = new Vec3d(pos3X - (double)pos1X, pos3Y - pos1Y, pos3Z - pos1Z);
-        Vec3d diff2 = new Vec3d(pos2X - (double)pos1X, pos2Y - pos1Y, pos2Z - pos1Z);
-        Vec3d normal1 = (new Vec3d(diff1.y * diff2.z - diff1.z * diff2.y, diff1.x * diff2.z - diff1.z * diff2.x, diff1.x * diff2.y - diff1.y * diff2.x)).normalize().scale(-1D);
-        Vec3d normal2 = (new Vec3d(normal1.z, -normal1.y, normal1.x)).scale(-1D);
-        Vec3d normal3 = (new Vec3d(-normal1.x, -normal1.y, -normal1.z)).scale(-1D);
-        Vec3d normal4 = (new Vec3d(-normal1.z, -normal1.y, -normal1.x)).scale(-1D);
-        Vec3d normal5 = (new Vec3d(normal1.x, normal1.y, normal1.z)).scale(-1D);
-        Vec3d normal6 = (new Vec3d(normal1.z, normal1.y, normal1.x)).scale(-1D);
-        Vec3d normal7 = (new Vec3d(-normal1.x, normal1.y, -normal1.z)).scale(-1D);
-        Vec3d normal8 = (new Vec3d(-normal1.z, normal1.y, -normal1.x)).scale(-1D);
-        normal1 = (new Vec3d(normal1.x, -normal1.y, normal1.z)).scale(-1D);
-        buf.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(r, g, b, a).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        buf.pos(pos2X, pos2Y, pos2Z).tex(minU, minV).color(r, g, b, a).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        buf.pos(pos3X, pos3Y, pos3Z).tex(maxU, minV).color(r, g, b, a).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        buf.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(r, g, b, a).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        buf.pos(pos3X, pos3Y, pos3Z).tex(minU, minV).color(r, g, b, a).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        buf.pos(pos4X, pos4Y, pos4Z).tex(maxU, minV).color(r, g, b, a).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        buf.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(r, g, b, a).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        buf.pos(pos4X, pos4Y, pos4Z).tex(minU, minV).color(r, g, b, a).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        buf.pos(pos5X, pos5Y, pos5Z).tex(maxU, minV).color(r, g, b, a).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        buf.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(r, g, b, a).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        buf.pos(pos5X, pos5Y, pos5Z).tex(minU, minV).color(r, g, b, a).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        buf.pos(pos2X, pos2Y, pos2Z).tex(maxU, minV).color(r, g, b, a).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        buf.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(r, g, b, a).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        buf.pos(pos2X, pos2Y, pos2Z).tex(minU, maxV).color(r, g, b, a).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        buf.pos(pos3X, pos3Y, pos3Z).tex(maxU, maxV).color(r, g, b, a).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        buf.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(r, g, b, a).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        buf.pos(pos3X, pos3Y, pos3Z).tex(minU, maxV).color(r, g, b, a).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        buf.pos(pos4X, pos4Y, pos4Z).tex(maxU, maxV).color(r, g, b, a).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        buf.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(r, g, b, a).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        buf.pos(pos4X, pos4Y, pos4Z).tex(minU, maxV).color(r, g, b, a).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        buf.pos(pos5X, pos5Y, pos5Z).tex(maxU, maxV).color(r, g, b, a).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        buf.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(r, g, b, a).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-        buf.pos(pos5X, pos5Y, pos5Z).tex(minU, maxV).color(r, g, b, a).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-        buf.pos(pos2X, pos2Y, pos2Z).tex(maxU, maxV).color(r, g, b, a).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-    }
-
-    public static void drawCrystal(BufferBuilder b, float x, float y, float z, float rotation, float hsize, float ysize, float minU, 
-            float minV, float maxU, float maxV)
-    {
-        float offX1 = hsize * 0.5F * (float)Math.sin(Math.toRadians(rotation));
-        float offZ1 = hsize * 0.5F * (float)Math.cos(Math.toRadians(rotation));
-        float offX2 = hsize * 0.5F * (float)Math.sin(Math.toRadians(rotation + 90F));
-        float offZ2 = hsize * 0.5F * (float)Math.cos(Math.toRadians(rotation + 90F));
-        float pos1X = x;
-        double pos1Y = y - ysize * 0.5F;
-        double pos1Z = z;
-        double pos2X = x + offX1;
-        double pos2Y = y;
-        double pos2Z = z + offZ1;
-        double pos3X = x + offX2;
-        double pos3Y = y;
-        double pos3Z = z + offZ2;
-        double pos4X = x - offX1;
-        double pos4Y = y;
-        double pos4Z = z - offZ1;
-        double pos5X = x - offX2;
-        double pos5Y = y;
-        double pos5Z = z - offZ2;
-        double pos6X = x;
-        double pos6Y = y + ysize * 0.5F;
-        double pos6Z = z;
-        Vec3d diff1 = new Vec3d(pos3X - (double)pos1X, pos3Y - pos1Y, pos3Z - pos1Z);
-        Vec3d diff2 = new Vec3d(pos2X - (double)pos1X, pos2Y - pos1Y, pos2Z - pos1Z);
-        Vec3d normal1 = (new Vec3d(diff1.y * diff2.z - diff1.z * diff2.y, diff1.x * diff2.z - diff1.z * diff2.x, diff1.x * diff2.y - diff1.y * diff2.x)).normalize().scale(-1D);
-        Vec3d normal2 = (new Vec3d(normal1.z, -normal1.y, normal1.x)).scale(-1D);
-        Vec3d normal3 = (new Vec3d(-normal1.x, -normal1.y, -normal1.z)).scale(-1D);
-        Vec3d normal4 = (new Vec3d(-normal1.z, -normal1.y, -normal1.x)).scale(-1D);
-        Vec3d normal5 = (new Vec3d(normal1.x, normal1.y, normal1.z)).scale(-1D);
-        Vec3d normal6 = (new Vec3d(normal1.z, normal1.y, normal1.x)).scale(-1D);
-        Vec3d normal7 = (new Vec3d(-normal1.x, normal1.y, -normal1.z)).scale(-1D);
-        Vec3d normal8 = (new Vec3d(-normal1.z, normal1.y, -normal1.x)).scale(-1D);
-        normal1 = (new Vec3d(normal1.x, -normal1.y, normal1.z)).scale(-1D);
-        b.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(255, 255, 255, 255).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        b.pos(pos2X, pos2Y, pos2Z).tex(minU, minV).color(255, 255, 255, 255).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        b.pos(pos3X, pos3Y, pos3Z).tex(maxU, minV).color(255, 255, 255, 255).normal((float)normal1.x, (float)normal1.y, (float)normal1.z).endVertex();
-        b.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(255, 255, 255, 255).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        b.pos(pos3X, pos3Y, pos3Z).tex(minU, minV).color(255, 255, 255, 255).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        b.pos(pos4X, pos4Y, pos4Z).tex(maxU, minV).color(255, 255, 255, 255).normal((float)normal2.x, (float)normal2.y, (float)normal2.z).endVertex();
-        b.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(255, 255, 255, 255).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        b.pos(pos4X, pos4Y, pos4Z).tex(minU, minV).color(255, 255, 255, 255).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        b.pos(pos5X, pos5Y, pos5Z).tex(maxU, minV).color(255, 255, 255, 255).normal((float)normal3.x, (float)normal3.y, (float)normal3.z).endVertex();
-        b.pos(pos1X, pos1Y, pos1Z).tex((double)(minU + maxU) / 2D, maxV).color(255, 255, 255, 255).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        b.pos(pos5X, pos5Y, pos5Z).tex(minU, minV).color(255, 255, 255, 255).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        b.pos(pos2X, pos2Y, pos2Z).tex(maxU, minV).color(255, 255, 255, 255).normal((float)normal4.x, (float)normal4.y, (float)normal4.z).endVertex();
-        b.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(255, 255, 255, 255).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        b.pos(pos2X, pos2Y, pos2Z).tex(minU, maxV).color(255, 255, 255, 255).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        b.pos(pos3X, pos3Y, pos3Z).tex(maxU, maxV).color(255, 255, 255, 255).normal((float)normal5.x, (float)normal5.y, (float)normal5.z).endVertex();
-        b.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(255, 255, 255, 255).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        b.pos(pos3X, pos3Y, pos3Z).tex(minU, maxV).color(255, 255, 255, 255).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        b.pos(pos4X, pos4Y, pos4Z).tex(maxU, maxV).color(255, 255, 255, 255).normal((float)normal6.x, (float)normal6.y, (float)normal6.z).endVertex();
-        b.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(255, 255, 255, 255).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        b.pos(pos4X, pos4Y, pos4Z).tex(minU, maxV).color(255, 255, 255, 255).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        b.pos(pos5X, pos5Y, pos5Z).tex(maxU, maxV).color(255, 255, 255, 255).normal((float)normal7.x, (float)normal7.y, (float)normal7.z).endVertex();
-        b.pos(pos6X, pos6Y, pos6Z).tex((double)(minU + maxU) / 2D, minV).color(255, 255, 255, 255).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-        b.pos(pos5X, pos5Y, pos5Z).tex(minU, maxV).color(255, 255, 255, 255).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-        b.pos(pos2X, pos2Y, pos2Z).tex(maxU, maxV).color(255, 255, 255, 255).normal((float)normal8.x, (float)normal8.y, (float)normal8.z).endVertex();
-    }
-
-    public static void setTransform(ItemCameraTransforms.TransformType t)
-    {
-        itemTransformType = t;
-    }
-
-    public static void setTransformGUI()
-    {
-        itemTransformType = ItemCameraTransforms.TransformType.GUI;
-    }
-
-    public static ResourceLocation beam_texture = new ResourceLocation("elulib:textures/effect/beam.png");
-    public static ResourceLocation glow_texture = new ResourceLocation("elulib:textures/effect/glow.png");
-    public static int maxLightX = 0xf000f0;
-    public static int maxLightY = 0xf000f0;
-    public static ItemCameraTransforms.TransformType itemTransformType;
-
-    static 
-    {
-        itemTransformType = ItemCameraTransforms.TransformType.NONE;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltOverworld.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltOverworld.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltOverworld.java	(date 1525605768000)
@@ -1,35 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.block.Block;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.biome.BiomeHellDecorator;
-
-import java.awt.*;
-import java.util.Objects;
-import java.util.Random;
-
-public class BiomeBasaltOverworld extends Biome {
-
-    public BiomeBasaltOverworld() {
-        super(new BiomeProperties("Basalt").setBaseHeight(1.0F).setHeightVariation(0.3F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled().setWaterColor(Color.GREEN.getRGB()));
-
-        topBlock = Objects.requireNonNull(Block.getBlockFromName("hmca:raw_basalt")).getDefaultState();
-        fillerBlock = Objects.requireNonNull(Block.getBlockFromName("hmca:raw_basalt")).getDefaultState();
-
-        this.spawnableCaveCreatureList.clear();
-        this.spawnableCreatureList.clear();
-
-        this.spawnableMonsterList.clear();
-        this.spawnableWaterCreatureList.clear();
-
-        this.decorator = new BiomeHellDecorator();
-
-    }
-
-    public void decorate(World worldIn, Random rand, BlockPos pos) {
-
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureScattered.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureScattered.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureScattered.java	(date 1525605768000)
@@ -1,64 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import net.minecraft.block.BlockBush;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public class FeatureScattered extends Feature
-{
-    private final IBlockState blockToSpawn;
-    private final IBlockState targetBlock;
-
-    public FeatureScattered(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        blockToSpawn = BlockUtil.getBlock(feature.getBlockToSpawn(), "minecraft:air");
-        targetBlock = BlockUtil.getBlock(feature.getTargetBlock(), "minecraft:air");
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        for(int i = 0; i < 64; ++i)
-        {
-            BlockPos newPos = pos.add(rand.nextInt(8) - rand.nextInt(8), rand.nextInt(4) - rand.nextInt(4), rand.nextInt(8) - rand.nextInt(8));
-
-            if(world.isAirBlock(newPos) && world.getBlockState(newPos.down()) == targetBlock)
-            {
-                if(blockToSpawn instanceof BlockBush)
-                {
-                    if(((BlockBush) blockToSpawn).canBlockStay(world, newPos, ((BlockBush) blockToSpawn).getDefaultState()))
-                    {
-                        world.setBlockState(newPos, blockToSpawn, 2);
-                    }
-                }
-                else
-                {
-                    world.setBlockState(newPos, blockToSpawn, 2);
-                }
-            }
-        }
-
-        return true;
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return !(blockToSpawn == Blocks.AIR.getDefaultState() || targetBlock == Blocks.AIR.getDefaultState());
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.SCATTERED;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherBase.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.nether;
-
-import net.minecraft.block.material.Material;
-import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockNetherBase extends BlockMod {
-
-    public BlockNetherBase(Material material, String name) {
-        super(material, MOD_ID, name);
-        setCreativeTab(Main.NETHER_EXPANSION_TAB);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummy.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummy.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummy.java	(date 1525605768000)
@@ -1,27 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.model.ModelZombie;
-import net.minecraft.client.renderer.entity.RenderBiped;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummy;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@SideOnly(Side.CLIENT)
-public class RenderMummy extends RenderBiped<EntityMummy> {
-
-    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation(MOD_ID,"textures/entity/mummy/mummy.png");
-
-    public RenderMummy(RenderManager rendermanagerIn) {
-        super(rendermanagerIn, new ModelZombie(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityMummy entity) {
-        return MUMMY_TEXTURE;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenMineshaft.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenMineshaft.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/MapGenMineshaft.java	(date 1525605768000)
@@ -1,95 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.structure;
-
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.biome.BiomeMesa;
-import net.minecraft.world.gen.structure.MapGenStructure;
-import net.minecraft.world.gen.structure.StructureStart;
-
-import java.util.Map;
-import java.util.Map.Entry;
-
-public class MapGenMineshaft extends MapGenStructure
-{
-    private double chance = 0.004D;
-
-    public MapGenMineshaft()
-    {
-    }
-
-    public String getStructureName()
-    {
-        return "NewDungeon";
-    }
-
-    public MapGenMineshaft(Map<String, String> p_i2034_1_)
-    {
-        for (Entry<String, String> entry : p_i2034_1_.entrySet())
-        {
-            if (entry.getKey().equals("chance"))
-            {
-                this.chance = MathHelper.getDouble(entry.getValue(), this.chance);
-            }
-        }
-    }
-
-    protected boolean canSpawnStructureAtCoords(int chunkX, int chunkZ)
-    {
-        return this.rand.nextDouble() < this.chance && this.rand.nextInt(80) < Math.max(Math.abs(chunkX), Math.abs(chunkZ));
-    }
-
-    public BlockPos getNearestStructurePos(World worldIn, BlockPos pos, boolean findUnexplored)
-    {
-        int i = 1000;
-        int j = pos.getX() >> 4;
-        int k = pos.getZ() >> 4;
-
-        for (int l = 0; l <= 1000; ++l)
-        {
-            for (int i1 = -l; i1 <= l; ++i1)
-            {
-                boolean flag = i1 == -l || i1 == l;
-
-                for (int j1 = -l; j1 <= l; ++j1)
-                {
-                    boolean flag1 = j1 == -l || j1 == l;
-
-                    if (flag || flag1)
-                    {
-                        int k1 = j + i1;
-                        int l1 = k + j1;
-                        this.rand.setSeed((long)(k1 ^ l1) ^ worldIn.getSeed());
-                        this.rand.nextInt();
-
-                        if (this.canSpawnStructureAtCoords(k1, l1) && (!findUnexplored || !worldIn.isChunkGeneratedAt(k1, l1)))
-                        {
-                            return new BlockPos((k1 << 4) + 8, 64, (l1 << 4) + 8);
-                        }
-                    }
-                }
-            }
-        }
-
-        return null;
-    }
-
-    protected StructureStart getStructureStart(int chunkX, int chunkZ)
-    {
-        Biome biome = this.world.getBiome(new BlockPos((chunkX << 4) + 8, 64, (chunkZ << 4) + 8));
-        MapGenMineshaft.Type mapgenmineshaft$type = biome instanceof BiomeMesa ? MapGenMineshaft.Type.MESA : MapGenMineshaft.Type.NORMAL;
-        return new StructureMineshaftStart(this.world, this.rand, chunkX, chunkZ, mapgenmineshaft$type);
-    }
-
-    public static enum Type
-    {
-        NORMAL,
-        MESA;
-
-        public static MapGenMineshaft.Type byId(int id)
-        {
-            return id >= 0 && id < values().length ? values()[id] : NORMAL;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationNode.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationNode.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationNode.java	(date 1525605768000)
@@ -1,97 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   GenerationNode.java
-
-package net.thegaminghuskymc.mcaddon.world;
-
-import java.util.Map;
-
-import elucent.elulib.world.IGeneratable;
-import elucent.elulib.world.StructureRegistry;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTUtil;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-
-// Referenced classes of package elucent.elulib.world:
-//            StructureRegistry, IGeneratable
-
-public class GenerationNode
-{
-
-    public GenerationNode(NBTTagCompound tag)
-    {
-        structure = "";
-        rotation = Rotation.NONE;
-        mirror = Mirror.NONE;
-        pos = new BlockPos(-1, -1, -1);
-        replaceWithAir = false;
-        isAlive = true;
-        readFromNBT(tag);
-    }
-
-    public GenerationNode(BlockPos pos, String structure, Rotation rotation, Mirror mirror, boolean replaceWithAir)
-    {
-        this.structure = "";
-        this.rotation = Rotation.NONE;
-        this.mirror = Mirror.NONE;
-        this.pos = new BlockPos(-1, -1, -1);
-        this.replaceWithAir = false;
-        isAlive = true;
-        this.pos = pos;
-        this.structure = structure;
-        this.rotation = rotation;
-        this.mirror = mirror;
-        this.replaceWithAir = replaceWithAir;
-    }
-
-    public void update(World world)
-    {
-        if(structure.length() > 0)
-        {
-            elucent.elulib.world.IGeneratable data = (IGeneratable)StructureRegistry.structures.get(structure);
-            if(data != null)
-            {
-                data.calcDimensions();
-                if(world.isAreaLoaded(new BlockPos(pos.getX() - 8, pos.getY(), pos.getZ() - 8), new BlockPos(pos.getX() + data.getWidth() + 8, pos.getY(), pos.getZ() + data.getLength() + 8)))
-                {
-                    data.generateIn(world, pos.getX(), pos.getY(), pos.getZ(), rotation, mirror, replaceWithAir);
-                    isAlive = false;
-                }
-            } else
-            {
-                isAlive = false;
-            }
-        }
-    }
-
-    protected void readFromNBT(NBTTagCompound compound)
-    {
-        structure = compound.getString("structure");
-        rotation = Rotation.values()[compound.getInteger("rotation")];
-        mirror = Mirror.values()[compound.getInteger("mirror")];
-        replaceWithAir = compound.getBoolean("replaceWithAir");
-        pos = NBTUtil.getPosFromTag(compound.getCompoundTag("pos"));
-    }
-
-    public NBTTagCompound writeToNBT()
-    {
-        NBTTagCompound compound = new NBTTagCompound();
-        compound.setTag("pos", NBTUtil.createPosTag(pos));
-        compound.setString("structure", structure);
-        compound.setInteger("rotation", rotation.ordinal());
-        compound.setInteger("mirror", mirror.ordinal());
-        compound.setBoolean("replaceWithAir", replaceWithAir);
-        return compound;
-    }
-
-    String structure;
-    Rotation rotation;
-    Mirror mirror;
-    public BlockPos pos;
-    boolean replaceWithAir;
-    public boolean isAlive;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseSword.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseSword.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseSword.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.tools;
-
-import net.thegaminghuskymc.huskylib2.items.ItemModSword;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BaseSword extends ItemModSword {
-
-    public BaseSword(String name, ToolMaterial material) {
-        super(name, MOD_ID, material);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrowned.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrowned.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrowned.java	(date 1525605768000)
@@ -1,275 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.block.Block;
-import net.minecraft.entity.*;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.ai.attributes.AttributeModifier;
-import net.minecraft.entity.monster.EntityCreeper;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.pathfinding.PathNavigateGround;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.DifficultyInstance;
-import net.minecraft.world.EnumDifficulty;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.thegaminghuskymc.mcaddon.init.MCAddonItems;
-
-import javax.annotation.Nullable;
-import java.util.Calendar;
-
-public class EntityDrowned extends EntityMob {
-
-
-    private final EntityAIBreakDoor breakDoor = new EntityAIBreakDoor(this);
-    private boolean isBreakDoorsTaskSet;
-
-    private float mummyWidth = 0.6F;
-    private float mummyHeight = 1.95F;
-
-    public EntityDrowned(World worldIn) {
-        super(worldIn);
-        this.setSize(mummyWidth, mummyHeight);
-    }
-
-    @Override
-    protected void initEntityAI() {
-        this.tasks.addTask(0, new EntityAISwimming(this));
-        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(6, new EntityAIMoveThroughVillage(this, 1.0D, false));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 7.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.applyEntityAI();
-    }
-
-    protected void applyEntityAI() {
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-        this.targetTasks.addTask(3, new EntityAINearestAttackableTarget<>(this, EntityVillager.class, true));
-    }
-    @Override
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(30.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(1.5D);
-        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-    public boolean isBreakDoorsTaskSet() {
-        return this.isBreakDoorsTaskSet;
-    }
-
-    public void setBreakDoorAItask(boolean enabled) {
-        if (this.isBreakDoorsTaskSet != enabled) {
-            this.isBreakDoorsTaskSet = enabled;
-            ((PathNavigateGround)this.getNavigator()).setBreakDoors(enabled);
-
-            if (enabled)
-                this.tasks.addTask(1, this.breakDoor);
-            else
-                this.tasks.removeTask(this.breakDoor);
-        }
-    }
-
-    @Override
-    protected int getExperiencePoints(EntityPlayer player) {
-        return super.getExperiencePoints(player);
-    }
-
-    @Override
-    public void notifyDataManagerChange(DataParameter<?> key) {
-        super.notifyDataManagerChange(key);
-    }
-
-    @Override
-    public void onLivingUpdate() {
-        super.onLivingUpdate();
-    }
-
-    @Override
-    public boolean attackEntityFrom(DamageSource source, float amount) {
-        return super.attackEntityFrom(source, amount);
-    }
-
-    @Override
-    public boolean attackEntityAsMob(Entity entityIn) {
-        boolean flag = super.attackEntityAsMob(entityIn);
-
-        if (flag) {
-            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
-
-            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
-                entityIn.setFire(2 * (int)f);
-        }
-        return flag;
-    }
-
-    /**
-     *  TODO: Change Sounds...
-     */
-    @Override
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_BAT_AMBIENT;
-    }
-
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.BLOCK_ANVIL_USE;
-    }
-
-    @Override
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_DONKEY_DEATH;
-    }
-
-    protected SoundEvent getStepSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_STEP;
-    }
-
-    // TODO ^
-
-
-    @Override
-    protected void playStepSound(BlockPos pos, Block blockIn) {
-        this.playSound(this.getStepSound(), 0.15F, 1.0F);
-    }
-
-    @Override
-    public EnumCreatureAttribute getCreatureAttribute() {
-        return EnumCreatureAttribute.UNDEAD;
-    }
-
-    @Nullable
-    @Override
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_ZOMBIE;
-    }
-
-    @Override
-    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
-        super.setEquipmentBasedOnDifficulty(difficulty);
-
-        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
-            int i = this.rand.nextInt(3);
-
-            if (i == 0)
-                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(MCAddonItems.ANCIENT_SWORD));
-            else
-                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(Item.getItemFromBlock(Blocks.SAND)));
-        }
-    }
-
-    public static void registerFixesmummy(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityDrowned.class);
-    }
-
-    @Override
-    public void writeEntityToNBT(NBTTagCompound compound) {
-        super.writeEntityToNBT(compound);
-        compound.setBoolean("CanBreakDoors", this.isBreakDoorsTaskSet());
-    }
-
-    @Override
-    public void readEntityFromNBT(NBTTagCompound compound) {
-        super.readEntityFromNBT(compound);
-        this.setBreakDoorAItask(compound.getBoolean("CanBreakDoors"));
-    }
-
-    @Override
-    public float getEyeHeight() {
-        return 1.74F;
-    }
-
-    @Override
-    protected boolean canEquipItem(ItemStack stack) {
-        return stack.getItem() == MCAddonItems.ANCIENT_SWORD;
-    }
-
-    @Override
-    public boolean getCanSpawnHere() {
-        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
-    }
-
-    @Nullable
-    @Override
-    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
-        if (!getCanSpawnHere())
-            despawnEntity();
-        else {
-            livingdata = super.onInitialSpawn(difficulty, livingdata);
-            float f = difficulty.getClampedAdditionalDifficulty();
-            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
-            this.setBreakDoorAItask(this.rand.nextFloat() < f * 0.1F);
-            this.setEquipmentBasedOnDifficulty(difficulty);
-            this.setEnchantmentBasedOnDifficulty(difficulty);
-
-            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
-                Calendar calendar = this.world.getCurrentDate();
-                if (calendar.get(2) + 1 == 10 && calendar.get(5) == 31 && this.rand.nextFloat() < 0.25F) {
-                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
-                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
-                }
-            }
-
-            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
-            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
-
-            if (d0 > 1.0D)
-                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random mummy-spawn bonus", d0, 2));
-
-            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
-                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader mummy bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
-                this.setBreakDoorAItask(true);
-            }
-        }
-        return livingdata;
-    }
-
-    public double getYOffset() {
-        return -0.45D;
-    }
-
-    @Override
-    public void onDeath(DamageSource cause) {
-        super.onDeath(cause);
-
-        if (cause.getTrueSource() instanceof EntityCreeper) {
-            EntityCreeper entityCreeper = (EntityCreeper)cause.getTrueSource();
-
-            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
-                entityCreeper.incrementDroppedSkulls();
-                ItemStack itemStack = this.getSkullDrop();
-
-                if(!itemStack.isEmpty())
-                    this.entityDropItem(itemStack, 0.0F);
-            }
-        }
-    }
-
-    protected ItemStack getSkullDrop() {
-        return new ItemStack(Items.SKULL, 1, 2);
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerDrownedOuter.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerDrownedOuter.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerDrownedOuter.java	(date 1525605768000)
@@ -1,36 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.layer;
-
-import net.minecraft.client.model.ModelSkeleton;
-import net.minecraft.client.model.ModelZombie;
-import net.minecraft.client.renderer.GlStateManager;
-import net.minecraft.client.renderer.entity.RenderLivingBase;
-import net.minecraft.client.renderer.entity.layers.LayerRenderer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.EntityDrowned;
-
-@SideOnly(Side.CLIENT)
-public class LayerDrownedOuter implements LayerRenderer<EntityDrowned> {
-
-    private static final ResourceLocation STRAY_CLOTHES_TEXTURES = new ResourceLocation("hmca:textures/entity/drowned/drowned_outer_layer.png");
-    private final RenderLivingBase<?> renderer;
-    private final ModelZombie layerModel = new ModelZombie(0.25F, false);
-
-    public LayerDrownedOuter(RenderLivingBase<?> p_i47183_1_) {
-        this.renderer = p_i47183_1_;
-    }
-
-    public void doRenderLayer(EntityDrowned entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
-        this.layerModel.setModelAttributes(this.renderer.getMainModel());
-        this.layerModel.setLivingAnimations(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks);
-        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-        this.renderer.bindTexture(STRAY_CLOTHES_TEXTURES);
-        this.layerModel.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
-    }
-
-    public boolean shouldCombineTextures() {
-        return false;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosPiranha.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosPiranha.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosPiranha.java	(date 1525605768000)
@@ -1,78 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosPiranha.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosPiranha;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelCod;
-import org.lwjgl.opengl.GL11;
-
-import javax.annotation.Nullable;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosPiranha
-
-public class RenderAtmosPiranha extends RenderLiving<EntityAtmosPiranha>
-{
-
-    public RenderAtmosPiranha(RenderManager manager)
-    {
-        super(manager, new ModelCod(), 0.5f);
-    }
-
-    public void renderPiranha(EntityAtmosPiranha entityPiranha, double d, double d1, double d2,
-                              float f, float f1)
-    {
-        super.renderMultipass(entityPiranha, d, d1, d2, f, f1);
-    }
-
-    public void a(EntityLiving entityliving, double d, double d1, double d2,
-                  float f, float f1)
-    {
-        renderPiranha((EntityAtmosPiranha)entityliving, d, d1, d2, f, f1);
-    }
-
-    public void a(Entity entity, double d, double d1, double d2,
-            float f, float f1)
-    {
-        renderPiranha((EntityAtmosPiranha)entity, d, d1, d2, f, f1);
-    }
-
-    protected void preRenderScale(Entity entityliving, float f)
-    {
-        GL11.glScalef(1.0F, 1.0F, 1.0F);
-        EntityAtmosPiranha entityPiranha = (EntityAtmosPiranha)entityliving;
-        if(entityPiranha.isDiving())
-            isDescending(entityliving);
-        if(entityPiranha.isRising())
-            isAscending(entityliving);
-    }
-
-    protected void a(Entity entityliving, float f)
-    {
-        preRenderScale((EntityAtmosPiranha)entityliving, f);
-    }
-
-    protected void isAscending(Entity entityliving)
-    {
-        GL11.glRotatef(-45F, -1F, 0.0F, 0.0F);
-    }
-
-    protected void isDescending(Entity entityliving)
-    {
-        GL11.glRotatef(45F, -1F, 0.0F, 0.0F);
-    }
-
-    @Nullable
-    @Override
-    protected ResourceLocation getEntityTexture(EntityAtmosPiranha entity) {
-        return null;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpAttack.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpAttack.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIScorpAttack.java	(date 1525605768000)
@@ -1,49 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.ai;
-
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.ai.EntityAIAttackMelee;
-import net.thegaminghuskymc.mcaddon.entity.EntityScorp;
-
-public class EntityAIScorpAttack extends EntityAIAttackMelee
-{
-    private final EntityScorp scorp;
-    private int extendTailTicks;
-
-    public EntityAIScorpAttack(EntityScorp scorpIn, double speedIn, boolean useLongMemory)
-    {
-        super(scorpIn, speedIn, useLongMemory);
-        this.scorp = scorpIn;
-    }
-
-    @Override
-    public void startExecuting()
-    {
-        super.startExecuting();
-        this.extendTailTicks = 0;
-    }
-
-    @Override
-    public void resetTask()
-    {
-        super.resetTask();
-        this.scorp.setTailOut(false);
-    }
-
-    @Override
-    public void updateTask()
-    {
-        super.updateTask();
-        ++extendTailTicks;
-
-        if (this.extendTailTicks >= 5 && this.attackTick < 10) {
-            this.scorp.setTailOut(true);
-        } else {
-            this.scorp.setTailOut(false);
-        }
-    }
-
-    protected double getAttackReachSqr(EntityLivingBase attackTarget)
-    {
-        return (double)(5.0F + attackTarget.width);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosWhale.java	(date 1525605768000)
@@ -1,109 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosWhale.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import axa;
-import ayf;
-import ke;
-import lq;
-import md;
-
-public class ModelAtmosWhale extends axa
-{
-
-    public ModelAtmosWhale()
-    {
-        t = 64;
-        u = 32;
-        Body1 = new ayf(this, 0, 0);
-        Body1.a(-3.5F, -2.5F, -7F, 7, 7, 14);
-        Body1.a(0.0F, 19F, -4F);
-        Body1.b(64, 32);
-        Body1.i = true;
-        setRotation(Body1, 0.0F, 0.0F, 0.0F);
-        Body2 = new ayf(this, 28, 0);
-        Body2.a(-2.5F, -2.5F, 0.0F, 5, 5, 9);
-        Body2.a(0.0F, 20F, 3F);
-        Body2.b(64, 32);
-        Body2.i = true;
-        setRotation(Body2, 0.0F, 0.0F, 0.0F);
-        Tail1 = new ayf(this, 0, 21);
-        Tail1.a(-2.5F, -1F, 8F, 5, 2, 6);
-        Tail1.a(0.0F, 20F, 3F);
-        Tail1.b(64, 32);
-        Tail1.i = true;
-        setRotation(Tail1, 0.0F, 0.0F, 0.0F);
-        Tail2 = new ayf(this, 18, 21);
-        Tail2.a(-5F, 0.0F, 13F, 3, 1, 5);
-        Tail2.a(0.0F, 20F, 3F);
-        Tail2.b(64, 32);
-        Tail2.i = true;
-        setRotation(Tail2, 0.0F, 0.3316126F, 0.0F);
-        Tail3 = new ayf(this, 18, 21);
-        Tail3.a(2.0F, 0.0F, 13F, 3, 1, 5);
-        Tail3.a(0.0F, 20F, 3F);
-        Tail3.b(64, 32);
-        Tail3.i = true;
-        setRotation(Tail3, 0.0F, -0.3316126F, 0.0F);
-        Fin1 = new ayf(this, 35, 21);
-        Fin1.a(0.0F, 1.0F, 0.0F, 2, 1, 5);
-        Fin1.a(3F, 20F, 0.0F);
-        Fin1.b(64, 32);
-        Fin1.i = true;
-        setRotation(Fin1, 0.0F, 0.4363323F, 0.0F);
-        Fin2 = new ayf(this, 35, 21);
-        Fin2.a(-2F, 0.0F, 0.0F, 2, 1, 5);
-        Fin2.a(-3F, 20F, 0.0F);
-        Fin2.b(64, 32);
-        Fin2.i = true;
-        setRotation(Fin2, 0.0F, -0.4363323F, 0.0F);
-    }
-
-    public void a(lq entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.a(entity, f, f1, f2, f3, f4, f5);
-        a(f, f1, f2, f3, f4, f5, entity);
-        Body1.a(f5);
-        Body2.a(f5);
-        Tail1.a(f5);
-        Tail2.a(f5);
-        Tail3.a(f5);
-        Fin1.a(f5);
-        Fin2.a(f5);
-    }
-
-    public void a(md entityliving, float par2, float par3, float par4)
-    {
-        float f1 = (0.5F + Math.max(par3, par4 - 1.0F)) * 0.25F;
-        float f2 = par2 * 0.3F;
-        Body2.f = ke.a(f2 - 0.375F) * f1;
-        Tail1.f = ke.a(f2 - 0.525F) * f1;
-        Tail2.f = ke.a(f2 - 0.675F) * f1;
-        Tail3.f = ke.a(f2 - 0.825F) * f1;
-    }
-
-    private void setRotation(ayf model, float x, float y, float z)
-    {
-        model.f = x;
-        model.g = y;
-        model.h = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, lq entity)
-    {
-        super.a(f, f1, f2, f3, f4, f5, entity);
-    }
-
-    ayf Body1;
-    ayf Body2;
-    ayf Tail1;
-    ayf Tail2;
-    ayf Tail3;
-    ayf Fin1;
-    ayf Fin2;
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/InventoryUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/InventoryUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/InventoryUtil.java	(date 1525605768000)
@@ -1,91 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   InventoryUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.item.ItemStack;
-import net.minecraftforge.items.IItemHandler;
-import net.minecraftforge.oredict.OreDictionary;
-
-// Referenced classes of package elucent.elulib.util:
-//            OreStack
-
-public class InventoryUtil
-{
-
-    public InventoryUtil()
-    {
-    }
-
-    public static int attemptInsert(ItemStack stack, IItemHandler inventory, boolean simulate)
-    {
-        int count = stack.getCount();
-        ItemStack toInsert = stack.copy();
-        for(int i = 0; i < inventory.getSlots() && !toInsert.isEmpty(); i++)
-        {
-            ItemStack s = inventory.insertItem(i, toInsert.copy(), simulate);
-            toInsert.setCount(s.getCount());
-        }
-
-        return count - toInsert.getCount();
-    }
-
-    public static int attemptInsert(ItemStack stack, IItemHandler inventory, boolean simulate, int startSlot, int endSlot)
-    {
-        int count = stack.getCount();
-        ItemStack toInsert = stack.copy();
-        for(int i = startSlot; i < endSlot && !toInsert.isEmpty(); i++)
-        {
-            ItemStack s = inventory.insertItem(i, toInsert.copy(), simulate);
-            toInsert.setCount(s.getCount());
-        }
-
-        return count - toInsert.getCount();
-    }
-
-    public static boolean stackMatches(ItemStack stack, Object recipeInput)
-    {
-        if(recipeInput instanceof ItemStack)
-        {
-            if(!ItemStack.areItemsEqual(stack, (ItemStack)recipeInput))
-                return false;
-        } else
-        if(recipeInput instanceof OreStack)
-        {
-            int id = OreDictionary.getOreID(((OreStack)recipeInput).oreId);
-            int ids[] = OreDictionary.getOreIDs(stack);
-            boolean hasMatch = false;
-            int ai[] = ids;
-            int i = ai.length;
-            for(int k = 0; k < i; k++)
-            {
-                int pid = ai[k];
-                if(pid == id)
-                    hasMatch = true;
-            }
-
-            if(!hasMatch)
-                return hasMatch;
-        } else
-        if(recipeInput instanceof String)
-        {
-            int id = OreDictionary.getOreID((String)recipeInput);
-            int ids[] = OreDictionary.getOreIDs(stack);
-            boolean hasMatch = false;
-            int ai1[] = ids;
-            int j = ai1.length;
-            for(int l = 0; l < j; l++)
-            {
-                int pid = ai1[l];
-                if(pid == id)
-                    hasMatch = true;
-            }
-
-            if(!hasMatch)
-                return hasMatch;
-        }
-        return true;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/WeightedUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/WeightedUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/WeightedUtil.java	(date 1525605768000)
@@ -1,25 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.util.WeightedRandom;
-
-import java.util.List;
-import java.util.Random;
-
-public class WeightedUtil
-{
-    public static NamedItem getRandomNamedItem(Random rand, List<NamedItem> variants)
-    {
-        return WeightedRandom.getRandomItem(rand, variants);
-    }
-
-    public static class NamedItem extends WeightedRandom.Item
-    {
-        public String name;
-
-        public NamedItem(String nameIn, int weight)
-        {
-            super(weight);
-            name = nameIn;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldStairBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldStairBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldStairBase.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.state.IBlockState;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockOverworldStairBase extends BlockModStairs {
-
-    public BlockOverworldStairBase(String name, IBlockState state) {
-        super(name, state);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    @Override
-    public String getModNamespace() {
-        return MOD_ID;
-    }
-
-    @Override
-    public String getPrefix() {
-        return MOD_ID;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosReefManta.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosReefManta.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosReefManta.java	(date 1525605768000)
@@ -1,94 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosReefManta.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-public class ModelAtmosReefManta extends ModelBase {
-
-    public ModelAtmosReefManta() {
-        textureWidth = 64;
-        textureHeight = 32;
-        Body1 = new ModelRenderer(this, 0, 16);
-        Body1.addBox(-5F, -1.5F, -6F, 10, 3, 12);
-        Body1.setRotationPoint(0.0F, 21F, 0.0F);
-        Body1.setTextureOffset(64, 32);
-        Body1.mirror = true;
-        setRotation(Body1, 0.0F, 0.0F, 0.0F);
-        Body2 = new ModelRenderer(this, 31, 9);
-        Body2.addBox(-3F, -0.5F, 0.0F, 6, 1, 4);
-        Body2.setRotationPoint(0.0F, 21.5F, 6F);
-        Body2.setTextureOffset(64, 32);
-        Body2.mirror = true;
-        setRotation(Body2, 0.0F, 0.0F, 0.0F);
-        Body3 = new ModelRenderer(this, 31, 0);
-        Body3.addBox(-0.5F, -0.5F, 4F, 1, 1, 6);
-        Body3.setRotationPoint(0.0F, 21.5F, 6F);
-        Body3.setTextureOffset(64, 32);
-        Body3.mirror = true;
-        setRotation(Body3, 0.0F, 0.0F, 0.0F);
-        Wing1 = new ModelRenderer(this, 0, 8);
-        Wing1.addBox(0.0F, -1F, -3F, 12, 1, 7);
-        Wing1.setRotationPoint(5F, 21F, 0.0F);
-        Wing1.setTextureOffset(64, 32);
-        Wing1.mirror = true;
-        setRotation(Wing1, 0.0F, 0.0F, 0.0F);
-        Wing2 = new ModelRenderer(this, 0, 0);
-        Wing2.addBox(-12F, -1F, -3F, 12, 1, 7);
-        Wing2.setRotationPoint(-5F, 21F, 0.0F);
-        Wing2.setTextureOffset(64, 32);
-        Wing2.mirror = true;
-        setRotation(Wing2, 0.0F, 0.0F, 0.0F);
-        Beak1 = new ModelRenderer(this, 0, 21);
-        Beak1.addBox(0.0F, 0.0F, -4F, 2, 1, 4);
-        Beak1.setRotationPoint(3F, 21F, -6F);
-        Beak1.setTextureOffset(64, 32);
-        Beak1.mirror = true;
-        setRotation(Beak1, 0.0F, -0.3490659F, 0.0F);
-        Beak2 = new ModelRenderer(this, 0, 16);
-        Beak2.addBox(-2F, 0.0F, -4F, 2, 1, 4);
-        Beak2.setRotationPoint(-3F, 21F, -6F);
-        Beak2.setTextureOffset(64, 32);
-        Beak2.mirror = true;
-        setRotation(Beak2, 0.0F, 0.3490659F, 0.0F);
-    }
-
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-        Body1.render(f5);
-        Body2.render(f5);
-        Body3.render(f5);
-        Wing1.render(f5);
-        Wing2.render(f5);
-        Beak1.render(f5);
-        Beak2.render(f5);
-    }
-
-    private void setRotation(ModelRenderer model, float x, float y, float z)
-    {
-        model.rotateAngleX = x;
-        model.rotateAngleY = y;
-        model.rotateAngleX = z;
-    }
-
-    public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5, Entity entity)
-    {
-        super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-//        Wing1.h = ke.b(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-//        Wing2.h = -ke.b(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-    }
-
-    ModelRenderer Body1;
-    ModelRenderer Body2;
-    ModelRenderer Body3;
-    ModelRenderer Wing1;
-    ModelRenderer Wing2;
-    ModelRenderer Beak1;
-    ModelRenderer Beak2;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndBase.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.end;
-
-import net.minecraft.block.material.Material;
-import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockEndBase extends BlockMod {
-
-    public BlockEndBase(Material material, String name) {
-        super(material, MOD_ID, name);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemPotionBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemPotionBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemPotionBase.java	(date 1525605768000)
@@ -1,59 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.client.util.ITooltipFlag;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntityPotion;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemPotion;
-import net.minecraft.item.ItemStack;
-import net.minecraft.potion.PotionUtils;
-import net.minecraft.stats.StatList;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.text.translation.I18n;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-import java.util.List;
-
-public class ItemPotionBase extends ItemPotion {
-
-    public String getItemStackDisplayName(ItemStack stack)
-    {
-        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("potion.effect."));
-    }
-
-    /**
-     * allows items to add custom lines of information to the mouseover description
-     */
-    @SideOnly(Side.CLIENT)
-    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn)
-    {
-        PotionUtils.addPotionTooltip(stack, tooltip, 0.25F);
-    }
-
-    /**
-     * Called when the equipped item is right clicked.
-     */
-    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)
-    {
-        ItemStack itemstack = playerIn.getHeldItem(handIn);
-        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
-        worldIn.playSound((EntityPlayer)null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_LINGERINGPOTION_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
-
-        if (!worldIn.isRemote)
-        {
-            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
-            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
-            worldIn.spawnEntity(entitypotion);
-        }
-
-        playerIn.addStat(StatList.getObjectUseStats(this));
-        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, itemstack);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RemapHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RemapHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RemapHandler.java	(date 1525605768000)
@@ -1,106 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import net.minecraft.block.Block;
-import net.minecraft.item.Item;
-import net.minecraft.util.ResourceLocation;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.minecraftforge.registries.IForgeRegistry;
-import net.minecraftforge.registries.IForgeRegistryEntry;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import java.util.List;
-import java.util.Map;
-import java.util.function.Predicate;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-/**
- * Remaps this mod's {@link Block}s and {@link Item}s after registry names have been changed.
- * <p>
- * Written by Choonster here:
- * https://github.com/Choonster-Minecraft-Mods/TestMod3/blob/2cb7b67adf7ab41e066c3308ac898224b2891752/src/main/java/choonster/testmod3/remap/Remapper.java
- *
- * @author Choonster
- */
-public class RemapHandler<T extends IForgeRegistryEntry<T>>
-{
-    private static final Map<String, String> customNames = ImmutableMap.<String, String>builder()
-            .build();
-
-    private final List<Predicate<RegistryEvent.MissingMappings.Mapping<T>>> remappingFunctions = ImmutableList.of(this::remapRegistryName);
-
-    private static final Logger LOGGER = LogManager.getLogger("NetherEx|RemapHandler");
-
-    public void remapAll(List<RegistryEvent.MissingMappings.Mapping<T>> missingMappings)
-    {
-        LOGGER.info("Fix Missing Mappings started.");
-
-        for(RegistryEvent.MissingMappings.Mapping<T> missingMapping : missingMappings)
-        {
-            LOGGER.info("Trying to remap %s", missingMapping.key);
-
-            boolean remapped = remappingFunctions.stream().anyMatch(mappingPredicate -> mappingPredicate.test(missingMapping));
-
-            if(!remapped)
-            {
-                LOGGER.info("Couldn't remap %s", missingMapping.key);
-            }
-        }
-
-        LOGGER.info("Fix Missing Mappings completed.");
-    }
-
-    private boolean attemptRemap(RegistryEvent.MissingMappings.Mapping<T> missingMapping, ResourceLocation registryName)
-    {
-        IForgeRegistry<T> registry = missingMapping.registry;
-
-        T value = registry.getValue(registryName);
-
-        if(registry.containsKey(registryName) && value != null)
-        {
-            LOGGER.info("Remapped %s %s to %s", registry.getRegistrySuperType().getSimpleName(), missingMapping.key, registryName);
-            missingMapping.remap(value);
-            return true;
-        }
-
-        return false;
-    }
-
-    private boolean remapRegistryName(RegistryEvent.MissingMappings.Mapping<T> missingMapping)
-    {
-        final String missingPath = missingMapping.key.getResourcePath();
-
-        if(!customNames.containsKey(missingPath))
-        {
-            return false;
-        }
-
-        String newPath = customNames.get(missingPath);
-        ResourceLocation newRegistryName = new ResourceLocation(missingMapping.key.getResourceDomain(), newPath);
-        return attemptRemap(missingMapping, newRegistryName);
-    }
-
-    @Mod.EventBusSubscriber(modid = MOD_ID)
-    private static class EventHandler
-    {
-        private static final RemapHandler<Block> blockRemapper = new RemapHandler<>();
-        private static final RemapHandler<Item> itemRemapper = new RemapHandler<>();
-
-        @SubscribeEvent
-        public static void missingBlockMappings(RegistryEvent.MissingMappings<Block> event)
-        {
-            blockRemapper.remapAll(event.getMappings());
-        }
-
-        @SubscribeEvent
-        public static void missingItemMappings(RegistryEvent.MissingMappings<Item> event)
-        {
-            itemRemapper.remapAll(event.getMappings());
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCrow.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCrow.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCrow.java	(date 1525605768000)
@@ -1,31 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosCrow;
-import net.thegaminghuskymc.mcaddon.entity.EntityCod;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelAtmosCrow;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelCod;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderCrow extends RenderLiving<EntityAtmosCrow> {
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/crow/crow.png");
-
-    public RenderCrow(RenderManager manager)
-    {
-        super(manager, new ModelAtmosCrow(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityAtmosCrow entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntityAtmosCrow entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherStairBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherStairBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherStairBase.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.nether;
-
-import net.minecraft.block.state.IBlockState;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockNetherStairBase extends BlockModStairs {
-
-    public BlockNetherStairBase(String name, IBlockState state) {
-        super(name, state);
-        setCreativeTab(Main.NETHER_EXPANSION_TAB);
-    }
-
-    @Override
-    public String getModNamespace() {
-        return MOD_ID;
-    }
-
-    @Override
-    public String getPrefix() {
-        return MOD_ID;
-    }
-    
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWater.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWater.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWater.java	(date 1525605768000)
@@ -1,133 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosWater.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-// Referenced classes of package atmosmobs:
-//            EntityAtmosWaterMob
-
-public class EntityAtmosWater extends EntityAtmosWaterMob {
-
-    public EntityAtmosWater(World world) {
-        super(world);
-        outOfWater = 0;
-    }
-
-    public boolean bj()
-    {
-        return false;
-    }
-
-    public float b(float f, float f1, float f2)
-    {
-        float f3 = f1;
-        for(f3 = f1 - f; f3 < -180F; f3 += 360F);
-        for(; f3 >= 180F; f3 -= 360F);
-        if(f3 > f2)
-            f3 = f2;
-        if(f3 < -f2)
-            f3 = -f2;
-        return f + f3;
-    }
-
-    protected void a(int i, int j, int k, int l)
-    {
-    }
-
-    protected void a(float f1)
-    {
-    }
-
-    public boolean isRising()
-    {
-        return rising && outOfWater == 0;
-    }
-
-    public int aT()
-    {
-        return maxHealth;
-    }
-
-    public void setMaxHealth(int i)
-    {
-        maxHealth = i;
-    }
-
-    protected String ba()
-    {
-        return null;
-    }
-
-    protected String aZ()
-    {
-        return null;
-    }
-
-    protected String aY()
-    {
-        return null;
-    }
-
-    protected float aX()
-    {
-        return 0.4F;
-    }
-
-    public boolean gettingOutOfWater()
-    {
-        int i = (int)posX;
-        int j = (int)posY;
-        int k = (int)posZ;
-        int l = 1;
-        return false;
-    }
-
-    protected String getUpsetSound()
-    {
-        return null;
-    }
-
-    public double speed()
-    {
-        return 1.5D;
-    }
-
-    public boolean H()
-    {
-        return false;
-    }
-
-    public boolean bc()
-    {
-        return true;
-    }
-
-    public boolean isDiving()
-    {
-        return diving && outOfWater == 0;
-    }
-
-    public void setDiving(boolean par1)
-    {
-        if(par1)
-            diving = true;
-        else
-            diving = false;
-    }
-
-    protected void bi()
-    {
-    }
-
-    public int outOfWater;
-    private int maxHealth;
-    public boolean rising;
-    private boolean diving;
-    private int divingCount;
-    public boolean isTamed;
-    private boolean Jump;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosReefManta.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosReefManta.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosReefManta.java	(date 1525605768000)
@@ -1,14 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.world.World;
-
-public class EntityAtmosReefManta extends EntityWaterMob {
-
-    public EntityAtmosReefManta(World world) {
-        super(world);
-        setSize(0.5F, 0.5F);
-        setHealth(25);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityShadowPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityShadowPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityShadowPhantom.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.world.World;
-
-public class EntityShadowPhantom extends EntityLiving {
-
-    public EntityShadowPhantom(World worldIn) {
-        super(worldIn);
-        this.setHealth(this.getMaxHealth());
-        setSize(0.5F, 0.5F);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrowned.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrowned.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrowned.java	(date 1525605768000)
@@ -1,33 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.Minecraft;
-import net.minecraft.client.model.ModelZombie;
-import net.minecraft.client.renderer.entity.RenderBiped;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.EntityDrowned;
-import net.thegaminghuskymc.mcaddon.entity.render.layer.LayerDrownedOuter;
-
-@SideOnly(Side.CLIENT)
-public class RenderDrowned extends RenderBiped<EntityDrowned> {
-
-    private static final ResourceLocation MUMMY_TEXTURE = new ResourceLocation("hmca:textures/entity/drowned/drowned.png");
-
-    public RenderDrowned(RenderManager rendermanagerIn) {
-        super(rendermanagerIn, new ModelZombie(), 0.5F);
-        this.addLayer(new LayerDrownedOuter(this));
-    }
-
-    @Override
-    protected boolean setBrightness(EntityDrowned entitylivingbaseIn, float partialTicks, boolean combineTextures) {
-        return true;
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityDrowned entity) {
-        return MUMMY_TEXTURE;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosColourfulFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosColourfulFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosColourfulFish.java	(date 1525605768000)
@@ -1,69 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosColourfulFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import axa;
-import bcj;
-import lq;
-import md;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosColourfulFish;
-import org.lwjgl.opengl.GL11;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosColourfulFish
-
-public class RenderAtmosColourfulFish extends bcj
-{
-
-    public RenderAtmosColourfulFish(axa modelbase, float f)
-    {
-        super(modelbase, f);
-    }
-
-    public void renderColourfulFish(EntityAtmosColourfulFish entityColourfulFish, double d, double d1, double d2,
-                                    float f, float f1)
-    {
-        super.a(entityColourfulFish, d, d1, d2, f, f1);
-    }
-
-    public void a(md entityliving, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderColourfulFish((EntityAtmosColourfulFish)entityliving, d, d1, d2, f, f1);
-    }
-
-    public void a(lq entity, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderColourfulFish((EntityAtmosColourfulFish)entity, d, d1, d2, f, f1);
-    }
-
-    protected void preRenderScale(md entityliving, float f)
-    {
-        EntityAtmosColourfulFish entityColourfulFish = (EntityAtmosColourfulFish)entityliving;
-        if(entityColourfulFish.isDiving())
-            isDescending(entityliving);
-        if(entityColourfulFish.isRising())
-            isAscending(entityliving);
-    }
-
-    protected void a(md entityliving, float f)
-    {
-        preRenderScale((EntityAtmosColourfulFish)entityliving, f);
-    }
-
-    protected void isAscending(md entityliving)
-    {
-        GL11.glRotatef(-45F, -1F, 0.0F, 0.0F);
-    }
-
-    protected void isDescending(md entityliving)
-    {
-        GL11.glRotatef(45F, -1F, 0.0F, 0.0F);
-    }
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemLingeringPotionBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemLingeringPotionBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemLingeringPotionBase.java	(date 1525605768000)
@@ -1,55 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
-import net.minecraft.client.util.ITooltipFlag;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntityPotion;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemPotion;
-import net.minecraft.item.ItemSplashPotion;
-import net.minecraft.item.ItemStack;
-import net.minecraft.potion.PotionUtils;
-import net.minecraft.stats.StatList;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.text.translation.I18n;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-public class ItemLingeringPotionBase extends ItemPotion {
-
-    public String getItemStackDisplayName(ItemStack stack) {
-        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("lingering_potion.effect."));
-    }
-
-    /**
-     * allows items to add custom lines of information to the mouseover description
-     */
-    @SideOnly(Side.CLIENT)
-    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
-        PotionUtils.addPotionTooltip(stack, tooltip, 0.25F);
-    }
-
-    /**
-     * Called when the equipped item is right clicked.
-     */
-    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
-        ItemStack itemstack = playerIn.getHeldItem(handIn);
-        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
-        worldIn.playSound(null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_LINGERINGPOTION_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
-
-        if (!worldIn.isRemote) {
-            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
-            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
-            worldIn.spawnEntity(entitypotion);
-        }
-
-        playerIn.addStat(Objects.requireNonNull(StatList.getObjectUseStats(this)));
-        return new ActionResult<>(EnumActionResult.SUCCESS, itemstack);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RenderHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RenderHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/RenderHandler.java	(date 1525605768000)
@@ -1,27 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraftforge.fml.client.registry.RenderingRegistry;
-import net.thegaminghuskymc.mcaddon.entity.*;
-import net.thegaminghuskymc.mcaddon.entity.render.*;
-
-public class RenderHandler {
-
-    public static void registerEntityRenders(){
-        RenderingRegistry.registerEntityRenderingHandler(EntityMummy.class, RenderMummy::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityMummyVillager.class, RenderMummyVillager::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityScorp.class, RenderScorp::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityDrowned.class, RenderDrowned::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityCod.class, RenderCod::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityPhantom.class, RenderPhantom::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityRedPhantom.class, RenderRedPhantom::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityEnderPhantom.class, RenderEnderPhantom::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityShadowPhantom.class, RenderShadowPhantom::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityAtmosCrow.class, RenderCrow::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityAtmosAngler.class, RenderAtmosAngler::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityAtmosReefManta.class, RenderAtmosReefManta::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntitySeaTurtle.class, RenderSeaTurtle::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityWhale.class, RenderWhale::new);
-        RenderingRegistry.registerEntityRenderingHandler(EntityHoveringInferno.class, RenderHoveringInferno::new);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/Reference.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/Reference.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/Reference.java	(date 1525605768000)
@@ -1,11 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-public class Reference
-{
-    public static final String MOD_ID = "hmca";
-    public static final String NAME = "Husky's Minecraft Additions";
-    public static final String VERSION = "0.0.1";
-
-    public static final String CLIENT_PROXY = "net.thegaminghuskymc.mcaddon.proxy.ClientProxy";
-    public static final String SERVER_PROXY = "net.thegaminghuskymc.mcaddon.proxy.CommonProxy";
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelSeaTurtle.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelSeaTurtle.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelSeaTurtle.java	(date 1525605768000)
@@ -1,74 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-/**
- * SeaTurtle - TheGamingHuskyMC
- * Created using Tabula 7.0.0
- */
-public class ModelSeaTurtle extends ModelBase {
-
-    public ModelRenderer head;
-    public ModelRenderer shellRing;
-    public ModelRenderer frontRightFin;
-    public ModelRenderer shell;
-    public ModelRenderer backLeftFin;
-    public ModelRenderer frontLeftFin;
-    public ModelRenderer body;
-    public ModelRenderer backRightFin;
-
-    public ModelSeaTurtle() {
-        this.textureWidth = 128;
-        this.textureHeight = 64;
-        this.frontLeftFin = new ModelRenderer(this, 18, 22);
-        this.frontLeftFin.setRotationPoint(-4.0F, 0.0F, 4.0F);
-        this.frontLeftFin.addBox(-1.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
-        this.backRightFin = new ModelRenderer(this, 18, 22);
-        this.backRightFin.setRotationPoint(4.0F, 0.0F, -4.0F);
-        this.backRightFin.addBox(0.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
-        this.body = new ModelRenderer(this, 0, 0);
-        this.body.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.body.addBox(-4.0F, -1.5F, -6.0F, 8, 3, 12, 0.0F);
-        this.backLeftFin = new ModelRenderer(this, 18, 22);
-        this.backLeftFin.setRotationPoint(-4.0F, 0.0F, -4.0F);
-        this.backLeftFin.addBox(-1.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
-        this.shellRing = new ModelRenderer(this, 0, 48);
-        this.shellRing.mirror = true;
-        this.shellRing.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.shellRing.addBox(-5.0F, -2.5F, -7.0F, 10, 2, 14, 0.0F);
-        this.head = new ModelRenderer(this, 0, 23);
-        this.head.mirror = true;
-        this.head.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.head.addBox(-2.0F, -2.5F, 6.0F, 4, 3, 5, 0.0F);
-        this.shell = new ModelRenderer(this, 0, 31);
-        this.shell.mirror = true;
-        this.shell.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.shell.addBox(-4.5F, -4.0F, -6.5F, 9, 2, 13, 0.0F);
-        this.frontRightFin = new ModelRenderer(this, 18, 22);
-        this.frontRightFin.setRotationPoint(4.0F, 0.0F, 4.0F);
-        this.frontRightFin.addBox(0.0F, -1.5F, -1.5F, 1, 6, 3, 0.0F);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) { 
-        this.frontLeftFin.render(f5);
-        this.shellRing.render(f5);
-        this.shell.render(f5);
-        this.backRightFin.render(f5);
-        this.frontRightFin.render(f5);
-        this.body.render(f5);
-        this.backLeftFin.render(f5);
-        this.head.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorpion.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorpion.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelScorpion.java	(date 1525605768000)
@@ -1,148 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-/**
- * ModelScorpion - Dion - Trikzon
- * Created using Tabula 7.0.0
- */
-public class ModelScorpion extends ModelBase {
-    public ModelRenderer body;
-    public ModelRenderer head;
-    public ModelRenderer tail1;
-    public ModelRenderer clawRight1;
-    public ModelRenderer clawLeft1;
-    public ModelRenderer tail2;
-    public ModelRenderer tail3;
-    public ModelRenderer tail4;
-    public ModelRenderer tail5;
-    public ModelRenderer stinger;
-    public ModelRenderer clawRight2;
-    public ModelRenderer clawLeft2;
-    public ModelRenderer legLeft1;
-    public ModelRenderer legLeft2;
-    public ModelRenderer legLeft3;
-    public ModelRenderer legLeft4;
-    public ModelRenderer legRight1;
-    public ModelRenderer legRight2;
-    public ModelRenderer legRight3;
-    public ModelRenderer legRight4;
-
-    public ModelScorpion() {
-        this.textureWidth = 64;
-        this.textureHeight = 32;
-        this.legLeft4 = new ModelRenderer(this, 45, 24);
-        this.legLeft4.setRotationPoint(4.0F, 20.5F, 3.5F);
-        this.legLeft4.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legLeft4, 0.0F, -0.4363323129985824F, 0.4886921905584123F);
-        this.tail5 = new ModelRenderer(this, 0, 8);
-        this.tail5.setRotationPoint(0.0F, 0.2F, 3.2F);
-        this.tail5.addBox(-1.0F, -1.0F, 0.0F, 2, 2, 4, 0.0F);
-        this.setRotateAngle(tail5, 0.5009094953223726F, 0.0F, 0.0F);
-        this.clawLeft2 = new ModelRenderer(this, 18, 4);
-        this.clawLeft2.setRotationPoint(0.0F, 0.0F, -2.8F);
-        this.clawLeft2.addBox(-1.0F, -1.0F, -2.8F, 2, 2, 3, 0.0F);
-        this.setRotateAngle(clawLeft2, 0.0F, 0.6981317007977318F, 0.0F);
-        this.head = new ModelRenderer(this, 44, 16);
-        this.head.setRotationPoint(0.0F, 20.5F, -5.0F);
-        this.head.addBox(-3.0F, -2.0F, -4.0F, 6, 4, 4, 0.0F);
-        this.tail1 = new ModelRenderer(this, 0, 22);
-        this.tail1.setRotationPoint(0.0F, 20.0F, 4.0F);
-        this.tail1.addBox(-2.5F, -2.0F, 0.0F, 5, 4, 6, 0.0F);
-        this.setRotateAngle(tail1, 0.3490658503988659F, 0.0F, 0.0F);
-        this.clawRight1 = new ModelRenderer(this, 20, 0);
-        this.clawRight1.setRotationPoint(-2.5F, 20.5F, -6.0F);
-        this.clawRight1.addBox(-0.5F, -0.5F, -3.0F, 1, 1, 3, 0.0F);
-        this.setRotateAngle(clawRight1, 0.0F, 0.6981317007977318F, 0.0F);
-        this.legRight3 = new ModelRenderer(this, 45, 24);
-        this.legRight3.setRotationPoint(-4.0F, 20.5F, 1.1F);
-        this.legRight3.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legRight3, 0.0F, 0.2617993877991494F, -0.4886921905584123F);
-        this.legLeft3 = new ModelRenderer(this, 45, 24);
-        this.legLeft3.setRotationPoint(4.0F, 20.5F, 1.1F);
-        this.legLeft3.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legLeft3, 0.0F, -0.2617993877991494F, 0.4886921905584123F);
-        this.legRight2 = new ModelRenderer(this, 45, 24);
-        this.legRight2.setRotationPoint(-4.0F, 20.5F, -1.2F);
-        this.legRight2.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legRight2, 0.0F, -0.2617993877991494F, -0.4886921905584123F);
-        this.body = new ModelRenderer(this, 28, 0);
-        this.body.setRotationPoint(0.0F, 20.5F, 0.0F);
-        this.body.addBox(-4.0F, -3.0F, -5.0F, 8, 6, 10, 0.0F);
-        this.clawLeft1 = new ModelRenderer(this, 20, 0);
-        this.clawLeft1.setRotationPoint(2.5F, 20.5F, -6.0F);
-        this.clawLeft1.addBox(-0.5F, -0.5F, -3.0F, 1, 1, 3, 0.0F);
-        this.setRotateAngle(clawLeft1, 0.0F, -0.6981317007977318F, 0.0F);
-        this.tail3 = new ModelRenderer(this, 0, 14);
-        this.tail3.setRotationPoint(0.0F, 0.0F, 4.3F);
-        this.tail3.addBox(-2.0F, -1.5F, 0.0F, 4, 3, 5, 0.0F);
-        this.setRotateAngle(tail3, 0.3490658503988659F, 0.0F, 0.0F);
-        this.legLeft1 = new ModelRenderer(this, 45, 24);
-        this.legLeft1.setRotationPoint(4.0F, 20.5F, -3.5F);
-        this.legLeft1.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legLeft1, 0.0F, 0.4363323129985824F, 0.4886921905584123F);
-        this.legRight1 = new ModelRenderer(this, 45, 24);
-        this.legRight1.setRotationPoint(-4.0F, 20.5F, -3.5F);
-        this.legRight1.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legRight1, 0.0F, -0.4363323129985824F, -0.4886921905584123F);
-        this.stinger = new ModelRenderer(this, 0, 4);
-        this.stinger.setRotationPoint(0.0F, 0.0F, 4.0F);
-        this.stinger.addBox(-0.5F, -0.5F, 0.0F, 1, 1, 3, 0.0F);
-        this.setRotateAngle(stinger, 0.2617993877991494F, 0.0F, 0.0F);
-        this.tail2 = new ModelRenderer(this, 0, 14);
-        this.tail2.setRotationPoint(0.0F, -0.9F, 4.9F);
-        this.tail2.addBox(-2.0F, -1.5F, 0.0F, 4, 3, 5, 0.0F);
-        this.setRotateAngle(tail2, 0.7853981633974483F, 0.0F, 0.0F);
-        this.legRight4 = new ModelRenderer(this, 45, 24);
-        this.legRight4.setRotationPoint(-4.0F, 20.5F, 3.5F);
-        this.legRight4.addBox(-6.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legRight4, 0.0F, 0.4455668605402397F, -0.4886921905584123F);
-        this.legLeft2 = new ModelRenderer(this, 45, 24);
-        this.legLeft2.setRotationPoint(4.0F, 20.5F, -1.2F);
-        this.legLeft2.addBox(-1.0F, -1.0F, -1.0F, 7, 2, 2, 0.0F);
-        this.setRotateAngle(legLeft2, 0.0F, 0.2617993877991494F, 0.4886921905584123F);
-        this.tail4 = new ModelRenderer(this, 0, 8);
-        this.tail4.setRotationPoint(0.0F, 0.0F, 4.3F);
-        this.tail4.addBox(-1.0F, -1.0F, 0.0F, 2, 2, 4, 0.0F);
-        this.setRotateAngle(tail4, 0.8726646259971648F, 0.0F, 0.0F);
-        this.clawRight2 = new ModelRenderer(this, 18, 4);
-        this.clawRight2.setRotationPoint(0.0F, 0.0F, -2.8F);
-        this.clawRight2.addBox(-1.0F, -1.0F, -2.8F, 2, 2, 3, 0.0F);
-        this.setRotateAngle(clawRight2, 0.0F, -0.6981317007977318F, 0.0F);
-        this.tail4.addChild(this.tail5);
-        this.clawLeft1.addChild(this.clawLeft2);
-        this.tail2.addChild(this.tail3);
-        this.tail5.addChild(this.stinger);
-        this.tail1.addChild(this.tail2);
-        this.tail3.addChild(this.tail4);
-        this.clawRight1.addChild(this.clawRight2);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) { 
-        this.legLeft4.render(f5);
-        this.head.render(f5);
-        this.tail1.render(f5);
-        this.clawRight1.render(f5);
-        this.legRight3.render(f5);
-        this.legLeft3.render(f5);
-        this.legRight2.render(f5);
-        this.body.render(f5);
-        this.clawLeft1.render(f5);
-        this.legLeft1.render(f5);
-        this.legRight1.render(f5);
-        this.legRight4.render(f5);
-        this.legLeft2.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderWhale.java	(date 1525605768000)
@@ -1,30 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityWhale;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelWhale;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderWhale extends RenderLiving<EntityWhale> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/whale.png");
-
-    public RenderWhale(RenderManager manager)
-    {
-        super(manager, new ModelWhale(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityWhale entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntityWhale entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrownedVillager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrownedVillager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderDrownedVillager.java	(date 1525605768000)
@@ -1,52 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderBiped;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummyVillager;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelMummyVillager;
-
-public class RenderDrownedVillager extends RenderBiped<EntityMummyVillager> {
-    /**
-     * TODO: Change Textures
-     * Set to Zombie Villager for now
-     */
-    private static final ResourceLocation ZOMBIE_VILLAGER_TEXTURES = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_villager.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_FARMER_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_farmer.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_LIBRARIAN_LOC = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_librarian.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_PRIEST_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_priest.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_SMITH_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_smith.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_BUTCHER_LOCATION = new ResourceLocation("minecraft:textures/entity/zombie_villager/zombie_butcher.png");
-
-    public RenderDrownedVillager(RenderManager renderManagerIn) {
-        super(renderManagerIn, new ModelMummyVillager(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityMummyVillager entity) {
-        if (true) return entity.getForgeProfession().getZombieSkin();
-
-        switch (entity.getProfession()) {
-            case 0:
-                return ZOMBIE_VILLAGER_FARMER_LOCATION;
-            case 1:
-                return ZOMBIE_VILLAGER_LIBRARIAN_LOC;
-            case 2:
-                return ZOMBIE_VILLAGER_PRIEST_LOCATION;
-            case 3:
-                return ZOMBIE_VILLAGER_SMITH_LOCATION;
-            case 4:
-                return ZOMBIE_VILLAGER_BUTCHER_LOCATION;
-            case 5:
-            default:
-                return ZOMBIE_VILLAGER_TEXTURES;
-        }
-    }
-
-    @Override
-    protected void applyRotations(EntityMummyVillager entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
-        if (entityLiving.isConverting())
-            rotationYaw += (float)(Math.cos((double)entityLiving.ticksExisted * 3.25D) * Math.PI * 0.25D);
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/commands/BiomeUtils.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/commands/BiomeUtils.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/commands/BiomeUtils.java	(date 1525605768000)
@@ -1,102 +0,0 @@
-package net.thegaminghuskymc.mcaddon.commands;
-
-import java.util.ArrayList;
-import java.util.List;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.biome.BiomeProvider;
-import net.minecraft.world.gen.ChunkGeneratorSettings;
-
-public class BiomeUtils {
-
-	public static List<Biome> getAllowedBiomes() {
-		final List<Biome> biomes = new ArrayList<Biome>();
-		for (Biome biome : Biome.REGISTRY) {
-			if (biome != null) {
-				biomes.add(biome);
-			}
-		}
-
-		return biomes;
-	}
-
-	public static SearchResult searchForBiome(World world, Biome biome, BlockPos startPos) {
-		final int sampleSpace = 16 * getBiomeSize(world);
-		final int maxDistance = 250000 * getBiomeSize(world);
-		if (maxDistance <= 0 || sampleSpace <= 0) {
-			return new SearchResult(0, 0, maxDistance, 0, false);
-		}
-
-		final BiomeProvider biomeProvider = world.getBiomeProvider();
-		int direction = -1;
-		int samples = 0;
-		int nextLength = sampleSpace;
-		int x = startPos.getX();
-		int z = startPos.getZ();
-		while (nextLength / 2 <= maxDistance && samples <= 100000) {
-			final int fixedDirection = direction == -1 ? -1 : direction % 4;
-			for (int i = 0; i < nextLength; i += sampleSpace) {
-				if (fixedDirection == 0) {
-					x += sampleSpace;
-				} else if (fixedDirection == 1) {
-					z -= sampleSpace;
-				} else if (fixedDirection == 2) {
-					x -= sampleSpace;
-				} else if (fixedDirection == 3) {
-					z += sampleSpace;
-				}
-
-				final Biome[] biomes = biomeProvider.getBiomes(null, x, z, 1, 1, false);
-				if (biomes[0] == biome) {
-					return new SearchResult(x, z, nextLength / 2, samples, true);
-				}
-
-				samples++;
-			}
-
-			if (direction >= 0) {
-				nextLength += sampleSpace;
-			}
-			direction++;
-		}
-
-		return new SearchResult(0, 0, nextLength / 2, samples, false);
-	}
-
-	public static int getBiomeSize(World world) {
-		final String settings = world.getWorldInfo().getGeneratorOptions();
-		return ChunkGeneratorSettings.Factory.jsonToFactory(settings).build().biomeSize;
-	}
-
-	public static int getDistanceToBiome(EntityPlayer player, int x, int z) {
-		return (int) player.getDistance(x, player.posY, z);
-	}
-
-	public static String getBiomeName(Biome biome) {
-		if (biome != null) {
-			final String original = biome.getBiomeName();
-			String fixed = "";
-			char pre = ' ';
-			for (int i = 0; i < original.length(); i++) {
-				final char c = original.charAt(i);
-				if (Character.isUpperCase(c) && Character.isLowerCase(pre) && Character.isAlphabetic(pre)) {
-					fixed = fixed + " ";
-				}
-				fixed = fixed + String.valueOf(c);
-				pre = c;
-			}
-
-			return fixed;
-
-		}
-
-		return "";
-	}
-
-	public static String getBiomeName(int biomeID) {
-		return getBiomeName(Biome.getBiomeForId(biomeID));
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenTest.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenTest.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/WorldGenTest.java	(date 1525605768000)
@@ -1,47 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen;
-
-import net.minecraft.block.BlockStone;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.thegaminghuskymc.mcaddon.init.MCAddonBlocks;
-import net.thegaminghuskymc.mcaddon.util.Util;
-import net.thegaminghuskymc.mcaddon.world.*;
-
-import java.util.Random;
-
-public class WorldGenTest extends WorldGenBase {
-    public String structureId;
-    public static final String[] compass = new String[]{"....E....", ".........", "....^....", "....|....", "N.<-O->.S", "....|....", "....v....", ".........", "....W...."};
-
-    public WorldGenTest(float chance) {
-        super(chance);
-        StructureData tower = new StructureData();
-        tower.addBlock("R", Blocks.STONE.getDefaultState().withProperty(BlockStone.VARIANT, BlockStone.EnumType.ANDESITE));
-        tower.addBlock("r", Blocks.NETHERRACK.getDefaultState());
-        tower.addBlock("B", Blocks.STONE.getDefaultState());
-        tower.addBlock("1", Blocks.SOUL_SAND.getDefaultState());
-        tower.addBlock("2", MCAddonBlocks.netherBlocks[0].getDefaultState());
-        tower.addBlock("3", MCAddonBlocks.netherBlocks[3].getDefaultState());
-        tower.addBlock("4", MCAddonBlocks.newStoneVariants[10].getDefaultState());
-        tower.addBlock(" ", Blocks.AIR.getDefaultState());
-        tower.addLayer(new String[]{"BBBBB", "BBBBB", "BBBBB", "BBBBB", "BBBBB"}, 0);
-        tower.addLayer(new String[]{"2   3", "     ", "     ", "     ", "1   4"}, 1);
-        tower.addLayer(new String[]{"2   3", "     ", "     ", "     ", "1   4"}, 2);
-        tower.addLayer(new String[]{"2   3", "     ", "     ", "rrrrr", "RRRRR"}, 3);
-        tower.addLayer(new String[]{"2   3", "     ", "rrrrr", "RRRRR", "     "}, 4);
-        tower.addLayer(new String[]{"2   3", "rrrrr", "RRRRR", "     ", "     "}, 5);
-        tower.addLayer(new String[]{"2rrr3", "RRRRR", "     ", "     ", "     "}, 6);
-        tower.addLayer(new String[]{"RRRRR", "     ", "     ", "     ", "     "}, 7);
-        this.structureId = StructureRegistry.addStructure(Util.getLowercaseClassName(this.getClass()) + "_0", tower);
-    }
-
-    public void generateStruct(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider)
-    {
-        GenerationData.get(world).addNode(new GenerationNode(world.getTopSolidOrLiquidBlock(new BlockPos(chunkX * 16, 64, chunkZ * 16)).down(1), structureId, Rotation.values()[random.nextInt(4)], Mirror.NONE, true));
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenStructure.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenStructure.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenStructure.java	(date 1525605768000)
@@ -1,53 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.generators;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.thegaminghuskymc.mcaddon.util.interfaces.IStructure;
-
-import java.util.Random;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class WorldGenStructure extends WorldGenerator implements IStructure
-{
-	private static String structureName;
-	
-	public WorldGenStructure(String name) 
-	{
-		structureName = name;
-	}
-	
-	@Override
-	public boolean generate(World worldIn, Random rand, BlockPos position) 
-	{
-		generateStructure(worldIn, position);
-		return true;
-	}
-	
-	private static void generateStructure(World world, BlockPos pos)
-	{
-		MinecraftServer mcServer = world.getMinecraftServer();
-		TemplateManager manager = worldServer.getStructureTemplateManager();
-		ResourceLocation location = new ResourceLocation(MOD_ID, structureName);
-		Template template = manager.get(mcServer, location);
-		
-		if(template != null)
-		{
-			IBlockState state = world.getBlockState(pos);
-			world.notifyBlockUpdate(pos, state, state, 3);
-			template.addBlocksToWorldChunk(world, pos, settings);
-		}
-
-        if(template == null)
-        {
-            System.out.println("NO STRUCTURE");
-        }
-
-	}
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldSlabBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldSlabBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldSlabBase.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.material.Material;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockOverworldSlabBase extends BlockModSlab {
-
-    public BlockOverworldSlabBase(String name, boolean isDouble) {
-        super(name, MOD_ID, Material.ROCK, isDouble);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/BlockUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/BlockUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/BlockUtil.java	(date 1525605768000)
@@ -1,220 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.Minecraft;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.player.EntityPlayerMP;
-import net.minecraft.init.Blocks;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.item.ItemStack;
-import net.minecraft.network.play.client.CPacketPlayerDigging;
-import net.minecraft.network.play.server.SPacketBlockChange;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.world.DimensionType;
-import net.minecraft.world.World;
-import net.minecraftforge.common.ForgeHooks;
-import net.minecraftforge.oredict.OreDictionary;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-public class BlockUtil
-{
-    public static IBlockState getBlock(NetherBiome.BiomeBlock block, String fallback)
-    {
-        return Block.getBlockFromName(block.getId() == null || block.getId().isEmpty() || Block.getBlockFromName(block.getId()) == null ? fallback : block.getId()).getStateFromMeta(block.getMeta());
-    }
-
-    public static Block getBlock(String blockId, String fallback)
-    {
-        return Block.getBlockFromName(blockId == null || blockId.isEmpty() || Block.getBlockFromName(blockId) == null ? fallback : blockId);
-    }
-
-    public static boolean mine3x3(World world, ItemStack stack, BlockPos pos, EntityPlayer player)
-    {
-        RayTraceResult traceResult = WorldUtil.rayTraceFromEntity(world, player, false, 4.5D);
-
-        if(traceResult == null)
-        {
-            return true;
-        }
-
-        EnumFacing sideHit = traceResult.sideHit;
-
-        BlockPos startPos;
-        BlockPos endPos;
-
-        if(sideHit.getAxis() == EnumFacing.Axis.X)
-        {
-            startPos = new BlockPos(0, 1, 1);
-            endPos = new BlockPos(0, -1, -1);
-        }
-        else if(sideHit.getAxis() == EnumFacing.Axis.Y)
-        {
-            startPos = new BlockPos(1, 0, 1);
-            endPos = new BlockPos(-1, 0, -1);
-        }
-        else
-        {
-            startPos = new BlockPos(1, 1, 0);
-            endPos = new BlockPos(-1, -1, 0);
-        }
-
-        Iterable<BlockPos> posIter = BlockPos.getAllInBox(startPos, endPos);
-        IBlockState originalState = world.getBlockState(pos);
-        float originalStrength = ForgeHooks.blockStrength(originalState, player, world, pos);
-
-        boolean canHarvestBedrock = false;
-
-        if(originalState.getBlock() == Blocks.BEDROCK)
-        {
-            if(player.dimension == DimensionType.NETHER.getId() && pos.getY() >= 120)
-            {
-                canHarvestBedrock = true;
-            }
-        }
-
-        for(BlockPos testPos : posIter)
-        {
-            testPos = testPos.add(pos);
-
-            if(testPos.equals(pos))
-            {
-                continue;
-            }
-
-            IBlockState testState = world.getBlockState(testPos);
-            float testStrength = ForgeHooks.blockStrength(testState, player, world, testPos);
-            boolean canBeHarvested = ForgeHooks.canHarvestBlock(testState.getBlock(), player, world, testPos);
-
-            if(originalState.getMaterial() == testState.getMaterial() && testStrength > 0.0F && (originalStrength / testStrength) <= 10.0F || canHarvestBedrock)
-            {
-                if(canBeHarvested && stack.canHarvestBlock(originalState) || canBeHarvested)
-                {
-                    BlockUtil.tryToHarvest(world, testState, testPos, player, sideHit);
-                }
-            }
-        }
-
-        if(canHarvestBedrock)
-        {
-            BlockUtil.tryToHarvest(world, originalState, pos, player, sideHit);
-        }
-
-        return false;
-    }
-
-    /**
-     * A method that harvests animations.blocks when they aren't able to normally
-     * <p>
-     * Written by VapourDrive here:
-     * https://github.com/VapourDrive/Hammerz/blob/55d31b8f8fd463d127110de04b2562605604e85c/src/main/java/vapourdrive/hammerz/utils/BlockUtils.java#L21
-     *
-     * @author VapourDrive
-     */
-    public static boolean tryToHarvest(World world, IBlockState state, BlockPos pos, EntityPlayer player, EnumFacing side)
-    {
-        Block block = state.getBlock();
-
-        if(world.isAirBlock(pos))
-        {
-            return false;
-        }
-
-        EntityPlayerMP playerMP = null;
-
-        if(player instanceof EntityPlayerMP)
-        {
-            playerMP = (EntityPlayerMP) player;
-        }
-
-        ItemStack stack = player.getHeldItemMainhand();
-
-        if(!(stack.getItem().getToolClasses(stack).contains(block.getHarvestTool(state)) || stack.getItem().getDestroySpeed(stack, state) > 1.0F))
-        {
-            return false;
-        }
-        if(!ForgeHooks.canHarvestBlock(block, player, world, pos))
-        {
-
-            return false;
-        }
-
-        int event = 0;
-
-        if(playerMP != null)
-        {
-            event = ForgeHooks.onBlockBreakEvent(world, world.getWorldInfo().getGameType(), playerMP, pos);
-
-            if(event == -1)
-            {
-                return false;
-            }
-        }
-
-        world.playEvent(playerMP, 2001, pos, Block.getStateId(state));
-
-
-        if(player.capabilities.isCreativeMode)
-        {
-            if(!world.isRemote)
-            {
-                block.onBlockHarvested(world, pos, state, player);
-            }
-            if(block.removedByPlayer(state, world, pos, player, false))
-            {
-                block.onBlockDestroyedByPlayer(world, pos, state);
-            }
-            if(!world.isRemote)
-            {
-                playerMP.connection.sendPacket(new SPacketBlockChange(world, pos));
-            }
-            else
-            {
-                Minecraft.getMinecraft().getConnection().sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, side));
-            }
-            return true;
-        }
-        if(!world.isRemote)
-        {
-            block.onBlockHarvested(world, pos, state, player);
-
-            if(block.removedByPlayer(state, world, pos, player, true))
-            {
-                block.onBlockDestroyedByPlayer(world, pos, state);
-                block.harvestBlock(world, player, pos, state, null, stack);
-                block.dropXpOnBlockBreak(world, pos, event);
-            }
-
-            playerMP.connection.sendPacket(new SPacketBlockChange(world, pos));
-        }
-        else
-        {
-            if(block.removedByPlayer(state, world, pos, player, true))
-            {
-                block.onBlockDestroyedByPlayer(world, pos, state);
-            }
-
-            Minecraft.getMinecraft().getConnection().sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, side));
-        }
-        return true;
-    }
-
-
-    public static boolean isOreDict(String id, Block block)
-    {
-        for(ItemStack stack : OreDictionary.getOres(id))
-        {
-            if(stack.getItem() instanceof ItemBlock)
-            {
-                if(((ItemBlock) stack.getItem()).getBlock() == block)
-                {
-                    return true;
-                }
-            }
-        }
-
-        return false;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureNetherBridgePieces.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureNetherBridgePieces.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureNetherBridgePieces.java	(date 1525605768000)
@@ -1,1531 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.structure;
-
-import com.google.common.collect.Lists;
-import net.minecraft.block.BlockStairs;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.EntityList;
-import net.minecraft.entity.monster.EntityBlaze;
-import net.minecraft.init.Blocks;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityMobSpawner;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.structure.MapGenStructureIO;
-import net.minecraft.world.gen.structure.StructureBoundingBox;
-import net.minecraft.world.gen.structure.StructureComponent;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.minecraft.world.storage.loot.LootTableList;
-
-import javax.annotation.Nullable;
-import java.util.List;
-import java.util.Random;
-
-@SuppressWarnings("incomplete-switch")
-public class StructureNetherBridgePieces
-{
-    private static final StructureNetherBridgePieces.PieceWeight[] PRIMARY_COMPONENTS = new StructureNetherBridgePieces.PieceWeight[] {new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Straight.class, 30, 0, true), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Crossing3.class, 10, 4), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Crossing.class, 10, 4), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Stairs.class, 10, 3), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Throne.class, 5, 2), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Entrance.class, 5, 1)};
-    private static final StructureNetherBridgePieces.PieceWeight[] SECONDARY_COMPONENTS = new StructureNetherBridgePieces.PieceWeight[] {new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Corridor5.class, 25, 0, true), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Crossing2.class, 15, 5), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Corridor2.class, 5, 10), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Corridor.class, 5, 10), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Corridor3.class, 10, 3, true), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.Corridor4.class, 7, 2), new StructureNetherBridgePieces.PieceWeight(StructureNetherBridgePieces.NetherStalkRoom.class, 5, 2)};
-
-    public static void registerNetherFortressPieces()
-    {
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Crossing3.class, "NeBCr");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.End.class, "NeBEF");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Straight.class, "NeBS");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Corridor3.class, "NeCCS");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Corridor4.class, "NeCTB");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Entrance.class, "NeCE");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Crossing2.class, "NeSCSC");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Corridor.class, "NeSCLT");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Corridor5.class, "NeSC");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Corridor2.class, "NeSCRT");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.NetherStalkRoom.class, "NeCSR");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Throne.class, "NeMT");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Crossing.class, "NeRC");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Stairs.class, "NeSR");
-        MapGenStructureIO.registerStructureComponent(StructureNetherBridgePieces.Start.class, "NeStart");
-    }
-
-    private static StructureNetherBridgePieces.Piece findAndCreateBridgePieceFactory(StructureNetherBridgePieces.PieceWeight p_175887_0_, List<StructureComponent> p_175887_1_, Random p_175887_2_, int p_175887_3_, int p_175887_4_, int p_175887_5_, EnumFacing p_175887_6_, int p_175887_7_)
-    {
-        Class <? extends StructureNetherBridgePieces.Piece > oclass = p_175887_0_.weightClass;
-        StructureNetherBridgePieces.Piece structurenetherbridgepieces$piece = null;
-
-        if (oclass == StructureNetherBridgePieces.Straight.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Straight.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Crossing3.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Crossing3.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Crossing.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Crossing.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Stairs.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Stairs.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_7_, p_175887_6_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Throne.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Throne.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_7_, p_175887_6_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Entrance.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Entrance.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Corridor5.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Corridor5.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Corridor2.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Corridor2.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Corridor.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Corridor.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Corridor3.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Corridor3.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Corridor4.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Corridor4.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.Crossing2.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.Crossing2.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-        else if (oclass == StructureNetherBridgePieces.NetherStalkRoom.class)
-        {
-            structurenetherbridgepieces$piece = StructureNetherBridgePieces.NetherStalkRoom.createPiece(p_175887_1_, p_175887_2_, p_175887_3_, p_175887_4_, p_175887_5_, p_175887_6_, p_175887_7_);
-        }
-
-        return structurenetherbridgepieces$piece;
-    }
-
-    public static class Corridor extends StructureNetherBridgePieces.Piece
-        {
-            private boolean chest;
-
-            public Corridor()
-            {
-            }
-
-            public Corridor(int p_i45615_1_, Random p_i45615_2_, StructureBoundingBox p_i45615_3_, EnumFacing p_i45615_4_)
-            {
-                super(p_i45615_1_);
-                this.setCoordBaseMode(p_i45615_4_);
-                this.boundingBox = p_i45615_3_;
-                this.chest = p_i45615_2_.nextInt(3) == 0;
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.chest = tagCompound.getBoolean("Chest");
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setBoolean("Chest", this.chest);
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentX((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 1, true);
-            }
-
-            public static StructureNetherBridgePieces.Corridor createPiece(List<StructureComponent> p_175879_0_, Random p_175879_1_, int p_175879_2_, int p_175879_3_, int p_175879_4_, EnumFacing p_175879_5_, int p_175879_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175879_2_, p_175879_3_, p_175879_4_, -1, 0, 0, 5, 7, 5, p_175879_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175879_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Corridor(p_175879_6_, p_175879_1_, structureboundingbox, p_175879_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 4, 1, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 4, 5, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 4, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 1, 4, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 3, 4, 4, 3, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 0, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 4, 3, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 3, 4, 1, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 3, 3, 4, 3, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                if (this.chest && structureBoundingBoxIn.isVecInside(new BlockPos(this.getXWithOffset(3, 3), this.getYWithOffset(2), this.getZWithOffset(3, 3))))
-                {
-                    this.chest = false;
-                    this.generateChest(worldIn, structureBoundingBoxIn, randomIn, 3, 2, 3, LootTableList.CHESTS_NETHER_BRIDGE);
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 0, 4, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 0; j <= 4; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Corridor2 extends StructureNetherBridgePieces.Piece
-        {
-            private boolean chest;
-
-            public Corridor2()
-            {
-            }
-
-            public Corridor2(int p_i45613_1_, Random p_i45613_2_, StructureBoundingBox p_i45613_3_, EnumFacing p_i45613_4_)
-            {
-                super(p_i45613_1_);
-                this.setCoordBaseMode(p_i45613_4_);
-                this.boundingBox = p_i45613_3_;
-                this.chest = p_i45613_2_.nextInt(3) == 0;
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.chest = tagCompound.getBoolean("Chest");
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setBoolean("Chest", this.chest);
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 1, true);
-            }
-
-            public static StructureNetherBridgePieces.Corridor2 createPiece(List<StructureComponent> p_175876_0_, Random p_175876_1_, int p_175876_2_, int p_175876_3_, int p_175876_4_, EnumFacing p_175876_5_, int p_175876_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175876_2_, p_175876_3_, p_175876_4_, -1, 0, 0, 5, 7, 5, p_175876_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175876_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Corridor2(p_175876_6_, p_175876_1_, structureboundingbox, p_175876_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 4, 1, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 4, 5, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 0, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 1, 0, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 3, 0, 4, 3, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 4, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 2, 4, 4, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 3, 4, 1, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 3, 3, 4, 3, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                if (this.chest && structureBoundingBoxIn.isVecInside(new BlockPos(this.getXWithOffset(1, 3), this.getYWithOffset(2), this.getZWithOffset(1, 3))))
-                {
-                    this.chest = false;
-                    this.generateChest(worldIn, structureBoundingBoxIn, randomIn, 1, 2, 3, LootTableList.CHESTS_NETHER_BRIDGE);
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 0, 4, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 0; j <= 4; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Corridor3 extends StructureNetherBridgePieces.Piece
-        {
-            public Corridor3()
-            {
-            }
-
-            public Corridor3(int p_i45619_1_, Random p_i45619_2_, StructureBoundingBox p_i45619_3_, EnumFacing p_i45619_4_)
-            {
-                super(p_i45619_1_);
-                this.setCoordBaseMode(p_i45619_4_);
-                this.boundingBox = p_i45619_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 1, 0, true);
-            }
-
-            public static StructureNetherBridgePieces.Corridor3 createPiece(List<StructureComponent> p_175883_0_, Random p_175883_1_, int p_175883_2_, int p_175883_3_, int p_175883_4_, EnumFacing p_175883_5_, int p_175883_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175883_2_, p_175883_3_, p_175883_4_, -1, -7, 0, 5, 14, 10, p_175883_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175883_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Corridor3(p_175883_6_, p_175883_1_, structureboundingbox, p_175883_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                IBlockState iblockstate = Blocks.NETHER_BRICK_STAIRS.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.SOUTH);
-
-                for (int i = 0; i <= 9; ++i)
-                {
-                    int j = Math.max(1, 7 - i);
-                    int k = Math.min(Math.max(j + 5, 14 - i), 13);
-                    int l = i;
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, i, 4, j, i, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, j + 1, i, 3, k - 1, i, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-
-                    if (i <= 6)
-                    {
-                        this.setBlockState(worldIn, iblockstate, 1, j + 1, i, structureBoundingBoxIn);
-                        this.setBlockState(worldIn, iblockstate, 2, j + 1, i, structureBoundingBoxIn);
-                        this.setBlockState(worldIn, iblockstate, 3, j + 1, i, structureBoundingBoxIn);
-                    }
-
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, k, i, 4, k, i, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, j + 1, i, 0, k - 1, i, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, j + 1, i, 4, k - 1, i, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                    if ((i & 1) == 0)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, j + 2, i, 0, j + 3, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, j + 2, i, 4, j + 3, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    }
-
-                    for (int i1 = 0; i1 <= 4; ++i1)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i1, -1, l, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Corridor4 extends StructureNetherBridgePieces.Piece
-        {
-            public Corridor4()
-            {
-            }
-
-            public Corridor4(int p_i45618_1_, Random p_i45618_2_, StructureBoundingBox p_i45618_3_, EnumFacing p_i45618_4_)
-            {
-                super(p_i45618_1_);
-                this.setCoordBaseMode(p_i45618_4_);
-                this.boundingBox = p_i45618_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                int i = 1;
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing == EnumFacing.WEST || enumfacing == EnumFacing.NORTH)
-                {
-                    i = 5;
-                }
-
-                this.getNextComponentX((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, i, rand.nextInt(8) > 0);
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, i, rand.nextInt(8) > 0);
-            }
-
-            public static StructureNetherBridgePieces.Corridor4 createPiece(List<StructureComponent> p_175880_0_, Random p_175880_1_, int p_175880_2_, int p_175880_3_, int p_175880_4_, EnumFacing p_175880_5_, int p_175880_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175880_2_, p_175880_3_, p_175880_4_, -3, 0, 0, 9, 7, 9, p_175880_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175880_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Corridor4(p_175880_6_, p_175880_1_, structureboundingbox, p_175880_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 8, 1, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 8, 5, 8, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 0, 8, 6, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 2, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 2, 0, 8, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 3, 0, 1, 4, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 3, 0, 7, 4, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 4, 8, 2, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 1, 4, 2, 2, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 1, 4, 7, 2, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 8, 8, 3, 8, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 6, 0, 3, 7, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 3, 6, 8, 3, 7, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 4, 0, 5, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 3, 4, 8, 5, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 3, 5, 2, 5, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 3, 5, 7, 5, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 4, 5, 1, 5, 5, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 4, 5, 7, 5, 5, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-
-                for (int i = 0; i <= 5; ++i)
-                {
-                    for (int j = 0; j <= 8; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), j, -1, i, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Corridor5 extends StructureNetherBridgePieces.Piece
-        {
-            public Corridor5()
-            {
-            }
-
-            public Corridor5(int p_i45614_1_, Random p_i45614_2_, StructureBoundingBox p_i45614_3_, EnumFacing p_i45614_4_)
-            {
-                super(p_i45614_1_);
-                this.setCoordBaseMode(p_i45614_4_);
-                this.boundingBox = p_i45614_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 1, 0, true);
-            }
-
-            public static StructureNetherBridgePieces.Corridor5 createPiece(List<StructureComponent> p_175877_0_, Random p_175877_1_, int p_175877_2_, int p_175877_3_, int p_175877_4_, EnumFacing p_175877_5_, int p_175877_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175877_2_, p_175877_3_, p_175877_4_, -1, 0, 0, 5, 7, 5, p_175877_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175877_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Corridor5(p_175877_6_, p_175877_1_, structureboundingbox, p_175877_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 4, 1, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 4, 5, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 0, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 4, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 1, 0, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 3, 0, 4, 3, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 1, 4, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 3, 4, 4, 3, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 0, 4, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 0; j <= 4; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Crossing extends StructureNetherBridgePieces.Piece
-        {
-            public Crossing()
-            {
-            }
-
-            public Crossing(int p_i45610_1_, Random p_i45610_2_, StructureBoundingBox p_i45610_3_, EnumFacing p_i45610_4_)
-            {
-                super(p_i45610_1_);
-                this.setCoordBaseMode(p_i45610_4_);
-                this.boundingBox = p_i45610_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 2, 0, false);
-                this.getNextComponentX((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 2, false);
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 2, false);
-            }
-
-            public static StructureNetherBridgePieces.Crossing createPiece(List<StructureComponent> p_175873_0_, Random p_175873_1_, int p_175873_2_, int p_175873_3_, int p_175873_4_, EnumFacing p_175873_5_, int p_175873_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175873_2_, p_175873_3_, p_175873_4_, -2, 0, 0, 7, 9, 7, p_175873_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175873_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Crossing(p_175873_6_, p_175873_1_, structureboundingbox, p_175873_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 6, 1, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 6, 7, 6, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 1, 6, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 6, 1, 6, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 2, 0, 6, 6, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 2, 6, 6, 6, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 0, 6, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 5, 0, 6, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 2, 0, 6, 6, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 2, 5, 6, 6, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 6, 0, 4, 6, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 0, 4, 5, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 6, 6, 4, 6, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 6, 4, 5, 6, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 2, 0, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 2, 0, 5, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 6, 2, 6, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 5, 2, 6, 5, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-
-                for (int i = 0; i <= 6; ++i)
-                {
-                    for (int j = 0; j <= 6; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Crossing2 extends StructureNetherBridgePieces.Piece
-        {
-            public Crossing2()
-            {
-            }
-
-            public Crossing2(int p_i45616_1_, Random p_i45616_2_, StructureBoundingBox p_i45616_3_, EnumFacing p_i45616_4_)
-            {
-                super(p_i45616_1_);
-                this.setCoordBaseMode(p_i45616_4_);
-                this.boundingBox = p_i45616_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 1, 0, true);
-                this.getNextComponentX((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 1, true);
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 0, 1, true);
-            }
-
-            public static StructureNetherBridgePieces.Crossing2 createPiece(List<StructureComponent> p_175878_0_, Random p_175878_1_, int p_175878_2_, int p_175878_3_, int p_175878_4_, EnumFacing p_175878_5_, int p_175878_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175878_2_, p_175878_3_, p_175878_4_, -1, 0, 0, 5, 7, 5, p_175878_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175878_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Crossing2(p_175878_6_, p_175878_1_, structureboundingbox, p_175878_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 4, 1, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 4, 5, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 0, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 4, 5, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 4, 0, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 4, 4, 5, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 0, 4, 6, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 0; j <= 4; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Crossing3 extends StructureNetherBridgePieces.Piece
-        {
-            public Crossing3()
-            {
-            }
-
-            public Crossing3(int p_i45622_1_, Random p_i45622_2_, StructureBoundingBox p_i45622_3_, EnumFacing p_i45622_4_)
-            {
-                super(p_i45622_1_);
-                this.setCoordBaseMode(p_i45622_4_);
-                this.boundingBox = p_i45622_3_;
-            }
-
-            protected Crossing3(Random p_i2042_1_, int p_i2042_2_, int p_i2042_3_)
-            {
-                super(0);
-                this.setCoordBaseMode(EnumFacing.Plane.HORIZONTAL.random(p_i2042_1_));
-
-                if (this.getCoordBaseMode().getAxis() == EnumFacing.Axis.Z)
-                {
-                    this.boundingBox = new StructureBoundingBox(p_i2042_2_, 64, p_i2042_3_, p_i2042_2_ + 19 - 1, 73, p_i2042_3_ + 19 - 1);
-                }
-                else
-                {
-                    this.boundingBox = new StructureBoundingBox(p_i2042_2_, 64, p_i2042_3_, p_i2042_2_ + 19 - 1, 73, p_i2042_3_ + 19 - 1);
-                }
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 8, 3, false);
-                this.getNextComponentX((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 3, 8, false);
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 3, 8, false);
-            }
-
-            public static StructureNetherBridgePieces.Crossing3 createPiece(List<StructureComponent> p_175885_0_, Random p_175885_1_, int p_175885_2_, int p_175885_3_, int p_175885_4_, EnumFacing p_175885_5_, int p_175885_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175885_2_, p_175885_3_, p_175885_4_, -8, -3, 0, 19, 10, 19, p_175885_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175885_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Crossing3(p_175885_6_, p_175885_1_, structureboundingbox, p_175885_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 3, 0, 11, 4, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 7, 18, 4, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 0, 10, 7, 18, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 8, 18, 7, 10, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 5, 0, 7, 5, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 5, 11, 7, 5, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 0, 11, 5, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 11, 11, 5, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 7, 7, 5, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 7, 18, 5, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 11, 7, 5, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 11, 18, 5, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 2, 0, 11, 2, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 2, 13, 11, 2, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 0, 0, 11, 1, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 0, 15, 11, 1, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 7; i <= 11; ++i)
-                {
-                    for (int j = 0; j <= 2; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, 18 - j, structureBoundingBoxIn);
-                    }
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 7, 5, 2, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 13, 2, 7, 18, 2, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 7, 3, 1, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 15, 0, 7, 18, 1, 11, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int k = 0; k <= 2; ++k)
-                {
-                    for (int l = 7; l <= 11; ++l)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), k, -1, l, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 18 - k, -1, l, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class End extends StructureNetherBridgePieces.Piece
-        {
-            private int fillSeed;
-
-            public End()
-            {
-            }
-
-            public End(int p_i45621_1_, Random p_i45621_2_, StructureBoundingBox p_i45621_3_, EnumFacing p_i45621_4_)
-            {
-                super(p_i45621_1_);
-                this.setCoordBaseMode(p_i45621_4_);
-                this.boundingBox = p_i45621_3_;
-                this.fillSeed = p_i45621_2_.nextInt();
-            }
-
-            public static StructureNetherBridgePieces.End createPiece(List<StructureComponent> p_175884_0_, Random p_175884_1_, int p_175884_2_, int p_175884_3_, int p_175884_4_, EnumFacing p_175884_5_, int p_175884_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175884_2_, p_175884_3_, p_175884_4_, -1, -3, 0, 5, 10, 8, p_175884_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175884_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.End(p_175884_6_, p_175884_1_, structureboundingbox, p_175884_5_) : null;
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.fillSeed = tagCompound.getInteger("Seed");
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setInteger("Seed", this.fillSeed);
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                Random random = new Random((long)this.fillSeed);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 3; j <= 4; ++j)
-                    {
-                        int k = random.nextInt(8);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, i, j, 0, i, j, k, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    }
-                }
-
-                int l = random.nextInt(8);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 0, 5, l, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                l = random.nextInt(8);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 5, 0, 4, 5, l, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i1 = 0; i1 <= 4; ++i1)
-                {
-                    int k1 = random.nextInt(5);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, i1, 2, 0, i1, 2, k1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                }
-
-                for (int j1 = 0; j1 <= 4; ++j1)
-                {
-                    for (int l1 = 0; l1 <= 1; ++l1)
-                    {
-                        int i2 = random.nextInt(3);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, j1, l1, 0, j1, l1, i2, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Entrance extends StructureNetherBridgePieces.Piece
-        {
-            public Entrance()
-            {
-            }
-
-            public Entrance(int p_i45617_1_, Random p_i45617_2_, StructureBoundingBox p_i45617_3_, EnumFacing p_i45617_4_)
-            {
-                super(p_i45617_1_);
-                this.setCoordBaseMode(p_i45617_4_);
-                this.boundingBox = p_i45617_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 5, 3, true);
-            }
-
-            public static StructureNetherBridgePieces.Entrance createPiece(List<StructureComponent> p_175881_0_, Random p_175881_1_, int p_175881_2_, int p_175881_3_, int p_175881_4_, EnumFacing p_175881_5_, int p_175881_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175881_2_, p_175881_3_, p_175881_4_, -5, -3, 0, 13, 14, 13, p_175881_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175881_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Entrance(p_175881_6_, p_175881_1_, structureboundingbox, p_175881_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 0, 12, 4, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 12, 13, 12, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 1, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 0, 12, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 11, 4, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 11, 10, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 9, 11, 7, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 0, 4, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 0, 10, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 9, 0, 7, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 11, 2, 10, 12, 10, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 8, 0, 7, 8, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-
-                for (int i = 1; i <= 11; i += 2)
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, i, 10, 0, i, 11, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, i, 10, 12, i, 11, 12, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 10, i, 0, 11, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 12, 10, i, 12, 11, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, 13, 0, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, 13, 12, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 0, 13, i, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 12, 13, i, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), i + 1, 13, 0, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), i + 1, 13, 12, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, i + 1, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 12, 13, i + 1, structureBoundingBoxIn);
-                }
-
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 0, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 12, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 0, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 12, 13, 0, structureBoundingBoxIn);
-
-                for (int k = 3; k <= 9; k += 2)
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 7, k, 1, 8, k, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 7, k, 11, 8, k, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 8, 2, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 4, 12, 2, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 0, 0, 8, 1, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 0, 9, 8, 1, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 4, 3, 1, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 9, 0, 4, 12, 1, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int l = 4; l <= 8; ++l)
-                {
-                    for (int j = 0; j <= 2; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), l, -1, j, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), l, -1, 12 - j, structureBoundingBoxIn);
-                    }
-                }
-
-                for (int i1 = 0; i1 <= 2; ++i1)
-                {
-                    for (int j1 = 4; j1 <= 8; ++j1)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i1, -1, j1, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 12 - i1, -1, j1, structureBoundingBoxIn);
-                    }
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 5, 5, 7, 5, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 1, 6, 6, 4, 6, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 6, 0, 6, structureBoundingBoxIn);
-                IBlockState iblockstate = Blocks.FLOWING_LAVA.getDefaultState();
-                this.setBlockState(worldIn, iblockstate, 6, 5, 6, structureBoundingBoxIn);
-                BlockPos blockpos = new BlockPos(this.getXWithOffset(6, 6), this.getYWithOffset(5), this.getZWithOffset(6, 6));
-
-                if (structureBoundingBoxIn.isVecInside(blockpos))
-                {
-                    worldIn.immediateBlockTick(blockpos, iblockstate, randomIn);
-                }
-
-                return true;
-            }
-        }
-
-    public static class NetherStalkRoom extends StructureNetherBridgePieces.Piece
-        {
-            public NetherStalkRoom()
-            {
-            }
-
-            public NetherStalkRoom(int p_i45612_1_, Random p_i45612_2_, StructureBoundingBox p_i45612_3_, EnumFacing p_i45612_4_)
-            {
-                super(p_i45612_1_);
-                this.setCoordBaseMode(p_i45612_4_);
-                this.boundingBox = p_i45612_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 5, 3, true);
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 5, 11, true);
-            }
-
-            public static StructureNetherBridgePieces.NetherStalkRoom createPiece(List<StructureComponent> p_175875_0_, Random p_175875_1_, int p_175875_2_, int p_175875_3_, int p_175875_4_, EnumFacing p_175875_5_, int p_175875_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175875_2_, p_175875_3_, p_175875_4_, -5, -3, 0, 13, 14, 13, p_175875_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175875_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.NetherStalkRoom(p_175875_6_, p_175875_1_, structureboundingbox, p_175875_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 0, 12, 4, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 12, 13, 12, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 1, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 5, 0, 12, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 11, 4, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 11, 10, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 9, 11, 7, 12, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 0, 4, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 0, 10, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 9, 0, 7, 12, 1, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 11, 2, 10, 12, 10, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 1; i <= 11; i += 2)
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, i, 10, 0, i, 11, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, i, 10, 12, i, 11, 12, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 10, i, 0, 11, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 12, 10, i, 12, 11, i, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, 13, 0, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, 13, 12, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 0, 13, i, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 12, 13, i, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), i + 1, 13, 0, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), i + 1, 13, 12, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, i + 1, structureBoundingBoxIn);
-                    this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 12, 13, i + 1, structureBoundingBoxIn);
-                }
-
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 0, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 12, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 0, 13, 0, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 12, 13, 0, structureBoundingBoxIn);
-
-                for (int j1 = 3; j1 <= 9; j1 += 2)
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 7, j1, 1, 8, j1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 11, 7, j1, 11, 8, j1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                }
-
-                IBlockState iblockstate = Blocks.NETHER_BRICK_STAIRS.getDefaultState().withProperty(BlockStairs.FACING, EnumFacing.NORTH);
-
-                for (int j = 0; j <= 6; ++j)
-                {
-                    int k = j + 4;
-
-                    for (int l = 5; l <= 7; ++l)
-                    {
-                        this.setBlockState(worldIn, iblockstate, l, 5 + j, k, structureBoundingBoxIn);
-                    }
-
-                    if (k >= 5 && k <= 8)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 5, k, 7, j + 4, k, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    }
-                    else if (k >= 9 && k <= 10)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 8, k, 7, j + 4, k, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                    }
-
-                    if (j >= 1)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 6 + j, k, 7, 9 + j, k, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    }
-                }
-
-                for (int k1 = 5; k1 <= 7; ++k1)
-                {
-                    this.setBlockState(worldIn, iblockstate, k1, 12, 11, structureBoundingBoxIn);
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 6, 7, 5, 7, 7, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 7, 6, 7, 7, 7, 7, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 13, 12, 7, 13, 12, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 2, 3, 5, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 9, 3, 5, 10, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 4, 2, 5, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 9, 5, 2, 10, 5, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 9, 5, 9, 10, 5, 10, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 10, 5, 4, 10, 5, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                IBlockState iblockstate1 = iblockstate.withProperty(BlockStairs.FACING, EnumFacing.EAST);
-                IBlockState iblockstate2 = iblockstate.withProperty(BlockStairs.FACING, EnumFacing.WEST);
-                this.setBlockState(worldIn, iblockstate2, 4, 5, 2, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate2, 4, 5, 3, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate2, 4, 5, 9, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate2, 4, 5, 10, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate1, 8, 5, 2, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate1, 8, 5, 3, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate1, 8, 5, 9, structureBoundingBoxIn);
-                this.setBlockState(worldIn, iblockstate1, 8, 5, 10, structureBoundingBoxIn);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 3, 4, 4, 4, 4, 8, Blocks.SOUL_SAND.getDefaultState(), Blocks.SOUL_SAND.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 4, 4, 9, 4, 8, Blocks.SOUL_SAND.getDefaultState(), Blocks.SOUL_SAND.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 3, 5, 4, 4, 5, 8, Blocks.NETHER_WART.getDefaultState(), Blocks.NETHER_WART.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 8, 5, 4, 9, 5, 8, Blocks.NETHER_WART.getDefaultState(), Blocks.NETHER_WART.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 0, 8, 2, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 4, 12, 2, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 0, 0, 8, 1, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 0, 9, 8, 1, 12, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 4, 3, 1, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 9, 0, 4, 12, 1, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int l1 = 4; l1 <= 8; ++l1)
-                {
-                    for (int i1 = 0; i1 <= 2; ++i1)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), l1, -1, i1, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), l1, -1, 12 - i1, structureBoundingBoxIn);
-                    }
-                }
-
-                for (int i2 = 0; i2 <= 2; ++i2)
-                {
-                    for (int j2 = 4; j2 <= 8; ++j2)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i2, -1, j2, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 12 - i2, -1, j2, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    abstract static class Piece extends StructureComponent
-        {
-            public Piece()
-            {
-            }
-
-            protected Piece(int p_i2054_1_)
-            {
-                super(p_i2054_1_);
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-            }
-
-            private int getTotalWeight(List<StructureNetherBridgePieces.PieceWeight> p_74960_1_)
-            {
-                boolean flag = false;
-                int i = 0;
-
-                for (StructureNetherBridgePieces.PieceWeight structurenetherbridgepieces$pieceweight : p_74960_1_)
-                {
-                    if (structurenetherbridgepieces$pieceweight.maxPlaceCount > 0 && structurenetherbridgepieces$pieceweight.placeCount < structurenetherbridgepieces$pieceweight.maxPlaceCount)
-                    {
-                        flag = true;
-                    }
-
-                    i += structurenetherbridgepieces$pieceweight.weight;
-                }
-
-                return flag ? i : -1;
-            }
-
-            private StructureNetherBridgePieces.Piece generatePiece(StructureNetherBridgePieces.Start p_175871_1_, List<StructureNetherBridgePieces.PieceWeight> p_175871_2_, List<StructureComponent> p_175871_3_, Random p_175871_4_, int p_175871_5_, int p_175871_6_, int p_175871_7_, EnumFacing p_175871_8_, int p_175871_9_)
-            {
-                int i = this.getTotalWeight(p_175871_2_);
-                boolean flag = i > 0 && p_175871_9_ <= 30;
-                int j = 0;
-
-                while (j < 5 && flag)
-                {
-                    ++j;
-                    int k = p_175871_4_.nextInt(i);
-
-                    for (StructureNetherBridgePieces.PieceWeight structurenetherbridgepieces$pieceweight : p_175871_2_)
-                    {
-                        k -= structurenetherbridgepieces$pieceweight.weight;
-
-                        if (k < 0)
-                        {
-                            if (!structurenetherbridgepieces$pieceweight.doPlace(p_175871_9_) || structurenetherbridgepieces$pieceweight == p_175871_1_.lastPlaced && !structurenetherbridgepieces$pieceweight.allowInRow)
-                            {
-                                break;
-                            }
-
-                            StructureNetherBridgePieces.Piece structurenetherbridgepieces$piece = StructureNetherBridgePieces.findAndCreateBridgePieceFactory(structurenetherbridgepieces$pieceweight, p_175871_3_, p_175871_4_, p_175871_5_, p_175871_6_, p_175871_7_, p_175871_8_, p_175871_9_);
-
-                            if (structurenetherbridgepieces$piece != null)
-                            {
-                                ++structurenetherbridgepieces$pieceweight.placeCount;
-                                p_175871_1_.lastPlaced = structurenetherbridgepieces$pieceweight;
-
-                                if (!structurenetherbridgepieces$pieceweight.isValid())
-                                {
-                                    p_175871_2_.remove(structurenetherbridgepieces$pieceweight);
-                                }
-
-                                return structurenetherbridgepieces$piece;
-                            }
-                        }
-                    }
-                }
-
-                return StructureNetherBridgePieces.End.createPiece(p_175871_3_, p_175871_4_, p_175871_5_, p_175871_6_, p_175871_7_, p_175871_8_, p_175871_9_);
-            }
-
-            private StructureComponent generateAndAddPiece(StructureNetherBridgePieces.Start p_175870_1_, List<StructureComponent> p_175870_2_, Random p_175870_3_, int p_175870_4_, int p_175870_5_, int p_175870_6_, @Nullable EnumFacing p_175870_7_, int p_175870_8_, boolean p_175870_9_)
-            {
-                if (Math.abs(p_175870_4_ - p_175870_1_.getBoundingBox().minX) <= 112 && Math.abs(p_175870_6_ - p_175870_1_.getBoundingBox().minZ) <= 112)
-                {
-                    List<StructureNetherBridgePieces.PieceWeight> list = p_175870_1_.primaryWeights;
-
-                    if (p_175870_9_)
-                    {
-                        list = p_175870_1_.secondaryWeights;
-                    }
-
-                    StructureComponent structurecomponent = this.generatePiece(p_175870_1_, list, p_175870_2_, p_175870_3_, p_175870_4_, p_175870_5_, p_175870_6_, p_175870_7_, p_175870_8_ + 1);
-
-                    if (structurecomponent != null)
-                    {
-                        p_175870_2_.add(structurecomponent);
-                        p_175870_1_.pendingChildren.add(structurecomponent);
-                    }
-
-                    return structurecomponent;
-                }
-                else
-                {
-                    return StructureNetherBridgePieces.End.createPiece(p_175870_2_, p_175870_3_, p_175870_4_, p_175870_5_, p_175870_6_, p_175870_7_, p_175870_8_);
-                }
-            }
-
-            /**
-             * Gets the next component in any cardinal direction
-             */
-            @Nullable
-            protected StructureComponent getNextComponentNormal(StructureNetherBridgePieces.Start p_74963_1_, List<StructureComponent> p_74963_2_, Random p_74963_3_, int p_74963_4_, int p_74963_5_, boolean p_74963_6_)
-            {
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing != null)
-                {
-                    switch (enumfacing)
-                    {
-                        case NORTH:
-                            return this.generateAndAddPiece(p_74963_1_, p_74963_2_, p_74963_3_, this.boundingBox.minX + p_74963_4_, this.boundingBox.minY + p_74963_5_, this.boundingBox.minZ - 1, enumfacing, this.getComponentType(), p_74963_6_);
-                        case SOUTH:
-                            return this.generateAndAddPiece(p_74963_1_, p_74963_2_, p_74963_3_, this.boundingBox.minX + p_74963_4_, this.boundingBox.minY + p_74963_5_, this.boundingBox.maxZ + 1, enumfacing, this.getComponentType(), p_74963_6_);
-                        case WEST:
-                            return this.generateAndAddPiece(p_74963_1_, p_74963_2_, p_74963_3_, this.boundingBox.minX - 1, this.boundingBox.minY + p_74963_5_, this.boundingBox.minZ + p_74963_4_, enumfacing, this.getComponentType(), p_74963_6_);
-                        case EAST:
-                            return this.generateAndAddPiece(p_74963_1_, p_74963_2_, p_74963_3_, this.boundingBox.maxX + 1, this.boundingBox.minY + p_74963_5_, this.boundingBox.minZ + p_74963_4_, enumfacing, this.getComponentType(), p_74963_6_);
-                    }
-                }
-
-                return null;
-            }
-
-            /**
-             * Gets the next component in the +/- X direction
-             */
-            @Nullable
-            protected StructureComponent getNextComponentX(StructureNetherBridgePieces.Start p_74961_1_, List<StructureComponent> p_74961_2_, Random p_74961_3_, int p_74961_4_, int p_74961_5_, boolean p_74961_6_)
-            {
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing != null)
-                {
-                    switch (enumfacing)
-                    {
-                        case NORTH:
-                            return this.generateAndAddPiece(p_74961_1_, p_74961_2_, p_74961_3_, this.boundingBox.minX - 1, this.boundingBox.minY + p_74961_4_, this.boundingBox.minZ + p_74961_5_, EnumFacing.WEST, this.getComponentType(), p_74961_6_);
-                        case SOUTH:
-                            return this.generateAndAddPiece(p_74961_1_, p_74961_2_, p_74961_3_, this.boundingBox.minX - 1, this.boundingBox.minY + p_74961_4_, this.boundingBox.minZ + p_74961_5_, EnumFacing.WEST, this.getComponentType(), p_74961_6_);
-                        case WEST:
-                            return this.generateAndAddPiece(p_74961_1_, p_74961_2_, p_74961_3_, this.boundingBox.minX + p_74961_5_, this.boundingBox.minY + p_74961_4_, this.boundingBox.minZ - 1, EnumFacing.NORTH, this.getComponentType(), p_74961_6_);
-                        case EAST:
-                            return this.generateAndAddPiece(p_74961_1_, p_74961_2_, p_74961_3_, this.boundingBox.minX + p_74961_5_, this.boundingBox.minY + p_74961_4_, this.boundingBox.minZ - 1, EnumFacing.NORTH, this.getComponentType(), p_74961_6_);
-                    }
-                }
-
-                return null;
-            }
-
-            /**
-             * Gets the next component in the +/- Z direction
-             */
-            @Nullable
-            protected StructureComponent getNextComponentZ(StructureNetherBridgePieces.Start p_74965_1_, List<StructureComponent> p_74965_2_, Random p_74965_3_, int p_74965_4_, int p_74965_5_, boolean p_74965_6_)
-            {
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing != null)
-                {
-                    switch (enumfacing)
-                    {
-                        case NORTH:
-                            return this.generateAndAddPiece(p_74965_1_, p_74965_2_, p_74965_3_, this.boundingBox.maxX + 1, this.boundingBox.minY + p_74965_4_, this.boundingBox.minZ + p_74965_5_, EnumFacing.EAST, this.getComponentType(), p_74965_6_);
-                        case SOUTH:
-                            return this.generateAndAddPiece(p_74965_1_, p_74965_2_, p_74965_3_, this.boundingBox.maxX + 1, this.boundingBox.minY + p_74965_4_, this.boundingBox.minZ + p_74965_5_, EnumFacing.EAST, this.getComponentType(), p_74965_6_);
-                        case WEST:
-                            return this.generateAndAddPiece(p_74965_1_, p_74965_2_, p_74965_3_, this.boundingBox.minX + p_74965_5_, this.boundingBox.minY + p_74965_4_, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, this.getComponentType(), p_74965_6_);
-                        case EAST:
-                            return this.generateAndAddPiece(p_74965_1_, p_74965_2_, p_74965_3_, this.boundingBox.minX + p_74965_5_, this.boundingBox.minY + p_74965_4_, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, this.getComponentType(), p_74965_6_);
-                    }
-                }
-
-                return null;
-            }
-
-            /**
-             * Checks if the bounding box's minY is > 10
-             */
-            protected static boolean isAboveGround(StructureBoundingBox p_74964_0_)
-            {
-                return p_74964_0_ != null && p_74964_0_.minY > 10;
-            }
-        }
-
-    static class PieceWeight
-        {
-            public Class <? extends StructureNetherBridgePieces.Piece > weightClass;
-            public final int weight;
-            public int placeCount;
-            public int maxPlaceCount;
-            public boolean allowInRow;
-
-            public PieceWeight(Class <? extends StructureNetherBridgePieces.Piece > p_i2055_1_, int p_i2055_2_, int p_i2055_3_, boolean p_i2055_4_)
-            {
-                this.weightClass = p_i2055_1_;
-                this.weight = p_i2055_2_;
-                this.maxPlaceCount = p_i2055_3_;
-                this.allowInRow = p_i2055_4_;
-            }
-
-            public PieceWeight(Class <? extends StructureNetherBridgePieces.Piece > p_i2056_1_, int p_i2056_2_, int p_i2056_3_)
-            {
-                this(p_i2056_1_, p_i2056_2_, p_i2056_3_, false);
-            }
-
-            public boolean doPlace(int p_78822_1_)
-            {
-                return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
-            }
-
-            public boolean isValid()
-            {
-                return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
-            }
-        }
-
-    public static class Stairs extends StructureNetherBridgePieces.Piece
-        {
-            public Stairs()
-            {
-            }
-
-            public Stairs(int p_i45609_1_, Random p_i45609_2_, StructureBoundingBox p_i45609_3_, EnumFacing p_i45609_4_)
-            {
-                super(p_i45609_1_);
-                this.setCoordBaseMode(p_i45609_4_);
-                this.boundingBox = p_i45609_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentZ((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 6, 2, false);
-            }
-
-            public static StructureNetherBridgePieces.Stairs createPiece(List<StructureComponent> p_175872_0_, Random p_175872_1_, int p_175872_2_, int p_175872_3_, int p_175872_4_, int p_175872_5_, EnumFacing p_175872_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175872_2_, p_175872_3_, p_175872_4_, -2, 0, 0, 7, 11, 7, p_175872_6_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175872_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Stairs(p_175872_5_, p_175872_1_, structureboundingbox, p_175872_6_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 6, 1, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 6, 10, 6, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 1, 8, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 2, 0, 6, 8, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 1, 0, 8, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 2, 1, 6, 8, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 2, 6, 5, 8, 6, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 2, 0, 5, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 3, 2, 6, 5, 2, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 3, 4, 6, 5, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK.getDefaultState(), 5, 2, 5, structureBoundingBoxIn);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 2, 5, 4, 3, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 3, 2, 5, 3, 4, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 2, 5, 2, 5, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 2, 5, 1, 6, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 7, 1, 5, 7, 4, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 8, 2, 6, 8, 4, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 6, 0, 4, 8, 0, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 5, 0, 4, 5, 0, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-
-                for (int i = 0; i <= 6; ++i)
-                {
-                    for (int j = 0; j <= 6; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Start extends StructureNetherBridgePieces.Crossing3
-        {
-            /** Instance of StructureNetherBridgePieceWeight. */
-            public StructureNetherBridgePieces.PieceWeight lastPlaced;
-            /** Contains the list of valid piece weights for the set of nether bridge structure pieces. */
-            public List<StructureNetherBridgePieces.PieceWeight> primaryWeights;
-            /** Contains the list of valid piece weights for the secondary set of nether bridge structure pieces. */
-            public List<StructureNetherBridgePieces.PieceWeight> secondaryWeights;
-            public List<StructureComponent> pendingChildren = Lists.<StructureComponent>newArrayList();
-
-            public Start()
-            {
-            }
-
-            public Start(Random p_i2059_1_, int p_i2059_2_, int p_i2059_3_)
-            {
-                super(p_i2059_1_, p_i2059_2_, p_i2059_3_);
-                this.primaryWeights = Lists.<StructureNetherBridgePieces.PieceWeight>newArrayList();
-
-                for (StructureNetherBridgePieces.PieceWeight structurenetherbridgepieces$pieceweight : StructureNetherBridgePieces.PRIMARY_COMPONENTS)
-                {
-                    structurenetherbridgepieces$pieceweight.placeCount = 0;
-                    this.primaryWeights.add(structurenetherbridgepieces$pieceweight);
-                }
-
-                this.secondaryWeights = Lists.<StructureNetherBridgePieces.PieceWeight>newArrayList();
-
-                for (StructureNetherBridgePieces.PieceWeight structurenetherbridgepieces$pieceweight1 : StructureNetherBridgePieces.SECONDARY_COMPONENTS)
-                {
-                    structurenetherbridgepieces$pieceweight1.placeCount = 0;
-                    this.secondaryWeights.add(structurenetherbridgepieces$pieceweight1);
-                }
-            }
-        }
-
-    public static class Straight extends StructureNetherBridgePieces.Piece
-        {
-            public Straight()
-            {
-            }
-
-            public Straight(int p_i45620_1_, Random p_i45620_2_, StructureBoundingBox p_i45620_3_, EnumFacing p_i45620_4_)
-            {
-                super(p_i45620_1_);
-                this.setCoordBaseMode(p_i45620_4_);
-                this.boundingBox = p_i45620_3_;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                this.getNextComponentNormal((StructureNetherBridgePieces.Start)componentIn, listIn, rand, 1, 3, false);
-            }
-
-            public static StructureNetherBridgePieces.Straight createPiece(List<StructureComponent> p_175882_0_, Random p_175882_1_, int p_175882_2_, int p_175882_3_, int p_175882_4_, EnumFacing p_175882_5_, int p_175882_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175882_2_, p_175882_3_, p_175882_4_, -1, -3, 0, 5, 10, 19, p_175882_5_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175882_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Straight(p_175882_6_, p_175882_1_, structureboundingbox, p_175882_5_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 0, 4, 4, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 5, 0, 3, 7, 18, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 0, 5, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 5, 0, 4, 5, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 4, 2, 5, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 13, 4, 2, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 4, 1, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 15, 4, 1, 18, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-
-                for (int i = 0; i <= 4; ++i)
-                {
-                    for (int j = 0; j <= 2; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, 18 - j, structureBoundingBoxIn);
-                    }
-                }
-
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 1, 1, 0, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 4, 0, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 3, 14, 0, 4, 14, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 1, 17, 0, 4, 17, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 1, 1, 4, 4, 1, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 4, 4, 4, 4, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 3, 14, 4, 4, 14, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 4, 1, 17, 4, 4, 17, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                return true;
-            }
-        }
-
-    public static class Throne extends StructureNetherBridgePieces.Piece
-        {
-            private boolean hasSpawner;
-
-            public Throne()
-            {
-            }
-
-            public Throne(int p_i45611_1_, Random p_i45611_2_, StructureBoundingBox p_i45611_3_, EnumFacing p_i45611_4_)
-            {
-                super(p_i45611_1_);
-                this.setCoordBaseMode(p_i45611_4_);
-                this.boundingBox = p_i45611_3_;
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.hasSpawner = tagCompound.getBoolean("Mob");
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setBoolean("Mob", this.hasSpawner);
-            }
-
-            public static StructureNetherBridgePieces.Throne createPiece(List<StructureComponent> p_175874_0_, Random p_175874_1_, int p_175874_2_, int p_175874_3_, int p_175874_4_, int p_175874_5_, EnumFacing p_175874_6_)
-            {
-                StructureBoundingBox structureboundingbox = StructureBoundingBox.getComponentToAddBoundingBox(p_175874_2_, p_175874_3_, p_175874_4_, -2, 0, 0, 7, 8, 9, p_175874_6_);
-                return isAboveGround(structureboundingbox) && StructureComponent.findIntersecting(p_175874_0_, structureboundingbox) == null ? new StructureNetherBridgePieces.Throne(p_175874_5_, p_175874_1_, structureboundingbox, p_175874_6_) : null;
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 2, 0, 6, 7, 7, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 0, 0, 5, 1, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 2, 1, 5, 2, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 3, 2, 5, 3, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 4, 3, 5, 4, 7, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 2, 0, 1, 4, 2, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 2, 0, 5, 4, 2, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 5, 2, 1, 5, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 5, 5, 2, 5, 5, 3, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 3, 0, 5, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 5, 3, 6, 5, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 5, 8, 5, 5, 8, Blocks.NETHER_BRICK.getDefaultState(), Blocks.NETHER_BRICK.getDefaultState(), false);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 1, 6, 3, structureBoundingBoxIn);
-                this.setBlockState(worldIn, Blocks.NETHER_BRICK_FENCE.getDefaultState(), 5, 6, 3, structureBoundingBoxIn);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 6, 3, 0, 6, 8, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 6, 6, 3, 6, 6, 8, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 1, 6, 8, 5, 7, 8, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-                this.fillWithBlocks(worldIn, structureBoundingBoxIn, 2, 8, 8, 4, 8, 8, Blocks.NETHER_BRICK_FENCE.getDefaultState(), Blocks.NETHER_BRICK_FENCE.getDefaultState(), false);
-
-                if (!this.hasSpawner)
-                {
-                    BlockPos blockpos = new BlockPos(this.getXWithOffset(3, 5), this.getYWithOffset(5), this.getZWithOffset(3, 5));
-
-                    if (structureBoundingBoxIn.isVecInside(blockpos))
-                    {
-                        this.hasSpawner = true;
-                        worldIn.setBlockState(blockpos, Blocks.MOB_SPAWNER.getDefaultState(), 2);
-                        TileEntity tileentity = worldIn.getTileEntity(blockpos);
-
-                        if (tileentity instanceof TileEntityMobSpawner)
-                        {
-                            ((TileEntityMobSpawner)tileentity).getSpawnerBaseLogic().setEntityId(EntityList.getKey(EntityBlaze.class));
-                        }
-                    }
-                }
-
-                for (int i = 0; i <= 6; ++i)
-                {
-                    for (int j = 0; j <= 6; ++j)
-                    {
-                        this.replaceAirAndLiquidDownwards(worldIn, Blocks.NETHER_BRICK.getDefaultState(), i, -1, j, structureBoundingBoxIn);
-                    }
-                }
-
-                return true;
-            }
-        }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAiShootTridentAtPlayer.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAiShootTridentAtPlayer.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAiShootTridentAtPlayer.java	(date 1525605768000)
@@ -1,4 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.ai;
-
-public class EntityAiShootTridentAtPlayer {
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/DungeonGenerator.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/DungeonGenerator.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/DungeonGenerator.java	(date 1525605768000)
@@ -1,142 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.dungeons;
-
-import net.minecraft.block.Block;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldType;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraftforge.fml.common.IWorldGenerator;
-import net.thegaminghuskymc.mcaddon.init.BiomeInit;
-import net.thegaminghuskymc.mcaddon.world.dungeons.generator.HallwayStructure;
-import net.thegaminghuskymc.mcaddon.world.dungeons.generator.RoomStructure;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-
-public class DungeonGenerator implements IWorldGenerator {
-
-    private static List<RoomStructure> structures = new ArrayList<>();
-
-    private static final RoomStructure room1 = new RoomStructure("room_0");
-    private static final RoomStructure room2 = new RoomStructure("room_1");
-    private static final RoomStructure room3 = new RoomStructure("room_2");
-    private static final RoomStructure room4 = new RoomStructure("room_3");
-    private static final RoomStructure room5 = new RoomStructure("room_4");
-    private static final RoomStructure room6 = new RoomStructure("room_5");
-    private static final RoomStructure room7 = new RoomStructure("room_6");
-    private static final RoomStructure room8 = new RoomStructure("room_7");
-    private static final RoomStructure room9 = new RoomStructure("room_8");
-    private static final RoomStructure room10 = new RoomStructure("room_9");
-
-    private static final HallwayStructure hallway_s = new HallwayStructure("hallway_straight");
-    private static final HallwayStructure hallway_cl = new HallwayStructure("hallway_corner_left");
-//    private static final HallwayStructure hallway_cr = new HallwayStructure("hallway_corner_right");
-    private static final HallwayStructure hallway_u = new HallwayStructure("hallway_up");
-    private static final HallwayStructure hallway_d = new HallwayStructure("hallway_down");
-
-    @Override
-    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-        for(int i = 0; i > random.nextInt(10); i++) {
-            structures.add(new RoomStructure(String.format("rooms/room_%d", i)));
-            switch(world.provider.getDimension()) {
-                case 1:
-                    break;
-                case 0:
-                    generateStructure(structures.get(random.nextInt(10)), world, random, chunkX, chunkZ, 1, Blocks.SAND, Biomes.DESERT, Biomes.DESERT_HILLS, BiomeInit.BLACK_DESERT, BiomeInit.RED_DESERT);
-                    break;
-                case -1:
-            }
-        }
-    }
-
-    private void generateStructure(WorldGenerator generator, World world, Random random, int chunkX, int chunkZ, int chance, Block topBlock, Biome... classes) {
-        ArrayList<Biome> classesList = new ArrayList<>(Arrays.asList(classes));
-
-        int x = (chunkX * 16) + random.nextInt(15);
-        int z = (chunkZ * 16) + random.nextInt(15);
-        int y = calculateGenerationHeight(world, x, z, topBlock);
-        BlockPos pos = new BlockPos(x,y,z);
-
-        Class<?> biome = world.provider.getBiomeForCoords(pos).getClass();
-
-        if(world.getWorldType() != WorldType.FLAT)
-        {
-            if(classesList.contains(biome))
-            {
-                if(random.nextInt(chance) == 0)
-                {
-                    generator.generate(world, random, pos);
-                }
-            }
-        }
-    }
-
-    private static int calculateGenerationHeight(World world, int x, int z, Block topBlock)
-    {
-        int y = world.getHeight();
-        boolean foundGround = false;
-
-        while(!foundGround && y-- >= 0)
-        {
-            Block block = world.getBlockState(new BlockPos(x, y, z)).getBlock();
-            foundGround = block == topBlock;
-        }
-
-        return y;
-    }
-
-    public static int getGroundFromAbove(World world, int x, int z)
-    {
-        int y = 255;
-        boolean foundGround = false;
-        while(!foundGround && y-- >= 31)
-        {
-            Block blockAt = world.getBlockState(new BlockPos(x,y,z)).getBlock();
-            foundGround =  blockAt == Blocks.WATER||blockAt == Blocks.FLOWING_WATER||blockAt == Blocks.GRASS || blockAt == Blocks.SAND || blockAt == Blocks.SNOW || blockAt == Blocks.SNOW_LAYER || blockAt == Blocks.GLASS||blockAt == Blocks.MYCELIUM;
-        }
-
-        return y;
-    }
-    public static int getLakeFromAbove(World world, int x, int z)
-    {
-        int y = 255;
-        boolean foundGround = false;
-        while(!foundGround && y-- >= 31)
-        {
-            Block blockAt = world.getBlockState(new BlockPos(x,y,z)).getBlock();
-            foundGround =  blockAt == Blocks.WATER||blockAt == Blocks.FLOWING_WATER;
-        }
-
-        return y;
-    }
-
-    public static boolean canSpawnHere(Template template, World world, BlockPos posAboveGround)
-    {
-        int zwidth = template.getSize().getZ();
-        int xwidth = template.getSize().getX();
-
-        // check all the corners to see which ones are replaceable
-        boolean corner1 = isCornerValid(world, posAboveGround);
-        boolean corner2 = isCornerValid(world, posAboveGround.add(xwidth, 0, zwidth));
-
-        // if Y > 20 and all corners pass the test, it's okay to spawn the structure
-        return posAboveGround.getY() > 31 && corner1 && corner2;
-    }
-
-    public static boolean isCornerValid(World world, BlockPos pos)
-    {
-        int variation = 3;
-        int highestBlock = getGroundFromAbove(world, pos.getX(), pos.getZ());
-
-        return highestBlock > pos.getY() - variation && highestBlock < pos.getY() + variation;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/DimensionInit.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/DimensionInit.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/DimensionInit.java	(date 1525605768000)
@@ -1,9 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-public class DimensionInit {
-
-	public static void registerDimensions() {
-
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumAquamarineVariants.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumAquamarineVariants.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumAquamarineVariants.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-
-public enum EnumAquamarineVariants implements IStringSerializable {
-
-    BRICKS,
-    CHISELED,
-    PILLAR,
-    RAW,
-    SMALL_BRICKS,
-    SMOOTH;
-
-    @Override
-    public String getName() {
-        return toString().toLowerCase();
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosAngler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosAngler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosAngler.java	(date 1525605768000)
@@ -1,103 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosAngler.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosAngler;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelAtmosAngler;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-import javax.annotation.Nullable;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            ModelAtmosAngler, EntityAtmosAngler
-
-public class RenderAtmosAngler extends RenderLiving<EntityAtmosAngler> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/angler.png");
-
-    public RenderAtmosAngler(RenderManager manager)
-    {
-        super(manager, new ModelAtmosAngler(), 1.0F);
-    }
-
-    @Nullable
-    @Override
-    protected ResourceLocation getEntityTexture(EntityAtmosAngler entity) {
-        return SCORP_TEXTURE;
-    }
-
-    /*public void renderAngler(EntityAtmosAngler entityAngler, double d, double d1, double d2,
-                             float f, float f1)
-    {
-        super.renderModel(entityAngler, d, d1, d2, f, f1);
-    }
-
-    public void a(md entityliving, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderAngler((EntityAtmosAngler)entityliving, d, d1, d2, f, f1);
-    }
-
-    public void a(lq entity, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderAngler((EntityAtmosAngler)entity, d, d1, d2, f, f1);
-    }
-
-    protected void preRenderScale(md entityliving, float f)
-    {
-        EntityAtmosAngler entityAngler = (EntityAtmosAngler)entityliving;
-        if(entityAngler.isDiving())
-            isDescending(entityliving);
-        if(entityAngler.isRising())
-            isAscending(entityliving);
-    }
-
-    protected void a(md entityliving, float f)
-    {
-        preRenderScale((EntityAtmosAngler)entityliving, f);
-    }
-
-    protected int setAnglerEyeBrightness(EntityAtmosAngler par1EntityAngler, int par2, float par3)
-    {
-        if(par2 != 0)
-        {
-            return -1;
-        } else
-        {
-            a("/atmosmobs/seacreatures/angler_light.png");
-            float f = 1.0F;
-            GL11.glEnable(3042);
-            GL11.glDisable(3008);
-            GL11.glBlendFunc(1, 1);
-            int i = 61680;
-            int j = i % 0x10000;
-            int k = i / 0x10000;
-            bfe.a(bfe.b, (float)j / 1.0F, (float)k / 1.0F);
-            GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-            GL11.glColor4f(1.0F, 1.0F, 1.0F, f);
-            return 1;
-        }
-    }
-
-    protected void isDescending(md entityliving)
-    {
-        GL11.glRotatef(-45F, -1F, 0.0F, 0.0F);
-    }
-
-    protected void isAscending(md entityliving)
-    {
-        GL11.glRotatef(-315F, -1F, 0.0F, 0.0F);
-    }
-
-    protected int a(md par1EntityLiving, int par2, float par3)
-    {
-        return setAnglerEyeBrightness((EntityAtmosAngler)par1EntityLiving, par2, par3);
-    }*/
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityPhantom.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.world.World;
-
-public class EntityPhantom extends EntityLiving {
-
-    public EntityPhantom(World worldIn) {
-        super(worldIn);
-        this.setHealth(this.getMaxHealth());
-        setSize(0.5F, 0.5F);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeNether.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.biome.BiomeDecorator;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public abstract class BiomeNether extends Biome {
-    public BiomeNether(BiomeProperties properties, String name) {
-        super(properties);
-
-        spawnableMonsterList.clear();
-        spawnableCreatureList.clear();
-        spawnableWaterCreatureList.clear();
-        spawnableCaveCreatureList.clear();
-
-        setRegistryName(MOD_ID, name);
-    }
-
-    @Override
-    public BiomeDecorator createBiomeDecorator() {
-        return new BiomeDecoratorNether();
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/FluidTextureUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/FluidTextureUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/FluidTextureUtil.java	(date 1525605768000)
@@ -1,47 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   FluidTextureUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import com.google.common.collect.Maps;
-import net.minecraft.client.renderer.texture.TextureAtlasSprite;
-import net.minecraft.client.renderer.texture.TextureMap;
-import net.minecraftforge.fluids.Fluid;
-import net.minecraftforge.fluids.FluidRegistry;
-
-import java.util.Iterator;
-import java.util.Map;
-
-public class FluidTextureUtil
-{
-
-    public FluidTextureUtil()
-    {
-    }
-
-    public static void initTextures(TextureMap map)
-    {
-        Iterator iterator = FluidRegistry.getRegisteredFluids().values().iterator();
-        do
-        {
-            if(!iterator.hasNext())
-                break;
-            Fluid fluid = (Fluid)iterator.next();
-            if(fluid.getStill() != null)
-            {
-                String still = fluid.getStill().toString();
-                TextureAtlasSprite sprite;
-                if(map.getTextureExtry(still) != null)
-                    sprite = map.getTextureExtry(still);
-                else
-                    sprite = map.registerSprite(fluid.getStill());
-                stillTextures.put(fluid, sprite);
-            }
-        } while(true);
-    }
-
-    public static Map stillTextures = Maps.newHashMap();
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoral.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoral.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoral.java	(date 1525605768000)
@@ -1,71 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.properties.EnumCoralColor;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockCoral extends BlockMod {
-
-    private final EnumCoralColor color;
-
-    public BlockCoral(EnumCoralColor colorIn, String name) {
-        super(Material.CORAL, MOD_ID, colorIn + "_" + name);
-        this.color = colorIn;
-        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    @Override
-    public String getPrefix() {
-        return MOD_ID;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return MOD_ID;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public static EnumCoralColor getColorFromItem(Item itemIn) {
-        return getColorFromBlock(Block.getBlockFromItem(itemIn));
-    }
-
-    @SideOnly(Side.CLIENT)
-    private static EnumCoralColor getColorFromBlock(Block blockIn) {
-        return blockIn instanceof BlockCoral ? ((BlockCoral) blockIn).getColor() : EnumCoralColor.BLUE;
-    }
-
-    @Override
-    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
-
-    }
-
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public EnumCoralColor getColor() {
-        return this.color;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/commands/TPBiomeCommand.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/commands/TPBiomeCommand.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/commands/TPBiomeCommand.java	(date 1525605768000)
@@ -1,74 +0,0 @@
-package net.thegaminghuskymc.mcaddon.commands;
-
-import com.google.common.collect.Lists;
-import net.minecraft.command.CommandBase;
-import net.minecraft.command.CommandException;
-import net.minecraft.command.ICommandSender;
-import net.minecraft.command.WrongUsageException;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.text.TextComponentString;
-import net.minecraft.world.biome.Biome;
-
-import javax.annotation.Nullable;
-import java.util.Collections;
-import java.util.List;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class TPBiomeCommand extends CommandBase {
-
-    private final List<String> aliases = Lists.newArrayList(MOD_ID, "f", "fn", "findbio", "findbiome", "find");
-
-    @Override
-    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException {
-
-        if (args.length != 1)
-        {
-            throw new WrongUsageException("findbiome <name>");
-        }
-        else
-        {
-            String s = args[0];
-
-            final SearchResult result = BiomeUtils.searchForBiome(server.getWorld(0), Biome.REGISTRY.getObject(new ResourceLocation(s)), sender.getPosition());
-            if (result.found()) {
-                sender.sendMessage(new TextComponentString(String.format("We found a biome at X: %d Z: %d with the name %s", result.getX(), result.getZ(), s)));
-            } else {
-                sender.sendMessage(new TextComponentString(String.format("We did not find any biomes with the name %s", s)));
-            }
-
-        }
-
-    }
-
-    @Override
-    public String getName() {
-        return "findbiome";
-    }
-
-    @Override
-    public String getUsage(ICommandSender sender) {
-        return "findbiome <name>";
-    }
-
-    @Override
-    public List<String> getAliases() {
-        return aliases;
-    }
-
-    @Override
-    public boolean checkPermission(MinecraftServer server, ICommandSender sender) {
-        return true;
-    }
-
-    /**
-     * Get a list of options for when the user presses the TAB key
-     */
-    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos)
-    {
-        return args.length == 1 ? getListOfStringsMatchingLastWord(args, "forest", "desert", "red_desert", "black_desert", "deep_ocean", "ocean", "swamp", "mesa") : Collections.emptyList();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBlackDesert.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBlackDesert.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBlackDesert.java	(date 1525605768000)
@@ -1,54 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.entity.monster.EntityHusk;
-import net.minecraft.entity.monster.EntityZombie;
-import net.minecraft.entity.monster.EntityZombieVillager;
-import net.minecraft.entity.passive.EntityRabbit;
-import net.minecraft.init.Biomes;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.feature.WorldGenDesertWells;
-import net.minecraft.world.gen.feature.WorldGenFossils;
-import net.thegaminghuskymc.mcaddon.init.MCAddonBlocks;
-
-import java.awt.*;
-import java.util.Random;
-
-public class BiomeBlackDesert extends Biome {
-
-    public BiomeBlackDesert() {
-        super((new BiomeProperties("black_desert")).setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled().setWaterColor(Color.DARK_GRAY.getRGB()).setBaseBiome(Biomes.DESERT.getBiomeName()));
-        this.spawnableCreatureList.clear();
-        this.topBlock = MCAddonBlocks.blackSand.getDefaultState();
-        this.fillerBlock = MCAddonBlocks.blackSand.getDefaultState();
-        this.decorator.treesPerChunk = -999;
-        this.decorator.deadBushPerChunk = 2;
-        this.decorator.reedsPerChunk = 50;
-        this.decorator.cactiPerChunk = 10;
-        this.spawnableCreatureList.clear();
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityRabbit.class, 4, 2, 3));
-
-        this.spawnableMonsterList.removeIf(biome$spawnlistentry -> biome$spawnlistentry.entityClass == EntityZombie.class || biome$spawnlistentry.entityClass == EntityZombieVillager.class);
-
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 19, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityZombieVillager.class, 1, 1, 1));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityHusk.class, 80, 4, 4));
-    }
-
-    public void decorate(World worldIn, Random rand, BlockPos pos) {
-        super.decorate(worldIn, rand, pos);
-        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.DESERT_WELL))
-            if (rand.nextInt(1000) == 0) {
-                int i = rand.nextInt(16) + 8;
-                int j = rand.nextInt(16) + 8;
-                BlockPos blockpos = worldIn.getHeight(pos.add(i, 0, j)).up();
-                (new WorldGenDesertWells()).generate(worldIn, rand, blockpos);
-            }
-
-        if (net.minecraftforge.event.terraingen.TerrainGen.decorate(worldIn, rand, pos, net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.FOSSIL))
-            if (rand.nextInt(64) == 0) {
-                (new WorldGenFossils()).generate(worldIn, rand, pos);
-            }
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlyingMob.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlyingMob.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlyingMob.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosFlyingMob.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityFlying;
-import net.minecraft.entity.monster.IMob;
-import net.minecraft.world.World;
-
-public class EntityAtmosFlyingMob extends EntityFlying implements IMob {
-
-    public EntityAtmosFlyingMob(World par1World)
-    {
-        super(par1World);
-    }
-
-    public int aT()
-    {
-        return 0;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureOre.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureOre.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureOre.java	(date 1525605768000)
@@ -1,104 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.block.state.pattern.BlockMatcher;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public class FeatureOre extends Feature
-{
-    private final IBlockState blockToSpawn;
-    private final IBlockState targetBlock;
-    private final int size;
-
-    public FeatureOre(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        blockToSpawn = BlockUtil.getBlock(feature.getBlockToSpawn(), "minecraft:air");
-        targetBlock = BlockUtil.getBlock(feature.getTargetBlock(), "minecraft:air");
-        size = feature.getSize() <= 0 ? 14 : feature.getSize();
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        float f = rand.nextFloat() * (float) Math.PI;
-        double d0 = (double) ((float) (pos.getX() + 8) + MathHelper.sin(f) * (float) size / 8.0F);
-        double d1 = (double) ((float) (pos.getX() + 8) - MathHelper.sin(f) * (float) size / 8.0F);
-        double d2 = (double) ((float) (pos.getZ() + 8) + MathHelper.cos(f) * (float) size / 8.0F);
-        double d3 = (double) ((float) (pos.getZ() + 8) - MathHelper.cos(f) * (float) size / 8.0F);
-        double d4 = (double) (pos.getY() + rand.nextInt(3) - 2);
-        double d5 = (double) (pos.getY() + rand.nextInt(3) - 2);
-
-        for(int i = 0; i < size; ++i)
-        {
-            float f1 = (float) i / (float) size;
-            double d6 = d0 + (d1 - d0) * (double) f1;
-            double d7 = d4 + (d5 - d4) * (double) f1;
-            double d8 = d2 + (d3 - d2) * (double) f1;
-            double d9 = rand.nextDouble() * (double) size / 16.0D;
-            double d10 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
-            double d11 = (double) (MathHelper.sin((float) Math.PI * f1) + 1.0F) * d9 + 1.0D;
-            int j = MathHelper.floor(d6 - d10 / 2.0D);
-            int k = MathHelper.floor(d7 - d11 / 2.0D);
-            int l = MathHelper.floor(d8 - d10 / 2.0D);
-            int i1 = MathHelper.floor(d6 + d10 / 2.0D);
-            int j1 = MathHelper.floor(d7 + d11 / 2.0D);
-            int k1 = MathHelper.floor(d8 + d10 / 2.0D);
-
-            for(int l1 = j; l1 <= i1; ++l1)
-            {
-                double d12 = ((double) l1 + 0.5D - d6) / (d10 / 2.0D);
-
-                if(d12 * d12 < 1.0D)
-                {
-                    for(int i2 = k; i2 <= j1; ++i2)
-                    {
-                        double d13 = ((double) i2 + 0.5D - d7) / (d11 / 2.0D);
-
-                        if(d12 * d12 + d13 * d13 < 1.0D)
-                        {
-                            for(int j2 = l; j2 <= k1; ++j2)
-                            {
-                                double d14 = ((double) j2 + 0.5D - d8) / (d10 / 2.0D);
-
-                                if(d12 * d12 + d13 * d13 + d14 * d14 < 1.0D)
-                                {
-                                    BlockPos newPos = new BlockPos(l1, i2, j2);
-                                    IBlockState state = world.getBlockState(newPos);
-
-                                    if(state.getBlock().isReplaceableOreGen(state, world, newPos, BlockMatcher.forBlock(targetBlock.getBlock())) && state == targetBlock)
-                                    {
-                                        world.setBlockState(newPos, blockToSpawn, 2);
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return !(blockToSpawn == Blocks.AIR.getDefaultState() || targetBlock == Blocks.AIR.getDefaultState());
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.ORE;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureStructure.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureStructure.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureStructure.java	(date 1525605768000)
@@ -1,178 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import com.google.common.base.Strings;
-import com.google.common.collect.Lists;
-import net.minecraft.block.Block;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.structure.template.PlacementSettings;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.util.WeightedUtil;
-import net.thegaminghuskymc.mcaddon.util.WorldGenUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.List;
-import java.util.Random;
-
-public class FeatureStructure extends Feature
-{
-    private final List<StructureType> types;
-    private final List<WeightedUtil.NamedItem> structures;
-    private final List<Block> replacedBlocks;
-    private final List<List<ResourceLocation>> lootTables;
-    private final List<List<ResourceLocation>> spawnerMobs;
-    private final List<Boolean> rotationList;
-    private final List<Boolean> mirrorList;
-    private final int minHeight;
-    private final int maxHeight;
-
-    public FeatureStructure(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        types = Lists.newArrayList();
-        structures = Lists.newArrayList();
-        replacedBlocks = Lists.newArrayList();
-        lootTables = Lists.newArrayList();
-        spawnerMobs = Lists.newArrayList();
-        rotationList = Lists.newArrayList();
-        mirrorList = Lists.newArrayList();
-        minHeight = feature.getMinHeight();
-        maxHeight = feature.getMaxHeight();
-
-        for(NetherBiome.BiomeStructure structure : feature.getStructureList())
-        {
-            int index = feature.getStructureList().indexOf(structure);
-            replacedBlocks.add(index, BlockUtil.getBlock(structure.getReplacedBlock(), ""));
-            structures.add(index, new WeightedUtil.NamedItem(structure.getStructureId(), structure.getWeight()));
-            types.add(index, StructureType.getFromString(structure.getStructureType()));
-            lootTables.add(index, Lists.newArrayList());
-            spawnerMobs.add(index, Lists.newArrayList());
-            rotationList.add(index, structure.mirror());
-            mirrorList.add(index, structure.rotate());
-
-            if(structure.getLootTables() != null)
-            {
-                for(String lootTable : structure.getLootTables())
-                {
-                    lootTables.get(index).add(new ResourceLocation(lootTable));
-                }
-            }
-            if(structure.getSpawnerMobs() != null)
-            {
-                for(String spawnerMob : structure.getSpawnerMobs())
-                {
-                    spawnerMobs.get(index).add(new ResourceLocation(spawnerMob));
-                }
-            }
-
-            if(lootTables.get(index).size() == 0)
-            {
-                lootTables.get(index).add(LootTableList.EMPTY);
-            }
-            if(spawnerMobs.get(index).size() == 0)
-            {
-                spawnerMobs.get(index).add(new ResourceLocation("minecraft:zombie_pigman"));
-            }
-        }
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        rand = world.getChunkFromBlockCoords(pos).getRandomWithSeed(world.getSeed());
-
-        WeightedUtil.NamedItem structure = WeightedUtil.getRandomNamedItem(rand, structures);
-        int index = structures.indexOf(structure);
-
-        StructureType type = types.get(index);
-
-        Mirror[] mirrors = Mirror.values();
-        Rotation[] rotations = Rotation.values();
-        Mirror mirror = mirrorList.get(index) ? mirrors[rand.nextInt(mirrors.length)] : Mirror.NONE;
-        Rotation rotation = rotationList.get(index) ? rotations[rand.nextInt(rotations.length)] : Rotation.NONE;
-
-        MinecraftServer minecraftServer = world.getMinecraftServer();
-        TemplateManager templateManager = world.getSaveHandler().getStructureTemplateManager();
-        Template template = templateManager.getTemplate(minecraftServer, new ResourceLocation(structure.name));
-
-        PlacementSettings placementSettings = new PlacementSettings().setMirror(mirror).setRotation(rotation).setReplacedBlock(replacedBlocks.get(index)).setRandom(rand);
-        BlockPos structureSize = Template.transformedBlockPos(placementSettings.copy(), template.getSize());
-        BlockPos newPos = new BlockPos(pos.getX() - structureSize.getX() / 2, maxHeight, pos.getZ() - structureSize.getZ() / 2);
-        BlockPos spawnPos;
-
-        if(type == StructureType.GROUND)
-        {
-            spawnPos = WorldGenUtil.getSuitableGroundPos(world, newPos, structureSize, 0.875F);
-        }
-        else if(type == StructureType.AIR)
-        {
-            spawnPos = WorldGenUtil.getSuitableAirPos(world, newPos, structureSize);
-        }
-        else if(type == StructureType.CEILING)
-        {
-            spawnPos = WorldGenUtil.getSuitableCeilingPos(world, newPos, structureSize);
-        }
-        else if(type == StructureType.WALL)
-        {
-            spawnPos = WorldGenUtil.getSuitableWallPos(world, newPos, structureSize, 0.8F);
-        }
-        else
-        {
-            return false;
-        }
-
-        if(!spawnPos.equals(BlockPos.ORIGIN) && spawnPos.getY() >= minHeight && spawnPos.getY() <= maxHeight)
-        {
-            WorldGenUtil.generateStructure(world, spawnPos, rand, template, placementSettings.copy(), lootTables.get(index), spawnerMobs.get(index));
-            return true;
-        }
-
-        return false;
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return structures.size() > 0;
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.STRUCTURE;
-    }
-
-    public enum StructureType
-    {
-        GROUND,
-        AIR,
-        CEILING,
-        WALL,
-        UNKNOWN;
-
-        public static StructureType getFromString(String string)
-        {
-            if(!Strings.isNullOrEmpty(string))
-            {
-                for(StructureType type : values())
-                {
-                    if(type.name().equalsIgnoreCase(string))
-                    {
-                        return type;
-                    }
-                }
-            }
-
-            return UNKNOWN;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFenceGate.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFenceGate.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFenceGate.java	(date 1525605768000)
@@ -1,160 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.base;
-
-import net.minecraft.block.*;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.pathfinding.PathNodeType;
-import net.minecraft.util.BlockRenderLayer;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.IBlockAccess;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.huskylib2.interf.IModBlock;
-import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-import org.apache.commons.lang3.StringUtils;
-
-import java.util.Random;
-
-public class BlockModFenceGate extends BlockFenceGate implements IModBlock {
-
-    private final String[] variants;
-    private String bareName, modid;
-
-    public BlockModFenceGate(String modid, String name, String... variants)  {
-        super(BlockPlanks.EnumType.OAK);
-
-        useNeighborBrightness = true;
-
-        if (variants.length == 0)
-            variants = new String[]{name};
-
-        bareName = name;
-        this.variants = variants;
-        this.modid = modid;
-
-        setUnlocalizedName(modid, name);
-
-        setHardness(1.5F);
-        setResistance(30F);
-        setHarvestLevel("pickaxe", 1);
-    }
-
-    @Override
-    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
-        return Item.getItemFromBlock(this);
-    }
-
-    @Override
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    public Block setUnlocalizedName(String modid, String name) {
-
-        String[] nameParts = name.split("_");
-
-        String gateName = ":fence_gate" + StringUtils.capitalize(nameParts[0]) + ".";
-        StringBuilder gateType = new StringBuilder(nameParts[1]);
-
-        for(int i = 2; i < nameParts.length; i++)
-        {
-            gateType.append(StringUtils.capitalize(nameParts[i]));
-        }
-
-        super.setUnlocalizedName(gateName + gateType);
-        this.setRegistryName(modid, gateName + gateType);
-        ProxyRegistry.register(this);
-        ProxyRegistry.register(this.createItemBlock(new ResourceLocation(modid, name)));
-        return this;
-    }
-
-    protected ItemBlock createItemBlock(ResourceLocation res) {
-        return new ItemModBlock(this, res);
-    }
-
-    @Override
-    public PathNodeType getAiPathNodeType(IBlockState state, IBlockAccess world, BlockPos pos)  {
-        return state.getValue(OPEN) ? PathNodeType.DOOR_OPEN : PathNodeType.DOOR_WOOD_CLOSED;
-    }
-
-    @Override
-    public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos)
-    {
-        EnumFacing.Axis facing = state.getValue(FACING).getAxis();
-
-        Block northBlock = worldIn.getBlockState(pos.north()).getBlock();
-        Block eastBlock = worldIn.getBlockState(pos.east()).getBlock();
-        Block southBlock = worldIn.getBlockState(pos.south()).getBlock();
-        Block westBlock = worldIn.getBlockState(pos.west()).getBlock();
-
-        if(facing == EnumFacing.Axis.Z && ((westBlock instanceof BlockWall) || (eastBlock instanceof BlockWall)) || facing == EnumFacing.Axis.X && ((northBlock instanceof BlockWall) || (southBlock instanceof BlockWall)))
-        {
-            return state.withProperty(IN_WALL, true);
-        }
-
-        return state.withProperty(IN_WALL, false);
-    }
-
-    @Override
-    public String getPrefix() {
-        return this.modid;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return this.modid;
-    }
-
-    @Override
-    public String getBareName() {
-        return bareName;
-    }
-
-    @Override
-    public String[] getVariants() {
-        return variants;
-    }
-
-    @Override
-    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
-        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.SOLID || layer == BlockRenderLayer.TRANSLUCENT;
-    }
-
-    @Override
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    @SideOnly(Side.CLIENT)
-    public ItemMeshDefinition getCustomMeshDefinition() {
-        return null;
-    }
-
-    @Override
-    public IProperty[] getIgnoredProperties() {
-        return new IProperty[0];
-    }
-
-    @Override
-    public IProperty getVariantProp() {
-        return null;
-    }
-
-    @Override
-    public Class getVariantEnum() {
-        return null;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/WorldGenBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/WorldGenBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/WorldGenBase.java	(date 1525605768000)
@@ -1,32 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world;
-
-import net.minecraft.block.Block;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraftforge.fml.common.IWorldGenerator;
-import net.thegaminghuskymc.mcaddon.util.NoiseGenUtil;
-
-import java.util.HashSet;
-import java.util.Random;
-import java.util.Set;
-
-public class WorldGenBase implements IWorldGenerator {
-    public float spawnChance = 0.0F;
-    public Set<Block> spawnable = new HashSet<>();
-
-    public WorldGenBase(float chance) {
-        this.spawnChance = chance;
-    }
-
-    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-        Random rand = NoiseGenUtil.getRandom(new int[]{chunkX, chunkZ, this.getClass().getTypeName().hashCode()});
-        if (rand.nextFloat() < this.spawnChance) {
-            this.generateStruct(random, chunkX, chunkZ, world, chunkGenerator, chunkProvider);
-        }
-
-    }
-
-    public void generateStruct(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGen, IChunkProvider chunkProv) {
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeProviderNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeProviderNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeProviderNether.java	(date 1525605768000)
@@ -1,27 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.world.World;
-import net.minecraft.world.biome.BiomeProvider;
-import net.minecraft.world.gen.layer.GenLayer;
-import net.minecraftforge.fml.relauncher.ReflectionHelper;
-import net.thegaminghuskymc.mcaddon.world.gen.layer.GenLayerNether;
-
-import java.lang.reflect.Field;
-
-public class BiomeProviderNether extends BiomeProvider {
-    private static final Field FIELD_GEN_BIOMES = ReflectionHelper.findField(BiomeProvider.class, "field_76944_d", "genBiomes");
-    private static final Field FIELD_BIOME_INDEX_LAYER = ReflectionHelper.findField(BiomeProvider.class, "field_76945_e", "biomeIndexLayer");
-
-    public BiomeProviderNether(World world) {
-        super();
-
-        GenLayer[] genLayers = GenLayerNether.initializeAllBiomeGenerators(world.getSeed(), world.getWorldType());
-
-        try {
-            FIELD_GEN_BIOMES.set(this, genLayers[0]);
-            FIELD_BIOME_INDEX_LAYER.set(this, genLayers[1]);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeaturePool.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeaturePool.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeaturePool.java	(date 1525605768000)
@@ -1,145 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public class FeaturePool extends Feature
-{
-    private final IBlockState blockToSpawn;
-    private final IBlockState surroundingBlock;
-
-    public FeaturePool(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        blockToSpawn = BlockUtil.getBlock(feature.getBlockToSpawn(), "minecraft:air");
-        surroundingBlock = BlockUtil.getBlock(feature.getSurroundingBlock(), "minecraft:air");
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        for(pos = pos.add(-8, 0, -8); pos.getY() > 33 && (world.isAirBlock(pos)); pos = pos.down())
-        {
-
-        }
-
-        if(pos.getY() < 33)
-        {
-            return false;
-        }
-        else
-        {
-            boolean[] hasSpace = new boolean[2048];
-            int i = rand.nextInt(4) + 4;
-            pos = pos.down(4);
-
-            for(int j = 0; j < i; ++j)
-            {
-                double d0 = rand.nextDouble() * 6.0D + 3.0D;
-                double d1 = rand.nextDouble() * 4.0D + 2.0D;
-                double d2 = rand.nextDouble() * 6.0D + 3.0D;
-                double d3 = rand.nextDouble() * (16.0D - d0 - 2.0D) + 1.0D + d0 / 2.0D;
-                double d4 = rand.nextDouble() * (8.0D - d1 - 4.0D) + 2.0D + d1 / 2.0D;
-                double d5 = rand.nextDouble() * (16.0D - d2 - 2.0D) + 1.0D + d2 / 2.0D;
-
-                for(int l = 1; l < 15; ++l)
-                {
-                    for(int i1 = 1; i1 < 15; ++i1)
-                    {
-                        for(int j1 = 1; j1 < 7; ++j1)
-                        {
-                            double d6 = ((double) l - d3) / (d0 / 2.0D);
-                            double d7 = ((double) j1 - d4) / (d1 / 2.0D);
-                            double d8 = ((double) i1 - d5) / (d2 / 2.0D);
-                            double d9 = d6 * d6 + d7 * d7 + d8 * d8;
-
-                            if(d9 < 1.0D)
-                            {
-                                hasSpace[(l * 16 + i1) * 8 + j1] = true;
-                            }
-                        }
-                    }
-                }
-            }
-
-            for(int k1 = 0; k1 < 16; ++k1)
-            {
-                for(int l2 = 0; l2 < 16; ++l2)
-                {
-                    for(int k = 0; k < 8; ++k)
-                    {
-                        boolean flag = !hasSpace[(k1 * 16 + l2) * 8 + k] && (k1 < 15 && hasSpace[((k1 + 1) * 16 + l2) * 8 + k] || k1 > 0 && hasSpace[((k1 - 1) * 16 + l2) * 8 + k] || l2 < 15 && hasSpace[(k1 * 16 + l2 + 1) * 8 + k] || l2 > 0 && hasSpace[(k1 * 16 + (l2 - 1)) * 8 + k] || k < 7 && hasSpace[(k1 * 16 + l2) * 8 + k + 1] || k > 0 && hasSpace[(k1 * 16 + l2) * 8 + (k - 1)]);
-
-                        if(flag)
-                        {
-                            Material material = world.getBlockState(pos.add(k1, k, l2)).getMaterial();
-
-                            if(k >= 4 && material.isLiquid())
-                            {
-                                return false;
-                            }
-
-                            if(k < 4 && !material.isSolid() && world.getBlockState(pos.add(k1, k, l2)).getBlock() != blockToSpawn.getBlock())
-                            {
-                                return false;
-                            }
-                        }
-                    }
-                }
-            }
-
-            for(int l1 = 0; l1 < 16; ++l1)
-            {
-                for(int i3 = 0; i3 < 16; ++i3)
-                {
-                    for(int i4 = 0; i4 < 8; ++i4)
-                    {
-                        if(hasSpace[(l1 * 16 + i3) * 8 + i4])
-                        {
-                            world.setBlockState(pos.add(l1, i4, i3), i4 >= 4 ? Blocks.AIR.getDefaultState() : blockToSpawn, 2);
-                        }
-                    }
-                }
-            }
-
-            for(int j2 = 0; j2 < 16; ++j2)
-            {
-                for(int k3 = 0; k3 < 16; ++k3)
-                {
-                    for(int k4 = 0; k4 < 8; ++k4)
-                    {
-                        boolean flag1 = !hasSpace[(j2 * 16 + k3) * 8 + k4] && (j2 < 15 && hasSpace[((j2 + 1) * 16 + k3) * 8 + k4] || j2 > 0 && hasSpace[((j2 - 1) * 16 + k3) * 8 + k4] || k3 < 15 && hasSpace[(j2 * 16 + k3 + 1) * 8 + k4] || k3 > 0 && hasSpace[(j2 * 16 + (k3 - 1)) * 8 + k4] || k4 < 7 && hasSpace[(j2 * 16 + k3) * 8 + k4 + 1] || k4 > 0 && hasSpace[(j2 * 16 + k3) * 8 + (k4 - 1)]);
-
-                        if(flag1 && (k4 < 4 || rand.nextInt(2) != 0) && world.getBlockState(pos.add(j2, k4, k3)).getMaterial().isSolid())
-                        {
-                            world.setBlockState(pos.add(j2, k4, k3), surroundingBlock, 2);
-                        }
-                    }
-                }
-            }
-
-            return true;
-        }
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return !(blockToSpawn == Blocks.AIR.getDefaultState() || surroundingBlock == Blocks.AIR.getDefaultState());
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.POOL;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosCrow.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosCrow.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosCrow.java	(date 1525605768000)
@@ -1,283 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosCrow.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosCrow;
-import org.lwjgl.opengl.GL11;
-
-// Referenced classes of package atmosmobs.birds:
-//            EntityAtmosCrow
-
-public class ModelAtmosCrow extends ModelBase
-{
-
-    public ModelAtmosCrow()
-    {
-        textureWidth = 64;
-        textureHeight = 32;
-        Head = new ModelRenderer(this, 0, 0);
-        Head.addBox(-1F, -1F, -2F, 2, 2, 2);
-        Head.setRotationPoint(0.0F, 0.0F, -5F);
-        Head.setTextureOffset(64, 32);
-        Head.mirror = true;
-        setRotation(Head, 0.0F, 0.0F, 0.0F);
-        Beak1 = new ModelRenderer(this, 10, 4);
-        Beak1.addBox(-0.5F, -4F, -1F, 1, 2, 1);
-        Beak1.setRotationPoint(0.0F, 0.0F, -5F);
-        Beak1.setTextureOffset(64, 32);
-        Beak1.mirror = true;
-        setRotation(Beak1, 1.570796F, 0.0F, 0.0F);
-        Beak2 = new ModelRenderer(this, 10, 0);
-        Beak2.addBox(-0.5F, 1.2F, -1.2F, 1, 3, 1);
-        Beak2.setRotationPoint(0.0F, 0.0F, -5F);
-        Beak2.setTextureOffset(64, 32);
-        Beak2.mirror = true;
-        setRotation(Beak2, -1.291544F, 0.0F, 0.0F);
-        Neck = new ModelRenderer(this, 0, 4);
-        Neck.addBox(-1F, -1F, -2F, 2, 2, 2);
-        Neck.setRotationPoint(0.0F, 0.0F, -3F);
-        Neck.setTextureOffset(64, 32);
-        Neck.mirror = true;
-        setRotation(Neck, 0.0F, 0.0F, 0.0F);
-        Body = new ModelRenderer(this, 0, 17);
-        Body.addBox(-1.5F, -6F, 0.0F, 3, 6, 3);
-        Body.setRotationPoint(0.0F, 2.0F, 2.0F);
-        Body.setTextureOffset(64, 32);
-        Body.mirror = true;
-        setRotation(Body, 1.570796F, 0.0F, 0.0F);
-        Tail1 = new ModelRenderer(this, 12, 20);
-        Tail1.addBox(-1F, -1F, 1.0F, 2, 1, 1);
-        Tail1.setRotationPoint(0.0F, 0.0F, 2.0F);
-        Tail1.setTextureOffset(64, 32);
-        Tail1.mirror = true;
-        setRotation(Tail1, 0.0F, 0.0F, 0.0F);
-        Tail2 = new ModelRenderer(this, 12, 17);
-        Tail2.addBox(-1F, -1F, 0.0F, 2, 2, 1);
-        Tail2.setRotationPoint(0.0F, 0.0F, 2.0F);
-        Tail2.setTextureOffset(64, 32);
-        Tail2.mirror = true;
-        setRotation(Tail2, 0.0F, 0.0F, 0.0F);
-        LegLeft1 = new ModelRenderer(this, 22, 0);
-        LegLeft1.addBox(-0.5F, 0.0F, 0.0F, 1, 2, 1);
-        LegLeft1.setRotationPoint(1.0F, 2.0F, 2.0F);
-        LegLeft1.setTextureOffset(64, 32);
-        LegLeft1.mirror = true;
-        setRotation(LegLeft1, 0.0F, 0.0F, 0.0F);
-        LegLeft2 = new ModelRenderer(this, 18, 0);
-        LegLeft2.addBox(-0.5F, 1.0F, 1.7F, 1, 2, 1);
-        LegLeft2.setRotationPoint(1.0F, 2.0F, 2.0F);
-        LegLeft2.setTextureOffset(64, 32);
-        LegLeft2.mirror = true;
-        setRotation(LegLeft2, -1.047198F, 0.0F, 0.0F);
-        LegRight1 = new ModelRenderer(this, 22, 0);
-        LegRight1.addBox(-0.5F, 0.0F, 0.0F, 1, 2, 1);
-        LegRight1.setRotationPoint(-1F, 2.0F, 2.0F);
-        setRotation(LegRight1, 0.0F, 0.0F, 0.0F);
-        LegRight1.mirror = false;
-        LegRight2 = new ModelRenderer(this, 18, 0);
-        LegRight2.addBox(-0.5F, 1.0F, 1.7F, 1, 2, 1);
-        LegRight2.setRotationPoint(-1F, 2.0F, 2.0F);
-        LegRight2.setTextureOffset(64, 32);
-        setRotation(LegRight2, -1.047198F, 0.0F, 0.0F);
-        LegRight2.mirror = false;
-        TailFeather1 = new ModelRenderer(this, 34, 12);
-        TailFeather1.addBox(-1.5F, 0.0F, -1F, 3, 7, 1);
-        TailFeather1.setRotationPoint(0.0F, -1F, 2.0F);
-        TailFeather1.setTextureOffset(64, 32);
-        TailFeather1.mirror = true;
-        setRotation(TailFeather1, 1.570796F, 0.0F, 0.0F);
-        TailFeather2 = new ModelRenderer(this, 42, 12);
-        TailFeather2.addBox(-1.5F, 0.0F, -1F, 3, 6, 1);
-        TailFeather2.setRotationPoint(0.0F, -1.2F, 2.0F);
-        TailFeather2.setTextureOffset(64, 32);
-        TailFeather2.mirror = true;
-        setRotation(TailFeather2, 1.570796F, 0.3490659F, 0.0F);
-        TailFeather3 = new ModelRenderer(this, 42, 12);
-        TailFeather3.addBox(-1.5F, 0.0F, -1F, 3, 6, 1);
-        TailFeather3.setRotationPoint(0.0F, -1.1F, 2.0F);
-        TailFeather3.setTextureOffset(64, 32);
-        setRotation(TailFeather3, 1.570796F, -0.3490659F, 0.0F);
-        TailFeather3.mirror = false;
-        WingLeft1 = new ModelRenderer(this, 34, 0);
-        WingLeft1.addBox(0.0F, -3F, -1F, 3, 6, 1);
-        WingLeft1.setRotationPoint(1.5F, -1F, -1F);
-        WingLeft1.setTextureOffset(64, 32);
-        WingLeft1.mirror = true;
-        setRotation(WingLeft1, 1.570796F, 0.0F, 0.0F);
-        WingLeft2 = new ModelRenderer(this, 42, 0);
-        WingLeft2.addBox(3F, -3F, -1F, 3, 6, 1);
-        WingLeft2.setRotationPoint(1.5F, -1F, -1F);
-        WingLeft2.setTextureOffset(64, 32);
-        WingLeft2.mirror = true;
-        setRotation(WingLeft2, 1.570796F, 0.0F, 0.0F);
-        WingLeft3 = new ModelRenderer(this, 50, 0);
-        WingLeft3.addBox(-1F, 4.5F, -1F, 6, 10, 1);
-        WingLeft3.setRotationPoint(1.5F, -0.9F, -1F);
-        WingLeft3.setTextureOffset(64, 32);
-        WingLeft3.mirror = true;
-        setRotation(WingLeft3, 1.570796F, 1.22173F, 0.0F);
-        WingRight1 = new ModelRenderer(this, 34, 0);
-        WingRight1.addBox(-3F, -3F, -1F, 3, 6, 1);
-        WingRight1.setRotationPoint(-1.5F, -1F, -1F);
-        WingRight1.setTextureOffset(64, 32);
-        setRotation(WingRight1, 1.570796F, 0.0F, 0.0F);
-        WingRight1.mirror = false;
-        WingRight2 = new ModelRenderer(this, 42, 0);
-        WingRight2.addBox(-6F, -3F, -1F, 3, 6, 1);
-        WingRight2.setRotationPoint(-1.5F, -1F, -1F);
-        WingRight2.setTextureOffset(64, 32);
-        setRotation(WingRight2, 1.570796F, 0.0F, 0.0F);
-        WingRight2.mirror = false;
-        WingRight3 = new ModelRenderer(this, 50, 11);
-        WingRight3.addBox(-1F, 4.5F, 0.0F, 6, 10, 1);
-        WingRight3.setRotationPoint(-1.5F, -0.9F, -1F);
-        WingRight3.setTextureOffset(64, 32);
-        WingRight3.mirror = true;
-        setRotation(WingRight3, 1.570796F, -1.22173F, 3.141593F);
-    }
-
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.render(entity, f, f1, f2, f3, f4, f5);
-        setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-        EntityAtmosCrow entitycrow = (EntityAtmosCrow)entity;
-        /*if(entitycrow.isFlying() || entitycrow.flyingMode)
-        {
-            float f6 = 1.5F;
-            GL11.glPushMatrix();
-            Head.render(f5);
-            Beak1.render(f5);
-            Beak2.render(f5);
-            Neck.render(f5);
-            Body.render(f5);
-            Tail1.render(f5);
-            Tail2.render(f5);
-            LegLeft1.render(f5);
-            LegLeft2.render(f5);
-            LegRight1.render(f5);
-            LegRight2.render(f5);
-            TailFeather1.render(f5);
-            TailFeather2.render(f5);
-            TailFeather3.render(f5);
-            GL11.glPopMatrix();
-            GL11.glPushMatrix();
-            GL11.glScalef(1.0F / f6, 1.0F / f6, 1.0F / f6);
-            GL11.glTranslatef(0.05F, 0.0F * f5, -0.1F);
-            WingLeft1.render(f5);
-            WingLeft2.render(f5);
-            WingLeft3.render(f5);
-            GL11.glTranslatef(-0.1F, 0.0F, 0.0F);
-            WingRight1.render(f5);
-            WingRight2.render(f5);
-            WingRight3.render(f5);
-            GL11.glPopMatrix();
-        } else
-        {*/
-            Head.render(f5);
-            Beak1.render(f5);
-            Beak2.render(f5);
-            Neck.render(f5);
-            Body.render(f5);
-            Tail1.render(f5);
-            Tail2.render(f5);
-            LegLeft1.render(f5);
-            LegLeft2.render(f5);
-            LegRight1.render(f5);
-            LegRight2.render(f5);
-            TailFeather1.render(f5);
-            TailFeather2.render(f5);
-            TailFeather3.render(f5);
-            WingLeft1.render(f5);
-            WingLeft2.render(f5);
-            WingLeft3.render(f5);
-            WingRight1.render(f5);
-            WingRight2.render(f5);
-            WingRight3.render(f5);
-//        }
-    }
-
-    private void setRotation(ModelRenderer model, float x, float y, float z)
-    {
-        model.rotateAngleX = x;
-        model.rotateAngleY = y;
-        model.rotateAngleZ = z;
-    }
-
-    public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5, Entity entity)
-    {
-        super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-        Head.rotateAngleX = f4 / 57.29578F;
-        Head.rotateAngleZ = f3 / 57.29578F;
-        Beak1.rotateAngleX = f4 / 57.29578F + 1.570796F;
-        Beak1.rotateAngleY = f3 / 57.29578F;
-        Beak2.rotateAngleX = f4 / 57.29578F - 1.291544F;
-        Beak2.rotateAngleY = f3 / 57.29578F;
-        WingLeft1.rotateAngleZ = -f2;
-        WingRight1.rotateAngleZ = f2;
-        WingLeft2.rotateAngleZ = -f2;
-        WingRight2.rotateAngleZ = f2;
-        WingLeft3.rotateAngleZ = -f2;
-        WingRight3.rotateAngleZ = f2;
-//        WingLeft2.d = -1F;
-//        WingRight2.d = -1F;
-        WingLeft3.rotateAngleY = 1.22173F;
-        WingLeft3.rotateAngleX = 1.570796F;
-//        WingLeft3.d = -0.9F;
-//        WingLeft3.e = -1F;
-        WingRight3.rotateAngleY = 1.919862F;
-        WingRight3.rotateAngleX = -1.570796F;
-//        WingRight3.d = -0.9F;
-//        WingRight3.e = -1F;
-        EntityAtmosCrow entitycrow = (EntityAtmosCrow)entity;
-        /*if(entitycrow.flyingMode || entitycrow.isFlying())
-        {
-            WingLeft1.rotateAngleZ = 1.5F;
-            WingRight1.rotateAngleZ = -1.5F;
-            WingLeft2.rotateAngleZ = -1.5F;
-            WingRight2.rotateAngleZ = 1.5F;
-//            WingLeft2.d = 5F;
-//            WingRight2.d = 5F;
-            WingLeft3.rotateAngleZ = -1.5F;
-            WingLeft3.rotateAngleY = 0.3F;
-            WingLeft3.rotateAngleX = 1.5F;
-//            WingLeft3.d = 5.9F;
-//            WingLeft3.e = -7F;
-            WingRight3.rotateAngleZ = -1.5F;
-            WingRight3.rotateAngleY = 0.3F;
-            WingRight3.rotateAngleX = 1.7F;
-//            WingRight3.d = 5.9F;
-//            WingRight3.e = -7F;
-        }*/
-//        LegLeft1.rotateAngleX = -ke.setTextureOffset(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-//        LegLeft2.rotateAngleX = -ke.setTextureOffset(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1 - 1.047198F;
-//        LegRight1.rotateAngleX = ke.setTextureOffset(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-//        LegRight2.rotateAngleX = ke.setTextureOffset(f * 0.6662F * 2.0F + 0.0F) * 0.6F * f1 - 1.047198F;
-    }
-
-    ModelRenderer Head;
-    ModelRenderer Beak1;
-    ModelRenderer Beak2;
-    ModelRenderer Neck;
-    ModelRenderer Body;
-    ModelRenderer Tail1;
-    ModelRenderer Tail2;
-    ModelRenderer LegLeft1;
-    ModelRenderer LegLeft2;
-    ModelRenderer LegRight1;
-    ModelRenderer LegRight2;
-    ModelRenderer TailFeather1;
-    ModelRenderer TailFeather2;
-    ModelRenderer TailFeather3;
-    ModelRenderer WingLeft1;
-    ModelRenderer WingLeft2;
-    ModelRenderer WingLeft3;
-    ModelRenderer WingRight1;
-    ModelRenderer WingRight2;
-    ModelRenderer WingRight3;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSeaTurtle.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSeaTurtle.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSeaTurtle.java	(date 1525605768000)
@@ -1,70 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosSeaTurtle.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import axa;
-import bcj;
-import lq;
-import md;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosSeaTurtle;
-import org.lwjgl.opengl.GL11;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosSeaTurtle
-
-public class RenderAtmosSeaTurtle extends bcj
-{
-
-    public RenderAtmosSeaTurtle(axa modelbase, float f)
-    {
-        super(modelbase, f);
-    }
-
-    public void renderSeaTurtle(EntityAtmosSeaTurtle entitySeaTurtle, double d, double d1, double d2,
-                                float f, float f1)
-    {
-        super.a(entitySeaTurtle, d, d1, d2, f, f1);
-    }
-
-    public void a(md entityliving, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderSeaTurtle((EntityAtmosSeaTurtle)entityliving, d, d1, d2, f, f1);
-    }
-
-    public void a(lq entity, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderSeaTurtle((EntityAtmosSeaTurtle)entity, d, d1, d2, f, f1);
-    }
-
-    protected void preRenderScale(md entityliving, float f)
-    {
-        GL11.glScalef(1.0F, 1.0F, 1.0F);
-        EntityAtmosSeaTurtle entitySeaTurtle = (EntityAtmosSeaTurtle)entityliving;
-        if(entitySeaTurtle.isDiving())
-            isDescending(entityliving);
-        if(entitySeaTurtle.isRising())
-            isAscending(entityliving);
-    }
-
-    protected void a(md entityliving, float f)
-    {
-        preRenderScale((EntityAtmosSeaTurtle)entityliving, f);
-    }
-
-    protected void isAscending(md entityliving)
-    {
-        GL11.glRotatef(-45F, -1F, 0.0F, 0.0F);
-    }
-
-    protected void isDescending(md entityliving)
-    {
-        GL11.glRotatef(45F, -1F, 0.0F, 0.0F);
-    }
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityRedPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityRedPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityRedPhantom.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.world.World;
-
-public class EntityRedPhantom extends EntityLiving {
-
-    public EntityRedPhantom(World worldIn) {
-        super(worldIn);
-        this.setHealth(this.getMaxHealth());
-        setSize(0.5F, 0.5F);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/utils/WorldGenerationTools.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/utils/WorldGenerationTools.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/utils/WorldGenerationTools.java	(date 1525605768000)
@@ -1,77 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.utils;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-
-public class WorldGenerationTools {
-
-    public static int findUpsideDownEmptySpot(World world, int x, int z) {
-        for (int y = 90 ; y > 0 ; y--) {
-            if (world.isAirBlock(new BlockPos(x, y, z)) && world.isAirBlock(new BlockPos(x, y+1, z)) && world.isAirBlock(new BlockPos(x, y+2, z))
-                    && world.isAirBlock(new BlockPos(x, y+3, z)) && world.isAirBlock(new BlockPos(x, y+4, z))) {
-                return y;
-            }
-        }
-        return -1;
-    }
-
-
-
-    public static int findSuitableEmptySpot(World world, int x, int z) {
-        int y = world.getTopSolidOrLiquidBlock(new BlockPos(x, 0, z)).getY();
-        if (y == -1) {
-            return -1;
-        }
-
-        y--;            // y should now be at a solid or liquid animation.animations.blocks.
-
-        if (y > world.getHeight() - 5) {
-            y = world.getHeight() / 2;
-        }
-
-
-        IBlockState state = world.getBlockState(new BlockPos(x, y + 1, z));
-        Block block = state.getBlock();
-        while (block.getMaterial(state).isLiquid()) {
-            y++;
-            if (y > world.getHeight()-10) {
-                return -1;
-            }
-            state = world.getBlockState(new BlockPos(x, y + 1, z));
-            block = state.getBlock();
-        }
-
-        return y;
-    }
-
-    // Return true if this animation.animations.blocks is solid.
-    public static boolean isSolid(World world, int x, int y, int z) {
-        if (world.isAirBlock(new BlockPos(x, y, z))) {
-            return false;
-        }
-        IBlockState state = world.getBlockState(new BlockPos(x, y, z));
-        Block block = state.getBlock();
-        return block.getMaterial(state).blocksMovement();
-    }
-
-    // Return true if this animation.animations.blocks is solid.
-    public static boolean isAir(World world, int x, int y, int z) {
-        if (world.isAirBlock(new BlockPos(x, y, z))) {
-            return true;
-        }
-        Block block = world.getBlockState(new BlockPos(x, y, z)).getBlock();
-        return block == null;
-    }
-
-    // Starting at the current height, go down and fill all air animations.blocks with stone until a
-    // non-air animation.animations.blocks is encountered.
-    public static void fillEmptyWithStone(World world, int x, int y, int z) {
-        while (y > 0 && !isSolid(world, x, y, z)) {
-            world.setBlockState(new BlockPos(x, y, z), Blocks.STONE.getDefaultState(), 2);
-            y--;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoralPlant.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoralPlant.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockCoralPlant.java	(date 1525605768000)
@@ -1,114 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockHorizontal;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.properties.PropertyEnum;
-import net.minecraft.block.state.BlockStateContainer;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.Minecraft;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.item.Item;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.IBlockAccess;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.blocks.BlockModBush;
-import net.thegaminghuskymc.mcaddon.properties.EnumCoralColor;
-
-import static net.minecraft.block.BlockLiquid.LEVEL;
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockCoralPlant extends BlockModBush {
-
-    private final EnumCoralColor color;
-    private static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
-
-    public BlockCoralPlant(EnumCoralColor coralColor, String name) {
-        super(Material.WATER, coralColor + "_" + name, MOD_ID);
-        this.color = coralColor;
-        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
-    }
-
-    @Override
-    public IProperty[] getIgnoredProperties() {
-        return new IProperty[] {LEVEL};
-    }
-
-    @SideOnly(Side.CLIENT)
-    public static EnumCoralColor getColorFromItem(Item itemIn) {
-        return getColorFromBlock(Block.getBlockFromItem(itemIn));
-    }
-
-    @SideOnly(Side.CLIENT)
-    private static EnumCoralColor getColorFromBlock(Block blockIn) {
-        return blockIn instanceof BlockCoralPlant ? ((BlockCoralPlant) blockIn).getColor() : EnumCoralColor.BLUE;
-    }
-
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    @Override
-    public boolean canPlaceBlockOnSide(World worldIn, BlockPos pos, EnumFacing side) {
-        if(this == Block.getBlockFromName("hmca:" + color.getName() + "_coral_fan")) {
-            return side != EnumFacing.DOWN && side != EnumFacing.UP;
-        } else {
-            return true;
-        }
-    }
-
-
-    @SideOnly(Side.CLIENT)
-    private EnumCoralColor getColor() {
-        return this.color;
-    }
-
-    @Override
-    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
-        state = worldIn.getBlockState(pos.down());
-        Block block = state.getBlock();
-        if (worldIn.getBlockState(pos.up()).getMaterial() != Material.WATER) return false;
-        return block.canSustainPlant(state, worldIn, pos.down(), EnumFacing.UP, this);
-    }
-
-    @Override
-    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand) {
-        IBlockState state = super.getStateForPlacement(world, pos, facing, hitX, hitY, hitZ, meta, placer, hand);
-        return state.withProperty(FACING, placer.getHorizontalFacing());
-    }
-
-    @Override
-    public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos) {
-        return canBlockStay(Minecraft.getMinecraft().world, pos, this.getDefaultState());
-    }
-
-    public int getMetaFromState(IBlockState state) {
-        return (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
-    }
-
-    @Override
-    public IBlockState getStateFromMeta(int meta) {
-        return this.getDefaultState().withProperty(FACING, EnumFacing.getHorizontal(meta));
-    }
-
-    protected BlockStateContainer createBlockState() {
-        return new BlockStateContainer(this, FACING, LEVEL);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosWhale.java	(date 1525605768000)
@@ -1,49 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosWhale.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import axa;
-import bcj;
-import md;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosWhale;
-import org.lwjgl.opengl.GL11;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosWhale
-
-public class RenderAtmosWhale extends bcj
-{
-
-    public RenderAtmosWhale(axa par1ModelBase, float par2)
-    {
-        super(par1ModelBase, par2);
-    }
-
-    public void renderWhale(EntityAtmosWhale par1EntityWhale, double par2, double par4, double par6,
-                            float par8, float par9)
-    {
-        super.a(par1EntityWhale, par2, par4, par6, par8, par9);
-    }
-
-    public void a(md par1EntityLiving, double par2, double par4, double par6, 
-            float par8, float par9)
-    {
-        renderWhale((EntityAtmosWhale)par1EntityLiving, par2, par4, par6, par8, par9);
-    }
-
-    protected void scaleWhale(EntityAtmosWhale par1EntityWhale, float par2)
-    {
-        float f = par1EntityWhale.whaleScaleAmount();
-        GL11.glScalef(f, f, f);
-    }
-
-    protected void a(md par1EntityLiving, float par2)
-    {
-        scaleWhale((EntityAtmosWhale)par1EntityLiving, par2);
-    }
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseHoe.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseHoe.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseHoe.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.tools;
-
-import net.thegaminghuskymc.mcaddon.items.ItemModHoe;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BaseHoe extends ItemModHoe {
-
-    public BaseHoe(String name, ToolMaterial material)  {
-        super(material, name, MOD_ID);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherSlabBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherSlabBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/nether/BlockNetherSlabBase.java	(date 1525605768000)
@@ -1,25 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.nether;
-
-import net.minecraft.block.material.Material;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModSlab;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockNetherSlabBase extends BlockModSlab {
-
-    public BlockNetherSlabBase(String name, boolean isDouble) {
-        super(name, MOD_ID, Material.ROCK, isDouble);
-        setCreativeTab(Main.NETHER_EXPANSION_TAB);
-    }
-
-    @Override
-    public String getModNamespace() {
-        return MOD_ID;
-    }
-
-    @Override
-    public String getPrefix() {
-        return MOD_ID;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/RoomStructure.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/RoomStructure.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/dungeons/generator/RoomStructure.java	(date 1525605768000)
@@ -1,52 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.dungeons.generator;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.thegaminghuskymc.mcaddon.util.interfaces.IStructure;
-
-import java.util.Random;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class RoomStructure extends WorldGenerator implements IStructure {
-
-    private static String structureName;
-
-    public RoomStructure(String name)
-    {
-        structureName = name;
-    }
-
-    @Override
-    public boolean generate(World worldIn, Random rand, BlockPos position) {
-        generateStructure(worldIn, position);
-        return true;
-    }
-
-    private static void generateStructure(World world, BlockPos pos)
-    {
-        MinecraftServer mcServer = world.getMinecraftServer();
-        TemplateManager manager = worldServer.getStructureTemplateManager();
-        ResourceLocation location = new ResourceLocation(MOD_ID, structureName);
-        Template template = manager.get(mcServer, location);
-
-        if(template != null)
-        {
-            IBlockState state = world.getBlockState(pos);
-            world.notifyBlockUpdate(pos, state, state, 3);
-            template.addBlocksToWorldChunk(world, pos, settings);
-        }
-
-        if(template == null)
-        {
-            System.out.println("NO STRUCTURE");
-        }
-
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/Type.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/Type.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/Type.java	(date 1525605768000)
@@ -1,90 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-
-public enum Type implements IStringSerializable {
-
-		RAW(0, "raw"),
-		PAVER(1, "paver"),
-		BRICKS(2, "bricks"),
-		CHISELED(3, "chiseled"),
-		BRICK_SMALL(4, "brick_small"),
-		TILE(5, "tile"),
-		PILLAR(6, "pillar"),
-		ARCH(7, "arch"),
-		ENGRAVED(8, "engraved"),
-		RUNED(9, "runed"),
-		PILLAR_TOP(10, "pillar_top"),
-		PILLAR_BOTTOM(11, "pillar_bottom"),
-		PILLAR_MIDDLE(12, "pillar_middle");
-
-		private static final Type[] METADATA_LOOKUP = new Type[values().length];
-
-		static {
-			for (Type type : values()) {
-				METADATA_LOOKUP[type.getMetadata()] = type;
-			}
-		}
-
-		private final int metadata;
-		private final String name;
-		private final int light;
-		private final float hardness;
-		private final float resistance;
-
-		Type(int metadata, String name, int light, float hardness, float resistance) {
-
-			this.metadata = metadata;
-			this.name = name;
-			this.light = light;
-			this.hardness = hardness;
-			this.resistance = resistance;
-		}
-
-		Type(int metadata, String name, float hardness, float resistance) {
-			this(metadata, name, 0, hardness, resistance);
-		}
-
-		Type(int metadata, String name, int light) {
-
-			this(metadata, name, light, 5.0F, 6.0F);
-		}
-
-		Type(int metadata, String name) {
-
-			this(metadata, name, 0, 5.0F, 6.0F);
-		}
-
-		public static Type byMetadata(int metadata) {
-
-			if (metadata < 0 || metadata >= METADATA_LOOKUP.length) {
-				metadata = 0;
-			}
-			return METADATA_LOOKUP[metadata];
-		}
-
-		public int getMetadata() {
-			return this.metadata;
-		}
-
-		@Override
-		public String getName() {
-
-			return this.name;
-		}
-
-		public int getLight() {
-
-			return this.light;
-		}
-
-		public float getHardness() {
-
-			return this.hardness;
-		}
-
-		public float getResistance() {
-
-			return this.resistance;
-		}
-	}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/NetherExBiomes.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/NetherExBiomes.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/NetherExBiomes.java	(date 1525605768000)
@@ -1,63 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.world.DimensionType;
-import net.minecraft.world.biome.Biome;
-import net.minecraftforge.common.BiomeDictionary;
-import net.minecraftforge.common.DimensionManager;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.minecraftforge.fml.common.registry.GameRegistry;
-import net.thegaminghuskymc.mcaddon.world.WorldProviderNether;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeBasaltNether;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeHell;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import static net.minecraftforge.common.BiomeDictionary.Type.*;
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@SuppressWarnings("ConstantConditions")
-@GameRegistry.ObjectHolder(MOD_ID)
-public class NetherExBiomes  {
-
-    @GameRegistry.ObjectHolder("hell")
-    public static final BiomeHell HELL = null;
-
-    @GameRegistry.ObjectHolder("basalt_nether")
-    public static final BiomeBasaltNether BASALT = null;
-
-    private static final Logger LOGGER = LogManager.getLogger("Husky's Minecraft Additions | Biomes");
-
-    @Mod.EventBusSubscriber(modid = MOD_ID)
-    public static class EventHandler
-    {
-        @SubscribeEvent
-        public static void onRegisterBiomes(RegistryEvent.Register<Biome> event)
-        {
-            LOGGER.info("Biome registration started.");
-
-            event.getRegistry().registerAll(
-                    new BiomeHell(),
-                    new BiomeBasaltNether()
-            );
-
-            LOGGER.info("Biome registration completed.");
-        }
-    }
-
-    public static void init()
-    {
-        BiomeDictionary.addTypes(HELL, NETHER, HOT, DRY);
-        BiomeDictionary.addTypes(BASALT, NETHER, HOT, SPOOKY, MAGICAL, WASTELAND);
-    }
-
-    public static void postInit()
-    {
-        DimensionManager.unregisterDimension(-1);
-        DimensionType nether = DimensionType.register("Nether", "_nether", -1, WorldProviderNether.class, false);
-        DimensionManager.registerDimension(-1, nether);
-
-        LOGGER.info("The Nether has been overridden.");
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/FileUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/FileUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/FileUtil.java	(date 1525605768000)
@@ -1,70 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.thegaminghuskymc.mcaddon.Main;
-
-import java.io.*;
-import java.net.JarURLConnection;
-import java.net.URL;
-import java.util.Enumeration;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
-public class FileUtil
-{
-    public static void extractFromJar(String sourcePath, String destinationPath)
-    {
-        URL sourceURL = Main.class.getResource(sourcePath);
-        String fromPath = sourcePath.substring(1);
-
-        if(sourceURL != null && sourceURL.getProtocol().equals("jar"))
-        {
-            try
-            {
-                JarURLConnection jarURLConnection = (JarURLConnection) sourceURL.openConnection();
-                ZipFile zipFile = jarURLConnection.getJarFile();
-                Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
-
-                while(zipEntries.hasMoreElements())
-                {
-                    ZipEntry zipEntry = zipEntries.nextElement();
-                    String zipName = zipEntry.getName();
-
-                    if(!zipName.startsWith(fromPath))
-                    {
-                        continue;
-                    }
-
-                    String pathTail = zipName.substring(fromPath.length());
-                    File file = new File(destinationPath + File.separator + pathTail);
-
-                    if(!file.exists())
-                    {
-                        if(zipEntry.isDirectory())
-                        {
-                            file.mkdir();
-                        }
-                        else
-                        {
-                            InputStream inputStream = zipFile.getInputStream(zipEntry);
-                            OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file));
-                            byte buffer[] = new byte[4096];
-                            int count;
-
-                            while((count = inputStream.read(buffer)) > 0)
-                            {
-                                outputStream.write(buffer, 0, count);
-                            }
-
-                            inputStream.close();
-                            outputStream.close();
-                        }
-                    }
-                }
-            }
-            catch(IOException e)
-            {
-                e.printStackTrace();
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosColourfulFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosColourfulFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosColourfulFish.java	(date 1525605768000)
@@ -1,99 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosColourfulFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import axa;
-import ayf;
-import ke;
-import lq;
-
-public class ModelAtmosColourfulFish extends axa
-{
-
-    public ModelAtmosColourfulFish()
-    {
-        t = 64;
-        u = 32;
-        Body = new ayf(this, 0, 6);
-        Body.a(-0.5F, -2F, -2.5F, 1, 4, 5);
-        Body.a(0.0F, 21F, 0.0F);
-        Body.b(64, 32);
-        Body.i = true;
-        setRotation(Body, 0.0F, 0.0F, 0.0F);
-        Fin1 = new ayf(this, 0, 19);
-        Fin1.a(0.0F, 0.0F, 0.0F, 1, 2, 2);
-        Fin1.a(0.0F, 21F, 2.0F);
-        Fin1.b(64, 32);
-        Fin1.i = true;
-        setRotation(Fin1, 0.7853982F, 0.0F, 0.0F);
-        Fin2 = new ayf(this, 8, 15);
-        Fin2.a(0.0F, 0.0F, 0.0F, 1, 1, 4);
-        Fin2.a(0.0F, 18F, -2F);
-        Fin2.b(64, 32);
-        Fin2.i = true;
-        setRotation(Fin2, -0.1745329F, 0.0F, 0.0F);
-        Fin3 = new ayf(this, 0, 15);
-        Fin3.a(0.0F, 0.0F, 0.0F, 1, 1, 3);
-        Fin3.a(0.0F, 23F, -1F);
-        Fin3.b(64, 32);
-        Fin3.i = true;
-        setRotation(Fin3, 0.296706F, 0.0F, 0.0F);
-        Head = new ayf(this, 0, 2);
-        Head.a(-0.5F, 0.0F, 0.0F, 1, 2, 2);
-        Head.a(0.0F, 21F, -1F);
-        Head.b(64, 32);
-        Head.i = true;
-        setRotation(Head, -2.356194F, 0.0F, 0.0F);
-        Fin4 = new ayf(this, 6, 0);
-        Fin4.a(0.0F, 0.0F, 0.0F, 2, 1, 1);
-        Fin4.a(0.0F, 22F, -2F);
-        Fin4.b(64, 32);
-        Fin4.i = true;
-        setRotation(Fin4, 0.0F, 0.0F, 0.3839724F);
-        Fin5 = new ayf(this, 0, 0);
-        Fin5.a(-2F, 0.0F, 0.0F, 2, 1, 1);
-        Fin5.a(0.0F, 22F, -2F);
-        Fin5.b(64, 32);
-        Fin5.i = true;
-        setRotation(Fin5, 0.0F, 0.0F, -0.3839724F);
-    }
-
-    public void a(lq entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.a(entity, f, f1, f2, f3, f4, f5);
-        a(f, f1, f2, f3, f4, f5, entity);
-        Body.a(f5);
-        Fin1.a(f5);
-        Fin2.a(f5);
-        Fin3.a(f5);
-        Head.a(f5);
-        Fin4.a(f5);
-        Fin5.a(f5);
-    }
-
-    private void setRotation(ayf model, float x, float y, float z)
-    {
-        model.f = x;
-        model.g = y;
-        model.h = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, lq entity)
-    {
-        super.a(f, f1, f2, f3, f4, f5, entity);
-        Fin1.g = -ke.b(f3 * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-    }
-
-    ayf Body;
-    ayf Fin1;
-    ayf Fin2;
-    ayf Fin3;
-    ayf Head;
-    ayf Fin4;
-    ayf Fin5;
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeHell.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeHell.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeHell.java	(date 1525605768000)
@@ -1,14 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.init.Blocks;
-import net.minecraft.world.biome.Biome;
-
-@SuppressWarnings("ConstantConditions")
-public class BiomeHell extends BiomeNether {
-    public BiomeHell() {
-        super(new Biome.BiomeProperties("Hell").setTemperature(2.0F).setRainfall(0.0F).setRainDisabled(), "hell");
-
-        topBlock = Blocks.NETHERRACK.getDefaultState();
-        fillerBlock = Blocks.NETHERRACK.getDefaultState();
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelWhale.java	(date 1525605768000)
@@ -1,68 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-public class ModelWhale extends ModelBase {
-    public ModelRenderer body1;
-    public ModelRenderer body2;
-    public ModelRenderer tail1;
-    public ModelRenderer tail2;
-    public ModelRenderer tail3;
-    public ModelRenderer fin1;
-    public ModelRenderer fin2;
-
-    public ModelWhale() {
-        this.textureWidth = 64;
-        this.textureHeight = 32;
-        this.tail1 = new ModelRenderer(this, 0, 21);
-        this.tail1.mirror = true;
-        this.tail1.setRotationPoint(0.0F, 20.0F, 3.0F);
-        this.tail1.addBox(-2.5F, -1.0F, 8.0F, 5, 2, 6, 0.0F);
-        this.fin2 = new ModelRenderer(this, 35, 21);
-        this.fin2.mirror = true;
-        this.fin2.setRotationPoint(-3.0F, 20.0F, 0.0F);
-        this.fin2.addBox(-2.0F, 1.0F, 0.0F, 2, 1, 5, 0.0F);
-        this.tail2 = new ModelRenderer(this, 18, 21);
-        this.tail2.mirror = true;
-        this.tail2.setRotationPoint(0.0F, 20.0F, 3.0F);
-        this.tail2.addBox(-5.0F, 0.0F, 13.0F, 3, 1, 5, 0.0F);
-        this.body2 = new ModelRenderer(this, 28, 0);
-        this.body2.mirror = true;
-        this.body2.setRotationPoint(0.0F, 20.0F, 3.0F);
-        this.body2.addBox(-2.5F, -2.5F, 0.0F, 5, 5, 9, 0.0F);
-        this.fin1 = new ModelRenderer(this, 35, 21);
-        this.fin1.mirror = true;
-        this.fin1.setRotationPoint(3.0F, 20.0F, 0.0F);
-        this.fin1.addBox(0.0F, 1.0F, 0.0F, 2, 1, 5, 0.0F);
-        this.body1 = new ModelRenderer(this, 0, 0);
-        this.body1.mirror = true;
-        this.body1.setRotationPoint(0.0F, 19.0F, -4.0F);
-        this.body1.addBox(-3.5F, -2.5F, -7.0F, 7, 7, 14, 0.0F);
-        this.tail3 = new ModelRenderer(this, 18, 21);
-        this.tail3.mirror = true;
-        this.tail3.setRotationPoint(0.0F, 20.0F, 3.0F);
-        this.tail3.addBox(2.0F, 0.0F, 13.0F, 3, 1, 5, 0.0F);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
-        this.tail1.render(f5);
-        this.fin2.render(f5);
-        this.tail2.render(f5);
-        this.body2.render(f5);
-        this.fin1.render(f5);
-        this.body1.render(f5);
-        this.tail3.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeVolcano.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeVolcano.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeVolcano.java	(date 1525605768000)
@@ -1,4 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-public class BiomeVolcano {
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelMummyVillager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelMummyVillager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelMummyVillager.java	(date 1525605768000)
@@ -1,91 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBiped;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.monster.EntityZombie;
-import net.minecraft.util.math.MathHelper;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummy;
-
-public class ModelMummyVillager extends ModelBiped {
-
-    public ModelMummyVillager()
-    {
-        this(0.0F, 0.0F, false);
-    }
-
-    public ModelMummyVillager(float p_i1165_1_, float p_i1165_2_, boolean p_i1165_3_)
-    {
-        super(p_i1165_1_, 0.0F, 64, p_i1165_3_ ? 32 : 64);
-
-        if (p_i1165_3_)
-        {
-            this.bipedHead = new ModelRenderer(this, 0, 0);
-            this.bipedHead.addBox(-4.0F, -10.0F, -4.0F, 8, 8, 8, p_i1165_1_);
-            this.bipedHead.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
-            this.bipedBody = new ModelRenderer(this, 16, 16);
-            this.bipedBody.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
-            this.bipedBody.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, p_i1165_1_ + 0.1F);
-            this.bipedRightLeg = new ModelRenderer(this, 0, 16);
-            this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F + p_i1165_2_, 0.0F);
-            this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_ + 0.1F);
-            this.bipedLeftLeg = new ModelRenderer(this, 0, 16);
-            this.bipedLeftLeg.mirror = true;
-            this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F + p_i1165_2_, 0.0F);
-            this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_ + 0.1F);
-        }
-        else
-        {
-            this.bipedHead = new ModelRenderer(this, 0, 0);
-            this.bipedHead.setRotationPoint(0.0F, p_i1165_2_, 0.0F);
-            this.bipedHead.setTextureOffset(0, 0).addBox(-4.0F, -10.0F, -4.0F, 8, 10, 8, p_i1165_1_);
-            this.bipedHead.setTextureOffset(24, 0).addBox(-1.0F, -3.0F, -6.0F, 2, 4, 2, p_i1165_1_);
-            this.bipedBody = new ModelRenderer(this, 16, 20);
-            this.bipedBody.setRotationPoint(0.0F, 0.0F + p_i1165_2_, 0.0F);
-            this.bipedBody.addBox(-4.0F, 0.0F, -3.0F, 8, 12, 6, p_i1165_1_);
-            this.bipedBody.setTextureOffset(0, 38).addBox(-4.0F, 0.0F, -3.0F, 8, 18, 6, p_i1165_1_ + 0.05F);
-            this.bipedRightArm = new ModelRenderer(this, 44, 38);
-            this.bipedRightArm.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, p_i1165_1_);
-            this.bipedRightArm.setRotationPoint(-5.0F, 2.0F + p_i1165_2_, 0.0F);
-            this.bipedLeftArm = new ModelRenderer(this, 44, 38);
-            this.bipedLeftArm.mirror = true;
-            this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, p_i1165_1_);
-            this.bipedLeftArm.setRotationPoint(5.0F, 2.0F + p_i1165_2_, 0.0F);
-            this.bipedRightLeg = new ModelRenderer(this, 0, 22);
-            this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F + p_i1165_2_, 0.0F);
-            this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_);
-            this.bipedLeftLeg = new ModelRenderer(this, 0, 22);
-            this.bipedLeftLeg.mirror = true;
-            this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F + p_i1165_2_, 0.0F);
-            this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, p_i1165_1_);
-        }
-    }
-
-    /**
-     * Sets the model's various rotation angles. For bipeds, par1 and par2 are used for animating the movement of arms
-     * and legs, where par1 represents the time(so that arms and legs swing back and forth) and par2 represents how
-     * "far" arms and legs can swing at most.
-     */
-    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
-    {
-        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);
-        EntityMummy entityMummy = (EntityMummy) entityIn;
-        float f = MathHelper.sin(this.swingProgress * (float)Math.PI);
-        float f1 = MathHelper.sin((1.0F - (1.0F - this.swingProgress) * (1.0F - this.swingProgress)) * (float)Math.PI);
-        this.bipedRightArm.rotateAngleZ = 0.0F;
-        this.bipedLeftArm.rotateAngleZ = 0.0F;
-        this.bipedRightArm.rotateAngleY = -(0.1F - f * 0.6F);
-        this.bipedLeftArm.rotateAngleY = 0.1F - f * 0.6F;
-        float f2 = -(float)Math.PI / (entityMummy.isArmsRaised() ? 1.5F : 2.25F);
-        this.bipedRightArm.rotateAngleX = f2;
-        this.bipedLeftArm.rotateAngleX = f2;
-        this.bipedRightArm.rotateAngleX += f * 1.2F - f1 * 0.4F;
-        this.bipedLeftArm.rotateAngleX += f * 1.2F - f1 * 0.4F;
-        this.bipedRightArm.rotateAngleZ += MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
-        this.bipedLeftArm.rotateAngleZ -= MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
-        this.bipedRightArm.rotateAngleX += MathHelper.sin(ageInTicks * 0.067F) * 0.05F;
-        this.bipedLeftArm.rotateAngleX -= MathHelper.sin(ageInTicks * 0.067F) * 0.05F;
-    }
-
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSwordFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSwordFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosSwordFish.java	(date 1525605768000)
@@ -1,70 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosSwordFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import axa;
-import bcj;
-import lq;
-import md;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosSwordFish;
-import org.lwjgl.opengl.GL11;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosSwordFish
-
-public class RenderAtmosSwordFish extends bcj
-{
-
-    public RenderAtmosSwordFish(axa modelbase, float f)
-    {
-        super(modelbase, f);
-    }
-
-    public void renderSwordFish(EntityAtmosSwordFish entitySwordFish, double d, double d1, double d2,
-                                float f, float f1)
-    {
-        super.a(entitySwordFish, d, d1, d2, f, f1);
-    }
-
-    public void a(md entityliving, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderSwordFish((EntityAtmosSwordFish)entityliving, d, d1, d2, f, f1);
-    }
-
-    public void a(lq entity, double d, double d1, double d2, 
-            float f, float f1)
-    {
-        renderSwordFish((EntityAtmosSwordFish)entity, d, d1, d2, f, f1);
-    }
-
-    protected void preRenderScale(md entityliving, float f)
-    {
-        GL11.glScalef(1.0F, 1.0F, 1.0F);
-        EntityAtmosSwordFish entitySwordFish = (EntityAtmosSwordFish)entityliving;
-        if(entitySwordFish.isDiving())
-            isDescending(entityliving);
-        if(entitySwordFish.isRising())
-            isAscending(entityliving);
-    }
-
-    protected void a(md entityliving, float f)
-    {
-        preRenderScale((EntityAtmosSwordFish)entityliving, f);
-    }
-
-    protected void isAscending(md entityliving)
-    {
-        GL11.glRotatef(-45F, -1F, 0.0F, 0.0F);
-    }
-
-    protected void isDescending(md entityliving)
-    {
-        GL11.glRotatef(45F, -1F, 0.0F, 0.0F);
-    }
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemTrident.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemTrident.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemTrident.java	(date 1525605768000)
@@ -1,12 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.creativetab.CreativeTabs;
-import net.thegaminghuskymc.mcaddon.Main;
-
-public class ItemTrident extends ItemBase {
-
-    public ItemTrident(String name, CreativeTabs creativeTabs) {
-        super("trident", Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityEnderPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityEnderPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityEnderPhantom.java	(date 1525605768000)
@@ -1,18 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.world.World;
-
-public class EntityEnderPhantom extends EntityLiving {
-
-    public EntityEnderPhantom(World worldIn) {
-        super(worldIn);
-        this.setHealth(this.getMaxHealth());
-        setSize(0.5F, 0.5F);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSuperDeepOcean.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSuperDeepOcean.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeSuperDeepOcean.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.world.biome.Biome;
-
-public class BiomeSuperDeepOcean extends Biome {
-
-    public BiomeSuperDeepOcean() {
-        super(new Biome.BiomeProperties("Super Deep Ocean").setBaseHeight(-5.0F).setHeightVariation(0.4F).setBaseBiome("ocean"));
-    }
-
-    public Biome.TempCategory getTempCategory()
-    {
-        return Biome.TempCategory.OCEAN;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderPhantom.java	(date 1525605768000)
@@ -1,23 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityPhantom;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelPhantom;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderPhantom extends RenderLiving<EntityPhantom> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/phantom.png");
-
-    public RenderPhantom(RenderManager manager) {
-        super(manager, new ModelPhantom(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityPhantom entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityTurtle.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityTurtle.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityTurtle.java	(date 1525605768000)
@@ -1,273 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntitySmallFireball;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNodeType;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-
-public class EntityTurtle extends EntityMob {
-
-    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityTurtle.class, DataSerializers.BYTE);
-    /**
-     * Random offset used in floating behaviour
-     */
-    private float heightOffset = 0.5F;
-    /**
-     * ticks until heightOffset is randomized
-     */
-    private int heightOffsetUpdateTime;
-
-    public EntityTurtle(World worldIn) {
-        super(worldIn);
-        this.isImmuneToFire = true;
-        this.experienceValue = 10;
-    }
-
-    public static void registerFixesBlaze(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityTurtle.class);
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(4, new EntityTurtle.AIFireballAttack(this));
-        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(ON_FIRE, (byte) 0);
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_BLAZE_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_BLAZE_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_BLAZE_DEATH;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender() {
-        return 15728880;
-    }
-
-    /**
-     * Gets how bright this entity is.
-     */
-    public float getBrightness() {
-        return 1.0F;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        if (!this.onGround && this.motionY < 0.0D) {
-            this.motionY *= 0.6D;
-        }
-
-        if (this.world.isRemote) {
-            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-
-            for (int i = 0; i < 2; ++i) {
-                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
-            }
-        }
-
-        super.onLivingUpdate();
-    }
-
-    protected void updateAITasks() {
-        if (this.isWet()) {
-            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
-        }
-
-        --this.heightOffsetUpdateTime;
-
-        if (this.heightOffsetUpdateTime <= 0) {
-            this.heightOffsetUpdateTime = 100;
-            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
-        }
-
-        EntityLivingBase entitylivingbase = this.getAttackTarget();
-
-        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
-            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
-            this.isAirBorne = true;
-        }
-
-        super.updateAITasks();
-    }
-
-    public void fall(float distance, float damageMultiplier) {
-    }
-
-    /**
-     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
-     */
-    public boolean isBurning() {
-        return this.isCharged();
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_BLAZE;
-    }
-
-    private boolean isCharged() {
-        return (this.dataManager.get(ON_FIRE) & 1) != 0;
-    }
-
-    private void setOnFire(boolean onFire) {
-        byte b0 = this.dataManager.get(ON_FIRE);
-
-        if (onFire) {
-            b0 = (byte) (b0 | 1);
-        } else {
-            b0 = (byte) (b0 & -2);
-        }
-
-        this.dataManager.set(ON_FIRE, b0);
-    }
-
-    /**
-     * Checks to make sure the light is not too bright where the mob is spawning
-     */
-    protected boolean isValidLightLevel() {
-        return true;
-    }
-
-    static class AIFireballAttack extends EntityAIBase {
-        private final EntityTurtle blaze;
-        private int attackStep;
-        private int attackTime;
-
-        AIFireballAttack(EntityTurtle blazeIn) {
-            this.blaze = blazeIn;
-            this.setMutexBits(3);
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            return entitylivingbase != null && entitylivingbase.isEntityAlive();
-        }
-
-        /**
-         * Execute a one shot task or start executing a continuous task
-         */
-        public void startExecuting() {
-            this.attackStep = 0;
-        }
-
-        /**
-         * Reset the task's internal state. Called when this task is interrupted by another one
-         */
-        public void resetTask() {
-            this.blaze.setOnFire(false);
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            --this.attackTime;
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
-
-            if (d0 < 4.0D) {
-                if (this.attackTime <= 0) {
-                    this.attackTime = 20;
-                    this.blaze.attackEntityAsMob(entitylivingbase);
-                }
-
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
-                double d1 = entitylivingbase.posX - this.blaze.posX;
-                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
-                double d3 = entitylivingbase.posZ - this.blaze.posZ;
-
-                if (this.attackTime <= 0) {
-                    ++this.attackStep;
-
-                    if (this.attackStep == 1) {
-                        this.attackTime = 60;
-                        this.blaze.setOnFire(true);
-                    } else if (this.attackStep <= 4) {
-                        this.attackTime = 6;
-                    } else {
-                        this.attackTime = 100;
-                        this.attackStep = 0;
-                        this.blaze.setOnFire(false);
-                    }
-
-                    if (this.attackStep > 1) {
-                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
-                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
-
-                        for (int i = 0; i < 1; ++i) {
-                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
-                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
-                            this.blaze.world.spawnEntity(entitysmallfireball);
-                        }
-                    }
-                }
-
-                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
-            } else {
-                this.blaze.getNavigator().clearPath();
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            }
-
-            super.updateTask();
-        }
-
-        private double getFollowDistance() {
-            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
-            return iattributeinstance.getAttributeValue();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/IGeneratable.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/IGeneratable.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/IGeneratable.java	(date 1525605768000)
@@ -1,15 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world;
-
-import net.minecraft.util.Mirror;
-import net.minecraft.util.Rotation;
-import net.minecraft.world.World;
-
-public interface IGeneratable {
-    void generateIn(World var1, int var2, int var3, int var4, Rotation var5, Mirror var6, boolean var7);
-
-    void calcDimensions();
-
-    int getWidth();
-
-    int getLength();
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosStarFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosStarFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosStarFish.java	(date 1525605768000)
@@ -1,44 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RenderAtmosStarFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import axa;
-import bcj;
-import lq;
-import md;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosStarFish;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosStarFish
-
-public class RenderAtmosStarFish extends bcj
-{
-
-    public RenderAtmosStarFish(axa par1ModelBase, float par2)
-    {
-        super(par1ModelBase, par2);
-    }
-
-    public void renderStarFish(EntityAtmosStarFish par1EntityStarFish, double par2, double par4, double par6,
-                               float par8, float par9)
-    {
-        super.a(par1EntityStarFish, par2, par4, par6, par8, par9);
-    }
-
-    public void a(md par1EntityLiving, double par2, double par4, double par6, 
-            float par8, float par9)
-    {
-        renderStarFish((EntityAtmosStarFish)par1EntityLiving, par2, par4, par6, par8, par9);
-    }
-
-    public void a(lq par1Entity, double par2, double par4, double par6, 
-            float par8, float par9)
-    {
-        renderStarFish((EntityAtmosStarFish)par1Entity, par2, par4, par6, par8, par9);
-    }
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/commands/SearchResult.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/commands/SearchResult.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/commands/SearchResult.java	(date 1525605768000)
@@ -1,39 +0,0 @@
-package net.thegaminghuskymc.mcaddon.commands;
-
-public class SearchResult {
-
-	private int x;
-	private int z;
-	private int radius;
-	private int samples;
-	private boolean found;
-
-	public SearchResult(int x, int z, int radius, int samples, boolean found) {
-		this.x = x;
-		this.z = z;
-		this.radius = radius;
-		this.samples = samples;
-		this.found = found;
-	}
-
-	public int getX() {
-		return x;
-	}
-
-	public int getZ() {
-		return z;
-	}
-
-	public int getRadius() {
-		return radius;
-	}
-	
-	public int getSamples() {
-		return samples;
-	}
-
-	public boolean found() {
-		return found;
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelCod.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelCod.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelCod.java	(date 1525605768000)
@@ -1,91 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.client.renderer.GlStateManager;
-import net.minecraft.entity.Entity;
-
-public class ModelCod extends ModelBase {
-
-    public ModelRenderer head0;
-    public ModelRenderer head1;
-    public ModelRenderer leftFin;
-    public ModelRenderer rightFin;
-    public ModelRenderer tailFin;
-    public ModelRenderer waist;
-    public ModelRenderer body0;
-    public ModelRenderer body1;
-
-    public ModelCod() {
-        this.textureWidth = 32;
-        this.textureHeight = 32;
-        this.leftFin = new ModelRenderer(this, 24, 4);
-        this.leftFin.setRotationPoint(0.0F, 3.0F, -3.0F);
-        this.leftFin.addBox(1.0F, 0.0F, 0.0F, 2, 1, 2, 0.0F);
-        this.setRotateAngle(leftFin, -0.045553093477052F, 0.0F, 0.0F);
-        this.body0 = new ModelRenderer(this, 0, 0);
-        this.body0.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.body0.addBox(-1.0F, 0.0F, -1.0F, 2, 4, 7, 0.0F);
-        this.head1 = new ModelRenderer(this, 11, 0);
-        this.head1.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.head1.addBox(-1.0F, 0.0F, -4.0F, 2, 4, 3, 0.0F);
-        this.head0 = new ModelRenderer(this, 0, 0);
-        this.head0.setRotationPoint(0.0F, -1.0F, 0.0F);
-        this.head0.addBox(-1.0F, 1.0F, -5.0F, 2, 3, 1, 0.0F);
-        this.tailFin = new ModelRenderer(this, 20, 1);
-        this.tailFin.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.tailFin.addBox(0.0F, 0.0F, 6.0F, 0, 4, 6, 0.0F);
-        this.waist = new ModelRenderer(this, 0, 0);
-        this.waist.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.waist.addBox(0.0F, 0.0F, 0.0F, 0, 0, 0, 0.0F);
-        this.body1 = new ModelRenderer(this, 20, -6);
-        this.body1.setRotationPoint(0.0F, -4.0F, 0.0F);
-        this.body1.addBox(-0.6F, 4.0F, -2.0F, 0, 0, 6, 0.5F);
-        this.rightFin = new ModelRenderer(this, 24, 1);
-        this.rightFin.setRotationPoint(0.0F, 3.0F, -3.0F);
-        this.rightFin.addBox(-3.0F, 0.0F, 0.0F, 2, 1, 2, 0.0F);
-    }
-
-    @Override
-    public void render(Entity entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
-        GlStateManager.pushMatrix();
-        GlStateManager.translate(this.leftFin.offsetX, this.leftFin.offsetY, this.leftFin.offsetZ);
-        GlStateManager.translate(this.leftFin.rotationPointX * scale, this.leftFin.rotationPointY * scale, this.leftFin.rotationPointZ * scale);
-        GlStateManager.scale(1.0D, 0.0D, 1.0D);
-        GlStateManager.translate(-this.leftFin.offsetX, -this.leftFin.offsetY, -this.leftFin.offsetZ);
-        GlStateManager.translate(-this.leftFin.rotationPointX * scale, -this.leftFin.rotationPointY * scale, -this.leftFin.rotationPointZ * scale);
-        this.leftFin.render(scale);
-        GlStateManager.popMatrix();
-        this.body0.render(scale);
-        this.head1.render(scale);
-        this.head0.render(scale);
-        this.tailFin.render(scale);
-        this.waist.render(scale);
-        GlStateManager.pushMatrix();
-        GlStateManager.translate(this.body1.offsetX, this.body1.offsetY, this.body1.offsetZ);
-        GlStateManager.translate(this.body1.rotationPointX * scale, this.body1.rotationPointY * scale, this.body1.rotationPointZ * scale);
-        GlStateManager.scale(0.0D, 0.9D, 1.0D);
-        GlStateManager.translate(-this.body1.offsetX, -this.body1.offsetY, -this.body1.offsetZ);
-        GlStateManager.translate(-this.body1.rotationPointX * scale, -this.body1.rotationPointY * scale, -this.body1.rotationPointZ * scale);
-        this.body1.render(scale);
-        GlStateManager.popMatrix();
-        GlStateManager.pushMatrix();
-        GlStateManager.translate(this.rightFin.offsetX, this.rightFin.offsetY, this.rightFin.offsetZ);
-        GlStateManager.translate(this.rightFin.rotationPointX * scale, this.rightFin.rotationPointY * scale, this.rightFin.rotationPointZ * scale);
-        GlStateManager.scale(1.0D, 0.0D, 1.0D);
-        GlStateManager.translate(-this.rightFin.offsetX, -this.rightFin.offsetY, -this.rightFin.offsetZ);
-        GlStateManager.translate(-this.rightFin.rotationPointX * scale, -this.rightFin.rotationPointY * scale, -this.rightFin.rotationPointZ * scale);
-        this.rightFin.render(scale);
-        GlStateManager.popMatrix();
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/WorldProviderNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/WorldProviderNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/WorldProviderNether.java	(date 1525605768000)
@@ -1,33 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world;
-
-import net.minecraft.world.WorldProviderHell;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.util.handlers.ConfigHandler;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeProviderNether;
-import net.thegaminghuskymc.mcaddon.world.gen.ChunkGeneratorNether;
-
-public class WorldProviderNether extends WorldProviderHell
-{
-    @Override
-    public void init()
-    {
-        biomeProvider = new BiomeProviderNether(world);
-        doesWaterVaporize = true;
-        nether = true;
-    }
-
-    @Override
-    public IChunkGenerator createChunkGenerator()
-    {
-        return new ChunkGeneratorNether(world);
-    }
-
-    @Override
-    @SideOnly(Side.CLIENT)
-    public boolean doesXZShowFog(int chunkX, int chunkZ)
-    {
-        return !ConfigHandler.client.visual.disableNetherFog;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemFood.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemFood.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemFood.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.creativetab.CreativeTabs;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class ItemFood extends ItemModFood {
-
-    public ItemFood(String name, CreativeTabs creativeTabs) {
-        super(MOD_ID, name, creativeTabs, 1, false);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCreature.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCreature.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosCreature.java	(date 1525605768000)
@@ -1,23 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosCreature.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityCreature;
-import net.minecraft.world.World;
-
-public class EntityAtmosCreature extends EntityCreature {
-
-    public EntityAtmosCreature(World par1World)
-    {
-        super(par1World);
-    }
-
-    @Override
-    protected void entityInit() {
-
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/proxy/ClientProxy.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/proxy/ClientProxy.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/proxy/ClientProxy.java	(date 1525605768000)
@@ -1,48 +0,0 @@
-package net.thegaminghuskymc.mcaddon.proxy;
-
-import net.minecraft.client.model.ModelBiped;
-import net.minecraft.item.Item;
-import net.minecraftforge.common.MinecraftForge;
-import net.minecraftforge.fml.common.event.FMLInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
-import net.thegaminghuskymc.mcaddon.init.MCAddonItems;
-import net.thegaminghuskymc.mcaddon.items.models.ModelCustomArmor;
-import net.thegaminghuskymc.mcaddon.util.handlers.EntityEventHandler;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class ClientProxy extends CommonProxy {
-
-    @Override
-    public void preInit(FMLPreInitializationEvent event) {
-        MinecraftForge.EVENT_BUS.register(new EntityEventHandler());
-        super.preInit(event);
-    }
-
-    @Override
-    public void init(FMLInitializationEvent event) {
-        super.init(event);
-    }
-
-    @Override
-    public void postInit(FMLPostInitializationEvent event) {
-        super.postInit(event);
-    }
-
-    public static final Map<Item, ModelBiped> armorModels = new HashMap<>();
-
-    public static void registerArmorRenders(){
-
-        ModelCustomArmor custom_armor = new ModelCustomArmor(1F);
-        ModelCustomArmor custom_legs = new ModelCustomArmor(0.5F);
-
-        armorModels.put(MCAddonItems.healmet, custom_armor);
-        armorModels.put(MCAddonItems.chestplate, custom_armor);
-        armorModels.put(MCAddonItems.leggings, custom_legs);
-        armorModels.put(MCAddonItems.boots, custom_armor);
-
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrownedVillager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrownedVillager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityDrownedVillager.java	(date 1525605768000)
@@ -1,309 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.block.Block;
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.IEntityLivingData;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.potion.PotionEffect;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.DifficultyInstance;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.common.registry.ForgeRegistries;
-import net.minecraftforge.fml.common.registry.VillagerRegistry;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.util.handlers.LootTableHandler;
-
-import javax.annotation.Nullable;
-import java.util.UUID;
-
-
-/**
- * TODO: Fix Texture and Model
- */
-public class EntityDrownedVillager extends EntityMummy {
-
-    private static final DataParameter<Boolean> CONVERTING = EntityDataManager.<Boolean>createKey(EntityDrownedVillager.class, DataSerializers.BOOLEAN);
-    private static final DataParameter<Integer> PROFESSION = EntityDataManager.<Integer>createKey(EntityDrownedVillager.class, DataSerializers.VARINT);
-
-    private int conversionTime;
-    private UUID converstionStarter;
-
-    public EntityDrownedVillager(World worldIn) {
-        super(worldIn);
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(CONVERTING, Boolean.valueOf(false));
-        this.dataManager.register(PROFESSION, Integer.valueOf(0));
-    }
-
-    public void setProfession(int profession) {
-        this.dataManager.set(PROFESSION, Integer.valueOf(profession));
-    }
-
-    public int getProfession() {
-        return Math.max(((Integer)this.dataManager.get(PROFESSION)).intValue(), 0);
-    }
-
-    public static void registerFixesMummyVillager(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityDrownedVillager.class);
-    }
-
-    @Override
-    public void writeEntityToNBT(NBTTagCompound compound) {
-        super.writeEntityToNBT(compound);
-        compound.setInteger("Profession", this.getProfession());
-        compound.setString("ProfessionName", this.getForgeProfession().getRegistryName().toString());
-        compound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);
-
-        if (this.converstionStarter != null) {
-            compound.setUniqueId("ConversionStarter", this.converstionStarter);
-        }
-    }
-
-    @Override
-    public void readEntityFromNBT(NBTTagCompound compound)
-    {
-        super.readEntityFromNBT(compound);
-        this.setProfession(compound.getInteger("Profession"));
-        if (compound.hasKey("ProfessionName"))
-        {
-            VillagerRegistry.VillagerProfession p = ForgeRegistries.VILLAGER_PROFESSIONS.getValue(new ResourceLocation(compound.getString("ProfessionName")));
-            if (p == null) p = VillagerRegistry.FARMER;
-            this.setForgeProfession(p);
-        }
-
-        if (compound.hasKey("ConversionTime", 99) && compound.getInteger("ConversionTime") > -1)
-        {
-            this.startConverting(compound.hasUniqueId("ConversionPlayer") ? compound.getUniqueId("ConversionPlayer") : null, compound.getInteger("ConversionTime"));
-        }
-    }
-
-    @Nullable
-    @Override
-    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata)
-    {
-        this.setProfession(this.world.rand.nextInt(6));
-        return super.onInitialSpawn(difficulty, livingdata);
-    }
-
-    @Override
-    public void onUpdate() {
-        if (!this.world.isRemote && this.isConverting())
-        {
-            int i = this.getConversionProgress();
-            this.conversionTime -= i;
-
-            if (this.conversionTime <= 0)
-            {
-                this.finishConversion();
-            }
-        }
-        super.onUpdate();
-    }
-
-    @Override
-    protected boolean processInteract(EntityPlayer player, EnumHand hand) {
-        ItemStack itemstack = player.getHeldItem(hand);
-
-        if (itemstack.getItem() == Items.GOLDEN_APPLE && itemstack.getMetadata() == 0 && this.isPotionActive(MobEffects.WEAKNESS))
-        {
-            if (!player.capabilities.isCreativeMode)
-            {
-                itemstack.shrink(1);
-            }
-
-            if (!this.world.isRemote)
-            {
-                this.startConverting(player.getUniqueID(), this.rand.nextInt(2401) + 3600);
-            }
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    @Override
-    protected boolean canDespawn() {
-        return !this.isConverting();
-    }
-
-    public boolean isConverting()
-    {
-        return ((Boolean)this.getDataManager().get(CONVERTING)).booleanValue();
-    }
-
-    protected void startConverting(@Nullable UUID conversionStarterIn, int conversionTimeIn)
-    {
-        this.converstionStarter = conversionStarterIn;
-        this.conversionTime = conversionTimeIn;
-        this.getDataManager().set(CONVERTING, Boolean.valueOf(true));
-        this.removePotionEffect(MobEffects.WEAKNESS);
-        this.addPotionEffect(new PotionEffect(MobEffects.STRENGTH, conversionTimeIn, Math.min(this.world.getDifficulty().getDifficultyId() - 1, 0)));
-        this.world.setEntityState(this, (byte)16);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id)
-    {
-        if (id == 16)
-        {
-            if (!this.isSilent())
-            {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_ZOMBIE_VILLAGER_CURE, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-        }
-        else
-        {
-            super.handleStatusUpdate(id);
-        }
-    }
-
-    protected void finishConversion()
-    {
-        EntityVillager entityvillager = new EntityVillager(this.world);
-        entityvillager.copyLocationAndAnglesFrom(this);
-        entityvillager.setProfession(this.getForgeProfession());
-        entityvillager.finalizeMobSpawn(this.world.getDifficultyForLocation(new BlockPos(entityvillager)), (IEntityLivingData)null, false);
-        entityvillager.setLookingForHome();
-        this.world.removeEntity(this);
-        entityvillager.setNoAI(this.isAIDisabled());
-
-        if (this.hasCustomName())
-        {
-            entityvillager.setCustomNameTag(this.getCustomNameTag());
-            entityvillager.setAlwaysRenderNameTag(this.getAlwaysRenderNameTag());
-        }
-
-        this.world.spawnEntity(entityvillager);
-        entityvillager.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 200, 0));
-        this.world.playEvent((EntityPlayer)null, 1027, new BlockPos((int)this.posX, (int)this.posY, (int)this.posZ), 0);
-    }
-
-    protected int getConversionProgress()
-    {
-        int i = 1;
-
-        if (this.rand.nextFloat() < 0.01F)
-        {
-            int j = 0;
-            BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
-
-            for (int k = (int)this.posX - 4; k < (int)this.posX + 4 && j < 14; ++k)
-            {
-                for (int l = (int)this.posY - 4; l < (int)this.posY + 4 && j < 14; ++l)
-                {
-                    for (int i1 = (int)this.posZ - 4; i1 < (int)this.posZ + 4 && j < 14; ++i1)
-                    {
-                        Block block = this.world.getBlockState(blockpos$mutableblockpos.setPos(k, l, i1)).getBlock();
-
-                        if (block == Blocks.IRON_BARS || block == Blocks.BED)
-                        {
-                            if (this.rand.nextFloat() < 0.3F)
-                            {
-                                ++i;
-                            }
-
-                            ++j;
-                        }
-                    }
-                }
-            }
-        }
-
-        return i;
-    }
-
-    protected float getSoundPitch()
-    {
-        return (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
-    }
-
-    /**
-     * TODO: FIX NEW SOUNDS
-     */
-
-    public SoundEvent getAmbientSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_AMBIENT;
-    }
-
-    public SoundEvent getHurtSound(DamageSource damageSourceIn)
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_HURT;
-    }
-
-    public SoundEvent getDeathSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_DEATH;
-    }
-
-    public SoundEvent getStepSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_STEP;
-    }
-
-    //TODO: ^
-
-    @Nullable
-    protected ResourceLocation getLootTable()
-    {
-        return LootTableHandler.MUMMY_VILLAGER;
-    }
-
-    protected ItemStack getSkullDrop()
-    {
-        return ItemStack.EMPTY;
-    }
-
-
-    /* ======================================== FORGE START =====================================*/
-
-    @Nullable
-    private VillagerRegistry.VillagerProfession prof;
-    public void setForgeProfession(VillagerRegistry.VillagerProfession prof)
-    {
-        this.prof = prof;
-        this.setProfession(VillagerRegistry.getId(prof));
-    }
-
-    public VillagerRegistry.VillagerProfession getForgeProfession()
-    {
-        if (this.prof == null)
-        {
-            this.prof = VillagerRegistry.getById(this.getProfession());
-            if (this.prof == null)
-                return VillagerRegistry.FARMER;
-        }
-        return this.prof;
-    }
-
-    @Override
-    public void notifyDataManagerChange(DataParameter<?> key)
-    {
-        super.notifyDataManagerChange(key);
-    }
-
-    /* ======================================== FORGE END =====================================*/
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemSplashPotionBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemSplashPotionBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemSplashPotionBase.java	(date 1525605768000)
@@ -1,43 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntityPotion;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemPotion;
-import net.minecraft.item.ItemStack;
-import net.minecraft.potion.PotionUtils;
-import net.minecraft.stats.StatList;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.text.translation.I18n;
-import net.minecraft.world.World;
-
-public class ItemSplashPotionBase extends ItemPotion
-{
-    public String getItemStackDisplayName(ItemStack stack)
-    {
-        return I18n.translateToLocal(PotionUtils.getPotionFromItem(stack).getNamePrefixed("splash_potion.effect."));
-    }
-
-    /**
-     * Called when the equipped item is right clicked.
-     */
-    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)
-    {
-        ItemStack itemstack = playerIn.getHeldItem(handIn);
-        ItemStack itemstack1 = playerIn.capabilities.isCreativeMode ? itemstack.copy() : itemstack.splitStack(1);
-        worldIn.playSound((EntityPlayer)null, playerIn.posX, playerIn.posY, playerIn.posZ, SoundEvents.ENTITY_SPLASH_POTION_THROW, SoundCategory.PLAYERS, 0.5F, 0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
-
-        if (!worldIn.isRemote)
-        {
-            EntityPotion entitypotion = new EntityPotion(worldIn, playerIn, itemstack1);
-            entitypotion.shoot(playerIn, playerIn.rotationPitch, playerIn.rotationYaw, -20.0F, 0.5F, 1.0F);
-            worldIn.spawnEntity(entitypotion);
-        }
-
-        playerIn.addStat(StatList.getObjectUseStats(this));
-        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, itemstack);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlying.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlying.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosFlying.java	(date 1525605768000)
@@ -1,41 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-public class EntityAtmosFlying extends EntityAtmosCreature {
-
-    public EntityAtmosFlying(World world) {
-        super(world);
-        flyingMode = true;
-        speed = 1.0F;
-        chanceFly = 200;
-        chanceLand = 200;
-        i = 0;
-        j = 0;
-        k = 0;
-        wingSpeed = 0.4F;
-    }
-
-    public boolean isFlying()
-    {
-        return flyingMode;
-    }
-
-    protected boolean be()
-    {
-        return isFlying();
-    }
-
-    protected void a(float f)
-    {
-    }
-
-    public boolean flyingMode;
-    public float speed;
-    public int chanceFly;
-    public int chanceLand;
-    int i;
-    int j;
-    int k;
-    public float wingSpeed;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumDecorationBlocks.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumDecorationBlocks.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumDecorationBlocks.java	(date 1525605768000)
@@ -1,57 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-public enum EnumDecorationBlocks implements IStringSerializable
-{
-    YELLOW(0, "yellow"),
-    PINK(1, "pink"),
-    PURPLE(2, "purple"),
-    BLUE(3, "blue"),
-    RED(4, "red");
-
-    private static final EnumDecorationBlocks[] META_LOOKUP = new EnumDecorationBlocks[values().length];
-    private final int meta;
-    private final String name;
-
-    private EnumDecorationBlocks(int metaIn, String nameIn)
-    {
-        this.meta = metaIn;
-        this.name = nameIn;
-    }
-
-    public int getMetadata()
-    {
-        return this.meta;
-    }
-
-    public static EnumDecorationBlocks byMetadata(int meta)
-    {
-        if (meta < 0 || meta >= META_LOOKUP.length)
-        {
-            meta = 0;
-        }
-
-        return META_LOOKUP[meta];
-    }
-
-    public String toString()
-    {
-        return this.name;
-    }
-
-    public String getName()
-    {
-        return this.name;
-    }
-
-    static
-    {
-        for (EnumDecorationBlocks enumdyecolor : values())
-        {
-            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/ArmorUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/ArmorUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/ArmorUtil.java	(date 1525605768000)
@@ -1,38 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import com.google.common.collect.Lists;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.item.ItemArmor;
-import net.minecraft.item.ItemStack;
-
-import java.util.List;
-
-public class ArmorUtil
-{
-    public static boolean isWearingFullArmorSet(EntityPlayer player, ItemArmor.ArmorMaterial material)
-    {
-        Iterable<ItemStack> armor = player.getArmorInventoryList();
-        List<ItemArmor.ArmorMaterial> armorMaterials = Lists.newArrayList();
-
-        for(ItemStack testStack : armor)
-        {
-            if(testStack == ItemStack.EMPTY || !(testStack.getItem() instanceof ItemArmor))
-            {
-                return false;
-            }
-
-            armorMaterials.add(((ItemArmor) testStack.getItem()).getArmorMaterial());
-        }
-
-        for(ItemArmor.ArmorMaterial testMaterial : armorMaterials)
-        {
-            if(testMaterial != material)
-            {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockOverworldBase.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.material.Material;
-import net.thegaminghuskymc.huskylib2.blocks.BlockMod;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockOverworldBase extends BlockMod {
-
-    public BlockOverworldBase(Material material, String name) {
-        super(material, MOD_ID, name);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDesertPlantBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDesertPlantBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDesertPlantBase.java	(date 1525605768000)
@@ -1,32 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.blocks.BlockModBush;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockDesertPlantBase extends BlockModBush {
-
-    public BlockDesertPlantBase(String name) {
-        super(Material.PLANTS, name, MOD_ID);
-        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/utils/ClayGenerator.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/utils/ClayGenerator.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/utils/ClayGenerator.java	(date 1525605768000)
@@ -1,35 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.utils;
-
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraft.world.gen.feature.WorldGenMinable;
-import net.minecraftforge.fml.common.IWorldGenerator;
-
-import java.util.Random;
-
-public class ClayGenerator implements IWorldGenerator {
-
-	int clusterCount;
-	WorldGenMinable generator;
-
-	public ClayGenerator(int clusterSize, int clusterCount) {
-		this.clusterCount = clusterCount;
-
-		generator = new WorldGenMinable(Blocks.CLAY.getDefaultState(), clusterSize);
-	}
-
-	@Override
-	public void generate(Random rand, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-		for(int i = 0; i < clusterCount; i++) {
-			int x = chunkX * 16 + rand.nextInt(16);
-			int y = rand.nextInt(60);
-			int z = chunkZ * 16 + rand.nextInt(16);
-
-			generator.generate(world, rand, new BlockPos(x, y, z));
-		}
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFence.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFence.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModFence.java	(date 1525605768000)
@@ -1,131 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.base;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockFence;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.util.BlockRenderLayer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.IBlockAccess;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.huskylib2.interf.IModBlock;
-import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-
-import java.util.Random;
-
-public class BlockModFence extends BlockFence implements IModBlock {
-
-    private final String[] variants;
-    private String bareName, modid;
-
-    public BlockModFence(Material material, String modid, String name, String... variants)  {
-        super(material, material.getMaterialMapColor());
-
-        useNeighborBrightness = true;
-
-        if (variants.length == 0)
-            variants = new String[]{name};
-
-        bareName = name;
-        this.variants = variants;
-        this.modid = modid;
-
-        setUnlocalizedName(modid, name);
-
-        setHardness(1.5F);
-        setResistance(30F);
-        setHarvestLevel("pickaxe", 1);
-    }
-
-    @Override
-    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
-        return Item.getItemFromBlock(this);
-    }
-
-    @Override
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    public Block setUnlocalizedName(String modid, String name) {
-        super.setUnlocalizedName(name);
-        this.setRegistryName(modid, name);
-        ProxyRegistry.register(this);
-        ProxyRegistry.register(this.createItemBlock(new ResourceLocation(modid, name)));
-        return this;
-    }
-
-    protected ItemBlock createItemBlock(ResourceLocation res) {
-        return new ItemModBlock(this, res);
-    }
-
-    @Override
-    public boolean canPlaceTorchOnTop(IBlockState state, IBlockAccess world, BlockPos pos)
-    {
-        return true;
-    }
-
-    @Override
-    public String getPrefix() {
-        return this.modid;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return this.modid;
-    }
-
-    @Override
-    public String getBareName() {
-        return bareName;
-    }
-
-    @Override
-    public String[] getVariants() {
-        return variants;
-    }
-
-    @Override
-    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
-        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.SOLID || layer == BlockRenderLayer.TRANSLUCENT;
-    }
-
-    @Override
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    @SideOnly(Side.CLIENT)
-    public ItemMeshDefinition getCustomMeshDefinition() {
-        return null;
-    }
-
-    @Override
-    public IProperty[] getIgnoredProperties() {
-        return new IProperty[0];
-    }
-
-    @Override
-    public IProperty getVariantProp() {
-        return null;
-    }
-
-    @Override
-    public Class getVariantEnum() {
-        return null;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerPhantomEyes.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerPhantomEyes.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/layer/LayerPhantomEyes.java	(date 1525605768000)
@@ -1,46 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.layer;
-
-import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.GlStateManager;
-import net.minecraft.client.renderer.OpenGlHelper;
-import net.minecraft.client.renderer.entity.layers.LayerRenderer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.EntityPhantom;
-import net.thegaminghuskymc.mcaddon.entity.render.RenderPhantom;
-
-@SideOnly(Side.CLIENT)
-public class LayerPhantomEyes implements LayerRenderer<EntityPhantom> {
-
-    private static final ResourceLocation PHANTOM_EYES_TEXTURES = new ResourceLocation("hmca:textures/entity/phantom/phantom_eyes.png");
-    private final RenderPhantom phantomRenderer;
-
-    public LayerPhantomEyes(RenderPhantom phantomRendererIn) {
-        this.phantomRenderer = phantomRendererIn;
-    }
-
-    public void doRenderLayer(EntityPhantom entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
-        this.phantomRenderer.bindTexture(PHANTOM_EYES_TEXTURES);
-        GlStateManager.enableBlend();
-        GlStateManager.disableAlpha();
-        GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
-        GlStateManager.disableLighting();
-        GlStateManager.depthFunc(514);
-        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
-        GlStateManager.enableLighting();
-        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-        Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-        this.phantomRenderer.getMainModel().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
-        Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-        this.phantomRenderer.setLightmap(entitylivingbaseIn);
-        GlStateManager.disableBlend();
-        GlStateManager.enableAlpha();
-        GlStateManager.depthFunc(515);
-    }
-
-    public boolean shouldCombineTextures() {
-        return false;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/NBTUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/NBTUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/NBTUtil.java	(date 1525605768000)
@@ -1,31 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-
-public class NBTUtil
-{
-    public static ItemStack setTag(ItemStack stack)
-    {
-        if(stack.getTagCompound() == null)
-        {
-            stack.setTagCompound(new NBTTagCompound());
-        }
-
-        return stack;
-    }
-
-    public static ItemStack setTag(ItemStack stack, NBTTagCompound compound)
-    {
-        if(stack.getTagCompound() == null)
-        {
-            stack.setTagCompound(compound);
-        }
-        else
-        {
-            stack.getTagCompound().merge(compound);
-        }
-
-        return stack;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/OreStack.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/OreStack.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/OreStack.java	(date 1525605768000)
@@ -1,11 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-public class OreStack {
-    public String oreId = "";
-    public int amount = 0;
-
-    public OreStack(String oreId, int amount) {
-        this.oreId = oreId;
-        this.amount = amount;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBandage.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBandage.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemBandage.java	(date 1525605768000)
@@ -1,30 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumHand;
-import net.minecraft.world.World;
-import net.thegaminghuskymc.huskylib2.items.ItemMod;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class ItemBandage extends ItemMod {
-
-    public ItemBandage() {
-        super("bandage", Reference.MOD_ID);
-        this.setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    @Override
-    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
-        if (playerIn.getHealth() < playerIn.getMaxHealth() && worldIn.isRemote && playerIn.getHeldItem(handIn).getItem() == this) {
-            float f = playerIn.getHealth();
-            playerIn.setHealth(f + 1.0F);
-            playerIn.getHeldItem(handIn).shrink(1);
-            return new ActionResult<>(EnumActionResult.SUCCESS, playerIn.getHeldItem(handIn));
-        }
-        return new ActionResult<>(EnumActionResult.PASS, playerIn.getHeldItem(handIn));
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderEnderPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderEnderPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderEnderPhantom.java	(date 1525605768000)
@@ -1,25 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityEnderPhantom;
-import net.thegaminghuskymc.mcaddon.entity.EntityPhantom;
-import net.thegaminghuskymc.mcaddon.entity.render.layer.LayerPhantomEyes;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelPhantom;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderEnderPhantom extends RenderLiving<EntityEnderPhantom> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/ender_phantom.png");
-
-    public RenderEnderPhantom(RenderManager manager) {
-        super(manager, new ModelPhantom(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityEnderPhantom entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModHoe.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModHoe.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemModHoe.java	(date 1525605768000)
@@ -1,78 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemHoe;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.huskylib2.interf.IVariantHolder;
-import net.thegaminghuskymc.huskylib2.items.ItemMod;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-
-public class ItemModHoe extends ItemHoe implements IVariantHolder {
-
-    private final String[] variants;
-    private final String bareName, modid;
-
-    public ItemModHoe(ToolMaterial material, String name, String modid, String... variants) {
-        super(material);
-
-        if (variants.length > 1)
-            setHasSubtypes(true);
-
-        if (variants.length == 0)
-            variants = new String[]{name};
-
-        bareName = name;
-        this.variants = variants;
-        this.modid = modid;
-        setUnlocalizedName(name, modid);
-        ItemMod.variantHolders.add(this);
-        this.toolMaterial = material;
-        this.maxStackSize = 1;
-        this.setCreativeTab(CreativeTabs.TOOLS);
-    }
-
-    @Override
-    public String getPrefix() {
-        return this.modid;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return this.modid;
-    }
-
-    public Item setUnlocalizedName(String name, String modid) {
-        super.setUnlocalizedName(name);
-        setRegistryName(new ResourceLocation(modid, name));
-        ProxyRegistry.register(this);
-
-        return this;
-    }
-
-    @Override
-    public String getUnlocalizedName(ItemStack par1ItemStack) {
-        int dmg = par1ItemStack.getItemDamage();
-        String[] variants = getVariants();
-
-        String name;
-        if (dmg >= variants.length)
-            name = bareName;
-        else name = variants[dmg];
-
-        return "item." + getPrefix() + name;
-    }
-
-    @Override
-    public String[] getVariants() {
-        return variants;
-    }
-
-    @Override
-    public ItemMeshDefinition getCustomMeshDefinition() {
-        return null;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenDungeons.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenDungeons.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/generators/WorldGenDungeons.java	(date 1525605768000)
@@ -1,157 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.generators;
-
-import net.minecraft.block.material.Material;
-import net.minecraft.entity.EntityList;
-import net.minecraft.entity.monster.EntitySkeleton;
-import net.minecraft.entity.monster.EntitySpider;
-import net.minecraft.entity.monster.EntityZombie;
-import net.minecraft.init.Blocks;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityChest;
-import net.minecraft.tileentity.TileEntityMobSpawner;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.IChunkProvider;
-import net.minecraft.world.gen.IChunkGenerator;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.common.IWorldGenerator;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import java.util.Objects;
-import java.util.Random;
-
-public class WorldGenDungeons implements IWorldGenerator {
-
-    private static final Logger LOGGER = LogManager.getLogger();
-    private static final ResourceLocation[] SPAWNERTYPES = new ResourceLocation[] {EntityList.getKey(EntitySkeleton.class), EntityList.getKey(EntityZombie.class), EntityList.getKey(EntityZombie.class), EntityList.getKey(EntitySpider.class)};
-
-    /**
-     * Randomly decides which spawner to use in a dungeon
-     */
-    private ResourceLocation pickMobSpawner(Random rand)
-    {
-        return net.minecraftforge.common.DungeonHooks.getRandomDungeonMob(rand);
-    }
-
-    @Override
-    public void generate(Random random, int chunkX, int chunkZ, World world, IChunkGenerator chunkGenerator, IChunkProvider chunkProvider) {
-        BlockPos position = new BlockPos(Objects.requireNonNull(chunkProvider.getLoadedChunk(chunkX, chunkZ)).x, Objects.requireNonNull(chunkProvider.getLoadedChunk(chunkX, chunkZ)).getHeightValue(chunkX, chunkZ), Objects.requireNonNull(chunkProvider.getLoadedChunk(chunkX, chunkZ)).x);
-        int i = 3;
-        int j = random.nextInt(2) + 2;
-        int k = -j - 1;
-        int l = j + 1;
-        int i1 = -1;
-        int j1 = 4;
-        int k1 = random.nextInt(2) + 2;
-        int l1 = -k1 - 1;
-        int i2 = k1 + 1;
-        int j2 = 0;
-
-        for (int k2 = k; k2 <= l; ++k2)
-        {
-            for (int l2 = -1; l2 <= 4; ++l2)
-            {
-                for (int i3 = l1; i3 <= i2; ++i3)
-                {
-                    BlockPos blockpos = position.add(k2, l2, i3);
-                    Material material = world.getBlockState(blockpos).getMaterial();
-                    boolean flag = material.isSolid();
-
-                    if ((k2 == k || k2 == l || i3 == l1 || i3 == i2) && l2 == 0 && world.isAirBlock(blockpos) && world.isAirBlock(blockpos.up()))
-                    {
-                        ++j2;
-                    }
-                }
-            }
-        }
-
-        if (j2 >= 1 && j2 <= 5)
-        {
-            for (int k3 = k; k3 <= l; ++k3)
-            {
-                for (int i4 = 3; i4 >= -1; --i4)
-                {
-                    for (int k4 = l1; k4 <= i2; ++k4)
-                    {
-                        BlockPos blockpos1 = position.add(k3, i4, k4);
-
-                        if (k3 != k && i4 != -1 && k4 != l1 && k3 != l && i4 != 4 && k4 != i2)
-                        {
-                            if (world.getBlockState(blockpos1).getBlock() != Blocks.CHEST)
-                            {
-                                world.setBlockToAir(blockpos1);
-                            }
-                        }
-                        else if (blockpos1.getY() >= 0 && !world.getBlockState(blockpos1.down()).getMaterial().isSolid())
-                        {
-                            world.setBlockToAir(blockpos1);
-                        }
-                        else if (world.getBlockState(blockpos1).getMaterial().isSolid() && world.getBlockState(blockpos1).getBlock() != Blocks.CHEST)
-                        {
-                            if (i4 == -1 && random.nextInt(4) != 0)
-                            {
-                                world.setBlockState(blockpos1, Blocks.NETHER_BRICK.getDefaultState(), 2);
-                            }
-                            else
-                            {
-                                world.setBlockState(blockpos1, Blocks.NETHERRACK.getDefaultState(), 2);
-                            }
-                        }
-                    }
-                }
-            }
-
-            for (int l3 = 0; l3 < 2; ++l3)
-            {
-                for (int j4 = 0; j4 < 3; ++j4)
-                {
-                    int l4 = position.getX() + random.nextInt(j * 2 + 1) - j;
-                    int i5 = position.getY();
-                    int j5 = position.getZ() + random.nextInt(k1 * 2 + 1) - k1;
-                    BlockPos blockpos2 = new BlockPos(l4, i5, j5);
-
-                    if (world.isAirBlock(blockpos2))
-                    {
-                        int j3 = 0;
-
-                        for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
-                        {
-                            if (world.getBlockState(blockpos2.offset(enumfacing)).getMaterial().isSolid())
-                            {
-                                ++j3;
-                            }
-                        }
-
-                        if (j3 == 1)
-                        {
-                            world.setBlockState(blockpos2, Blocks.CHEST.correctFacing(world, blockpos2, Blocks.CHEST.getDefaultState()), 2);
-                            TileEntity tileentity1 = world.getTileEntity(blockpos2);
-
-                            if (tileentity1 instanceof TileEntityChest)
-                            {
-                                ((TileEntityChest)tileentity1).setLootTable(LootTableList.CHESTS_SIMPLE_DUNGEON, random.nextLong());
-                            }
-
-                            break;
-                        }
-                    }
-                }
-            }
-
-            world.setBlockState(position, Blocks.MOB_SPAWNER.getDefaultState(), 2);
-            TileEntity tileentity = world.getTileEntity(position);
-
-            if (tileentity instanceof TileEntityMobSpawner)
-            {
-                ((TileEntityMobSpawner)tileentity).getSpawnerBaseLogic().setEntityId(this.pickMobSpawner(random));
-            }
-            else
-            {
-                LOGGER.error("Failed to fetch mob spawner entity at ({}, {}, {})", position.getX(), position.getY(), position.getZ());
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/Main.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/Main.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/Main.java	(date 1525605768000)
@@ -1,338 +0,0 @@
-package net.thegaminghuskymc.mcaddon;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.entity.EnumCreatureType;
-import net.minecraft.entity.monster.EntityBlaze;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.launchwrapper.Launch;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityChest;
-import net.minecraft.tileentity.TileEntityMobSpawner;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldServer;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.gen.feature.WorldGenBigMushroom;
-import net.minecraft.world.gen.feature.WorldGenerator;
-import net.minecraft.world.gen.structure.template.PlacementSettings;
-import net.minecraft.world.gen.structure.template.Template;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.common.BiomeDictionary;
-import net.minecraftforge.common.DungeonHooks;
-import net.minecraftforge.common.MinecraftForge;
-import net.minecraftforge.event.entity.living.LivingSpawnEvent;
-import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
-import net.minecraftforge.event.terraingen.PopulateChunkEvent;
-import net.minecraftforge.fluids.FluidRegistry;
-import net.minecraftforge.fml.common.Loader;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.SidedProxy;
-import net.minecraftforge.fml.common.event.FMLInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
-import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
-import net.minecraftforge.fml.common.eventhandler.Event;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.minecraftforge.fml.common.registry.GameRegistry;
-import net.thegaminghuskymc.mcaddon.commands.TPBiomeCommand;
-import net.thegaminghuskymc.mcaddon.commands.TPDimensionCommand;
-import net.thegaminghuskymc.mcaddon.init.BiomeInit;
-import net.thegaminghuskymc.mcaddon.init.MCAddonBlocks;
-import net.thegaminghuskymc.mcaddon.init.NetherExBiomes;
-import net.thegaminghuskymc.mcaddon.proxy.ClientProxy;
-import net.thegaminghuskymc.mcaddon.proxy.CommonProxy;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiomeManager;
-import net.thegaminghuskymc.mcaddon.world.dungeons.DungeonGenerator;
-import net.thegaminghuskymc.mcaddon.world.gen.WorldGenCustomStructures;
-import net.thegaminghuskymc.mcaddon.world.utils.ClayGenerator;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.util.*;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@Mod(modid = MOD_ID, name = Reference.NAME, version = Reference.VERSION, dependencies = "required-after:llibrary@[1.7.9,)")
-public class Main {
-
-    @Mod.Instance
-    public static Main instance;
-    private List<String> allowedBlocks;
-    public static boolean isInDevEnv = (Boolean) Launch.blackboard.get("fml.deobfuscatedEnvironment");
-
-    private static File configDirectory;
-
-    private static final Logger LOGGER = LogManager.getLogger("Husky's Minecraft Additions | Main");
-
-    @SidedProxy(clientSide = Reference.CLIENT_PROXY, serverSide = Reference.SERVER_PROXY)
-    public static CommonProxy proxy;
-
-    public static final CreativeTabs OVERWORLD_EXPANSION_TAB = new CreativeTabs("overworld_expansion") {
-        @Override
-        public ItemStack getTabIconItem() {
-            return new ItemStack(Item.getItemFromBlock(MCAddonBlocks.brain_coral[0]));
-        }
-    };
-
-    public static final CreativeTabs NETHER_EXPANSION_TAB = new CreativeTabs("nether_expansion") {
-        @Override
-        public ItemStack getTabIconItem() {
-            return new ItemStack(Item.getItemFromBlock(Blocks.NETHER_BRICK));
-        }
-    };
-
-    public static final CreativeTabs END_EXPANSION_TAB = new CreativeTabs("end_expansion") {
-        @Override
-        public ItemStack getTabIconItem() {
-            return new ItemStack(Item.getItemFromBlock(Blocks.END_BRICKS));
-        }
-    };
-
-    public static final CreativeTabs WEAPON_EXPANSION_TAB = new CreativeTabs("weapons_expansion") {
-        @Override
-        public ItemStack getTabIconItem() {
-            return ItemStack.EMPTY;
-        }
-    };
-
-    static
-    {
-        FluidRegistry.enableUniversalBucket();
-    }
-
-    @Mod.EventHandler
-    public static void preInit(FMLPreInitializationEvent event) {
-
-        LOGGER.info("PreInitialization started.");
-
-        configDirectory = event.getModConfigurationDirectory();
-        GameRegistry.registerWorldGenerator(new ClayGenerator(20, 3), 1);
-//        GameRegistry.registerWorldGenerator(new FormationCaveGenerator(), 0);
-        proxy.preInit(event);
-
-        LOGGER.info("PreInitialization completed.");
-
-    }
-
-    @Mod.EventHandler
-    public static void init(FMLInitializationEvent event) {
-
-        LOGGER.info("Initialization started.");
-
-        GameRegistry.registerWorldGenerator(new WorldGenCustomStructures(), 0);
-//        GameRegistry.registerWorldGenerator(new WorldGenTest(10), 0);
-        GameRegistry.registerWorldGenerator(new DungeonGenerator(), 0);
-//        GameRegistry.registerWorldGenerator(new WorldGenDungeons(), 1);
-        Biome.SpawnListEntry blazeEntry = new Biome.SpawnListEntry(EntityBlaze.class, 5, 1, 2);
-        BiomeDictionary.getBiomes(BiomeDictionary.Type.NETHER).forEach(biome -> biome.getSpawnableList(EnumCreatureType.MONSTER).add(blazeEntry));
-        BiomeInit.registerBiomes();
-        NetherExBiomes.init();
-        ClientProxy.registerArmorRenders();
-        proxy.init(event);
-
-        LOGGER.info("Initialization completed.");
-
-    }
-
-    @Mod.EventHandler
-    public static void postInit(FMLPostInitializationEvent event) {
-
-        LOGGER.info("PostInitialization started.");
-
-        NetherExBiomes.postInit();
-        NetherBiomeManager.postInit(new File(configDirectory, "/Husky's Minecraft Additions/Biome Lists"));
-        proxy.postInit(event);
-
-        LOGGER.info("PostInitialization completed.");
-
-    }
-
-    @Mod.EventHandler
-    public static void serverInit(FMLServerStartingEvent event) {
-        event.registerServerCommand(new TPBiomeCommand());
-        event.registerServerCommand(new TPDimensionCommand());
-    }
-
-    @SubscribeEvent
-    public void onSpawn(LivingSpawnEvent.CheckSpawn event) {
-        allowedBlocks = Arrays.asList(Objects.requireNonNull(Blocks.NETHERRACK.getRegistryName()).toString(),
-                Objects.requireNonNull(Blocks.SOUL_SAND.getRegistryName()).toString(),
-                Objects.requireNonNull(Blocks.MAGMA.getRegistryName()).toString());
-        if(!event.isSpawner() && event.getEntityLiving() instanceof EntityBlaze && event.getResult() != Event.Result.DENY && event.getEntityLiving().world instanceof WorldServer) {
-            EntityBlaze blaze = (EntityBlaze) event.getEntityLiving();
-            WorldServer world = (WorldServer) blaze.world;
-            BlockPos pos = blaze.getPosition();
-            Block block = world.getBlockState(pos.down()).getBlock();
-            ResourceLocation res = block.getRegistryName();
-            if(res != null) {
-                boolean allowedBlock = allowedBlocks.contains(res.toString());
-                boolean fortress = world.getChunkProvider().isInsideStructure(world, "Fortress", pos);
-                if(!fortress && !allowedBlock)
-                    event.setResult(Event.Result.DENY);
-            }
-        }
-    }
-
-    @SubscribeEvent
-    public void decorate(DecorateBiomeEvent.Decorate event) {
-        World world = event.getWorld();
-        Biome biome = world.getBiome(event.getPos());
-        Random rand = event.getRand();
-        double bigMushroomsPerChunk = 0.5;
-        WorldGenerator bigMushroomGen = new WorldGenBigMushroom();
-
-        if((biome == Biomes.SWAMPLAND || biome == Biomes.MUTATED_SWAMPLAND) && event.getType() == DecorateBiomeEvent.Decorate.EventType.BIG_SHROOM) {
-            if(rand.nextDouble() > bigMushroomsPerChunk)
-                return;
-
-            int amount = (int) Math.max(1, bigMushroomsPerChunk);
-            for(int i = 0; i < amount; i++) {
-                int x = rand.nextInt(16) + 8;
-                int y = rand.nextInt(16) + 8;
-                bigMushroomGen.generate(world, rand, world.getHeight(event.getPos().add(x, 0, y)));
-            }
-
-            event.setResult(Event.Result.DENY);
-        }
-    }
-
-    @SubscribeEvent
-    public void onDungeonSpawn(PopulateChunkEvent.Populate event) {
-        if(event.getType() != PopulateChunkEvent.Populate.EventType.DUNGEON)
-            return;
-
-        int i = event.getChunkX() * 16;
-        int j = event.getChunkZ() * 16;
-
-        BlockPos blockpos = new BlockPos(i, 0, j);
-        World world = event.getWorld();
-        Random rand = event.getRand();
-
-        int x = rand.nextInt(16) + 8;
-        int y = rand.nextInt(256);
-        int z = rand.nextInt(16) + 8;
-        BlockPos generatePos = blockpos.add(x, y, z);
-        if(couldDungeonGenerate(world, rand, generatePos) && world instanceof WorldServer) {
-            placeDungeonAt((WorldServer) world, rand, generatePos);
-            event.setResult(Event.Result.DENY);
-        }
-    }
-
-    private boolean couldDungeonGenerate(World worldIn, Random rand, BlockPos position) {
-        int i = 3;
-        int j = rand.nextInt(2) + 2;
-        int k = -j - 1;
-        int l = j + 1;
-        int i1 = -1;
-        int j1 = 4;
-        int k1 = rand.nextInt(2) + 2;
-        int l1 = -k1 - 1;
-        int i2 = k1 + 1;
-        int j2 = 0;
-
-        for(int k2 = k; k2 <= l; ++k2) {
-            for(int l2 = -1; l2 <= 4; ++l2) {
-                for(int i3 = l1; i3 <= i2; ++i3) {
-                    BlockPos blockpos = position.add(k2, l2, i3);
-                    Material material = worldIn.getBlockState(blockpos).getMaterial();
-                    boolean flag = material.isSolid();
-
-                    if(l2 == -1 && !flag)
-                        return false;
-
-                    if(l2 == 4 && !flag)
-                        return false;
-
-                    if((k2 == k || k2 == l || i3 == l1 || i3 == i2) && l2 == 0 && worldIn.isAirBlock(blockpos) && worldIn.isAirBlock(blockpos.up()))
-                        ++j2;
-                }
-            }
-        }
-
-        return j2 >= 1 && j2 <= 5;
-    }
-
-    private void placeDungeonAt(WorldServer world, Random rand, BlockPos position) {
-        int dungeonType = rand.nextInt(10);
-
-        MinecraftServer server = world.getMinecraftServer();
-        Template template = world.getStructureTemplateManager().getTemplate(server, new ResourceLocation(MOD_ID,"dungeon_" + dungeonType));
-        PlacementSettings settings = new PlacementSettings();
-        settings.setRotation(Rotation.values()[rand.nextInt(Rotation.values().length)]);
-
-        BlockPos size = template.getSize();
-        for(int x = 0; x < size.getX(); x++)
-            for(int y = 0; y < size.getY(); y++)
-                for(int z = 0; z < size.getZ(); z++) {
-                    BlockPos checkPos = position.add(Template.transformedBlockPos(settings, new BlockPos(x, y, z)));
-                    IBlockState checkState = world.getBlockState(checkPos);
-                    if(checkState.getBlock().getBlockHardness(checkState, world, checkPos) == -1 || world.canBlockSeeSky(checkPos))
-                        return; // Obstructed or exposed, can't generate here
-                }
-
-        template.addBlocksToWorld(world, position, settings);
-
-        int spawners = 0;
-        List<BlockPos> chests = new ArrayList<>();
-        Map<BlockPos, String> dataBlocks = template.getDataBlocks(position, settings);
-
-        for(Map.Entry<BlockPos, String> entry : dataBlocks.entrySet()) {
-            BlockPos pos = entry.getKey();
-            String data = entry.getValue();
-
-            if(data.equals("spawner")) {
-                spawners++;
-                world.setBlockState(pos, Blocks.MOB_SPAWNER.getDefaultState(), 2);
-                TileEntity tile = world.getTileEntity(pos);
-
-                if(tile instanceof TileEntityMobSpawner) {
-                    if(Loader.isModLoaded("dungeontweaks")) {
-                        try {
-                            Constructor<? extends Event> constructor = (Constructor<? extends Event>) Class.forName("com.EvilNotch.dungeontweeks.main.Events.EventDungeon$Post").getConstructor(TileEntity.class, BlockPos.class, Random.class, ResourceLocation.class, World.class);
-                            Event event = constructor.newInstance(tile, tile.getPos(), world.rand, new ResourceLocation(MOD_ID,"dungeon"), world);
-                            MinecraftForge.EVENT_BUS.post(event);
-                        } catch(Throwable t) {
-                            t.printStackTrace();
-                        }
-                    } else ((TileEntityMobSpawner) tile).getSpawnerBaseLogic().setEntityId(DungeonHooks.getRandomDungeonMob(rand));
-                }
-            }
-            else if(data.equals("chest"))
-                chests.add(pos);
-        }
-
-        int maxChests = spawners * 2 + rand.nextInt(spawners + 2);
-        while(chests.size() > maxChests) {
-            int i = rand.nextInt(chests.size());
-            BlockPos chestPos = chests.get(i);
-            chests.remove(i);
-            world.setBlockToAir(chestPos);
-        }
-
-        for(BlockPos pos : chests) {
-            world.setBlockState(pos, Blocks.CHEST.correctFacing(world, pos, Blocks.CHEST.getDefaultState()), 2);
-            TileEntity tile = world.getTileEntity(pos);
-            String lootTableStr = "";
-            ResourceLocation lootTable =  lootTableStr.isEmpty() ? null : new ResourceLocation(lootTableStr);
-
-            if(tile instanceof TileEntityChest) {
-                if(lootTable == null)
-                    ((TileEntityChest) tile).setLootTable(LootTableList.CHESTS_SIMPLE_DUNGEON, rand.nextLong());
-                else ((TileEntityChest) tile).setLootTable(lootTable, rand.nextLong());
-            }
-        }
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/ItemAncientSword.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/ItemAncientSword.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/ItemAncientSword.java	(date 1525605768000)
@@ -1,30 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items;
-
-import net.minecraft.client.util.ITooltipFlag;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.text.TextFormatting;
-import net.minecraft.world.World;
-import net.minecraftforge.common.util.EnumHelper;
-import net.thegaminghuskymc.huskylib2.items.ItemModSword;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import javax.annotation.Nullable;
-import java.util.List;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class ItemAncientSword extends ItemModSword {
-
-    private static Item.ToolMaterial ancientToolMaterial = EnumHelper.addToolMaterial("egyptian", 1, 131, 8.0F, 3.5F, 22);
-
-    public ItemAncientSword() {
-        super("khopesh", MOD_ID, ancientToolMaterial);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    @Override
-    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
-        tooltip.add(TextFormatting.GOLD + String.format(TextFormatting.ITALIC + "This is a khopesh from the old egyptian times. It was only used by the pharaohs best guards"));
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMonsterOfTheOceanDepths.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMonsterOfTheOceanDepths.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMonsterOfTheOceanDepths.java	(date 1525605768000)
@@ -1,248 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.MoverType;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.EntityAIBase;
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-
-public class EntityMonsterOfTheOceanDepths extends EntityWaterMob {
-
-    public float squidPitch;
-    public float prevSquidPitch;
-    public float squidYaw;
-    public float prevSquidYaw;
-    /**
-     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
-     */
-    public float squidRotation;
-    /**
-     * previous squidRotation in radians
-     */
-    public float prevSquidRotation;
-    /**
-     * angle of the tentacles in radians
-     */
-    public float tentacleAngle;
-    /**
-     * the last calculated angle of the tentacles in radians
-     */
-    public float lastTentacleAngle;
-    private float randomMotionSpeed;
-    /**
-     * change in squidRotation in radians.
-     */
-    private float rotationVelocity;
-    private float rotateSpeed;
-    private float randomMotionVecX;
-    private float randomMotionVecY;
-    private float randomMotionVecZ;
-
-    public EntityMonsterOfTheOceanDepths(World worldIn) {
-        super(worldIn);
-        this.setSize(0.8F, 0.8F);
-        this.rand.setSeed((long) (1 + this.getEntityId()));
-        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-    }
-
-    public static void registerFixesSquid(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityMonsterOfTheOceanDepths.class);
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(0, new EntityMonsterOfTheOceanDepths.AIMoveRandom(this));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
-    }
-
-    public float getEyeHeight() {
-        return this.height * 0.5F;
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_SQUID_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_SQUID_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_SQUID_DEATH;
-    }
-
-    /**
-     * Returns the volume for the sounds this mob makes.
-     */
-    protected float getSoundVolume() {
-        return 0.4F;
-    }
-
-    /**
-     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
-     * prevent them from trampling crops
-     */
-    protected boolean canTriggerWalking() {
-        return false;
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_SQUID;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        super.onLivingUpdate();
-        this.prevSquidPitch = this.squidPitch;
-        this.prevSquidYaw = this.squidYaw;
-        this.prevSquidRotation = this.squidRotation;
-        this.lastTentacleAngle = this.tentacleAngle;
-        this.squidRotation += this.rotationVelocity;
-
-        if ((double) this.squidRotation > (Math.PI * 2D)) {
-            if (this.world.isRemote) {
-                this.squidRotation = ((float) Math.PI * 2F);
-            } else {
-                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
-
-                if (this.rand.nextInt(10) == 0) {
-                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-                }
-
-                this.world.setEntityState(this, (byte) 19);
-            }
-        }
-
-        if (this.inWater) {
-            if (this.squidRotation < (float) Math.PI) {
-                float f = this.squidRotation / (float) Math.PI;
-                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
-
-                if ((double) f > 0.75D) {
-                    this.randomMotionSpeed = 1.0F;
-                    this.rotateSpeed = 1.0F;
-                } else {
-                    this.rotateSpeed *= 0.8F;
-                }
-            } else {
-                this.tentacleAngle = 0.0F;
-                this.randomMotionSpeed *= 0.9F;
-                this.rotateSpeed *= 0.99F;
-            }
-
-            if (!this.world.isRemote) {
-                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
-                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
-                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
-            }
-
-            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
-            this.rotationYaw = this.renderYawOffset;
-            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
-            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
-        } else {
-            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
-
-            if (!this.world.isRemote) {
-                this.motionX = 0.0D;
-                this.motionZ = 0.0D;
-
-                if (this.isPotionActive(MobEffects.LEVITATION)) {
-                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
-                } else if (!this.hasNoGravity()) {
-                    this.motionY -= 0.08D;
-                }
-
-                this.motionY *= 0.9800000190734863D;
-            }
-
-            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
-        }
-    }
-
-    public void travel(float strafe, float vertical, float forward) {
-        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
-    }
-
-    /**
-     * Checks if the entity's current position is a valid location to spawn this entity.
-     */
-    public boolean getCanSpawnHere() {
-        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
-    }
-
-    /**
-     * Handler for {@link World#setEntityState}
-     */
-    @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id) {
-        if (id == 19) {
-            this.squidRotation = 0.0F;
-        } else {
-            super.handleStatusUpdate(id);
-        }
-    }
-
-    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
-        this.randomMotionVecX = randomMotionVecXIn;
-        this.randomMotionVecY = randomMotionVecYIn;
-        this.randomMotionVecZ = randomMotionVecZIn;
-    }
-
-    public boolean hasMovementVector() {
-        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
-    }
-
-    static class AIMoveRandom extends EntityAIBase {
-        private final EntityMonsterOfTheOceanDepths squid;
-
-        public AIMoveRandom(EntityMonsterOfTheOceanDepths p_i45859_1_) {
-            this.squid = p_i45859_1_;
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            return true;
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            int i = this.squid.getIdleTime();
-
-            if (i > 100) {
-                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
-            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
-                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
-                float f1 = MathHelper.cos(f) * 0.2F;
-                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
-                float f3 = MathHelper.sin(f) * 0.2F;
-                this.squid.setMovementVector(f1, f2, f3);
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/commands/CustomTeleporter.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/commands/CustomTeleporter.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/commands/CustomTeleporter.java	(date 1525605768000)
@@ -1,58 +0,0 @@
-package net.thegaminghuskymc.mcaddon.commands;
-
-import net.minecraft.command.CommandLocate;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.player.EntityPlayerMP;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.Teleporter;
-import net.minecraft.world.WorldServer;
-import net.minecraft.world.biome.Biome;
-
-public class CustomTeleporter extends Teleporter {
-    private final WorldServer world;
-    private double x, y, z;
-
-    public CustomTeleporter(WorldServer world, double x, double y, double z) {
-        super(world);
-        this.world = world;
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    public static void teleportToDimension(EntityPlayer player, int dimension, double x, double y, double z) {
-        int oldDimension = player.getEntityWorld().provider.getDimension();
-        EntityPlayerMP entityPlayerMP = (EntityPlayerMP) player;
-        MinecraftServer server = player.getEntityWorld().getMinecraftServer();
-        WorldServer worldServer = server.getWorld(dimension);
-        player.addExperienceLevel(0);
-
-        if (worldServer == null || worldServer.getMinecraftServer() == null) {
-            throw new IllegalArgumentException("Dimension: " + dimension + " doesn't exist!");
-        }
-
-        worldServer.getMinecraftServer().getPlayerList().transferPlayerToDimension(entityPlayerMP, dimension, new CustomTeleporter(worldServer, x, y, z));
-        player.setPositionAndUpdate(x, y, z);
-    }
-
-    public static void teleportToBiome(EntityPlayer player, String biome_name, double x, double y, double z) {
-        int oldDimension = player.getEntityWorld().provider.getDimension();
-        player.addExperienceLevel(0);
-
-        Biome biome = Biome.REGISTRY.getObject(new ResourceLocation(biome_name));
-
-        player.setPositionAndUpdate(x, y, z);
-    }
-
-    @Override
-    public void placeInPortal(Entity entity, float rotationYaw) {
-        this.world.getBlockState(new BlockPos((int) this.x, (int) this.y, (int) this.z));
-        entity.setPosition(this.x, this.y, this.z);
-        entity.motionX = 0.0f;
-        entity.motionY = 0.0f;
-        entity.motionZ = 0.0f;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCod.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCod.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderCod.java	(date 1525605768000)
@@ -1,34 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityCod;
-import net.thegaminghuskymc.mcaddon.entity.EntityScorp;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelCod;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelScorp;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-/*
- *TODO:Add Custom Model and Textures
- */
-public class RenderCod extends RenderLiving<EntityCod> {
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/fish/fish.png");
-
-    public RenderCod(RenderManager manager)
-    {
-        super(manager, new ModelCod(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityCod entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntityCod entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/StructureData.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/StructureData.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/StructureData.java	(date 1525605768000)
@@ -1,127 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   StructureData.java
-
-package net.thegaminghuskymc.mcaddon.world;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3i;
-import net.minecraft.world.World;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-// Referenced classes of package elucent.elulib.world:
-//            IGeneratable
-
-public class StructureData
-    implements IGeneratable
-{
-
-    public StructureData()
-    {
-        data = new HashMap();
-        blocks = new HashMap();
-        width = 0;
-        height = 0;
-        length = 0;
-    }
-
-    public void addBlock(String string, IBlockState state)
-    {
-        blocks.put(string, state);
-    }
-
-    public void addLayer(String layer[], int y)
-    {
-        for(int i = 0; i < layer.length; i++)
-        {
-            for(int j = 0; j < layer[i].length(); j++)
-                data.put(new Vec3i(i, y, j), layer[i].substring(j, j + 1));
-
-        }
-
-    }
-
-    public void calcDimensions()
-    {
-        int minX = 0;
-        int minY = 0;
-        int minZ = 0;
-        int maxX = 0;
-        int maxY = 0;
-        int maxZ = 0;
-        Iterator iterator = data.keySet().iterator();
-        do
-        {
-            if(!iterator.hasNext())
-                break;
-            Vec3i v = (Vec3i)iterator.next();
-            if(v.getX() < minX)
-                minX = v.getX();
-            if(v.getY() < minY)
-                minY = v.getY();
-            if(v.getZ() < minZ)
-                minZ = v.getZ();
-            if(v.getX() > maxX)
-                maxX = v.getX();
-            if(v.getY() > maxY)
-                maxY = v.getY();
-            if(v.getY() > maxZ)
-                maxZ = v.getZ();
-        } while(true);
-        width = maxX - minX;
-        height = maxY - minY;
-        length = maxZ - minZ;
-    }
-
-    public int getWidth()
-    {
-        return width;
-    }
-
-    public int getLength()
-    {
-        return length;
-    }
-
-    public void generateIn(World world, int x, int y, int z, Rotation rotation, Mirror doMirror, boolean replaceWithAir)
-    {
-        calcDimensions();
-        Iterator iterator = data.entrySet().iterator();
-        do
-        {
-            if(!iterator.hasNext())
-                break;
-            Map.Entry e = (Map.Entry)iterator.next();
-            Vec3i v = (Vec3i)e.getKey();
-            String b = (String)e.getValue();
-            if(rotation == Rotation.CLOCKWISE_180)
-                placeBlock(world, new BlockPos(x + v.getX(), y + v.getY(), (z - v.getZ()) + length), (IBlockState)blocks.get(b), rotation, doMirror, replaceWithAir);
-            if(rotation == Rotation.COUNTERCLOCKWISE_90)
-                placeBlock(world, new BlockPos(x + v.getZ(), y + v.getY(), z + v.getX()), (IBlockState)blocks.get(b), rotation, doMirror, replaceWithAir);
-            if(rotation == Rotation.NONE)
-                placeBlock(world, new BlockPos((x - v.getX()) + width, y + v.getY(), z + v.getZ()), (IBlockState)blocks.get(b), rotation, doMirror, replaceWithAir);
-            if(rotation == Rotation.CLOCKWISE_90)
-                placeBlock(world, new BlockPos((x - v.getZ()) + length, y + v.getY(), (z - v.getX()) + width), (IBlockState)blocks.get(b), rotation, doMirror, replaceWithAir);
-        } while(true);
-    }
-
-    public void placeBlock(World world, BlockPos pos, IBlockState state, Rotation rotation, Mirror mirror, boolean replaceWithAir)
-    {
-        if(state.getBlock() != Blocks.AIR || state.getBlock() == Blocks.AIR && replaceWithAir)
-            world.setBlockState(pos, state.withRotation(rotation).withMirror(mirror));
-    }
-
-    public Map data;
-    public Map blocks;
-    int width;
-    int height;
-    int length;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumBasaltTypes.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumBasaltTypes.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumBasaltTypes.java	(date 1525605768000)
@@ -1,58 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-
-public enum EnumBasaltTypes implements IStringSerializable {
-
-		RAW(0, "raw"),
-		PAVER(1, "paver"),
-		BRICKS(2, "bricks"),
-		CHISELED(3, "chiseled"),
-		BRICK_SMALL(4, "brick_small"),
-		TILE(5, "tile"),
-		PILLAR(6, "pillar"),
-		ARCH(7, "arch"),
-		ENGRAVED(8, "engraved"),
-		RUNED(9, "runed"),
-		PILLAR_TOP(10, "pillar_top"),
-		PILLAR_BOTTOM(11, "pillar_bottom"),
-		PILLAR_MIDDLE(12, "pillar_middle"),
-		COBBLE(13, "cobble"),
-		BRICKS_CRACKED(14, "bricks_cracked"),
-		CRACKED_LAVA(15, "cracked_lava");
-
-		private static final EnumBasaltTypes[] METADATA_LOOKUP = new EnumBasaltTypes[values().length];
-
-		static {
-			for (EnumBasaltTypes type : values()) {
-				METADATA_LOOKUP[type.getMetadata()] = type;
-			}
-		}
-
-		private final int metadata;
-		private final String name;
-
-		EnumBasaltTypes(int metadata, String name) {
-
-			this.metadata = metadata;
-			this.name = name;
-		}
-
-		public static EnumBasaltTypes byMetadata(int metadata) {
-
-			if (metadata < 0 || metadata >= METADATA_LOOKUP.length) {
-				metadata = 0;
-			}
-			return METADATA_LOOKUP[metadata];
-		}
-
-		public int getMetadata() {
-			return this.metadata;
-		}
-
-		@Override
-		public String getName() {
-
-			return this.name;
-		}
-	}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/Util.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/Util.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/Util.java	(date 1525605768000)
@@ -1,79 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   Util.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import java.util.*;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.chunk.Chunk;
-
-public class Util
-{
-
-    public Util()
-    {
-    }
-
-    public static List getTileEntitiesWithin(World world, Class teClass, int x1, int y1, int z1, int x2, int y2, int z2)
-    {
-        List tiles = new ArrayList();
-        for(int i = x1; i <= x2; i++)
-        {
-            for(int j = y1; j <= y2; j++)
-            {
-                for(int k = z1; k <= z2; k++)
-                {
-                    BlockPos p = new BlockPos(i, j, k);
-                    Chunk c = world.getChunkFromBlockCoords(p);
-                    if(!c.isLoaded())
-                        continue;
-                    net.minecraft.tileentity.TileEntity t = world.getChunkFromBlockCoords(p).getTileEntity(p, Chunk.EnumCreateEntityType.CHECK);
-                    if(t != null && teClass.isInstance(t))
-                        tiles.add(t);
-                }
-
-            }
-
-        }
-
-        return tiles;
-    }
-
-    public static String lowercase(String s)
-    {
-        String f = "";
-        for(int i = 0; i < s.length(); i++)
-        {
-            String c = s.substring(i, i + 1);
-            if(c.toUpperCase().compareTo(c) == 0)
-            {
-                if(i > 0)
-                    f = (new StringBuilder()).append(f).append("_").toString();
-                f = (new StringBuilder()).append(f).append(c.toLowerCase()).toString();
-            } else
-            {
-                f = (new StringBuilder()).append(f).append(c).toString();
-            }
-        }
-
-        return f;
-    }
-
-    public static int intColor(int r, int g, int b)
-    {
-        return 0xff000000 + r * 0x10000 + g * 256 + b;
-    }
-
-    public static String getLowercaseClassName(Class c)
-    {
-        String nameParts[] = c.getTypeName().split("\\.");
-        String className = nameParts[nameParts.length - 1];
-        return lowercase(className);
-    }
-
-    public static Random rand = new Random();
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/TerrainEventHandlers.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/TerrainEventHandlers.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/TerrainEventHandlers.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraft.world.World;
-import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
-import net.minecraftforge.fml.common.eventhandler.Event;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.thegaminghuskymc.mcaddon.init.BiomeInit;
-
-import static net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.CUSTOM;
-
-public class TerrainEventHandlers {
-
-    @SubscribeEvent
-    public void onCreateDecorate(DecorateBiomeEvent.Decorate event) {
-        World world = event.getWorld();
-        if(world.getBiome(event.getPos()) == BiomeInit.BASALT) {
-            if (!world.isRemote) {
-                if(event.getType() != CUSTOM) {
-                    event.setResult(Event.Result.DENY);
-                    System.out.print("Denying vanilla worldgen for this biome");
-                }
-            }
-        }
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummyVillager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummyVillager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummyVillager.java	(date 1525605768000)
@@ -1,304 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.block.Block;
-import net.minecraft.entity.IEntityLivingData;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.potion.PotionEffect;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.DifficultyInstance;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.common.registry.ForgeRegistries;
-import net.minecraftforge.fml.common.registry.VillagerRegistry;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.util.handlers.LootTableHandler;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-import java.util.UUID;
-
-
-/**
- * TODO: Fix Texture and Model
- */
-public class EntityMummyVillager extends EntityMummy {
-
-    private static final DataParameter<Boolean> CONVERTING = EntityDataManager.createKey(EntityMummyVillager.class, DataSerializers.BOOLEAN);
-    private static final DataParameter<Integer> PROFESSION = EntityDataManager.createKey(EntityMummyVillager.class, DataSerializers.VARINT);
-
-    private int conversionTime;
-    private UUID converstionStarter;
-
-    public EntityMummyVillager(World worldIn) {
-        super(worldIn);
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(CONVERTING, Boolean.FALSE);
-        this.dataManager.register(PROFESSION, 0);
-    }
-
-    public void setProfession(int profession) {
-        this.dataManager.set(PROFESSION, profession);
-    }
-
-    public int getProfession() {
-        return Math.max(this.dataManager.get(PROFESSION), 0);
-    }
-
-    @Override
-    public void writeEntityToNBT(NBTTagCompound compound) {
-        super.writeEntityToNBT(compound);
-        compound.setInteger("Profession", this.getProfession());
-        compound.setString("ProfessionName", Objects.requireNonNull(this.getForgeProfession().getRegistryName()).toString());
-        compound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);
-
-        if (this.converstionStarter != null) {
-            compound.setUniqueId("ConversionStarter", this.converstionStarter);
-        }
-    }
-
-    @Override
-    public void readEntityFromNBT(NBTTagCompound compound)
-    {
-        super.readEntityFromNBT(compound);
-        this.setProfession(compound.getInteger("Profession"));
-        if (compound.hasKey("ProfessionName"))
-        {
-            VillagerRegistry.VillagerProfession p = ForgeRegistries.VILLAGER_PROFESSIONS.getValue(new net.minecraft.util.ResourceLocation(compound.getString("ProfessionName")));
-            if (p == null) p = VillagerRegistry.FARMER;
-            this.setForgeProfession(p);
-        }
-
-        if (compound.hasKey("ConversionTime", 99) && compound.getInteger("ConversionTime") > -1)
-        {
-            this.startConverting(compound.hasUniqueId("ConversionPlayer") ? compound.getUniqueId("ConversionPlayer") : null, compound.getInteger("ConversionTime"));
-        }
-    }
-
-    @Nullable
-    @Override
-    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata)
-    {
-        this.setProfession(this.world.rand.nextInt(6));
-        return super.onInitialSpawn(difficulty, livingdata);
-    }
-
-    @Override
-    public void onUpdate() {
-        if (!this.world.isRemote && this.isConverting())
-        {
-            int i = this.getConversionProgress();
-            this.conversionTime -= i;
-
-            if (this.conversionTime <= 0)
-            {
-                this.finishConversion();
-            }
-        }
-        super.onUpdate();
-    }
-
-    @Override
-    protected boolean processInteract(EntityPlayer player, EnumHand hand) {
-        ItemStack itemstack = player.getHeldItem(hand);
-
-        if (itemstack.getItem() == Items.GOLDEN_APPLE && itemstack.getMetadata() == 0 && this.isPotionActive(MobEffects.WEAKNESS))
-        {
-            if (!player.capabilities.isCreativeMode)
-            {
-                itemstack.shrink(1);
-            }
-
-            if (!this.world.isRemote)
-            {
-                this.startConverting(player.getUniqueID(), this.rand.nextInt(2401) + 3600);
-            }
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    @Override
-    protected boolean canDespawn() {
-        return !this.isConverting();
-    }
-
-    public boolean isConverting()
-    {
-        return this.getDataManager().get(CONVERTING);
-    }
-
-    protected void startConverting(@Nullable UUID conversionStarterIn, int conversionTimeIn)
-    {
-        this.converstionStarter = conversionStarterIn;
-        this.conversionTime = conversionTimeIn;
-        this.getDataManager().set(CONVERTING, Boolean.TRUE);
-        this.removePotionEffect(MobEffects.WEAKNESS);
-        this.addPotionEffect(new PotionEffect(MobEffects.STRENGTH, conversionTimeIn, Math.min(this.world.getDifficulty().getDifficultyId() - 1, 0)));
-        this.world.setEntityState(this, (byte)16);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id)
-    {
-        if (id == 16)
-        {
-            if (!this.isSilent())
-            {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_ZOMBIE_VILLAGER_CURE, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-        }
-        else
-        {
-            super.handleStatusUpdate(id);
-        }
-    }
-
-    protected void finishConversion()
-    {
-        EntityVillager entityvillager = new EntityVillager(this.world);
-        entityvillager.copyLocationAndAnglesFrom(this);
-        entityvillager.setProfession(this.getForgeProfession());
-        entityvillager.finalizeMobSpawn(this.world.getDifficultyForLocation(new BlockPos(entityvillager)), null, false);
-        entityvillager.setLookingForHome();
-        this.world.removeEntity(this);
-        entityvillager.setNoAI(this.isAIDisabled());
-
-        if (this.hasCustomName())
-        {
-            entityvillager.setCustomNameTag(this.getCustomNameTag());
-            entityvillager.setAlwaysRenderNameTag(this.getAlwaysRenderNameTag());
-        }
-
-        this.world.spawnEntity(entityvillager);
-        entityvillager.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 200, 0));
-        this.world.playEvent(null, 1027, new BlockPos((int)this.posX, (int)this.posY, (int)this.posZ), 0);
-    }
-
-    protected int getConversionProgress()
-    {
-        int i = 1;
-
-        if (this.rand.nextFloat() < 0.01F)
-        {
-            int j = 0;
-            BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
-
-            for (int k = (int)this.posX - 4; k < (int)this.posX + 4 && j < 14; ++k)
-            {
-                for (int l = (int)this.posY - 4; l < (int)this.posY + 4 && j < 14; ++l)
-                {
-                    for (int i1 = (int)this.posZ - 4; i1 < (int)this.posZ + 4 && j < 14; ++i1)
-                    {
-                        Block block = this.world.getBlockState(blockpos$mutableblockpos.setPos(k, l, i1)).getBlock();
-
-                        if (block == Blocks.IRON_BARS || block == Blocks.BED)
-                        {
-                            if (this.rand.nextFloat() < 0.3F)
-                            {
-                                ++i;
-                            }
-
-                            ++j;
-                        }
-                    }
-                }
-            }
-        }
-
-        return i;
-    }
-
-    protected float getSoundPitch()
-    {
-        return (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
-    }
-
-    /**
-     * TODO: FIX NEW SOUNDS
-     */
-
-    public SoundEvent getAmbientSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_AMBIENT;
-    }
-
-    public SoundEvent getHurtSound(DamageSource damageSourceIn)
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_HURT;
-    }
-
-    public SoundEvent getDeathSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_DEATH;
-    }
-
-    public SoundEvent getStepSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_VILLAGER_STEP;
-    }
-
-    //TODO: ^
-
-    @Nullable
-    protected ResourceLocation getLootTable()
-    {
-        return LootTableHandler.MUMMY_VILLAGER;
-    }
-
-    protected ItemStack getSkullDrop()
-    {
-        return ItemStack.EMPTY;
-    }
-
-
-    /* ======================================== FORGE START =====================================*/
-
-    @Nullable
-    private VillagerRegistry.VillagerProfession prof;
-    public void setForgeProfession(VillagerRegistry.VillagerProfession prof)
-    {
-        this.prof = prof;
-        this.setProfession(VillagerRegistry.getId(prof));
-    }
-
-    public VillagerRegistry.VillagerProfession getForgeProfession()
-    {
-        if (this.prof == null)
-        {
-            this.prof = VillagerRegistry.getById(this.getProfession());
-            if (this.prof == null)
-                return VillagerRegistry.FARMER;
-        }
-        return this.prof;
-    }
-
-    @Override
-    public void notifyDataManagerChange(DataParameter<?> key)
-    {
-        super.notifyDataManagerChange(key);
-    }
-
-    /* ======================================== FORGE END =====================================*/
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummy.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummy.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityMummy.java	(date 1525605768000)
@@ -1,391 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.block.Block;
-import net.minecraft.entity.*;
-import net.minecraft.entity.ai.EntityAIBreakDoor;
-import net.minecraft.entity.ai.EntityAIHurtByTarget;
-import net.minecraft.entity.ai.EntityAIMoveThroughVillage;
-import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
-import net.minecraft.entity.ai.attributes.AttributeModifier;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.monster.EntityCreeper;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Biomes;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNavigateGround;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.DifficultyInstance;
-import net.minecraft.world.EnumDifficulty;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.entity.ai.EntityAIMummyAttack;
-import net.thegaminghuskymc.mcaddon.init.MCAddonItems;
-import net.thegaminghuskymc.mcaddon.util.handlers.LootTableHandler;
-
-import javax.annotation.Nullable;
-import java.util.Calendar;
-import java.util.UUID;
-
-public class EntityMummy extends EntityUndeadBase {
-
-    private static final UUID BABY_SPEED_BOOST_ID = UUID.fromString("B9766B59-9566-4402-BC1F-2EE2A276D836");
-    private static final AttributeModifier BABY_SPEED_BOOST = new AttributeModifier(BABY_SPEED_BOOST_ID, "Mummy Baby Speed Boost", 0.5D, 1);
-    private static final DataParameter<Boolean> IS_CHILD = EntityDataManager.createKey(EntityMummy.class, DataSerializers.BOOLEAN);
-
-    private static final DataParameter<Integer> VILLAGER_TYPE = EntityDataManager.createKey(EntityMummy.class, DataSerializers.VARINT);
-    public static final DataParameter<Boolean> ARMS_RAISED = EntityDataManager.createKey(EntityMummy.class, DataSerializers.BOOLEAN);
-    private final EntityAIBreakDoor breakDoor = new EntityAIBreakDoor(this);
-    private boolean isBreakDoorsTaskSet;
-
-    private double mummyBabyChance = 0.05;
-    private float mummyWidth = -1.0F;
-    private float mummyHeight;
-
-    public EntityMummy(World worldIn) {
-        super(worldIn);
-        this.setSize(0.6F, 1.95F);
-    }
-
-    @Override
-    protected void initEntityAI() {
-        this.tasks.addTask(2, new EntityAIMummyAttack(this, 1.0D, false));
-        this.tasks.addTask(6, new EntityAIMoveThroughVillage(this, 1.0D, false));
-        this.applyEntityAI();
-    }
-
-    protected void applyEntityAI() {
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(3, new EntityAINearestAttackableTarget<>(this, EntityVillager.class, true));
-    }
-    @Override
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);
-        this.getEntityAttribute(SharedMonsterAttributes.ARMOR).setBaseValue(1.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(2.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(10.0D);
-    }
-
-    @Override
-    protected void entityInit() {
-        super.entityInit();
-        this.getDataManager().register(VILLAGER_TYPE, 0);
-        this.getDataManager().register(ARMS_RAISED, Boolean.FALSE);
-        this.getDataManager().register(IS_CHILD, Boolean.valueOf(false));
-    }
-
-    public void setArmsRaised(boolean armsRaised) {
-        this.getDataManager().set(ARMS_RAISED, armsRaised);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean isArmsRaised() {
-        return this.getDataManager().get(ARMS_RAISED);
-    }
-
-    public boolean isBreakDoorsTaskSet() {
-        return this.isBreakDoorsTaskSet;
-    }
-
-    public void setBreakDoorAItask(boolean enabled) {
-        if (this.isBreakDoorsTaskSet != enabled) {
-            this.isBreakDoorsTaskSet = enabled;
-            ((PathNavigateGround)this.getNavigator()).setBreakDoors(enabled);
-
-            if (enabled)
-                this.tasks.addTask(1, this.breakDoor);
-            else
-                this.tasks.removeTask(this.breakDoor);
-        }
-    }
-
-    public boolean isChild() {
-        return this.getDataManager().get(IS_CHILD);
-    }
-
-    @Override
-    protected int getExperiencePoints(EntityPlayer player) {
-        if (this.isChild())
-            this.experienceValue = (int)((float)this.experienceValue * 2.5F);
-        return super.getExperiencePoints(player);
-    }
-
-    public void setChild(boolean child) {
-        this.getDataManager().set(IS_CHILD, child);
-        if (this.world != null && !this.world.isRemote) {
-            IAttributeInstance attributeInstance = this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);
-            attributeInstance.removeModifier(BABY_SPEED_BOOST);
-
-            if (child)
-                attributeInstance.applyModifier(BABY_SPEED_BOOST);
-        }
-        this.setChildSize(child);
-    }
-
-    @Override
-    public void notifyDataManagerChange(DataParameter<?> key) {
-        if (IS_CHILD.equals(key))
-            this.setChildSize(this.isChild());
-        super.notifyDataManagerChange(key);
-    }
-
-    @Override
-    public void onLivingUpdate() {
-        super.onLivingUpdate();
-    }
-
-    @Override
-    public boolean attackEntityFrom(DamageSource source, float amount) {
-        return super.attackEntityFrom(source, amount);
-    }
-
-    @Override
-    public boolean attackEntityAsMob(Entity entityIn) {
-        boolean flag = super.attackEntityAsMob(entityIn);
-
-        if (flag) {
-            float f = this.world.getDifficultyForLocation(new BlockPos(this)).getAdditionalDifficulty();
-
-            if (this.getHeldItemMainhand().isEmpty() && this.isBurning() && this.rand.nextFloat() < f * 0.3F)
-                entityIn.setFire(2 * (int)f);
-        }
-        return flag;
-    }
-
-    /**
-     *  TODO: Change Sounds...
-     */
-    @Override
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_ZOMBIE_AMBIENT;
-    }
-
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_ZOMBIE_HURT;
-    }
-
-    @Override
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_ZOMBIE_DEATH;
-    }
-
-    protected SoundEvent getStepSound()
-    {
-        return SoundEvents.ENTITY_ZOMBIE_STEP;
-    }
-
-    // TODO ^
-
-
-    @Override
-    protected void playStepSound(BlockPos pos, Block blockIn) {
-        this.playSound(this.getStepSound(), 0.15F, 1.0F);
-    }
-
-    @Override
-    public EnumCreatureAttribute getCreatureAttribute() {
-        return EnumCreatureAttribute.UNDEAD;
-    }
-
-    @Nullable
-    @Override
-    protected ResourceLocation getLootTable() {
-        return LootTableHandler.MUMMY;
-    }
-
-    @Override
-    protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
-        super.setEquipmentBasedOnDifficulty(difficulty);
-
-        if (this.rand.nextFloat() < (this.world.getDifficulty() == EnumDifficulty.HARD ? 0.05F : 0.01F)) {
-            int i = this.rand.nextInt(3);
-
-            if (i == 0)
-                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(MCAddonItems.ANCIENT_SWORD));
-            else
-                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, new ItemStack(Item.getItemFromBlock(Blocks.SAND)));
-        }
-    }
-
-    public static void registerFixesMummy(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityMummy.class);
-    }
-
-    @Override
-    public void writeEntityToNBT(NBTTagCompound compound) {
-        super.writeEntityToNBT(compound);
-        if (this.isChild())
-            compound.setBoolean("IsBaby", true);
-        compound.setBoolean("CanBreakDoors", this.isBreakDoorsTaskSet());
-    }
-
-    @Override
-    public void readEntityFromNBT(NBTTagCompound compound) {
-        super.readEntityFromNBT(compound);
-        if (compound.getBoolean("IsBaby"))
-            this.setChild(true);
-        this.setBreakDoorAItask(compound.getBoolean("CanBreakDoors"));
-    }
-
-    @Override
-    public void onKillEntity(EntityLivingBase entityLivingIn) {
-        super.onKillEntity(entityLivingIn);
-
-        if ((this.world.getDifficulty() == EnumDifficulty.NORMAL || this.world.getDifficulty() == EnumDifficulty.HARD) && entityLivingIn instanceof EntityVillager) {
-            if (this.world.getDifficulty() != EnumDifficulty.HARD && this.rand.nextBoolean())
-                return;
-
-            EntityVillager entityVillager = (EntityVillager) entityLivingIn;
-            EntityMummyVillager entityMummyVillager = new EntityMummyVillager(this.world);
-            entityMummyVillager.copyLocationAndAnglesFrom(entityVillager);
-            this.world.removeEntity(entityVillager);
-            entityMummyVillager.onInitialSpawn(this.world.getDifficultyForLocation(new BlockPos(entityMummyVillager)), null);
-            entityMummyVillager.setProfession(entityVillager.getProfession());
-            entityMummyVillager.setNoAI(entityVillager.isAIDisabled());
-
-            if (entityVillager.hasCustomName()) {
-                entityMummyVillager.setCustomNameTag(entityVillager.getCustomNameTag());
-                entityMummyVillager.setAlwaysRenderNameTag(entityVillager.getAlwaysRenderNameTag());
-            }
-
-            this.world.spawnEntity(entityMummyVillager);
-            this.world.playEvent(null, 1026, new BlockPos(this), 0);
-        }
-    }
-
-    @Override
-    public float getEyeHeight() {
-        float f = 1.74F;
-        if (this.isChild())
-            f = (float)((double)f - 0.81D);
-        return f;
-    }
-
-    @Override
-    protected boolean canEquipItem(ItemStack stack) {
-        return stack.getItem() == MCAddonItems.ANCIENT_SWORD;
-    }
-
-    @Override
-    public boolean getCanSpawnHere() {
-        return this.world.getDifficulty() != EnumDifficulty.PEACEFUL && world.getBiome(new BlockPos(this)) == Biomes.DESERT || world.getBiome(new BlockPos(this)) == Biomes.DESERT_HILLS;
-    }
-
-    @Nullable
-    @Override
-    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
-        if (!getCanSpawnHere())
-            despawnEntity();
-        else {
-            livingdata = super.onInitialSpawn(difficulty, livingdata);
-            float f = difficulty.getClampedAdditionalDifficulty();
-            this.setCanPickUpLoot(this.rand.nextFloat() < 0.55F * f);
-            if (this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
-                Calendar calendar = this.world.getCurrentDate();
-                if (calendar.get(Calendar.MONTH) + 1 == 10 && calendar.get(Calendar.DATE) == 31 && this.rand.nextFloat() < 0.25F) {
-                    this.setItemStackToSlot(EntityEquipmentSlot.HEAD, new ItemStack(this.rand.nextFloat() < 0.1F ? Blocks.LIT_PUMPKIN : Blocks.PUMPKIN));
-                    this.inventoryArmorDropChances[EntityEquipmentSlot.HEAD.getIndex()] = 0.0F;
-                }
-            }
-            if (livingdata == null)
-            {
-                livingdata = new EntityMummy.GroupData(this.world.rand.nextFloat() < mummyBabyChance);
-            }
-
-            if (livingdata instanceof EntityMummy.GroupData)
-            {
-                EntityMummy.GroupData entitymummy$groupdata = (EntityMummy.GroupData)livingdata;
-                if (entitymummy$groupdata.isChild)
-                {
-                    this.setChild(true);
-                }
-            }
-            this.setBreakDoorAItask(this.rand.nextFloat() < f * 0.1F);
-            this.setEquipmentBasedOnDifficulty(difficulty);
-            this.setEnchantmentBasedOnDifficulty(difficulty);
-
-            this.getEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).applyModifier(new AttributeModifier("Spawn Bonus", this.rand.nextDouble() * 0.05000000074505806D, 0));
-            double d0 = this.rand.nextDouble() * 1.5D * (double) f;
-
-            if (d0 > 1.0D)
-                this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).applyModifier(new AttributeModifier("Random mummy-spawn bonus", d0, 2));
-
-            if (this.rand.nextFloat() < f * 0.0F && this.world.getDifficulty() == EnumDifficulty.HARD) {
-                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).applyModifier(new AttributeModifier("Leader mummy bonus", this.rand.nextDouble() * 3.0D + 1.0D, 2));
-                this.setBreakDoorAItask(true);
-            }
-        }
-        return livingdata;
-    }
-
-    public void setChildSize(boolean isChild) {
-        this.multiplySize(isChild ? 0.5F : 1.0F);
-    }
-
-    @Override
-    protected final void setSize(float width, float height) {
-        boolean flag = this.mummyWidth > 0.0F && this.mummyHeight > 0.0F;
-        this.mummyWidth = width;
-        this.mummyHeight = height;
-
-        if (!flag)
-            this.multiplySize(1.0f);
-    }
-
-    protected final void multiplySize(float size) {
-        super.setSize(this.mummyWidth * size, this.mummyHeight * size);
-    }
-
-    public double getYOffset() {
-        return this.isChild() ? 0.0D : -0.45D;
-    }
-
-    @Override
-    public void onDeath(DamageSource cause) {
-        super.onDeath(cause);
-
-        if (cause.getTrueSource() instanceof EntityCreeper) {
-            EntityCreeper entityCreeper = (EntityCreeper)cause.getTrueSource();
-
-            if (entityCreeper.getPowered() && entityCreeper.ableToCauseSkullDrop()) {
-                entityCreeper.incrementDroppedSkulls();
-                ItemStack itemStack = this.getSkullDrop();
-
-                if(!itemStack.isEmpty())
-                    this.entityDropItem(itemStack, 0.0F);
-            }
-        }
-    }
-
-    protected ItemStack getSkullDrop() {
-        return new ItemStack(Items.SKULL, 1, 2);
-    }
-
-    class GroupData implements IEntityLivingData
-    {
-        public boolean isChild;
-
-        private GroupData(boolean isChild)
-        {
-            this.isChild = isChild;
-        }
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosStarFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosStarFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosStarFish.java	(date 1525605768000)
@@ -1,92 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosStarFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import axa;
-import ayf;
-import ke;
-import lq;
-import md;
-
-public class ModelAtmosStarFish extends axa
-{
-
-    public ModelAtmosStarFish()
-    {
-        t = 64;
-        u = 32;
-        Side1 = new ayf(this, 0, 0);
-        Side1.a(-0.5F, -0.5F, -0.5F, 1, 1, 4);
-        Side1.a(0.0F, 23F, 0.0F);
-        Side1.b(64, 32);
-        Side1.i = true;
-        setRotation(Side1, -0.1396263F, 0.0F, 0.0F);
-        Side2 = new ayf(this, 0, 0);
-        Side2.a(-0.5F, -0.5F, -0.5F, 1, 1, 4);
-        Side2.a(0.0F, 23F, 0.0F);
-        Side2.b(64, 32);
-        Side2.i = true;
-        setRotation(Side2, -0.1396263F, 0.9599311F, 0.0F);
-        Side3 = new ayf(this, 0, 0);
-        Side3.a(-0.5F, -0.5F, -0.5F, 1, 1, 4);
-        Side3.a(0.0F, 23F, 0.0F);
-        Side3.b(64, 32);
-        Side3.i = true;
-        setRotation(Side3, -0.1396263F, -0.9599311F, 0.0F);
-        Side4 = new ayf(this, 0, 0);
-        Side4.a(-0.5F, -0.5F, -0.5F, 1, 1, 4);
-        Side4.a(0.0F, 23F, 0.0F);
-        Side4.b(64, 32);
-        Side4.i = true;
-        setRotation(Side4, -0.1396263F, 2.268928F, 0.0F);
-        Side5 = new ayf(this, 0, 0);
-        Side5.a(-0.5F, -0.5F, -0.5F, 1, 1, 4);
-        Side5.a(0.0F, 23F, 0.0F);
-        Side5.b(64, 32);
-        Side5.i = true;
-        setRotation(Side5, -0.1396263F, -2.268928F, 0.0F);
-    }
-
-    public void a(md entityliving, float f, float f1, float f2)
-    {
-        Side1.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.2F * f2;
-        Side2.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.2F * f2;
-        Side3.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.2F * f2;
-        Side4.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.2F * f2;
-        Side5.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.2F * f2;
-    }
-
-    public void a(lq entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.a(entity, f, f1, f2, f3, f4, f5);
-        a(f, f1, f2, f3, f4, f5, entity);
-        Side1.a(f5);
-        Side2.a(f5);
-        Side3.a(f5);
-        Side4.a(f5);
-        Side5.a(f5);
-    }
-
-    private void setRotation(ayf model, float x, float y, float z)
-    {
-        model.f = x;
-        model.g = y;
-        model.h = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, lq entity)
-    {
-        super.a(f, f1, f2, f3, f4, f5, entity);
-    }
-
-    ayf Side1;
-    ayf Side2;
-    ayf Side3;
-    ayf Side4;
-    ayf Side5;
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/ConfigHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/ConfigHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/ConfigHandler.java	(date 1525605768000)
@@ -1,460 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraftforge.common.config.Config;
-import net.minecraftforge.common.config.ConfigManager;
-import net.minecraftforge.fml.client.event.ConfigChangedEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@Config.LangKey("config.hmca:title")
-@Config(modid = MOD_ID, name = "Husky's Minecraft Additions/hmca", category = "hmca")
-public class ConfigHandler
-{
-    @Config.Name("client")
-    @Config.LangKey("config.hmca:client")
-    public static Client client = new Client();
-
-    @Config.Name("dimension")
-    @Config.LangKey("config.hmca:dimension")
-    public static Dimension dimension = new Dimension();
-
-    @Config.Name("animation.animations.blocks")
-    @Config.LangKey("config.hmca:animation.animations.blocks")
-    public static Block block = new Block();
-
-    @Config.Name("potion_effect")
-    @Config.LangKey("config.hmca:potionEffect")
-    public static PotionEffect potionEffect = new PotionEffect();
-
-    @Config.Name("entity")
-    @Config.LangKey("config.hmca:entity")
-    public static Entity entity = new Entity();
-
-    @Config.Name("biome")
-    @Config.LangKey("config.hmca:biome")
-    public static Biome biome = new Biome();
-
-    private static final Logger LOGGER = LogManager.getLogger("NetherEx|ConfigHandler");
-
-    public static class Client
-    {
-        @Config.Name("visual")
-        @Config.LangKey("config.hmca:client.visual")
-        public Visual visual = new Visual();
-
-        public class Visual
-        {
-            @Config.LangKey("config.hmca:client.visual.disableNetherFog")
-            public boolean disableNetherFog = true;
-        }
-    }
-
-    public static class Dimension
-    {
-        @Config.Name("nether")
-        @Config.LangKey("config.hmca:dimension.nether")
-        public Nether nether = new Nether();
-
-        public class Nether
-        {
-            @Config.LangKey("config.hmca:dimension.nether.generateSoulSand")
-            public boolean generateSoulSand = false;
-
-            @Config.LangKey("config.hmca:dimension.nether.generateGravel")
-            public boolean generateGravel = false;
-
-            @Config.LangKey("config.hmca:dimension.nether.isLavaInfinite")
-            public boolean isLavaInfinite = false;
-        }
-    }
-
-    public static class Block
-    {
-        @Config.Name("nether_portal")
-        @Config.LangKey("config.hmca:animation.animations.blocks.netherPortal")
-        public NetherPortal netherPortal = new NetherPortal();
-
-        @Config.Name("netherrack")
-        @Config.LangKey("config.hmca:animation.animations.blocks.netherrack")
-        public Netherrack netherrack = new Netherrack();
-
-        @Config.Name("soul_sand")
-        @Config.LangKey("config.hmca:animation.animations.blocks.soulSand")
-        public SoulSand soulSand = new SoulSand();
-
-        @Config.Name("magma")
-        @Config.LangKey("config.hmca:animation.animations.blocks.magma")
-        public Magma magma = new Magma();
-
-        @Config.Name("rime")
-        @Config.LangKey("config.hmca:animation.animations.blocks.rime")
-        public Rime rime = new Rime();
-
-        @Config.Name("thornstalk")
-        @Config.LangKey("config.hmca:animation.animations.blocks.thornstalk")
-        public Thornstalk thornstalk = new Thornstalk();
-
-        @Config.Name("hyphae")
-        @Config.LangKey("config.hmca:animation.animations.blocks.hyphae")
-        public Hyphae hyphae = new Hyphae();
-
-        public class NetherPortal
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.netherrack.allowPigmanSpawning")
-            public boolean allowPigmanSpawning = true;
-
-            @Config.RangeInt(min = 4, max = 2048)
-            @Config.LangKey("config.hmca:animation.animations.blocks.netherrack.pigmanSpawnRarity")
-            @Config.Comment({"The higher the number, the rarer it is for Pigman to spawn", "The lower the number, the more common it is for Pigman to spawn"})
-            public int pigmanSpawnRarity = 2000;
-        }
-
-        public class Netherrack
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.netherrack.allowAllShovelsToFlatten")
-            public boolean allowAllShovelsToFlatten = false;
-        }
-
-        public class SoulSand
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.soulSand.doesNetherwartUseNewGrowthSystem")
-            public boolean doesNetherwartUseNewGrowthSystem = true;
-
-            @Config.LangKey("config.hmca:animation.animations.blocks.soulSand.allowAllHoesToTill")
-            public boolean allowAllHoesToTill = false;
-
-            @Config.LangKey("config.hmca:animation.animations.blocks.soulSand.doesRequireIchor")
-            public boolean doesRequireIchor = true;
-        }
-
-        public class Magma
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.magma.turnIntoLava")
-            public boolean turnIntoLava = false;
-        }
-
-        public class Rime
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.rime.canFreezeWater")
-            public boolean canFreezeWater = true;
-
-            @Config.LangKey("config.hmca:animation.animations.blocks.rime.canFreezeLava")
-            public boolean canFreezeLava = true;
-
-            @Config.LangKey("config.hmca:animation.animations.blocks.rime.canFreezeMobs")
-            public boolean canFreezeMobs = true;
-        }
-
-        public class Thornstalk
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.thornstalk.canDestroyItems")
-            public boolean canDestroyItems = false;
-
-            @Config.LangKey("config.hmca:animation.animations.blocks.thornstalk.blacklist")
-            @Config.Comment("Mobs the Thornstalk shouldn't hurt")
-            public String[] blacklist = new String[]{
-                    "minecraft:wither_skeleton",
-                    "minecraft:zombie_pigman",
-                    "hmca:monster_spinout"
-            };
-        }
-
-        public class Hyphae
-        {
-            @Config.LangKey("config.hmca:animation.animations.blocks.hyphae.doesSpread")
-            public boolean doesSpread = false;
-        }
-    }
-
-    public static class PotionEffect
-    {
-        @Config.Name("freeze")
-        @Config.LangKey("config.hmca:potionEffect.freeze")
-        public Freeze freeze = new Freeze();
-
-        @Config.Name("spore")
-        @Config.LangKey("config.hmca:potionEffect.spore")
-        public Spore spore = new Spore();
-
-        @Config.Name("lost")
-        @Config.LangKey("config.hmca:potionEffect.lost")
-        public Lost lost = new Lost();
-
-        public class Freeze
-        {
-            @Config.LangKey("config.hmca:potionEffect.freeze.chanceOfThawing")
-            @Config.Comment({"The higher the number, the rarer it is to thaw", "The lower the number, the more common it is to thaw"})
-            @Config.RangeInt(min = 1, max = 2048)
-            public int chanceOfThawing = 1024;
-
-            @Config.LangKey("config.hmca:potionEffect.freeze.blacklist")
-            @Config.Comment("Mobs that shouldn't freeze")
-            public String[] blacklist = new String[]{
-                    "minecraft:blaze",
-                    "minecraft:ghast",
-                    "minecraft:wither_skeleton",
-                    "minecraft:polar_bear",
-                    "hmca:monster_wight",
-                    "hmca:monster_ember",
-                    "hmca:monster_spinout",
-                    "hmca:monster_bone_spider",
-                    "hmca:monster_brute"
-            };
-        }
-
-        public class Spore
-        {
-            @Config.LangKey("config.hmca:potionEffect.spore.chanceOfSporeSpawning")
-            @Config.Comment({"The higher the number, the rarer it is to spawn a Spore", "The lower the number, the more common it is to spawn a Spore"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int chanceOfSporeSpawning = 128;
-
-            @Config.LangKey("config.hmca:potionEffect.spore.blacklist")
-            @Config.Comment("Mobs that shouldn't spawn Spores")
-            public String[] blacklist = new String[]{
-                    "hmca:monster_spore_creeper",
-                    "hmca:monster_spore",
-                    "hmca:neutral_mogus"
-            };
-        }
-
-        public class Lost
-        {
-            @Config.LangKey("config.hmca:potionEffect.lost.chanceOfGhastlingSpawning")
-            @Config.Comment({"The higher the number, the rarer it is to spawn a Ghastling", "The lower the number, the more common it is to spawn a Ghastling"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int chanceOfGhastlingSpawning = 256;
-        }
-    }
-
-    public static class Entity
-    {
-        @Config.Name("ember")
-        @Config.LangKey("config.hmca:entity.ember")
-        public Ember ember = new Ember();
-
-        @Config.Name("nethermite")
-        @Config.LangKey("config.hmca:entity.nethermite")
-        public Nethermite nethermite = new Nethermite();
-
-        @Config.Name("spinout")
-        @Config.LangKey("config.hmca:entity.spinout")
-        public Spinout spinout = new Spinout();
-
-        @Config.Name("spore_creeper")
-        @Config.LangKey("config.hmca:entity.sporeCreeper")
-        public SporeCreeper sporeCreeper = new SporeCreeper();
-
-        @Config.Name("spore")
-        @Config.LangKey("config.hmca:entity.spore")
-        public Spore spore = new Spore();
-
-        @Config.Name("brute")
-        @Config.LangKey("config.hmca:entity.brute")
-        public Brute brute = new Brute();
-
-        @Config.Name("ghast_queen")
-        @Config.LangKey("config.hmca:entity.ghastQueen")
-        public GhastQueen ghastQueen = new GhastQueen();
-
-        public class Ember
-        {
-            @Config.LangKey("config.hmca:entity.ember.chanceOfSettingPlayerOnFire")
-            @Config.Comment({"The higher the number, the rarer it is to set a player on fire", "The lower the number, the more common it is to set a player on fire"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int chanceOfSettingPlayerOnFire = 1;
-        }
-
-        public class Nethermite
-        {
-            @Config.LangKey("config.hmca:entity.nethermite.chanceOfSpawning")
-            @Config.Comment({"The higher the number, the rarer it is for a Nethermite to spawn", "The lower the number, the more common it is for a Nethermite to spawn"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int chanceOfSpawning = 64;
-
-            @Config.LangKey("config.hmca:entity.nethermite.whitelist")
-            @Config.Comment("Blocks the Nethermite should spawn from")
-            public String[] whitelist = new String[]{
-                    "minecraft:quartz_ore",
-                    "hmca:ore_quartz",
-                    "hmca:ore_amethyst",
-                    "hmca:ore_rime",
-                    "tconstruct:ore",
-                    "nethermetals:nether_coal_ore",
-                    "nethermetals:nether_redstone_ore",
-                    "nethermetals:nether_diamond_ore",
-                    "nethermetals:nether_emerald_ore",
-                    "nethermetals:nether_gold_ore",
-                    "nethermetals:nether_iron_ore",
-                    "nethermetals:nether_lapis_ore",
-                    "nethermetals:nether_antimony_ore",
-                    "nethermetals:nether_bismuth_ore",
-                    "nethermetals:nether_copper_ore",
-                    "nethermetals:nether_lead_ore",
-                    "nethermetals:nether_mercury_ore",
-                    "nethermetals:nether_nickel_ore",
-                    "nethermetals:nether_platnium_ore",
-                    "nethermetals:nether_silver_ore",
-                    "nethermetals:nether_tin_ore",
-                    "nethermetals:nether_zinc_ore",
-                    "nethermetals:nether_aluminum_ore",
-                    "nethermetals:nether_cadmium_ore",
-                    "nethermetals:nether_chromium_ore",
-                    "nethermetals:nether_iridium_ore",
-                    "nethermetals:nether_magnesium_ore",
-                    "nethermetals:nether_magnanese_ore",
-                    "nethermetals:nether_osmium_ore",
-                    "nethermetals:nether_plutonium_ore",
-                    "nethermetals:nether_rutile_ore",
-                    "nethermetals:nether_tantalum_ore",
-                    "nethermetals:nether_titanium_ore",
-                    "nethermetals:nether_tungsten_ore",
-                    "nethermetals:nether_uramium_ore",
-                    "nethermetals:nether_zirconium_ore"
-            };
-        }
-
-        public class Spinout
-        {
-            @Config.LangKey("config.hmca:entity.spinout.spinTime")
-            @Config.Comment({"The lower the number, the less time a Spinout spins", "The higher the number, the more time a Spinout spins"})
-            @Config.RangeInt(min = 1, max = 512)
-            public int spinTime = 6;
-
-            @Config.LangKey("config.hmca:entity.spinout.spinCooldown")
-            @Config.Comment({"The lower the number, the less time a Spinout goes without spinning", "The higher the number, the more time a Spinout goes without spinning"})
-            @Config.RangeInt(min = 1, max = 512)
-            public int spinCooldown = 2;
-        }
-
-        public class SporeCreeper
-        {
-            @Config.LangKey("config.hmca:entity.sporeCreeper.chanceOfSporeSpawning")
-            @Config.Comment({"The higher the number, the rarer it is for s Spore Creeper to spawn a Spore on death", "The lower the number, the more common it is for a Spore Creeper to spawn a Spore on death"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int chanceOfSporeSpawning = 12;
-        }
-
-        public class Spore
-        {
-            @Config.LangKey("config.hmca:entity.spore.growthTime")
-            @Config.Comment({"The lower the number, the less it takes a Spore to grow", "The higher the number, the more time it takes for a Spore to grow"})
-            @Config.RangeInt(min = 1, max = 512)
-            public int growthTime = 60;
-
-            @Config.LangKey("config.hmca:entity.spore.creeperSpawns")
-            @Config.Comment({"The lower the number, the less Spore Creeper spawn from a Spore", "The higher the number, the more Spore Creeper spawn from a Spore"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int creeperSpawns = 3;
-        }
-
-        public class Brute
-        {
-            @Config.LangKey("config.hmca:entity.brute.chargeCooldown")
-            @Config.Comment({"The lower the number, the less cooldown the Brute has after charging", "The higher the number, the more cooldown the Brute has after charging"})
-            @Config.RangeInt(min = 1, max = 512)
-            public int chargeCooldown = 2;
-        }
-
-        public class GhastQueen
-        {
-            @Config.LangKey("config.hmca:entity.ghastQueen.ghastlingSpawnCooldown")
-            @Config.Comment({"The lower the number, the less cooldown the Ghast Queen has after spawning Ghastlings", "The higher the number, the more cooldown the Ghast Queen has after spawning Ghastlings"})
-            @Config.RangeInt(min = 1, max = 512)
-            public int ghastlingSpawnCooldown = 10;
-
-            @Config.LangKey("config.hmca:entity.ghastQueen.ghastlingSpawns")
-            @Config.Comment({"The lower the number, the less Ghastling spawn", "The higher the number, the more Ghastling spawn"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int ghastlingSpawns = 4;
-        }
-    }
-
-    public static class Biome
-    {
-        @Config.Name("hell")
-        @Config.LangKey("config.hmca:biome.hell")
-        public Hell hell = new Hell();
-
-        @Config.Name("ruthless_sands")
-        @Config.LangKey("config.hmca:biome.ruthlessSands")
-        public RuthlessSands ruthlessSands = new RuthlessSands();
-
-        @Config.Name("fungi_forest")
-        @Config.LangKey("config.hmca:biome.fungiForest")
-        public FungiForest fungiForest = new FungiForest();
-
-        @Config.Name("torrid_wasteland")
-        @Config.LangKey("config.hmca:biome.torridWasteland")
-        public TorridWasteland torridWasteland = new TorridWasteland();
-
-        @Config.Name("arctic_abyss")
-        @Config.LangKey("config.hmca:biome.arcticAbyss")
-        public ArcticAbyss arcticAbyss = new ArcticAbyss();
-
-        public class Hell
-        {
-        }
-
-        public class RuthlessSands
-        {
-            @Config.LangKey("config.hmca:biome.ruthlessSands.generateThornstalk")
-            public boolean generateThornstalk = true;
-
-            @Config.LangKey("config.hmca:biome.ruthlessSands.thornstalkRarity")
-            @Config.Comment({"The lower the number, the rarer Thornstalk is", "The higher the number, the more common Thornstalk is"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int thornstalkRarity = 10;
-        }
-
-        public class FungiForest
-        {
-            @Config.LangKey("config.hmca:biome.fungiForest.generateElderMushrooms")
-            public boolean generateElderMushrooms = true;
-
-            @Config.LangKey("config.hmca:biome.fungiForest.generateEnokiMushrooms")
-            public boolean generateEnokiMushrooms = true;
-
-            @Config.LangKey("config.hmca:biome.fungiForest.elderMushroomRarity")
-            @Config.Comment({"The lower the number, the rarer Elder Mushrooms are", "The higher the number, the more common Elder Mushrooms are"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int elderMushroomRarity = 32;
-
-            @Config.LangKey("config.hmca:biome.fungiForest.enokiMushroomRarity")
-            @Config.Comment({"The lower the number, the rarer Enoki Mushrooms are", "The higher the number, the more common Enoki Mushrooms are"})
-            @Config.RangeInt(min = 1, max = 256)
-            public int enokiMushroomRarity = 4;
-        }
-
-        public class TorridWasteland
-        {
-        }
-
-        public class ArcticAbyss
-        {
-            @Config.LangKey("config.hmca:biome.arcticAbyss.chanceOfFreezing")
-            @Config.Comment({"The higher the number, the rarer it is for mobs to Freeze in the Arctic Abyss biome", "The lower the number, the more common it is for mobs to Freeze in the Arctic Abyss biome"})
-            @Config.RangeInt(min = 1, max = 2048)
-            public int chanceOfFreezing = 512;
-
-        }
-    }
-
-    @Mod.EventBusSubscriber(modid = MOD_ID)
-    public static class ConfigSyncHandler
-    {
-        @SubscribeEvent
-        public static void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent event)
-        {
-            if(event.getModID().equals(MOD_ID))
-            {
-                ConfigManager.sync(MOD_ID, Config.Type.INSTANCE);
-                LOGGER.info("Configuration has been saved.");
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EntityEventHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EntityEventHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EntityEventHandler.java	(date 1525605768000)
@@ -1,40 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.monster.EntitySpider;
-import net.minecraft.entity.passive.EntityVillager;
-import net.minecraft.init.Biomes;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraftforge.event.entity.living.LivingDeathEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummyVillager;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummy;
-
-@Mod.EventBusSubscriber(modid = Reference.MOD_ID)
-public class EntityEventHandler {
-
-    @SubscribeEvent
-    public static void onLivingDeath(LivingDeathEvent event) {
-        if (event.getEntity() instanceof EntityVillager) {
-            EntityMob entityMob = (EntityMob) event.getEntity();
-            World world = entityMob.world;
-            BlockPos pos = entityMob.getPosition();
-            if (entityMob.getEntityWorld().getBiome(new BlockPos(pos)) == Biomes.DESERT && !world.isRemote) {
-                if (entityMob instanceof EntitySpider || entityMob instanceof EntityMummy)
-                    return;
-
-            EntityMummyVillager mummy = new EntityMummyVillager(world);
-            if (mummy.isAIDisabled())
-                mummy.setNoAI(false);
-            mummy.setPositionAndRotation(pos.getX() + 1D, pos.getY() + 0.5D, pos.getZ() + 1D, mummy.rotationYaw, mummy.cameraPitch);
-            mummy.onInitialSpawn(world.getDifficultyForLocation(new BlockPos(mummy)), null);
-//            mummy.setLootTable(LootTableHandler.MUMMY);
-            world.spawnEntity(mummy);
-            }
-        }
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/BiomeInit.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/BiomeInit.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/BiomeInit.java	(date 1525605768000)
@@ -1,40 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.world.biome.Biome;
-import net.minecraftforge.common.BiomeDictionary;
-import net.minecraftforge.common.BiomeManager;
-import net.minecraftforge.fml.common.registry.ForgeRegistries;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeBasaltOverworld;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeBlackDesert;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeRedDesert;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeSuperDeepOcean;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BiomeInit {
-
-    public static final Biome BASALT = new BiomeBasaltOverworld();
-    public static final Biome RED_DESERT = new BiomeRedDesert();
-    public static final Biome BLACK_DESERT = new BiomeBlackDesert();
-    public static final Biome SUPER_DEEP_OCEAN = new BiomeSuperDeepOcean();
-
-    public static void registerBiomes()
-    {
-        initBiome(BASALT, "basalt", 3, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.SPOOKY, BiomeDictionary.Type.MAGICAL, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DEAD);
-        initBiome(RED_DESERT, "red_desert", 20, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DRY, BiomeDictionary.Type.SANDY);
-        initBiome(BLACK_DESERT, "black_desert", 10, BiomeManager.BiomeType.WARM, BiomeDictionary.Type.HOT, BiomeDictionary.Type.DRY, BiomeDictionary.Type.SANDY);
-        initBiome(SUPER_DEEP_OCEAN, "super_deep_ocean", 20, BiomeManager.BiomeType.COOL, BiomeDictionary.Type.WATER, BiomeDictionary.Type.OCEAN, BiomeDictionary.Type.WET);
-    }
-
-    private static Biome initBiome(Biome biome, String name, int weight, BiomeManager.BiomeType biomeType, BiomeDictionary.Type... types) {
-        biome.setRegistryName(MOD_ID, name);
-        ForgeRegistries.BIOMES.register(biome);
-        System.out.println(String.format("Biome: %s is now registered", name));
-        BiomeDictionary.addTypes(biome, types);
-        BiomeManager.addBiome(biomeType, new BiomeManager.BiomeEntry(biome, weight));
-        BiomeManager.addSpawnBiome(biome);
-        System.out.println(String.format("Biome: %s is now added to the spawn biome's", name));
-        return biome;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeBasaltNether.java	(date 1525605768000)
@@ -1,15 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.block.Block;
-
-import java.util.Objects;
-
-@SuppressWarnings("ConstantConditions")
-public class BiomeBasaltNether extends BiomeNether {
-    public BiomeBasaltNether() {
-        super(new BiomeProperties("Basalt Nether").setTemperature(2.0F).setRainfall(0.0F).setRainDisabled(), "basalt_nether");
-
-        topBlock = Objects.requireNonNull(Block.getBlockFromName("hmca:raw_basalt")).getDefaultState();
-        fillerBlock = Objects.requireNonNull(Block.getBlockFromName("hmca:raw_basalt")).getDefaultState();
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderHoveringInferno.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderHoveringInferno.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderHoveringInferno.java	(date 1525605768000)
@@ -1,29 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityHoveringInferno;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelHoveringInferno;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderHoveringInferno extends RenderLiving<EntityHoveringInferno> {
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/nether/hovering_inferno/hovering_inferno.png");
-
-    public RenderHoveringInferno(RenderManager manager)
-    {
-        super(manager, new ModelHoveringInferno(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityHoveringInferno entity)
-    {
-        return SCORP_TEXTURE;
-    }
-
-    @Override
-    protected void applyRotations(EntityHoveringInferno entityLiving, float p_77043_2_, float rotationYaw, float partialTicks)
-    {
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/ChunkGeneratorNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/ChunkGeneratorNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/ChunkGeneratorNether.java	(date 1525605768000)
@@ -1,509 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen;
-
-import net.minecraft.block.BlockFalling;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.EnumCreatureType;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.chunk.Chunk;
-import net.minecraft.world.chunk.ChunkPrimer;
-import net.minecraft.world.gen.ChunkGeneratorHell;
-import net.minecraft.world.gen.MapGenCavesHell;
-import net.minecraft.world.gen.NoiseGeneratorOctaves;
-import net.minecraft.world.gen.structure.MapGenNetherBridge;
-import net.minecraftforge.common.ForgeModContainer;
-import net.minecraftforge.common.MinecraftForge;
-import net.minecraftforge.event.ForgeEventFactory;
-import net.minecraftforge.event.terraingen.*;
-import net.minecraftforge.fml.common.eventhandler.Event;
-import net.thegaminghuskymc.mcaddon.util.RandomUtil;
-import net.thegaminghuskymc.mcaddon.util.handlers.ConfigHandler;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiomeManager;
-import net.thegaminghuskymc.mcaddon.world.gen.feature.Feature;
-
-import java.util.List;
-import java.util.Random;
-
-@SuppressWarnings("ConstantConditions")
-public class ChunkGeneratorNether extends ChunkGeneratorHell
-{
-    private final World world;
-    private final Random rand;
-
-    private NoiseGeneratorOctaves noiseGen1;
-    private NoiseGeneratorOctaves noiseGen2;
-    private NoiseGeneratorOctaves noiseGen3;
-    private NoiseGeneratorOctaves noiseGenSoulSandGravel;
-    private NoiseGeneratorOctaves noiseGenNetherrack;
-    private NoiseGeneratorOctaves noiseGenScale;
-    private NoiseGeneratorOctaves noiseGenDepth;
-
-    private Biome[] biomesForGen;
-
-    private double[] buffer;
-    private double[] depthBuffer = new double[256];
-    private double[] soulSandNoise = new double[256];
-    private double[] gravelNoise = new double[256];
-    private double[] noiseData1;
-    private double[] noiseData2;
-    private double[] noiseData3;
-    private double[] noiseData4;
-    private double[] noiseData5;
-
-    private MapGenCavesHell netherCaves = new MapGenCavesHell();
-    private MapGenNetherBridge netherBridge = new MapGenNetherBridge();
-
-    public ChunkGeneratorNether(World worldIn)
-    {
-        super(worldIn, true, worldIn.getSeed());
-        world = worldIn;
-        rand = new Random(world.getSeed());
-        noiseGen1 = new NoiseGeneratorOctaves(rand, 16);
-        noiseGen2 = new NoiseGeneratorOctaves(rand, 16);
-        noiseGen3 = new NoiseGeneratorOctaves(rand, 8);
-        noiseGenSoulSandGravel = new NoiseGeneratorOctaves(rand, 4);
-        noiseGenNetherrack = new NoiseGeneratorOctaves(rand, 4);
-        noiseGenScale = new NoiseGeneratorOctaves(rand, 10);
-        noiseGenDepth = new NoiseGeneratorOctaves(rand, 16);
-
-        InitNoiseGensEvent.ContextHell ctx = new InitNoiseGensEvent.ContextHell(noiseGen1, noiseGen2, noiseGen3, noiseGenSoulSandGravel, noiseGenNetherrack, noiseGenScale, noiseGenDepth);
-        ctx = TerrainGen.getModdedNoiseGenerators(world, rand, ctx);
-
-        noiseGen1 = ctx.getLPerlin1();
-        noiseGen2 = ctx.getLPerlin2();
-        noiseGen3 = ctx.getPerlin();
-        noiseGenSoulSandGravel = ctx.getPerlin2();
-        noiseGenNetherrack = ctx.getPerlin3();
-        noiseGenScale = ctx.getScale();
-        noiseGenDepth = ctx.getDepth();
-
-        netherCaves = (MapGenCavesHell) TerrainGen.getModdedMapGen(netherCaves, InitMapGenEvent.EventType.NETHER_CAVE);
-        netherBridge = (MapGenNetherBridge) TerrainGen.getModdedMapGen(netherBridge, InitMapGenEvent.EventType.NETHER_BRIDGE);
-
-        worldIn.setSeaLevel(31);
-    }
-
-    @Override
-    public void prepareHeights(int chunkX, int chunkZ, ChunkPrimer primer)
-    {
-        buffer = generateHeightMap(buffer, chunkX * 4, 0, chunkZ * 4, 5, 17, 5);
-
-        for(int x = 0; x < 4; x++)
-        {
-            for(int z = 0; z < 4; z++)
-            {
-                for(int y = 0; y < 16; y++)
-                {
-                    double d1 = buffer[(x * 5 + z) * 17 + y];
-                    double d2 = buffer[(((x * 5) + z + 1) * 17) + y];
-                    double d3 = buffer[((((x + 1) * 5) + z) * 17) + y];
-                    double d4 = buffer[((x + 1) * 5 + z + 1) * 17 + y];
-                    double d5 = (buffer[(x * 5 + z) * 17 + y + 1] - d1) * 0.125D;
-                    double d6 = (buffer[(x * 5 + z + 1) * 17 + y + 1] - d2) * 0.125D;
-                    double d7 = (buffer[((x + 1) * 5 + z) * 17 + y + 1] - d3) * 0.125D;
-                    double d8 = (buffer[((x + 1) * 5 + z + 1) * 17 + y + 1] - d4) * 0.125D;
-
-                    for(int y2 = 0; y2 < 8; y2++)
-                    {
-                        double d10 = d1;
-                        double d11 = d2;
-                        double d12 = (d3 - d1) * 0.25D;
-                        double d13 = (d4 - d2) * 0.25D;
-
-                        for(int x2 = 0; x2 < 4; x2++)
-                        {
-                            double d15 = d10;
-                            double d16 = (d11 - d10) * 0.25D;
-
-                            for(int z2 = 0; z2 < 4; z2++)
-                            {
-                                int posX = x2 + x * 4;
-                                int posY = y2 + y * 8;
-                                int posZ = z2 + z * 4;
-
-                                Biome biome = biomesForGen[posX + posZ * 16];
-
-                                IBlockState state = null;
-                                IBlockState biomeFillerBlock = NetherBiomeManager.getBiomeFillerBlock(biome);
-                                IBlockState biomeOceanBlock = NetherBiomeManager.getBiomeOceanBlock(biome);
-
-                                if(posY < 32)
-                                {
-                                    state = biomeOceanBlock;
-                                }
-
-                                if(d15 > 0.0D)
-                                {
-                                    state = biomeFillerBlock;
-                                }
-
-                                primer.setBlockState(posX, posY, posZ, state);
-                                d15 += d16;
-                            }
-
-                            d10 += d12;
-                            d11 += d13;
-                        }
-
-                        d1 += d5;
-                        d2 += d6;
-                        d3 += d7;
-                        d4 += d8;
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public void buildSurfaces(int chunkX, int chunkZ, ChunkPrimer primer)
-    {
-        if(!ForgeEventFactory.onReplaceBiomeBlocks(this, chunkX, chunkZ, primer, world))
-        {
-            return;
-        }
-
-        soulSandNoise = noiseGenSoulSandGravel.generateNoiseOctaves(soulSandNoise, chunkX * 16, chunkZ * 16, 0, 16, 16, 1, 0.03125D, 0.03125D, 1.0D);
-        gravelNoise = noiseGenSoulSandGravel.generateNoiseOctaves(gravelNoise, chunkX * 16, 109, chunkZ * 16, 16, 1, 16, 0.03125D, 1.0D, 0.03125D);
-        depthBuffer = noiseGenNetherrack.generateNoiseOctaves(depthBuffer, chunkX * 16, chunkZ * 16, 0, 16, 16, 1, 0.0625D, 0.0625D, 0.0625D);
-
-        for(int x = 0; x < 16; x++)
-        {
-            for(int z = 0; z < 16; z++)
-            {
-                int l = (int) (depthBuffer[x + z * 16] / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
-                int i1 = -1;
-                boolean genSoulSand = soulSandNoise[x + z * 16] + rand.nextDouble() * 0.2D > 0.0D;
-                boolean genGravel = gravelNoise[x + z * 16] + rand.nextDouble() * 0.2D > 0.0D;
-                Biome biome = biomesForGen[x + z * 16];
-
-                final IBlockState biomeTopBlock = NetherBiomeManager.getBiomeTopBlock(biome);
-                final IBlockState biomeFillerBlock = NetherBiomeManager.getBiomeFillerBlock(biome);
-                final IBlockState biomeOceanBlock = NetherBiomeManager.getBiomeOceanBlock(biome);
-
-                IBlockState topBlock = biomeTopBlock;
-                IBlockState fillerBlock = biomeFillerBlock;
-
-                for(int y = 127; y >= 0; y--)
-                {
-                    if(y < 127 && y > 0)
-                    {
-                        IBlockState checkBlock = primer.getBlockState(x, y, z);
-
-                        if(checkBlock.getMaterial() != Material.AIR)
-                        {
-                            if(checkBlock == biomeFillerBlock)
-                            {
-                                if(i1 == -1)
-                                {
-                                    if(l <= 0)
-                                    {
-                                        topBlock = Blocks.AIR.getDefaultState();
-                                        fillerBlock = biomeTopBlock;
-                                    }
-                                    else if(y >= 62 && y <= 66)
-                                    {
-                                        topBlock = biomeTopBlock;
-                                        fillerBlock = biomeFillerBlock;
-
-                                        if(ConfigHandler.dimension.nether.generateGravel && genGravel)
-                                        {
-                                            topBlock = Blocks.GRAVEL.getDefaultState();
-                                        }
-
-                                        if(ConfigHandler.dimension.nether.generateSoulSand && genSoulSand)
-                                        {
-                                            topBlock = Blocks.SOUL_SAND.getDefaultState();
-                                            fillerBlock = Blocks.SOUL_SAND.getDefaultState();
-                                        }
-                                    }
-
-                                    if(y <= 32 && (topBlock == null || topBlock.getMaterial() == Material.AIR))
-                                    {
-                                        topBlock = biomeOceanBlock;
-                                    }
-
-                                    i1 = l;
-
-                                    if(topBlock == biomeTopBlock && fillerBlock == biomeFillerBlock)
-                                    {
-                                        primer.setBlockState(x, y, z, topBlock);
-                                    }
-                                    else
-                                    {
-                                        if(y > 64)
-                                        {
-                                            primer.setBlockState(x, y, z, topBlock);
-                                        }
-                                        else
-                                        {
-                                            primer.setBlockState(x, y, z, fillerBlock);
-                                        }
-                                    }
-                                }
-                                else if(i1 > 0)
-                                {
-                                    i1--;
-                                    primer.setBlockState(x, y, z, fillerBlock);
-                                }
-                            }
-                        }
-                        else
-                        {
-                            i1 = -1;
-                        }
-                    }
-                    else
-                    {
-                        primer.setBlockState(x, y, z, Blocks.BEDROCK.getDefaultState());
-                    }
-                }
-            }
-        }
-    }
-
-    private double[] generateHeightMap(double[] heightMap, int posX, int posY, int posZ, int xSize, int ySize, int zSize)
-    {
-        if(heightMap == null)
-        {
-            heightMap = new double[xSize * ySize * zSize];
-        }
-
-        ChunkGeneratorEvent.InitNoiseField event = new ChunkGeneratorEvent.InitNoiseField(this, heightMap, posX, posY, posZ, xSize, ySize, zSize);
-        MinecraftForge.EVENT_BUS.post(event);
-
-        if(event.getResult() == Event.Result.DENY)
-        {
-            return event.getNoisefield();
-        }
-
-        noiseData4 = noiseGenScale.generateNoiseOctaves(noiseData4, posX, posY, posZ, xSize, 1, zSize, 1.0D, 0.0D, 1.0D);
-        noiseData5 = noiseGenDepth.generateNoiseOctaves(noiseData5, posX, posY, posZ, xSize, 1, zSize, 100.0D, 0.0D, 100.0D);
-        noiseData1 = noiseGen3.generateNoiseOctaves(noiseData1, posX, posY, posZ, xSize, ySize, zSize, 8.555150000000001D, 34.2206D, 8.555150000000001D);
-        noiseData2 = noiseGen1.generateNoiseOctaves(noiseData2, posX, posY, posZ, xSize, ySize, zSize, 684.412D, 2053.236D, 684.412D);
-        noiseData3 = noiseGen2.generateNoiseOctaves(noiseData3, posX, posY, posZ, xSize, ySize, zSize, 684.412D, 2053.236D, 684.412D);
-
-        double[] newYSize = new double[ySize];
-
-        for(int j = 0; j < ySize; ++j)
-        {
-            newYSize[j] = Math.cos((double) j * Math.PI * 6.0D / (double) ySize) * 2.0D;
-            double d2 = (double) j;
-
-            if(j > ySize / 2)
-            {
-                d2 = (double) (ySize - 1 - j);
-            }
-
-            if(d2 < 4.0D)
-            {
-                d2 = 4.0D - d2;
-                newYSize[j] -= d2 * d2 * d2 * 10.0D;
-            }
-        }
-
-        int index = 0;
-
-        for(int l = 0; l < xSize; ++l)
-        {
-            for(int i1 = 0; i1 < zSize; ++i1)
-            {
-                for(int k = 0; k < ySize; ++k)
-                {
-                    double d4 = newYSize[k];
-                    double d5 = noiseData2[index] / 512.0D;
-                    double d6 = noiseData3[index] / 512.0D;
-                    double d7 = (noiseData1[index] / 10.0D + 1.0D) / 2.0D;
-                    double d8;
-
-                    if(d7 < 0.0D)
-                    {
-                        d8 = d5;
-                    }
-                    else if(d7 > 1.0D)
-                    {
-                        d8 = d6;
-                    }
-                    else
-                    {
-                        d8 = d5 + (d6 - d5) * d7;
-                    }
-
-                    d8 = d8 - d4;
-
-                    if(k > ySize - 4)
-                    {
-                        double d9 = (double) ((float) (k - (ySize - 4)) / 3.0F);
-                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
-                    }
-
-                    if((double) k < 0.0D)
-                    {
-                        double d10 = (0.0D - (double) k) / 4.0D;
-                        d10 = MathHelper.clamp(d10, 0.0D, 1.0D);
-                        d8 = d8 * (1.0D - d10) + -10.0D * d10;
-                    }
-
-                    heightMap[index] = d8;
-                    index++;
-                }
-            }
-        }
-
-        return heightMap;
-    }
-
-    @Override
-    public Chunk generateChunk(int chunkX, int chunkZ)
-    {
-        ChunkPrimer primer = new ChunkPrimer();
-        rand.setSeed((long) chunkX * 341873128712L + (long) chunkZ * 132897987541L);
-        biomesForGen = world.getBiomeProvider().getBiomes(null, chunkX * 16, chunkZ * 16, 16, 16);
-        prepareHeights(chunkX, chunkZ, primer);
-        buildSurfaces(chunkX, chunkZ, primer);
-        netherCaves.generate(world, chunkX, chunkZ, primer);
-        netherBridge.generate(world, chunkX, chunkZ, primer);
-
-        Chunk chunk = new Chunk(world, primer, chunkX, chunkZ);
-        byte[] biomeArray = chunk.getBiomeArray();
-
-        for(int i = 0; i < biomeArray.length; ++i)
-        {
-            biomeArray[i] = (byte) Biome.getIdForBiome(biomesForGen[i]);
-        }
-
-        chunk.resetRelightChecks();
-        return chunk;
-    }
-
-    @Override
-    public void populate(int chunkX, int chunkZ)
-    {
-        boolean logCascadingWorldGeneration = ForgeModContainer.logCascadingWorldGeneration;
-        ForgeModContainer.logCascadingWorldGeneration = false;
-
-        ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
-        BlockPos blockPos = new BlockPos(chunkX * 16, 0, chunkZ * 16);
-        Biome biome = world.getBiome(blockPos.add(16, 0, 16));
-
-        BlockFalling.fallInstantly = true;
-
-        netherBridge.generateStructure(world, rand, chunkPos);
-
-        List<Feature> features = NetherBiomeManager.getBiomeFeatures(biome);
-
-        if(features.size() > 0)
-        {
-            for(Feature feature : features)
-            {
-                if(feature.getBiome() != biome)
-                {
-                    continue;
-                }
-                if(!feature.canGenerate())
-                {
-                    continue;
-                }
-
-                int featureRarity = feature.useRandomRarity() ? rand.nextInt(feature.getRarity()) + 1 : feature.getRarity();
-
-                if(feature.getType() == Feature.FeatureType.ORE)
-                {
-                    MinecraftForge.ORE_GEN_BUS.post(new OreGenEvent.Pre(world, rand, blockPos));
-
-                    if(!feature.isSuperRare())
-                    {
-                        for(int i = 0; i < featureRarity; i++)
-                        {
-                            feature.generate(world, blockPos.add(rand.nextInt(16), RandomUtil.getNumberInRange(feature.getMinHeight(), feature.getMaxHeight(), rand), rand.nextInt(16)), rand);
-                        }
-                    }
-                    else
-                    {
-                        if(rand.nextInt(featureRarity) == 0)
-                        {
-                            feature.generate(world, blockPos.add(rand.nextInt(16), RandomUtil.getNumberInRange(feature.getMinHeight(), feature.getMaxHeight(), rand), rand.nextInt(16)), rand);
-                        }
-                    }
-
-                    MinecraftForge.ORE_GEN_BUS.post(new OreGenEvent.Post(world, rand, blockPos));
-                }
-                else
-                {
-                    MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Pre(world, rand, blockPos));
-
-                    if(!feature.isSuperRare())
-                    {
-                        for(int i = 0; i < featureRarity; i++)
-                        {
-                            feature.generate(world, blockPos.add(rand.nextInt(16) + 8, RandomUtil.getNumberInRange(feature.getMinHeight(), feature.getMaxHeight(), rand), rand.nextInt(16) + 8), rand);
-                        }
-                    }
-                    else
-                    {
-                        if(rand.nextInt(featureRarity) == 0)
-                        {
-                            feature.generate(world, blockPos.add(rand.nextInt(16) + 8, RandomUtil.getNumberInRange(feature.getMinHeight(), feature.getMaxHeight(), rand), rand.nextInt(16) + 8), rand);
-                        }
-                    }
-
-                    MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Post(world, rand, blockPos));
-                }
-            }
-        }
-
-        biome.decorate(world, rand, blockPos);
-
-        BlockFalling.fallInstantly = false;
-
-        ForgeModContainer.logCascadingWorldGeneration = logCascadingWorldGeneration;
-    }
-
-    @Override
-    public boolean generateStructures(Chunk chunk, int chunkX, int chunkZ)
-    {
-        return false;
-    }
-
-    @Override
-    public List<Biome.SpawnListEntry> getPossibleCreatures(EnumCreatureType creatureType, BlockPos pos)
-    {
-        if(creatureType == EnumCreatureType.MONSTER)
-        {
-            if(netherBridge.isInsideStructure(pos))
-            {
-                return netherBridge.getSpawnList();
-            }
-
-            if(netherBridge.isPositionInStructure(world, pos) && world.getBlockState(pos.down()).getBlock() == Blocks.NETHER_BRICK)
-            {
-                return netherBridge.getSpawnList();
-            }
-        }
-
-        Biome biome = world.getBiome(pos);
-        return NetherBiomeManager.getBiomeEntitySpawnList(biome).get(creatureType);
-    }
-
-    @Override
-    public BlockPos getNearestStructurePos(World world, String structureName, BlockPos pos, boolean force)
-    {
-        if("Fortress".equals(structureName))
-        {
-            return netherBridge != null ? netherBridge.getNearestStructurePos(world, pos, force) : null;
-        }
-
-        return null;
-    }
-
-    @Override
-    public void recreateStructures(Chunk chunk, int chunkX, int chunkZ)
-    {
-        netherBridge.generate(world, chunkX, chunkZ, null);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/NoiseGenUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/NoiseGenUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/NoiseGenUtil.java	(date 1525605768000)
@@ -1,113 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   NoiseGenUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.util.math.MathHelper;
-
-import java.util.Random;
-
-public class NoiseGenUtil
-{
-
-    public NoiseGenUtil()
-    {
-    }
-
-    public static float getNoise(long seed, int x, int y)
-    {
-        random.setSeed(simple_hash(new int[] {
-            (int)seed, (int)(seed << 32), (int)Math.signum(y) * 512 + 512, (int)Math.signum(x) * 512 + 512, x, y
-        }, 5));
-        return random.nextFloat();
-    }
-
-    public static Random getRandom(int args[])
-    {
-        return new Random(simple_hash(args, args.length));
-    }
-
-    public static long getSeed(int seed, int x, int y)
-    {
-        return (long)simple_hash(new int[] {
-            seed, (int)Math.signum(y) * 512 + 512, (int)Math.signum(x) * 512 + 512, x, y
-        }, 5);
-    }
-
-    public static int simple_hash(int is[], int count)
-    {
-        int hash = 0x4c856cf;
-        for(int i = 0; i < count; i++)
-            hash = hash << 4 ^ hash >> 28 ^ (is[i] * 5449) % 0x1fe5b;
-
-        return hash % 0x47d67ab;
-    }
-
-    public static float get2DNoise(long seed, int x, int z)
-    {
-        return (float)Math.pow((80F * getOctave(seed, x, z, 112) + 20F * getOctave(seed, x, z, 68) + 6F * getOctave(seed, x, z, 34) + 4F * getOctave(seed, x, z, 21) + 2.0F * getOctave(seed, x, z, 11) + 1.0F * getOctave(seed, x, z, 4)) / 93F, 1.6000000238418579D);
-    }
-
-    public static float fastSin(float x)
-    {
-        if((double)x < -3.1415926500000002D)
-            x = (float)((double)x + 6.2831853100000004D);
-        else
-        if((double)x > 3.1415926500000002D)
-            x = (float)((double)x - 6.2831853100000004D);
-        if(x < 0.0F)
-            return (float)(1.2732395400000001D * (double)x + 0.40528473500000001D * (double)x * (double)x);
-        else
-            return (float)(1.2732395400000001D * (double)x - 0.40528473500000001D * (double)x * (double)x);
-    }
-
-    public static float fastCos(float x)
-    {
-        if((double)x < -3.1415926500000002D)
-            x = (float)((double)x + 6.2831853100000004D);
-        else
-        if((double)x > 3.1415926500000002D)
-            x = (float)((double)x - 6.2831853100000004D);
-        x = (float)((double)x + 1.5707963199999999D);
-        if((double)x > 3.1415926500000002D)
-            x = (float)((double)x - 6.2831853100000004D);
-        if(x < 0.0F)
-            return (float)(1.2732395400000001D * (double)x + 0.40528473500000001D * (double)x * (double)x);
-        else
-            return (float)(1.2732395400000001D * (double)x - 0.40528473500000001D * (double)x * (double)x);
-    }
-
-    public static float interpolate(float s, float e, float t)
-    {
-        float t2 = (1.0F - fastCos(t * 3.141593F)) / 2.0F;
-        return s * (1.0F - t2) + e * t2;
-    }
-
-    public static float interpolate(float s, float e, float t, float phase, float mult)
-    {
-        float t2 = 1.0F - MathHelper.cos(mult * (t * 3.141593F + phase)) / 2.0F;
-        float coeff = (0.5F - Math.abs(0.5F - t)) / 0.5F;
-        float t3 = t * (1.0F - coeff) + t2 * coeff;
-        return s * (1.0F - t3) + e * t3;
-    }
-
-    public static float lerp(float s, float e, float t)
-    {
-        return s * (1.0F - t) + e * t;
-    }
-
-    public static float bilinear(float ul, float ur, float dr, float dl, float t1, float t2)
-    {
-        return interpolate(interpolate(ul, ur, t1), interpolate(dl, dr, t1), t2);
-    }
-
-    public static float getOctave(long seed, int x, int y, int dimen)
-    {
-        return bilinear(getNoise(seed, (int)Math.floor((float)x / (float)dimen) * dimen, (int)Math.floor((float)y / (float)dimen) * dimen), getNoise(seed, (int)Math.floor((float)x / (float)dimen) * dimen + dimen, (int)Math.floor((float)y / (float)dimen) * dimen), getNoise(seed, (int)Math.floor((float)x / (float)dimen) * dimen + dimen, (int)Math.floor((float)y / (float)dimen) * dimen + dimen), getNoise(seed, (int)Math.floor((float)x / (float)dimen) * dimen, (int)Math.floor((float)y / (float)dimen) * dimen + dimen), Math.abs((float)((double)x - Math.floor((float)x / (float)dimen) * (double)dimen) / (float)dimen), Math.abs((float)((double)y - Math.floor((float)y / (float)dimen) * (double)dimen) / (float)dimen));
-    }
-
-    static Random random = new Random();
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelPlayer.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelPlayer.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/models/ModelPlayer.java	(date 1525605768000)
@@ -1,72 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.models;
-
-import net.minecraft.client.model.ModelBiped;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-/**
- * ModelPlayer - Either Mojang or a mod author
- * Created using Tabula 7.0.0
- */
-public class ModelPlayer extends ModelBiped {
-
-    public ModelRenderer bipedRightArm;
-    public ModelRenderer bipedLeftArm;
-    public ModelRenderer bipedBody;
-    public ModelRenderer bipedHead;
-    public ModelRenderer bipedRightLeg;
-    public ModelRenderer bipedLeftLeg;
-    public ModelRenderer shape15;
-    public ModelRenderer shape15_1;
-
-    public ModelPlayer() {
-        this.textureWidth = 64;
-        this.textureHeight = 64;
-        this.bipedRightLeg = new ModelRenderer(this, 0, 16);
-        this.bipedRightLeg.setRotationPoint(-1.9F, 12.0F, 0.0F);
-        this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, 0.0F);
-        this.bipedLeftLeg = new ModelRenderer(this, 16, 48);
-        this.bipedLeftLeg.setRotationPoint(1.9F, 12.0F, 0.0F);
-        this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, 0.0F);
-        this.shape15 = new ModelRenderer(this, 25, 0);
-        this.shape15.setRotationPoint(3.5F, -0.5F, 1.5F);
-        this.shape15.addBox(0.0F, 0.0F, -4.0F, 5, 5, 5, 0.0F);
-        this.bipedHead = new ModelRenderer(this, 0, 2);
-        this.bipedHead.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.bipedHead.addBox(-4.0F, -8.0F, -4.0F, 8, 8, 8, 0.0F);
-        this.shape15_1 = new ModelRenderer(this, 25, 0);
-        this.shape15_1.setRotationPoint(-8.5F, -0.5F, -2.5F);
-        this.shape15_1.addBox(0.0F, 0.0F, 0.0F, 5, 5, 5, 0.0F);
-        this.bipedLeftArm = new ModelRenderer(this, 32, 48);
-        this.bipedLeftArm.setRotationPoint(5.0F, 2.0F, 0.0F);
-        this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, 0.0F);
-        this.bipedRightArm = new ModelRenderer(this, 40, 16);
-        this.bipedRightArm.setRotationPoint(-5.0F, 2.0F, 0.0F);
-        this.bipedRightArm.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, 0.0F);
-        this.bipedBody = new ModelRenderer(this, 16, 16);
-        this.bipedBody.setRotationPoint(0.0F, 0.0F, 0.0F);
-        this.bipedBody.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, 0.0F);
-    }
-
-    @Override
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) { 
-        this.bipedRightLeg.render(f5);
-        this.bipedLeftLeg.render(f5);
-        this.shape15.render(f5);
-        this.bipedHead.render(f5);
-        this.shape15_1.render(f5);
-        this.bipedLeftArm.render(f5);
-        this.bipedRightArm.render(f5);
-        this.bipedBody.render(f5);
-    }
-
-    /**
-     * This is a helper function from Tabula to set the rotation of model parts
-     */
-    public void setRotateAngle(ModelRenderer modelRenderer, float x, float y, float z) {
-        modelRenderer.rotateAngleX = x;
-        modelRenderer.rotateAngleY = y;
-        modelRenderer.rotateAngleZ = z;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/RayCastUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/RayCastUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/RayCastUtil.java	(date 1525605768000)
@@ -1,140 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   RayCastUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.math.*;
-import net.minecraft.world.World;
-
-public class RayCastUtil
-{
-
-    public RayCastUtil()
-    {
-    }
-
-    public static RayTraceResult rayTraceBlocks(World world, Vec3d vec31, Vec3d vec32, boolean stopOnLiquid, boolean ignoreBlockWithoutBoundingBox, boolean returnLastUncollidableBlock, boolean allowNonfullCube)
-    {
-        if(!Double.isNaN(vec31.x) && !Double.isNaN(vec31.y) && !Double.isNaN(vec31.z))
-        {
-            if(!Double.isNaN(vec32.x) && !Double.isNaN(vec32.y) && !Double.isNaN(vec32.z))
-            {
-                int i = MathHelper.floor(vec32.x);
-                int j = MathHelper.floor(vec32.y);
-                int k = MathHelper.floor(vec32.z);
-                int l = MathHelper.floor(vec31.x);
-                int i1 = MathHelper.floor(vec31.y);
-                int j1 = MathHelper.floor(vec31.z);
-                BlockPos blockpos = new BlockPos(l, i1, j1);
-                IBlockState iblockstate = world.getBlockState(blockpos);
-                Block block = iblockstate.getBlock();
-                if(iblockstate.getCollisionBoundingBox(world, blockpos) != Block.NULL_AABB && (iblockstate.isFullCube() || allowNonfullCube) && block.canCollideCheck(iblockstate, stopOnLiquid))
-                {
-                    RayTraceResult raytraceresult = iblockstate.collisionRayTrace(world, blockpos, vec31, vec32);
-                    if(raytraceresult != null)
-                        return raytraceresult;
-                }
-                RayTraceResult raytraceresult2 = null;
-                int k1 = 200;
-                do
-                {
-                    if(k1-- < 0)
-                        break;
-                    if(Double.isNaN(vec31.x) || Double.isNaN(vec31.y) || Double.isNaN(vec31.z))
-                        return null;
-                    if(l == i && i1 == j && j1 == k)
-                        return returnLastUncollidableBlock ? raytraceresult2 : null;
-                    boolean flag2 = true;
-                    boolean flag = true;
-                    boolean flag1 = true;
-                    double d0 = 999D;
-                    double d1 = 999D;
-                    double d2 = 999D;
-                    if(i > l)
-                        d0 = (double)l + 1.0D;
-                    else
-                    if(i < l)
-                        d0 = (double)l + 0.0D;
-                    else
-                        flag2 = false;
-                    if(j > i1)
-                        d1 = (double)i1 + 1.0D;
-                    else
-                    if(j < i1)
-                        d1 = (double)i1 + 0.0D;
-                    else
-                        flag = false;
-                    if(k > j1)
-                        d2 = (double)j1 + 1.0D;
-                    else
-                    if(k < j1)
-                        d2 = (double)j1 + 0.0D;
-                    else
-                        flag1 = false;
-                    double d3 = 999D;
-                    double d4 = 999D;
-                    double d5 = 999D;
-                    double d6 = vec32.x - vec31.x;
-                    double d7 = vec32.y - vec31.y;
-                    double d8 = vec32.z - vec31.z;
-                    if(flag2)
-                        d3 = (d0 - vec31.x) / d6;
-                    if(flag)
-                        d4 = (d1 - vec31.y) / d7;
-                    if(flag1)
-                        d5 = (d2 - vec31.z) / d8;
-                    if(d3 == -0D)
-                        d3 = -0.0001D;
-                    if(d4 == -0D)
-                        d4 = -0.0001D;
-                    if(d5 == -0D)
-                        d5 = -0.0001D;
-                    EnumFacing enumfacing;
-                    if(d3 < d4 && d3 < d5)
-                    {
-                        enumfacing = i <= l ? EnumFacing.EAST : EnumFacing.WEST;
-                        vec31 = new Vec3d(d0, vec31.y + d7 * d3, vec31.z + d8 * d3);
-                    } else
-                    if(d4 < d5)
-                    {
-                        enumfacing = j <= i1 ? EnumFacing.UP : EnumFacing.DOWN;
-                        vec31 = new Vec3d(vec31.x + d6 * d4, d1, vec31.z + d8 * d4);
-                    } else
-                    {
-                        enumfacing = k <= j1 ? EnumFacing.SOUTH : EnumFacing.NORTH;
-                        vec31 = new Vec3d(vec31.x + d6 * d5, vec31.y + d7 * d5, d2);
-                    }
-                    l = MathHelper.floor(vec31.x) - (enumfacing != EnumFacing.EAST ? 0 : 1);
-                    i1 = MathHelper.floor(vec31.y) - (enumfacing != EnumFacing.UP ? 0 : 1);
-                    j1 = MathHelper.floor(vec31.z) - (enumfacing != EnumFacing.SOUTH ? 0 : 1);
-                    blockpos = new BlockPos(l, i1, j1);
-                    IBlockState iblockstate1 = world.getBlockState(blockpos);
-                    Block block1 = iblockstate1.getBlock();
-                    if(iblockstate1.getMaterial() == Material.PORTAL || iblockstate1.getCollisionBoundingBox(world, blockpos) != Block.NULL_AABB)
-                        if(block1.canCollideCheck(iblockstate1, stopOnLiquid) && (iblockstate.isFullCube() || allowNonfullCube))
-                        {
-                            RayTraceResult raytraceresult1 = iblockstate1.collisionRayTrace(world, blockpos, vec31, vec32);
-                            if(raytraceresult1 != null)
-                                return raytraceresult1;
-                        } else
-                        {
-                            raytraceresult2 = new RayTraceResult(RayTraceResult.Type.MISS, vec31, enumfacing, blockpos);
-                        }
-                } while(true);
-                return returnLastUncollidableBlock ? raytraceresult2 : null;
-            } else
-            {
-                return null;
-            }
-        } else
-        {
-            return null;
-        }
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosLavaMob.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosLavaMob.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosLavaMob.java	(date 1525605768000)
@@ -1,43 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosLavaMob.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-// Referenced classes of package atmosmobs:
-//            EntityAtmosWaterMob
-
-public class EntityAtmosLavaMob extends EntityAtmosWaterMob {
-
-    public EntityAtmosLavaMob(World world) {
-        super(world);
-        chosenway = false;
-    }
-
-    public int aT()
-    {
-        return maxHealth;
-    }
-
-    public boolean H()
-    {
-        return false;
-    }
-
-    public boolean bc()
-    {
-        return true;
-    }
-
-    private int maxHealth;
-    public boolean diving;
-    public boolean rising;
-    private int divingCount;
-    public boolean isTamed;
-    private boolean chosenway;
-    private double chosenwayX;
-    private double chosenwayZ;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndStairBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndStairBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/end/BlockEndStairBase.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.end;
-
-import net.minecraft.block.state.IBlockState;
-import net.thegaminghuskymc.huskylib2.blocks.BlockModStairs;
-import net.thegaminghuskymc.mcaddon.Main;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockEndStairBase extends BlockModStairs {
-
-    public BlockEndStairBase(String name, IBlockState state) {
-        super(name, state);
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    @Override
-    public String getModNamespace() {
-        return MOD_ID;
-    }
-
-    @Override
-    public String getPrefix() {
-        return MOD_ID;
-    }
-    
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityWhale.java	(date 1525605768000)
@@ -1,17 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.world.World;
-
-public class EntityWhale extends EntityWaterMob {
-
-    public EntityWhale(World worldIn) {
-        super(worldIn);
-        setSize(0.5F, 0.5F);
-    }
-
-    protected void initEntityAI() {
-        super.initEntityAI();
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosColourfulFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosColourfulFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosColourfulFish.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.world.World;
-
-public class EntityAtmosColourfulFish extends EntityLiving {
-
-    private static final DataParameter<Integer> FISH_VARIANTS = EntityDataManager.createKey(EntityAtmosColourfulFish.class, DataSerializers.VARINT);
-
-    public EntityAtmosColourfulFish(World world) {
-        super(world);
-        setSize(0.5F, 0.5F);
-        setHealth(5);
-    }
-
-    @Override
-    protected void initEntityAI() {
-        super.initEntityAI();
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/type/WorldTypeBasalt.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/type/WorldTypeBasalt.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/type/WorldTypeBasalt.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.type;
-
-import net.minecraft.world.World;
-import net.minecraft.world.WorldType;
-import net.minecraft.world.biome.BiomeProvider;
-import net.minecraft.world.biome.BiomeProviderSingle;
-import net.thegaminghuskymc.mcaddon.init.BiomeInit;
-
-public class WorldTypeBasalt extends WorldType {
-
-	public WorldTypeBasalt()
-	{
-		super("basalt");
-	}
-
-	@Override
-	public BiomeProvider getBiomeProvider(World world)
-	{
-		if(world.provider.getDimension() == 1) {
-            return new BiomeProviderSingle(BiomeInit.BASALT);
-        } else {
-		    return null;
-        }
-	}
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIMummyAttack.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIMummyAttack.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/ai/EntityAIMummyAttack.java	(date 1525605768000)
@@ -1,39 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.ai;
-
-import net.minecraft.entity.ai.EntityAIAttackMelee;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummy;
-
-public class EntityAIMummyAttack extends EntityAIAttackMelee {
-
-    private final EntityMummy mummy;
-    private int raiseArmTicks;
-
-    public EntityAIMummyAttack(EntityMummy mummyIn, double speedIn, boolean longMemoryIn) {
-        super(mummyIn, speedIn, longMemoryIn);
-        this.mummy = mummyIn;
-    }
-
-    @Override
-    public void startExecuting() {
-        super.startExecuting();
-        this.raiseArmTicks = 0;
-    }
-
-    @Override
-    public void resetTask() {
-        super.resetTask();
-        this.mummy.setArmsRaised(false);
-    }
-
-    @Override
-    public void updateTask() {
-        super.updateTask();
-        ++this.raiseArmTicks;
-
-        if (this.raiseArmTicks >= 5 && this.attackTick < 10) {
-            this.mummy.setArmsRaised(true);
-        } else {
-            this.mummy.setArmsRaised(false);
-        }
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModWall.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModWall.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModWall.java	(date 1525605768000)
@@ -1,129 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.base;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockWall;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.client.renderer.ItemMeshDefinition;
-import net.minecraft.init.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.util.BlockRenderLayer;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.IBlockAccess;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.huskylib2.interf.IModBlock;
-import net.thegaminghuskymc.huskylib2.items.blocks.ItemModBlock;
-import net.thegaminghuskymc.huskylib2.utils.ProxyRegistry;
-
-import java.util.Random;
-
-public class BlockModWall extends BlockWall implements IModBlock {
-
-    private final String[] variants;
-    private String bareName, modid;
-
-    public BlockModWall(String modid, String name, String... variants)  {
-        super(Blocks.PLANKS);
-
-        if (variants.length == 0)
-            variants = new String[]{name};
-
-        bareName = name;
-        this.variants = variants;
-        this.modid = modid;
-
-        setUnlocalizedName(modid, name);
-
-        setHardness(1.5F);
-        setResistance(30F);
-        setHarvestLevel("pickaxe", 1);
-    }
-
-    @Override
-    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
-        return Item.getItemFromBlock(this);
-    }
-
-    @Override
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    public Block setUnlocalizedName(String modid, String name) {
-        super.setUnlocalizedName(name);
-        this.setRegistryName(modid, name);
-        ProxyRegistry.register(this);
-        ProxyRegistry.register(this.createItemBlock(new ResourceLocation(modid, name)));
-        return this;
-    }
-
-    protected ItemBlock createItemBlock(ResourceLocation res) {
-        return new ItemModBlock(this, res);
-    }
-
-    @Override
-    public boolean canPlaceTorchOnTop(IBlockState state, IBlockAccess world, BlockPos pos)
-    {
-        return true;
-    }
-
-    @Override
-    public String getPrefix() {
-        return this.modid;
-    }
-
-    @Override
-    public String getModNamespace() {
-        return this.modid;
-    }
-
-    @Override
-    public String getBareName() {
-        return bareName;
-    }
-
-    @Override
-    public String[] getVariants() {
-        return variants;
-    }
-
-    @Override
-    public boolean canRenderInLayer(IBlockState state, BlockRenderLayer layer) {
-        return layer == BlockRenderLayer.CUTOUT_MIPPED || layer == BlockRenderLayer.CUTOUT || layer == BlockRenderLayer.SOLID || layer == BlockRenderLayer.TRANSLUCENT;
-    }
-
-    @Override
-    public boolean isOpaqueCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    public boolean isFullCube(IBlockState state) {
-        return false;
-    }
-
-    @Override
-    @SideOnly(Side.CLIENT)
-    public ItemMeshDefinition getCustomMeshDefinition() {
-        return null;
-    }
-
-    @Override
-    public IProperty[] getIgnoredProperties() {
-        return new IProperty[0];
-    }
-
-    @Override
-    public IProperty getVariantProp() {
-        return null;
-    }
-
-    @Override
-    public Class getVariantEnum() {
-        return null;
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/RecipeUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/RecipeUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/RecipeUtil.java	(date 1525605768000)
@@ -1,275 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util;
-
-import com.google.common.collect.ImmutableMap;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import net.minecraft.block.Block;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.*;
-
-/**
- * Turns recipes into json form.
- * <p>
- * Written by the Botania Team here:
- * https://github.com/Vazkii/Botania/blob/209b52bb80a766b15eff3c48cd1cd581f4020e97/src/main/java/vazkii/botania/common/crafting/ModCraftingRecipes.java
- *
- * @author Choonster
- */
-public class RecipeUtil  {
-
-    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
-    private static File RECIPE_DIR = null;
-    private static final Set<String> USED_ORE_DICTIONARY_NAMES = new TreeSet<>();
-    private static final Set<String> USED_REGISTRY_NAMES = new TreeSet<>();
-
-    public static void setupDir(File file)
-    {
-        if(RECIPE_DIR == null)
-        {
-            RECIPE_DIR = file;
-        }
-        if(!RECIPE_DIR.exists())
-        {
-            RECIPE_DIR.mkdir();
-        }
-    }
-
-    private static void addShaped(ItemStack result, Object... components)
-    {
-        Map<String, Object> json = new LinkedHashMap<>();
-
-        int i = 0;
-
-        List<String> pattern = new ArrayList<>();
-
-        while(i < components.length && components[i] instanceof String)
-        {
-            pattern.add((String) components[i]);
-            i++;
-        }
-
-        boolean isOreDict = false;
-        Map<String, Map<String, Object>> key = new HashMap<>();
-        Character curKey = null;
-
-        for(; i < components.length; i++)
-        {
-            Object o = components[i];
-
-            if(o instanceof Character)
-            {
-                if(curKey != null)
-                {
-                    throw new IllegalArgumentException("Provided two char keys in a row");
-                }
-                curKey = (Character) o;
-            }
-            else
-            {
-                if(curKey == null)
-                {
-                    throw new IllegalArgumentException("Providing object without a char key");
-                }
-                if(o instanceof String)
-                {
-                    isOreDict = true;
-                }
-                key.put(Character.toString(curKey), serializeItem(o));
-                curKey = null;
-            }
-        }
-
-        json.put("type", isOreDict ? "forge:ore_shaped" : "minecraft:crafting_shaped");
-        json.put("pattern", pattern);
-        json.put("key", key);
-        json.put("result", serializeItem(result));
-
-        String registryName = result.getItem().getRegistryName().getResourcePath() + "_" + result.getItemDamage();
-        File f = new File(RECIPE_DIR, registryName + ".json");
-
-        while(f.exists())
-        {
-            registryName = findSuitableName(registryName);
-            f = new File(RECIPE_DIR, registryName + ".json");
-        }
-
-        try(FileWriter w = new FileWriter(f))
-        {
-            GSON.toJson(json, w);
-        }
-        catch(IOException e)
-        {
-            e.printStackTrace();
-        }
-
-        USED_REGISTRY_NAMES.add(registryName);
-    }
-
-    private static void addShapeless(ItemStack result, Object... components)
-    {
-        Map<String, Object> json = new LinkedHashMap<>();
-
-        boolean isOreDict = false;
-        List<Map<String, Object>> ingredients = new ArrayList<>();
-
-        for(Object o : components)
-        {
-            if(o instanceof String)
-            {
-                isOreDict = true;
-            }
-
-            ingredients.add(serializeItem(o));
-        }
-
-        json.put("type", isOreDict ? "forge:ore_shapeless" : "minecraft:crafting_shapeless");
-        json.put("ingredients", ingredients);
-        json.put("result", serializeItem(result));
-
-        String registryName = Objects.requireNonNull(result.getItem().getRegistryName()).getResourcePath() + "_" + result.getItemDamage();
-        File f = new File(RECIPE_DIR, registryName + ".json");
-
-        while(f.exists())
-        {
-            registryName = findSuitableName(registryName);
-            f = new File(RECIPE_DIR, registryName + ".json");
-        }
-
-        try(FileWriter w = new FileWriter(f))
-        {
-            GSON.toJson(json, w);
-        }
-        catch(IOException e)
-        {
-            e.printStackTrace();
-        }
-
-        USED_REGISTRY_NAMES.add(registryName);
-    }
-
-    private static String findSuitableName(String registryName)
-    {
-        if(registryName.contains("hmca:"))
-        {
-            registryName = registryName.replace("hmca:", "");
-        }
-
-        if(registryName.contains("minecraft:"))
-        {
-            registryName = registryName.replace("minecraft:", "");
-        }
-
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName + "_alt";
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt", "_alt_2");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_2", "_alt_3");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_3", "_alt_4");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_4", "_alt_5");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_5", "_alt_6");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_6", "_alt_7");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_7", "_alt_8");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_8", "_alt_9");
-        }
-        if(USED_REGISTRY_NAMES.contains(registryName))
-        {
-            registryName = registryName.replace("_alt_9", "_alt_10");
-        }
-
-        return registryName;
-    }
-
-    private static Map<String, Object> serializeItem(Object thing)
-    {
-        if(thing instanceof Item)
-        {
-            return serializeItem(new ItemStack((Item) thing));
-        }
-        if(thing instanceof Block)
-        {
-            return serializeItem(new ItemStack((Block) thing));
-        }
-        if(thing instanceof ItemStack)
-        {
-            ItemStack stack = (ItemStack) thing;
-            Map<String, Object> ret = new HashMap<>();
-            ret.put("item", stack.getItem().getRegistryName().toString());
-
-            if(stack.getItem().getHasSubtypes() || stack.getItemDamage() != 0)
-            {
-                ret.put("data", stack.getItemDamage());
-            }
-            if(stack.getCount() > 1)
-            {
-                ret.put("count", stack.getCount());
-            }
-
-            if(stack.hasTagCompound())
-            {
-                ret.put("nbt", stack.getTagCompound().toString());
-            }
-
-            return ret;
-        }
-        if(thing instanceof String)
-        {
-            Map<String, Object> ret = new HashMap<>();
-            USED_ORE_DICTIONARY_NAMES.add((String) thing);
-            ret.put("item", "#" + ((String) thing).toUpperCase(Locale.ROOT));
-            return ret;
-        }
-
-        throw new IllegalArgumentException("Not a animation.animations.blocks, item, stack, or od name");
-    }
-
-    private static void generateConstants()
-    {
-        List<Map<String, Object>> json = new ArrayList<>();
-
-        for(String s : USED_ORE_DICTIONARY_NAMES)
-        {
-            Map<String, Object> entry = new HashMap<>();
-            entry.put("name", s.toUpperCase(Locale.ROOT));
-            entry.put("ingredient", ImmutableMap.of("type", "forge:ore_dict", "ore", s));
-            json.add(entry);
-        }
-
-        try(FileWriter w = new FileWriter(new File(RECIPE_DIR, "_constants.json")))
-        {
-            GSON.toJson(json, w);
-        }
-        catch(IOException e)
-        {
-            e.printStackTrace();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/MathUtil.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/MathUtil.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/MathUtil.java	(date 1525605768000)
@@ -1,37 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   MathUtil.java
-
-package net.thegaminghuskymc.mcaddon.util;
-
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-
-public class MathUtil
-{
-
-    public MathUtil()
-    {
-    }
-
-    public static double nclamp(double d, double n)
-    {
-        return d - Math.floor(d / n) * n;
-    }
-
-    public static Vec3d rotateX(Vec3d v, float angle)
-    {
-        return new Vec3d(v.x * (double)MathHelper.cos(angle) - v.y * (double)MathHelper.sin(angle), v.x * (double)MathHelper.sin(angle) + v.y * (double)MathHelper.cos(angle), v.z);
-    }
-
-    public static Vec3d rotateZ(Vec3d v, float angle)
-    {
-        return new Vec3d(v.x, v.y * (double)MathHelper.cos(angle) - v.z * (double)MathHelper.sin(angle), v.y * (double)MathHelper.sin(angle) + v.z * (double)MathHelper.cos(angle));
-    }
-
-    public static Vec3d rotateY(Vec3d v, float angle)
-    {
-        return new Vec3d(v.z * (double)MathHelper.cos(angle) - v.x * (double)MathHelper.sin(angle), v.y, v.z * (double)MathHelper.sin(angle) + v.x * (double)MathHelper.cos(angle));
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/init/ModBiomes.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/init/ModBiomes.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/init/ModBiomes.java	(date 1525605768000)
@@ -1,42 +0,0 @@
-package net.thegaminghuskymc.mcaddon.init;
-
-import net.minecraft.world.biome.Biome;
-import net.minecraftforge.common.BiomeDictionary;
-import net.minecraftforge.common.BiomeManager;
-import net.minecraftforge.event.RegistryEvent;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.minecraftforge.registries.IForgeRegistry;
-import net.thegaminghuskymc.mcaddon.world.biome.BiomeBasaltOverworld;
-
-import static net.minecraftforge.common.BiomeDictionary.Type.*;
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@SuppressWarnings("WeakerAccess")
-//@GameRegistry.ObjectHolder(MOD_ID)
-public class ModBiomes {
-
-	public static final BiomeBasaltOverworld DESERT_TEST = null;
-
-//	@Mod.EventBusSubscriber(modid = MOD_ID)
-	public static class RegistrationHandler {
-
-		/**
-		 * Register this mod's {@link Biome}s.
-		 *
-		 * @param event The event
-		 */
-		@SubscribeEvent
-		public static void registerBiomes(final RegistryEvent.Register<Biome> event) {
-			final IForgeRegistry<Biome> registry = event.getRegistry();
-
-			registerBiome(registry, new BiomeBasaltOverworld(), "desert_test", BiomeManager.BiomeType.DESERT, 3, MAGICAL, DEAD, DRY, SPOOKY);
-		}
-
-		private static <T extends Biome> void registerBiome(final IForgeRegistry<Biome> registry, final T biome, final String biomeName, final BiomeManager.BiomeType biomeType, final int weight, final BiomeDictionary.Type... types) {
-			registry.register(biome.setRegistryName(MOD_ID, biomeName));
-			BiomeDictionary.addTypes(biome, types);
-			BiomeManager.addBiome(biomeType, new BiomeManager.BiomeEntry(biome, weight));
-			System.out.print(String.format("%s is now registered! With Biome Types %s", biomeName, biomeType.name()));
-		}
-	}
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAngler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAngler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosAngler.java	(date 1525605768000)
@@ -1,24 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosAngler.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.world.World;
-
-public class EntityAtmosAngler extends EntityWaterMob {
-
-    public EntityAtmosAngler(World world) {
-        super(world);
-        setSize(0.5F, 0.5F);
-        setHealth(25);
-    }
-
-    protected void initEntityAI()
-    {
-        super.initEntityAI();
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModDoor.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModDoor.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/base/BlockModDoor.java	(date 1525605768000)
@@ -1,4 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.base;
-
-public class BlockModDoor {
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosPiranha.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosPiranha.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosPiranha.java	(date 1525605768000)
@@ -1,25 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosPiranha.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-// Referenced classes of package atmosmobs.watercreatures:
-//            EntityAtmosStarFish
-
-public class EntityAtmosPiranha extends EntityAtmosWater
-{
-
-    public EntityAtmosPiranha(World world)
-    {
-        super(world);
-        setSize(0.5F, 0.8F);
-        setMaxHealth(10);
-        caught = false;
-    }
-
-    private boolean caught;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftPieces.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftPieces.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftPieces.java	(date 1525605768000)
@@ -1,986 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.structure;
-
-import com.google.common.collect.Lists;
-import net.minecraft.block.BlockPlanks;
-import net.minecraft.block.BlockRail;
-import net.minecraft.block.BlockRailBase;
-import net.minecraft.block.BlockTorch;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.EntityList;
-import net.minecraft.entity.item.EntityMinecartChest;
-import net.minecraft.entity.monster.EntityCaveSpider;
-import net.minecraft.init.Blocks;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagList;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityMobSpawner;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.gen.structure.MapGenStructureIO;
-import net.minecraft.world.gen.structure.StructureBoundingBox;
-import net.minecraft.world.gen.structure.StructureComponent;
-import net.minecraft.world.gen.structure.template.TemplateManager;
-import net.minecraft.world.storage.loot.LootTableList;
-
-import javax.annotation.Nullable;
-import java.util.List;
-import java.util.Random;
-
-public class StructureMineshaftPieces
-{
-    public static void registerStructurePieces()
-    {
-        MapGenStructureIO.registerStructureComponent(StructureMineshaftPieces.Corridor.class, "MSCorridor");
-        MapGenStructureIO.registerStructureComponent(StructureMineshaftPieces.Cross.class, "MSCrossing");
-        MapGenStructureIO.registerStructureComponent(StructureMineshaftPieces.Room.class, "MSRoom");
-        MapGenStructureIO.registerStructureComponent(StructureMineshaftPieces.Stairs.class, "MSStairs");
-    }
-
-    private static StructureMineshaftPieces.Peice createRandomShaftPiece(List<StructureComponent> p_189940_0_, Random p_189940_1_, int p_189940_2_, int p_189940_3_, int p_189940_4_, @Nullable EnumFacing p_189940_5_, int p_189940_6_, MapGenMineshaft.Type p_189940_7_)
-    {
-        int i = p_189940_1_.nextInt(100);
-
-        if (i >= 80)
-        {
-            StructureBoundingBox structureboundingbox = StructureMineshaftPieces.Cross.findCrossing(p_189940_0_, p_189940_1_, p_189940_2_, p_189940_3_, p_189940_4_, p_189940_5_);
-
-            if (structureboundingbox != null)
-            {
-                return new StructureMineshaftPieces.Cross(p_189940_6_, p_189940_1_, structureboundingbox, p_189940_5_, p_189940_7_);
-            }
-        }
-        else if (i >= 70)
-        {
-            StructureBoundingBox structureboundingbox1 = StructureMineshaftPieces.Stairs.findStairs(p_189940_0_, p_189940_1_, p_189940_2_, p_189940_3_, p_189940_4_, p_189940_5_);
-
-            if (structureboundingbox1 != null)
-            {
-                return new StructureMineshaftPieces.Stairs(p_189940_6_, p_189940_1_, structureboundingbox1, p_189940_5_, p_189940_7_);
-            }
-        }
-        else
-        {
-            StructureBoundingBox structureboundingbox2 = StructureMineshaftPieces.Corridor.findCorridorSize(p_189940_0_, p_189940_1_, p_189940_2_, p_189940_3_, p_189940_4_, p_189940_5_);
-
-            if (structureboundingbox2 != null)
-            {
-                return new StructureMineshaftPieces.Corridor(p_189940_6_, p_189940_1_, structureboundingbox2, p_189940_5_, p_189940_7_);
-            }
-        }
-
-        return null;
-    }
-
-    private static StructureMineshaftPieces.Peice generateAndAddPiece(StructureComponent p_189938_0_, List<StructureComponent> p_189938_1_, Random p_189938_2_, int p_189938_3_, int p_189938_4_, int p_189938_5_, EnumFacing p_189938_6_, int p_189938_7_)
-    {
-        if (p_189938_7_ > 8)
-        {
-            return null;
-        }
-        else if (Math.abs(p_189938_3_ - p_189938_0_.getBoundingBox().minX) <= 80 && Math.abs(p_189938_5_ - p_189938_0_.getBoundingBox().minZ) <= 80)
-        {
-            MapGenMineshaft.Type mapgenmineshaft$type = ((StructureMineshaftPieces.Peice)p_189938_0_).mineShaftType;
-            StructureMineshaftPieces.Peice structuremineshaftpieces$peice = createRandomShaftPiece(p_189938_1_, p_189938_2_, p_189938_3_, p_189938_4_, p_189938_5_, p_189938_6_, p_189938_7_ + 1, mapgenmineshaft$type);
-
-            if (structuremineshaftpieces$peice != null)
-            {
-                p_189938_1_.add(structuremineshaftpieces$peice);
-                structuremineshaftpieces$peice.buildComponent(p_189938_0_, p_189938_1_, p_189938_2_);
-            }
-
-            return structuremineshaftpieces$peice;
-        }
-        else
-        {
-            return null;
-        }
-    }
-
-    public static class Corridor extends StructureMineshaftPieces.Peice
-        {
-            private boolean hasRails;
-            private boolean hasSpiders;
-            private boolean spawnerPlaced;
-            /** A count of the different sections of this mine. The space between ceiling supports. */
-            private int sectionCount;
-
-            public Corridor()
-            {
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setBoolean("hr", this.hasRails);
-                tagCompound.setBoolean("sc", this.hasSpiders);
-                tagCompound.setBoolean("hps", this.spawnerPlaced);
-                tagCompound.setInteger("Num", this.sectionCount);
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.hasRails = tagCompound.getBoolean("hr");
-                this.hasSpiders = tagCompound.getBoolean("sc");
-                this.spawnerPlaced = tagCompound.getBoolean("hps");
-                this.sectionCount = tagCompound.getInteger("Num");
-            }
-
-            public Corridor(int p_i47140_1_, Random p_i47140_2_, StructureBoundingBox p_i47140_3_, EnumFacing p_i47140_4_, MapGenMineshaft.Type p_i47140_5_)
-            {
-                super(p_i47140_1_, p_i47140_5_);
-                this.setCoordBaseMode(p_i47140_4_);
-                this.boundingBox = p_i47140_3_;
-                this.hasRails = p_i47140_2_.nextInt(3) == 0;
-                this.hasSpiders = !this.hasRails && p_i47140_2_.nextInt(23) == 0;
-
-                if (this.getCoordBaseMode().getAxis() == EnumFacing.Axis.Z)
-                {
-                    this.sectionCount = p_i47140_3_.getZSize() / 5;
-                }
-                else
-                {
-                    this.sectionCount = p_i47140_3_.getXSize() / 5;
-                }
-            }
-
-            public static StructureBoundingBox findCorridorSize(List<StructureComponent> p_175814_0_, Random rand, int x, int y, int z, EnumFacing facing)
-            {
-                StructureBoundingBox structureboundingbox = new StructureBoundingBox(x, y, z, x, y + 2, z);
-                int i;
-
-                for (i = rand.nextInt(3) + 2; i > 0; --i)
-                {
-                    int j = i * 5;
-
-                    switch (facing)
-                    {
-                        case NORTH:
-                        default:
-                            structureboundingbox.maxX = x + 2;
-                            structureboundingbox.minZ = z - (j - 1);
-                            break;
-                        case SOUTH:
-                            structureboundingbox.maxX = x + 2;
-                            structureboundingbox.maxZ = z + (j - 1);
-                            break;
-                        case WEST:
-                            structureboundingbox.minX = x - (j - 1);
-                            structureboundingbox.maxZ = z + 2;
-                            break;
-                        case EAST:
-                            structureboundingbox.maxX = x + (j - 1);
-                            structureboundingbox.maxZ = z + 2;
-                    }
-
-                    if (StructureComponent.findIntersecting(p_175814_0_, structureboundingbox) == null)
-                    {
-                        break;
-                    }
-                }
-
-                return i > 0 ? structureboundingbox : null;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                int i = this.getComponentType();
-                int j = rand.nextInt(4);
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing != null)
-                {
-                    switch (enumfacing)
-                    {
-                        case NORTH:
-                        default:
-
-                            if (j <= 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ - 1, enumfacing, i);
-                            }
-                            else if (j == 2)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ, EnumFacing.WEST, i);
-                            }
-                            else
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ, EnumFacing.EAST, i);
-                            }
-
-                            break;
-                        case SOUTH:
-
-                            if (j <= 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.maxZ + 1, enumfacing, i);
-                            }
-                            else if (j == 2)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.maxZ - 3, EnumFacing.WEST, i);
-                            }
-                            else
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.maxZ - 3, EnumFacing.EAST, i);
-                            }
-
-                            break;
-                        case WEST:
-
-                            if (j <= 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ, enumfacing, i);
-                            }
-                            else if (j == 2)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                            }
-                            else
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                            }
-
-                            break;
-                        case EAST:
-
-                            if (j <= 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ, enumfacing, i);
-                            }
-                            else if (j == 2)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX - 3, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                            }
-                            else
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX - 3, this.boundingBox.minY - 1 + rand.nextInt(3), this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                            }
-                    }
-                }
-
-                if (i < 8)
-                {
-                    if (enumfacing != EnumFacing.NORTH && enumfacing != EnumFacing.SOUTH)
-                    {
-                        for (int i1 = this.boundingBox.minX + 3; i1 + 3 <= this.boundingBox.maxX; i1 += 5)
-                        {
-                            int j1 = rand.nextInt(5);
-
-                            if (j1 == 0)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, i1, this.boundingBox.minY, this.boundingBox.minZ - 1, EnumFacing.NORTH, i + 1);
-                            }
-                            else if (j1 == 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, i1, this.boundingBox.minY, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i + 1);
-                            }
-                        }
-                    }
-                    else
-                    {
-                        for (int k = this.boundingBox.minZ + 3; k + 3 <= this.boundingBox.maxZ; k += 5)
-                        {
-                            int l = rand.nextInt(5);
-
-                            if (l == 0)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY, k, EnumFacing.WEST, i + 1);
-                            }
-                            else if (l == 1)
-                            {
-                                StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY, k, EnumFacing.EAST, i + 1);
-                            }
-                        }
-                    }
-                }
-            }
-
-            /**
-             * Adds chest to the structure and sets its contents
-             */
-            protected boolean generateChest(World worldIn, StructureBoundingBox structurebb, Random randomIn, int x, int y, int z, ResourceLocation loot)
-            {
-                BlockPos blockpos = new BlockPos(this.getXWithOffset(x, z), this.getYWithOffset(y), this.getZWithOffset(x, z));
-
-                if (structurebb.isVecInside(blockpos) && worldIn.getBlockState(blockpos).getMaterial() == Material.AIR && worldIn.getBlockState(blockpos.down()).getMaterial() != Material.AIR)
-                {
-                    IBlockState iblockstate = Blocks.RAIL.getDefaultState().withProperty(BlockRail.SHAPE, randomIn.nextBoolean() ? BlockRailBase.EnumRailDirection.NORTH_SOUTH : BlockRailBase.EnumRailDirection.EAST_WEST);
-                    this.setBlockState(worldIn, iblockstate, x, y, z, structurebb);
-                    EntityMinecartChest entityminecartchest = new EntityMinecartChest(worldIn, (double)((float)blockpos.getX() + 0.5F), (double)((float)blockpos.getY() + 0.5F), (double)((float)blockpos.getZ() + 0.5F));
-                    entityminecartchest.setLootTable(loot, randomIn.nextLong());
-                    worldIn.spawnEntity(entityminecartchest);
-                    return true;
-                }
-                else
-                {
-                    return false;
-                }
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                if (this.isLiquidInStructureBoundingBox(worldIn, structureBoundingBoxIn))
-                {
-                    return false;
-                }
-                else
-                {
-                    int i = 0;
-                    int j = 2;
-                    int k = 0;
-                    int l = 2;
-                    int i1 = this.sectionCount * 5 - 1;
-                    IBlockState iblockstate = this.getPlanksBlock();
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 0, 2, 1, i1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    this.generateMaybeBox(worldIn, structureBoundingBoxIn, randomIn, 0.8F, 0, 2, 0, 2, 2, i1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false, 0);
-
-                    if (this.hasSpiders)
-                    {
-                        this.generateMaybeBox(worldIn, structureBoundingBoxIn, randomIn, 0.6F, 0, 0, 0, 2, 1, i1, Blocks.WEB.getDefaultState(), Blocks.AIR.getDefaultState(), false, 8);
-                    }
-
-                    for (int j1 = 0; j1 < this.sectionCount; ++j1)
-                    {
-                        int k1 = 2 + j1 * 5;
-                        this.placeSupport(worldIn, structureBoundingBoxIn, 0, 0, k1, 2, 2, randomIn);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.1F, 0, 2, k1 - 1);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.1F, 2, 2, k1 - 1);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.1F, 0, 2, k1 + 1);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.1F, 2, 2, k1 + 1);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.05F, 0, 2, k1 - 2);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.05F, 2, 2, k1 - 2);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.05F, 0, 2, k1 + 2);
-                        this.placeCobWeb(worldIn, structureBoundingBoxIn, randomIn, 0.05F, 2, 2, k1 + 2);
-
-                        if (randomIn.nextInt(100) == 0)
-                        {
-                            this.generateChest(worldIn, structureBoundingBoxIn, randomIn, 2, 0, k1 - 1, LootTableList.CHESTS_ABANDONED_MINESHAFT);
-                        }
-
-                        if (randomIn.nextInt(100) == 0)
-                        {
-                            this.generateChest(worldIn, structureBoundingBoxIn, randomIn, 0, 0, k1 + 1, LootTableList.CHESTS_ABANDONED_MINESHAFT);
-                        }
-
-                        if (this.hasSpiders && !this.spawnerPlaced)
-                        {
-                            int l1 = this.getYWithOffset(0);
-                            int i2 = k1 - 1 + randomIn.nextInt(3);
-                            int j2 = this.getXWithOffset(1, i2);
-                            int k2 = this.getZWithOffset(1, i2);
-                            BlockPos blockpos = new BlockPos(j2, l1, k2);
-
-                            if (structureBoundingBoxIn.isVecInside(blockpos) && this.getSkyBrightness(worldIn, 1, 0, i2, structureBoundingBoxIn) < 8)
-                            {
-                                this.spawnerPlaced = true;
-                                worldIn.setBlockState(blockpos, Blocks.MOB_SPAWNER.getDefaultState(), 2);
-                                TileEntity tileentity = worldIn.getTileEntity(blockpos);
-
-                                if (tileentity instanceof TileEntityMobSpawner)
-                                {
-                                    ((TileEntityMobSpawner)tileentity).getSpawnerBaseLogic().setEntityId(EntityList.getKey(EntityCaveSpider.class));
-                                }
-                            }
-                        }
-                    }
-
-                    for (int l2 = 0; l2 <= 2; ++l2)
-                    {
-                        for (int i3 = 0; i3 <= i1; ++i3)
-                        {
-                            int k3 = -1;
-                            IBlockState iblockstate3 = this.getBlockStateFromPos(worldIn, l2, -1, i3, structureBoundingBoxIn);
-
-                            if (iblockstate3.getMaterial() == Material.AIR && this.getSkyBrightness(worldIn, l2, -1, i3, structureBoundingBoxIn) < 8)
-                            {
-                                int l3 = -1;
-                                this.setBlockState(worldIn, iblockstate, l2, -1, i3, structureBoundingBoxIn);
-                            }
-                        }
-                    }
-
-                    if (this.hasRails)
-                    {
-                        IBlockState iblockstate1 = Blocks.RAIL.getDefaultState().withProperty(BlockRail.SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);
-
-                        for (int j3 = 0; j3 <= i1; ++j3)
-                        {
-                            IBlockState iblockstate2 = this.getBlockStateFromPos(worldIn, 1, -1, j3, structureBoundingBoxIn);
-
-                            if (iblockstate2.getMaterial() != Material.AIR && iblockstate2.isFullBlock())
-                            {
-                                float f = this.getSkyBrightness(worldIn, 1, 0, j3, structureBoundingBoxIn) > 8 ? 0.9F : 0.7F;
-                                this.randomlyPlaceBlock(worldIn, structureBoundingBoxIn, randomIn, f, 1, 0, j3, iblockstate1);
-                            }
-                        }
-                    }
-
-                    return true;
-                }
-            }
-
-            private void placeSupport(World p_189921_1_, StructureBoundingBox p_189921_2_, int p_189921_3_, int p_189921_4_, int p_189921_5_, int p_189921_6_, int p_189921_7_, Random p_189921_8_)
-            {
-                if (this.isSupportingBox(p_189921_1_, p_189921_2_, p_189921_3_, p_189921_7_, p_189921_6_, p_189921_5_))
-                {
-                    IBlockState iblockstate = this.getPlanksBlock();
-                    IBlockState iblockstate1 = this.getFenceBlock();
-                    IBlockState iblockstate2 = Blocks.AIR.getDefaultState();
-                    this.fillWithBlocks(p_189921_1_, p_189921_2_, p_189921_3_, p_189921_4_, p_189921_5_, p_189921_3_, p_189921_6_ - 1, p_189921_5_, iblockstate1, iblockstate2, false);
-                    this.fillWithBlocks(p_189921_1_, p_189921_2_, p_189921_7_, p_189921_4_, p_189921_5_, p_189921_7_, p_189921_6_ - 1, p_189921_5_, iblockstate1, iblockstate2, false);
-
-                    if (p_189921_8_.nextInt(4) == 0)
-                    {
-                        this.fillWithBlocks(p_189921_1_, p_189921_2_, p_189921_3_, p_189921_6_, p_189921_5_, p_189921_3_, p_189921_6_, p_189921_5_, iblockstate, iblockstate2, false);
-                        this.fillWithBlocks(p_189921_1_, p_189921_2_, p_189921_7_, p_189921_6_, p_189921_5_, p_189921_7_, p_189921_6_, p_189921_5_, iblockstate, iblockstate2, false);
-                    }
-                    else
-                    {
-                        this.fillWithBlocks(p_189921_1_, p_189921_2_, p_189921_3_, p_189921_6_, p_189921_5_, p_189921_7_, p_189921_6_, p_189921_5_, iblockstate, iblockstate2, false);
-                        this.randomlyPlaceBlock(p_189921_1_, p_189921_2_, p_189921_8_, 0.05F, p_189921_3_ + 1, p_189921_6_, p_189921_5_ - 1, Blocks.TORCH.getDefaultState().withProperty(BlockTorch.FACING, EnumFacing.NORTH));
-                        this.randomlyPlaceBlock(p_189921_1_, p_189921_2_, p_189921_8_, 0.05F, p_189921_3_ + 1, p_189921_6_, p_189921_5_ + 1, Blocks.TORCH.getDefaultState().withProperty(BlockTorch.FACING, EnumFacing.SOUTH));
-                    }
-                }
-            }
-
-            private void placeCobWeb(World p_189922_1_, StructureBoundingBox p_189922_2_, Random p_189922_3_, float p_189922_4_, int p_189922_5_, int p_189922_6_, int p_189922_7_)
-            {
-                if (this.getSkyBrightness(p_189922_1_, p_189922_5_, p_189922_6_, p_189922_7_, p_189922_2_) < 8)
-                {
-                    this.randomlyPlaceBlock(p_189922_1_, p_189922_2_, p_189922_3_, p_189922_4_, p_189922_5_, p_189922_6_, p_189922_7_, Blocks.WEB.getDefaultState());
-                }
-            }
-        }
-
-    public static class Cross extends StructureMineshaftPieces.Peice
-        {
-            private EnumFacing corridorDirection;
-            private boolean isMultipleFloors;
-
-            public Cross()
-            {
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                tagCompound.setBoolean("tf", this.isMultipleFloors);
-                tagCompound.setInteger("D", this.corridorDirection.getHorizontalIndex());
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                this.isMultipleFloors = tagCompound.getBoolean("tf");
-                this.corridorDirection = EnumFacing.getHorizontal(tagCompound.getInteger("D"));
-            }
-
-            public Cross(int p_i47139_1_, Random p_i47139_2_, StructureBoundingBox p_i47139_3_, @Nullable EnumFacing p_i47139_4_, MapGenMineshaft.Type p_i47139_5_)
-            {
-                super(p_i47139_1_, p_i47139_5_);
-                this.corridorDirection = p_i47139_4_;
-                this.boundingBox = p_i47139_3_;
-                this.isMultipleFloors = p_i47139_3_.getYSize() > 3;
-            }
-
-            public static StructureBoundingBox findCrossing(List<StructureComponent> listIn, Random rand, int x, int y, int z, EnumFacing facing)
-            {
-                StructureBoundingBox structureboundingbox = new StructureBoundingBox(x, y, z, x, y + 2, z);
-
-                if (rand.nextInt(4) == 0)
-                {
-                    structureboundingbox.maxY += 4;
-                }
-
-                switch (facing)
-                {
-                    case NORTH:
-                    default:
-                        structureboundingbox.minX = x - 1;
-                        structureboundingbox.maxX = x + 3;
-                        structureboundingbox.minZ = z - 4;
-                        break;
-                    case SOUTH:
-                        structureboundingbox.minX = x - 1;
-                        structureboundingbox.maxX = x + 3;
-                        structureboundingbox.maxZ = z + 3 + 1;
-                        break;
-                    case WEST:
-                        structureboundingbox.minX = x - 4;
-                        structureboundingbox.minZ = z - 1;
-                        structureboundingbox.maxZ = z + 3;
-                        break;
-                    case EAST:
-                        structureboundingbox.maxX = x + 3 + 1;
-                        structureboundingbox.minZ = z - 1;
-                        structureboundingbox.maxZ = z + 3;
-                }
-
-                return StructureComponent.findIntersecting(listIn, structureboundingbox) != null ? null : structureboundingbox;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                int i = this.getComponentType();
-
-                switch (this.corridorDirection)
-                {
-                    case NORTH:
-                    default:
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.WEST, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.EAST, i);
-                        break;
-                    case SOUTH:
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.WEST, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.EAST, i);
-                        break;
-                    case WEST:
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.WEST, i);
-                        break;
-                    case EAST:
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY, this.boundingBox.minZ + 1, EnumFacing.EAST, i);
-                }
-
-                if (this.isMultipleFloors)
-                {
-                    if (rand.nextBoolean())
-                    {
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY + 3 + 1, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                    }
-
-                    if (rand.nextBoolean())
-                    {
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY + 3 + 1, this.boundingBox.minZ + 1, EnumFacing.WEST, i);
-                    }
-
-                    if (rand.nextBoolean())
-                    {
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY + 3 + 1, this.boundingBox.minZ + 1, EnumFacing.EAST, i);
-                    }
-
-                    if (rand.nextBoolean())
-                    {
-                        StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + 1, this.boundingBox.minY + 3 + 1, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                    }
-                }
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                if (this.isLiquidInStructureBoundingBox(worldIn, structureBoundingBoxIn))
-                {
-                    return false;
-                }
-                else
-                {
-                    IBlockState iblockstate = this.getPlanksBlock();
-
-                    if (this.isMultipleFloors)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ, this.boundingBox.maxX - 1, this.boundingBox.minY + 3 - 1, this.boundingBox.maxZ, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.minY, this.boundingBox.minZ + 1, this.boundingBox.maxX, this.boundingBox.minY + 3 - 1, this.boundingBox.maxZ - 1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.maxY - 2, this.boundingBox.minZ, this.boundingBox.maxX - 1, this.boundingBox.maxY, this.boundingBox.maxZ, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.maxY - 2, this.boundingBox.minZ + 1, this.boundingBox.maxX, this.boundingBox.maxY, this.boundingBox.maxZ - 1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.minY + 3, this.boundingBox.minZ + 1, this.boundingBox.maxX - 1, this.boundingBox.minY + 3, this.boundingBox.maxZ - 1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    }
-                    else
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ, this.boundingBox.maxX - 1, this.boundingBox.maxY, this.boundingBox.maxZ, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.minY, this.boundingBox.minZ + 1, this.boundingBox.maxX, this.boundingBox.maxY, this.boundingBox.maxZ - 1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    }
-
-                    this.placeSupportPillar(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.minZ + 1, this.boundingBox.maxY);
-                    this.placeSupportPillar(worldIn, structureBoundingBoxIn, this.boundingBox.minX + 1, this.boundingBox.minY, this.boundingBox.maxZ - 1, this.boundingBox.maxY);
-                    this.placeSupportPillar(worldIn, structureBoundingBoxIn, this.boundingBox.maxX - 1, this.boundingBox.minY, this.boundingBox.minZ + 1, this.boundingBox.maxY);
-                    this.placeSupportPillar(worldIn, structureBoundingBoxIn, this.boundingBox.maxX - 1, this.boundingBox.minY, this.boundingBox.maxZ - 1, this.boundingBox.maxY);
-
-                    for (int i = this.boundingBox.minX; i <= this.boundingBox.maxX; ++i)
-                    {
-                        for (int j = this.boundingBox.minZ; j <= this.boundingBox.maxZ; ++j)
-                        {
-                            if (this.getBlockStateFromPos(worldIn, i, this.boundingBox.minY - 1, j, structureBoundingBoxIn).getMaterial() == Material.AIR && this.getSkyBrightness(worldIn, i, this.boundingBox.minY - 1, j, structureBoundingBoxIn) < 8)
-                            {
-                                this.setBlockState(worldIn, iblockstate, i, this.boundingBox.minY - 1, j, structureBoundingBoxIn);
-                            }
-                        }
-                    }
-
-                    return true;
-                }
-            }
-
-            private void placeSupportPillar(World p_189923_1_, StructureBoundingBox p_189923_2_, int p_189923_3_, int p_189923_4_, int p_189923_5_, int p_189923_6_)
-            {
-                if (this.getBlockStateFromPos(p_189923_1_, p_189923_3_, p_189923_6_ + 1, p_189923_5_, p_189923_2_).getMaterial() != Material.AIR)
-                {
-                    this.fillWithBlocks(p_189923_1_, p_189923_2_, p_189923_3_, p_189923_4_, p_189923_5_, p_189923_3_, p_189923_6_, p_189923_5_, this.getPlanksBlock(), Blocks.AIR.getDefaultState(), false);
-                }
-            }
-        }
-
-    abstract static class Peice extends StructureComponent
-        {
-            protected MapGenMineshaft.Type mineShaftType;
-
-            public Peice()
-            {
-            }
-
-            public Peice(int p_i47138_1_, MapGenMineshaft.Type p_i47138_2_)
-            {
-                super(p_i47138_1_);
-                this.mineShaftType = p_i47138_2_;
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                tagCompound.setInteger("MST", this.mineShaftType.ordinal());
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                this.mineShaftType = MapGenMineshaft.Type.byId(tagCompound.getInteger("MST"));
-            }
-
-            protected IBlockState getPlanksBlock()
-            {
-                switch (this.mineShaftType)
-                {
-                    case NORMAL:
-                    default:
-                        return Blocks.PLANKS.getDefaultState();
-                    case MESA:
-                        return Blocks.PLANKS.getDefaultState().withProperty(BlockPlanks.VARIANT, BlockPlanks.EnumType.DARK_OAK);
-                }
-            }
-
-            protected IBlockState getFenceBlock()
-            {
-                switch (this.mineShaftType)
-                {
-                    case NORMAL:
-                    default:
-                        return Blocks.OAK_FENCE.getDefaultState();
-                    case MESA:
-                        return Blocks.DARK_OAK_FENCE.getDefaultState();
-                }
-            }
-
-            protected boolean isSupportingBox(World p_189918_1_, StructureBoundingBox p_189918_2_, int p_189918_3_, int p_189918_4_, int p_189918_5_, int p_189918_6_)
-            {
-                for (int i = p_189918_3_; i <= p_189918_4_; ++i)
-                {
-                    if (this.getBlockStateFromPos(p_189918_1_, i, p_189918_5_ + 1, p_189918_6_, p_189918_2_).getMaterial() == Material.AIR)
-                    {
-                        return false;
-                    }
-                }
-
-                return true;
-            }
-        }
-
-    public static class Room extends StructureMineshaftPieces.Peice
-        {
-            /** List of other Mineshaft components linked to this room. */
-            private final List<StructureBoundingBox> connectedRooms = Lists.<StructureBoundingBox>newLinkedList();
-
-            public Room()
-            {
-            }
-
-            public Room(int p_i47137_1_, Random p_i47137_2_, int p_i47137_3_, int p_i47137_4_, MapGenMineshaft.Type p_i47137_5_)
-            {
-                super(p_i47137_1_, p_i47137_5_);
-                this.mineShaftType = p_i47137_5_;
-                this.boundingBox = new StructureBoundingBox(p_i47137_3_, 50, p_i47137_4_, p_i47137_3_ + 7 + p_i47137_2_.nextInt(6), 54 + p_i47137_2_.nextInt(6), p_i47137_4_ + 7 + p_i47137_2_.nextInt(6));
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                int i = this.getComponentType();
-                int j = this.boundingBox.getYSize() - 3 - 1;
-
-                if (j <= 0)
-                {
-                    j = 1;
-                }
-
-                int k;
-
-                for (k = 0; k < this.boundingBox.getXSize(); k = k + 4)
-                {
-                    k = k + rand.nextInt(this.boundingBox.getXSize());
-
-                    if (k + 3 > this.boundingBox.getXSize())
-                    {
-                        break;
-                    }
-
-                    StructureMineshaftPieces.Peice structuremineshaftpieces$peice = StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + k, this.boundingBox.minY + rand.nextInt(j) + 1, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-
-                    if (structuremineshaftpieces$peice != null)
-                    {
-                        StructureBoundingBox structureboundingbox = structuremineshaftpieces$peice.getBoundingBox();
-                        this.connectedRooms.add(new StructureBoundingBox(structureboundingbox.minX, structureboundingbox.minY, this.boundingBox.minZ, structureboundingbox.maxX, structureboundingbox.maxY, this.boundingBox.minZ + 1));
-                    }
-                }
-
-                for (k = 0; k < this.boundingBox.getXSize(); k = k + 4)
-                {
-                    k = k + rand.nextInt(this.boundingBox.getXSize());
-
-                    if (k + 3 > this.boundingBox.getXSize())
-                    {
-                        break;
-                    }
-
-                    StructureMineshaftPieces.Peice structuremineshaftpieces$peice1 = StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX + k, this.boundingBox.minY + rand.nextInt(j) + 1, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-
-                    if (structuremineshaftpieces$peice1 != null)
-                    {
-                        StructureBoundingBox structureboundingbox1 = structuremineshaftpieces$peice1.getBoundingBox();
-                        this.connectedRooms.add(new StructureBoundingBox(structureboundingbox1.minX, structureboundingbox1.minY, this.boundingBox.maxZ - 1, structureboundingbox1.maxX, structureboundingbox1.maxY, this.boundingBox.maxZ));
-                    }
-                }
-
-                for (k = 0; k < this.boundingBox.getZSize(); k = k + 4)
-                {
-                    k = k + rand.nextInt(this.boundingBox.getZSize());
-
-                    if (k + 3 > this.boundingBox.getZSize())
-                    {
-                        break;
-                    }
-
-                    StructureMineshaftPieces.Peice structuremineshaftpieces$peice2 = StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY + rand.nextInt(j) + 1, this.boundingBox.minZ + k, EnumFacing.WEST, i);
-
-                    if (structuremineshaftpieces$peice2 != null)
-                    {
-                        StructureBoundingBox structureboundingbox2 = structuremineshaftpieces$peice2.getBoundingBox();
-                        this.connectedRooms.add(new StructureBoundingBox(this.boundingBox.minX, structureboundingbox2.minY, structureboundingbox2.minZ, this.boundingBox.minX + 1, structureboundingbox2.maxY, structureboundingbox2.maxZ));
-                    }
-                }
-
-                for (k = 0; k < this.boundingBox.getZSize(); k = k + 4)
-                {
-                    k = k + rand.nextInt(this.boundingBox.getZSize());
-
-                    if (k + 3 > this.boundingBox.getZSize())
-                    {
-                        break;
-                    }
-
-                    StructureComponent structurecomponent = StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY + rand.nextInt(j) + 1, this.boundingBox.minZ + k, EnumFacing.EAST, i);
-
-                    if (structurecomponent != null)
-                    {
-                        StructureBoundingBox structureboundingbox3 = structurecomponent.getBoundingBox();
-                        this.connectedRooms.add(new StructureBoundingBox(this.boundingBox.maxX - 1, structureboundingbox3.minY, structureboundingbox3.minZ, this.boundingBox.maxX, structureboundingbox3.maxY, structureboundingbox3.maxZ));
-                    }
-                }
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                if (this.isLiquidInStructureBoundingBox(worldIn, structureBoundingBoxIn))
-                {
-                    return false;
-                }
-                else
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.minY, this.boundingBox.minZ, this.boundingBox.maxX, this.boundingBox.minY, this.boundingBox.maxZ, Blocks.DIRT.getDefaultState(), Blocks.AIR.getDefaultState(), true);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.minY + 1, this.boundingBox.minZ, this.boundingBox.maxX, Math.min(this.boundingBox.minY + 3, this.boundingBox.maxY), this.boundingBox.maxZ, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-
-                    for (StructureBoundingBox structureboundingbox : this.connectedRooms)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, structureboundingbox.minX, structureboundingbox.maxY - 2, structureboundingbox.minZ, structureboundingbox.maxX, structureboundingbox.maxY, structureboundingbox.maxZ, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    }
-
-                    this.randomlyRareFillWithBlocks(worldIn, structureBoundingBoxIn, this.boundingBox.minX, this.boundingBox.minY + 4, this.boundingBox.minZ, this.boundingBox.maxX, this.boundingBox.maxY, this.boundingBox.maxZ, Blocks.AIR.getDefaultState(), false);
-                    return true;
-                }
-            }
-
-            public void offset(int x, int y, int z)
-            {
-                super.offset(x, y, z);
-
-                for (StructureBoundingBox structureboundingbox : this.connectedRooms)
-                {
-                    structureboundingbox.offset(x, y, z);
-                }
-            }
-
-            /**
-             * (abstract) Helper method to write subclass data to NBT
-             */
-            protected void writeStructureToNBT(NBTTagCompound tagCompound)
-            {
-                super.writeStructureToNBT(tagCompound);
-                NBTTagList nbttaglist = new NBTTagList();
-
-                for (StructureBoundingBox structureboundingbox : this.connectedRooms)
-                {
-                    nbttaglist.appendTag(structureboundingbox.toNBTTagIntArray());
-                }
-
-                tagCompound.setTag("Entrances", nbttaglist);
-            }
-
-            /**
-             * (abstract) Helper method to read subclass data from NBT
-             */
-            protected void readStructureFromNBT(NBTTagCompound tagCompound, TemplateManager p_143011_2_)
-            {
-                super.readStructureFromNBT(tagCompound, p_143011_2_);
-                NBTTagList nbttaglist = tagCompound.getTagList("Entrances", 11);
-
-                for (int i = 0; i < nbttaglist.tagCount(); ++i)
-                {
-                    this.connectedRooms.add(new StructureBoundingBox(nbttaglist.getIntArrayAt(i)));
-                }
-            }
-        }
-
-    public static class Stairs extends StructureMineshaftPieces.Peice
-        {
-            public Stairs()
-            {
-            }
-
-            public Stairs(int p_i47136_1_, Random p_i47136_2_, StructureBoundingBox p_i47136_3_, EnumFacing p_i47136_4_, MapGenMineshaft.Type p_i47136_5_)
-            {
-                super(p_i47136_1_, p_i47136_5_);
-                this.setCoordBaseMode(p_i47136_4_);
-                this.boundingBox = p_i47136_3_;
-            }
-
-            public static StructureBoundingBox findStairs(List<StructureComponent> listIn, Random rand, int x, int y, int z, EnumFacing facing)
-            {
-                StructureBoundingBox structureboundingbox = new StructureBoundingBox(x, y - 5, z, x, y + 2, z);
-
-                switch (facing)
-                {
-                    case NORTH:
-                    default:
-                        structureboundingbox.maxX = x + 2;
-                        structureboundingbox.minZ = z - 8;
-                        break;
-                    case SOUTH:
-                        structureboundingbox.maxX = x + 2;
-                        structureboundingbox.maxZ = z + 8;
-                        break;
-                    case WEST:
-                        structureboundingbox.minX = x - 8;
-                        structureboundingbox.maxZ = z + 2;
-                        break;
-                    case EAST:
-                        structureboundingbox.maxX = x + 8;
-                        structureboundingbox.maxZ = z + 2;
-                }
-
-                return StructureComponent.findIntersecting(listIn, structureboundingbox) != null ? null : structureboundingbox;
-            }
-
-            /**
-             * Initiates construction of the Structure Component picked, at the current Location of StructGen
-             */
-            public void buildComponent(StructureComponent componentIn, List<StructureComponent> listIn, Random rand)
-            {
-                int i = this.getComponentType();
-                EnumFacing enumfacing = this.getCoordBaseMode();
-
-                if (enumfacing != null)
-                {
-                    switch (enumfacing)
-                    {
-                        case NORTH:
-                        default:
-                            StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY, this.boundingBox.minZ - 1, EnumFacing.NORTH, i);
-                            break;
-                        case SOUTH:
-                            StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX, this.boundingBox.minY, this.boundingBox.maxZ + 1, EnumFacing.SOUTH, i);
-                            break;
-                        case WEST:
-                            StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.minX - 1, this.boundingBox.minY, this.boundingBox.minZ, EnumFacing.WEST, i);
-                            break;
-                        case EAST:
-                            StructureMineshaftPieces.generateAndAddPiece(componentIn, listIn, rand, this.boundingBox.maxX + 1, this.boundingBox.minY, this.boundingBox.minZ, EnumFacing.EAST, i);
-                    }
-                }
-            }
-
-            /**
-             * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes
-             * Mineshafts at the end, it adds Fences...
-             */
-            public boolean addComponentParts(World worldIn, Random randomIn, StructureBoundingBox structureBoundingBoxIn)
-            {
-                if (this.isLiquidInStructureBoundingBox(worldIn, structureBoundingBoxIn))
-                {
-                    return false;
-                }
-                else
-                {
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5, 0, 2, 7, 1, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 0, 7, 2, 2, 8, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-
-                    for (int i = 0; i < 5; ++i)
-                    {
-                        this.fillWithBlocks(worldIn, structureBoundingBoxIn, 0, 5 - i - (i < 4 ? 1 : 0), 2 + i, 2, 7 - i, 2 + i, Blocks.AIR.getDefaultState(), Blocks.AIR.getDefaultState(), false);
-                    }
-
-                    return true;
-                }
-            }
-        }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/armors/ArmorBase.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/armors/ArmorBase.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/armors/ArmorBase.java	(date 1525605768000)
@@ -1,16 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.armors;
-
-import net.minecraft.creativetab.CreativeTabs;
-import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.ItemArmor;
-
-public class ArmorBase extends ItemArmor
-{
-    public ArmorBase(String name, ArmorMaterial materialIn, int renderIndexIn, EntityEquipmentSlot equipmentSlotIn)
-    {
-        super(materialIn, renderIndexIn, equipmentSlotIn);
-        setUnlocalizedName(name);
-        setRegistryName(name);
-        setCreativeTab(CreativeTabs.COMBAT);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelPhantom.java	(date 1525605768000)
@@ -1,74 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-@SideOnly(Side.CLIENT)
-public class ModelPhantom extends ModelBase {
-
-    ModelRenderer head;
-    ModelRenderer body;
-    ModelRenderer leftWing;
-    ModelRenderer rightWing;
-    ModelRenderer bodyLeft;
-    ModelRenderer bodyMiddle;
-    ModelRenderer tailStart;
-    ModelRenderer tailEnd;
-
-    public ModelPhantom() {
-        this.textureWidth = 128;
-        this.textureHeight = 32;
-        this.bodyLeft = new ModelRenderer(this, 0, 8);
-        this.bodyLeft.setRotationPoint(2.6F, 17.0F, 1.1F);
-        this.bodyLeft.addBox(0.0F, 0.0F, 0.0F, 6, 2, 9, 0.0F);
-        this.leftWing = new ModelRenderer(this, 0, 20);
-        this.leftWing.setRotationPoint(6.0F, 0.0F, 0.0F);
-        this.leftWing.addBox(0.0F, 0.0F, 0.0F, 13, 1, 9, 0.0F);
-        this.tailStart = new ModelRenderer(this, 26, 0);
-        this.tailStart.setRotationPoint(-1.4F, 17.0F, 10.1F);
-        this.tailStart.addBox(0.0F, 0.0F, 0.0F, 3, 2, 6, 0.0F);
-        this.tailEnd = new ModelRenderer(this, 46, 0);
-        this.tailEnd.setRotationPoint(1.0F, 0.0F, 6.0F);
-        this.tailEnd.addBox(0.0F, 0.0F, 0.0F, 1, 1, 6, 0.0F);
-        this.rightWing = new ModelRenderer(this, 44, 20);
-        this.rightWing.setRotationPoint(-13.0F, 0.0F, 0.0F);
-        this.rightWing.addBox(0.0F, 0.0F, 0.0F, 13, 1, 9, 0.0F);
-        this.head = new ModelRenderer(this, 0, 0);
-        this.head.setRotationPoint(0.0F, 18.0F, 1.27F);
-        this.head.addBox(-3.4F, 0.0F, -5.0F, 7, 3, 5, 0.0F);
-        this.bodyMiddle = new ModelRenderer(this, 28, 8);
-        this.bodyMiddle.setRotationPoint(-2.4F, 17.0F, 1.1F);
-        this.bodyMiddle.addBox(0.0F, 0.0F, 0.0F, 5, 3, 9, 0.0F);
-        this.body = new ModelRenderer(this, 56, 8);
-        this.body.setRotationPoint(-8.4F, 17.0F, 1.1F);
-        this.body.addBox(0.0F, 0.0F, 0.0F, 6, 2, 9, 0.0F);
-        this.bodyLeft.addChild(this.leftWing);
-        this.tailStart.addChild(this.tailEnd);
-        this.body.addChild(this.rightWing);
-    }
-
-    public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        this.bodyLeft.render(f5);
-        this.tailStart.render(f5);
-        this.head.render(f5);
-        this.bodyMiddle.render(f5);
-        this.body.render(f5);
-    }
-
-    private void setRotation(ModelRenderer model, float x, float y, float z)
-    {
-        model.rotateAngleX = x;
-        model.rotateAngleY = y;
-        model.rotateAngleZ = z;
-    }
-
-    public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5, Entity entity)
-    {
-        super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-    }
-
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureFluid.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureFluid.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/FeatureFluid.java	(date 1525605768000)
@@ -1,117 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public class FeatureFluid extends Feature
-{
-    private final IBlockState blockToSpawn;
-    private final IBlockState targetBlock;
-    private final boolean hidden;
-
-    public FeatureFluid(Biome biome, NetherBiome.BiomeFeature feature)
-    {
-        super(biome, feature);
-
-        blockToSpawn = BlockUtil.getBlock(feature.getBlockToSpawn(), "minecraft:air");
-        targetBlock = BlockUtil.getBlock(feature.getTargetBlock(), "minecraft:air");
-        hidden = feature.isHidden();
-    }
-
-    @Override
-    public boolean generate(World world, BlockPos pos, Random rand)
-    {
-        if(world.getBlockState(pos.up()) != targetBlock)
-        {
-            return false;
-        }
-        else if(!world.isAirBlock(pos) && world.getBlockState(pos) != targetBlock)
-        {
-            return false;
-        }
-        else
-        {
-            int i = 0;
-
-            if(world.getBlockState(pos.west()) == targetBlock)
-            {
-                ++i;
-            }
-
-            if(world.getBlockState(pos.east()) == targetBlock)
-            {
-                ++i;
-            }
-
-            if(world.getBlockState(pos.north()) == targetBlock)
-            {
-                ++i;
-            }
-
-            if(world.getBlockState(pos.south()) == targetBlock)
-            {
-                ++i;
-            }
-
-            if(world.getBlockState(pos.down()) == targetBlock)
-            {
-                ++i;
-            }
-
-            int j = 0;
-
-            if(world.isAirBlock(pos.west()))
-            {
-                ++j;
-            }
-
-            if(world.isAirBlock(pos.east()))
-            {
-                ++j;
-            }
-
-            if(world.isAirBlock(pos.north()))
-            {
-                ++j;
-            }
-
-            if(world.isAirBlock(pos.south()))
-            {
-                ++j;
-            }
-
-            if(world.isAirBlock(pos.down()))
-            {
-                ++j;
-            }
-
-            if(!hidden && i == 4 && j == 1 || i == 5)
-            {
-                IBlockState state = blockToSpawn;
-                world.setBlockState(pos, state, 2);
-                world.immediateBlockTick(pos, state, rand);
-            }
-
-            return true;
-        }
-    }
-
-    @Override
-    public boolean canGenerate()
-    {
-        return !(blockToSpawn == Blocks.AIR.getDefaultState() || targetBlock == Blocks.AIR.getDefaultState());
-    }
-
-    @Override
-    public FeatureType getType()
-    {
-        return FeatureType.FLUID;
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseAxe.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseAxe.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseAxe.java	(date 1525605768000)
@@ -1,14 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.tools;
-
-import net.minecraft.creativetab.CreativeTabs;
-import net.thegaminghuskymc.huskylib2.items.ItemModAxe;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BaseAxe extends ItemModAxe {
-
-    public BaseAxe(String name, ToolMaterial material) {
-        super(material.getAttackDamage(), 1.0f, material, name, MOD_ID);
-        setCreativeTab(CreativeTabs.TOOLS);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/Feature.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/Feature.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/feature/Feature.java	(date 1525605768000)
@@ -1,92 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.feature;
-
-import com.google.common.base.Strings;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.thegaminghuskymc.mcaddon.world.biome.NetherBiome;
-
-import java.util.Random;
-
-public abstract class Feature
-{
-    private final Biome biome;
-    private final int rarity;
-    private final int minHeight;
-    private final int maxHeight;
-    private final boolean randomRarity;
-    private final boolean superRare;
-
-    public Feature(Biome biomeIn, NetherBiome.BiomeFeature feature)
-    {
-        biome = biomeIn;
-        rarity = feature.getRarity() <= 0 ? 10 : feature.getRarity();
-        minHeight = feature.getMinHeight() <= 0 || feature.getMinHeight() >= 128 ? 4 : feature.getMinHeight();
-        maxHeight = feature.getMaxHeight() >= 120 || feature.getMaxHeight() <= 0 ? 108 : feature.getMaxHeight();
-        randomRarity = feature.useRandomRarity();
-        superRare = feature.isSuperRare();
-    }
-
-    public abstract boolean generate(World world, BlockPos pos, Random rand);
-
-    public abstract boolean canGenerate();
-
-    public abstract FeatureType getType();
-
-    public Biome getBiome()
-    {
-        return biome;
-    }
-
-    public int getRarity()
-    {
-        return rarity;
-    }
-
-    public int getMinHeight()
-    {
-        return minHeight;
-    }
-
-    public int getMaxHeight()
-    {
-        return maxHeight;
-    }
-
-    public boolean useRandomRarity()
-    {
-        return randomRarity;
-    }
-
-    public boolean isSuperRare()
-    {
-        return superRare;
-    }
-
-    public enum FeatureType
-    {
-        SCATTERED,
-        CLUMPED,
-        ORE,
-        FLUID,
-        POOL,
-        STRUCTURE,
-        UNKNOWN;
-
-        public static FeatureType getFromString(String string)
-        {
-            if(!Strings.isNullOrEmpty(string))
-            {
-                for(FeatureType type : values())
-                {
-                    if(type.name().equalsIgnoreCase(string))
-                    {
-                        return type;
-                    }
-                }
-            }
-
-            return UNKNOWN;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumCoralColor.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumCoralColor.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumCoralColor.java	(date 1525605768000)
@@ -1,81 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-public enum EnumCoralColor implements IStringSerializable
-{
-    YELLOW(0, "yellow", 16701501),
-    PINK(1, "pink", 15961002),
-    PURPLE(2, "purple", 8991416),
-    BLUE(3, "blue", 3949738),
-    RED(4, "red", 11546150);
-
-    private static final EnumCoralColor[] META_LOOKUP = new EnumCoralColor[values().length];
-    private final int meta;
-    private final String name;
-    private final int colorValue;
-    private final float[] colorComponentValues;
-
-    private EnumCoralColor(int metaIn, String nameIn, int colorValueIn)
-    {
-        this.meta = metaIn;
-        this.name = nameIn;
-        this.colorValue = colorValueIn;
-        int i = (colorValueIn & 16711680) >> 16;
-        int j = (colorValueIn & 65280) >> 8;
-        int k = (colorValueIn & 255);
-        this.colorComponentValues = new float[] {(float)i / 255.0F, (float)j / 255.0F, (float)k / 255.0F};
-    }
-
-    public int getMetadata()
-    {
-        return this.meta;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public String getDyeColorName()
-    {
-        return this.name;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public int getColorValue()
-    {
-        return this.colorValue;
-    }
-
-    public float[] getColorComponentValues()
-    {
-        return this.colorComponentValues;
-    }
-
-    public static EnumCoralColor byMetadata(int meta)
-    {
-        if (meta < 0 || meta >= META_LOOKUP.length)
-        {
-            meta = 0;
-        }
-
-        return META_LOOKUP[meta];
-    }
-
-    public String toString()
-    {
-        return this.name;
-    }
-
-    public String getName()
-    {
-        return this.name;
-    }
-
-    static
-    {
-        for (EnumCoralColor enumdyecolor : values())
-        {
-            META_LOOKUP[enumdyecolor.getMetadata()] = enumdyecolor;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderRedPhantom.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderRedPhantom.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderRedPhantom.java	(date 1525605768000)
@@ -1,25 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityPhantom;
-import net.thegaminghuskymc.mcaddon.entity.EntityRedPhantom;
-import net.thegaminghuskymc.mcaddon.entity.render.layer.LayerPhantomEyes;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelPhantom;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-public class RenderRedPhantom extends RenderLiving<EntityRedPhantom> {
-
-    public static final ResourceLocation SCORP_TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/phantom/red_phantom.png");
-
-    public RenderRedPhantom(RenderManager manager) {
-        super(manager, new ModelPhantom(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityRedPhantom entity)
-    {
-        return  SCORP_TEXTURE;
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationData.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationData.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/GenerationData.java	(date 1525605768000)
@@ -1,100 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   GenerationData.java
-
-package net.thegaminghuskymc.mcaddon.world;
-
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagList;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.MapStorage;
-import net.minecraft.world.storage.WorldSavedData;
-
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
-// Referenced classes of package elucent.hmca.world:
-//            GenerationNode
-
-public class GenerationData extends WorldSavedData
-{
-
-    public GenerationData(String name)
-    {
-        super(name);
-        nodes = new HashSet();
-    }
-
-    public GenerationData()
-    {
-        super("hmca_generation_data");
-        nodes = new HashSet();
-    }
-
-    public void addNode(GenerationNode node)
-    {
-        nodes.add(node);
-        markDirty();
-    }
-
-    public void readFromNBT(NBTTagCompound nbt)
-    {
-        NBTTagList list = nbt.getTagList("gen_data_nodes", 10);
-        for(int i = 0; i < list.tagCount(); i++)
-            nodes.add(new GenerationNode(list.getCompoundTagAt(i)));
-
-    }
-
-    public NBTTagCompound writeToNBT(NBTTagCompound compound)
-    {
-        NBTTagList list = new NBTTagList();
-        GenerationNode g;
-        for(Iterator iterator = nodes.iterator(); iterator.hasNext(); list.appendTag(g.writeToNBT()))
-            g = (GenerationNode)iterator.next();
-
-        compound.setTag("gen_data_nodes", list);
-        return compound;
-    }
-
-    public static GenerationData get(World w)
-    {
-        MapStorage s = w.getPerWorldStorage();
-        GenerationData d = (GenerationData)s.getOrLoadData(GenerationData.class, "hmca_generation_data");
-        if(d == null)
-        {
-            d = new GenerationData();
-            s.setData("hmca_generation_data", d);
-        }
-        return d;
-    }
-
-    public void update(World world)
-    {
-        Set toDelete = new HashSet();
-        Iterator iterator = nodes.iterator();
-        do
-        {
-            if(!iterator.hasNext())
-                break;
-            GenerationNode n = (GenerationNode)iterator.next();
-            if(n != null)
-                n.update(world);
-            if(!n.isAlive || n == null)
-                toDelete.add(n);
-        } while(true);
-        iterator = toDelete.iterator();
-        do
-        {
-            if(!iterator.hasNext())
-                break;
-            GenerationNode n = (GenerationNode)iterator.next();
-            if(nodes.contains(n))
-                nodes.remove(n);
-        } while(true);
-        toDelete.clear();
-    }
-
-    public Set nodes;
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeDecoratorNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeDecoratorNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/BiomeDecoratorNether.java	(date 1525605768000)
@@ -1,14 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.World;
-import net.minecraft.world.biome.Biome;
-import net.minecraft.world.biome.BiomeDecorator;
-
-import java.util.Random;
-
-public class BiomeDecoratorNether extends BiomeDecorator {
-    @Override
-    public void decorate(World world, Random rand, Biome biome, BlockPos pos) {
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityCod.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityCod.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityCod.java	(date 1525605768000)
@@ -1,245 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.MoverType;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.EntityAIBase;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.passive.EntityWaterMob;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-
-public class EntityCod extends EntityWaterMob {
-
-    public float squidPitch;
-    public float prevSquidPitch;
-    public float squidYaw;
-    public float prevSquidYaw;
-    /**
-     * appears to be rotation in radians; we already have pitch & yaw, so this completes the triumvirate.
-     */
-    public float squidRotation;
-    /**
-     * previous squidRotation in radians
-     */
-    public float prevSquidRotation;
-    /**
-     * angle of the tentacles in radians
-     */
-    public float tentacleAngle;
-    /**
-     * the last calculated angle of the tentacles in radians
-     */
-    public float lastTentacleAngle;
-    private float randomMotionSpeed;
-    /**
-     * change in squidRotation in radians.
-     */
-    private float rotationVelocity;
-    private float rotateSpeed;
-    private float randomMotionVecX;
-    private float randomMotionVecY;
-    private float randomMotionVecZ;
-
-    public EntityCod(World worldIn) {
-        super(worldIn);
-        this.setSize(0.5F, 0.3F);
-        this.rand.setSeed((long) (1 + this.getEntityId()));
-        this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(0, new EntityCod.AIMoveRandom(this));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(10.0D);
-    }
-
-    public float getEyeHeight() {
-        return this.height;
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_SQUID_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_SQUID_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_SQUID_DEATH;
-    }
-
-    /**
-     * Returns the volume for the sounds this mob makes.
-     */
-    protected float getSoundVolume() {
-        return 0.4F;
-    }
-
-    /**
-     * returns if this entity triggers Block.onEntityWalking on the animations.blocks they walk on. used for spiders and wolves to
-     * prevent them from trampling crops
-     */
-    protected boolean canTriggerWalking() {
-        return false;
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_SQUID;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        super.onLivingUpdate();
-        this.prevSquidPitch = this.squidPitch;
-        this.prevSquidYaw = this.squidYaw;
-        this.prevSquidRotation = this.squidRotation;
-        this.lastTentacleAngle = this.tentacleAngle;
-        this.squidRotation += this.rotationVelocity;
-
-        if ((double) this.squidRotation > (Math.PI * 2D)) {
-            if (this.world.isRemote) {
-                this.squidRotation = ((float) Math.PI * 2F);
-            } else {
-                this.squidRotation = (float) ((double) this.squidRotation - (Math.PI * 2D));
-
-                if (this.rand.nextInt(10) == 0) {
-                    this.rotationVelocity = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
-                }
-
-                this.world.setEntityState(this, (byte) 19);
-            }
-        }
-
-        if (this.inWater) {
-            if (this.squidRotation < (float) Math.PI) {
-                float f = this.squidRotation / (float) Math.PI;
-                this.tentacleAngle = MathHelper.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
-
-                if ((double) f > 0.75D) {
-                    this.randomMotionSpeed = 1.0F;
-                    this.rotateSpeed = 1.0F;
-                } else {
-                    this.rotateSpeed *= 0.8F;
-                }
-            } else {
-                this.tentacleAngle = 0.0F;
-                this.randomMotionSpeed *= 0.9F;
-                this.rotateSpeed *= 0.99F;
-            }
-
-            if (!this.world.isRemote) {
-                this.motionX = (double) (this.randomMotionVecX * this.randomMotionSpeed);
-                this.motionY = (double) (this.randomMotionVecY * this.randomMotionSpeed);
-                this.motionZ = (double) (this.randomMotionVecZ * this.randomMotionSpeed);
-            }
-
-            float f1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-            this.renderYawOffset += (-((float) MathHelper.atan2(this.motionX, this.motionZ)) * (180F / (float) Math.PI) - this.renderYawOffset) * 0.1F;
-            this.rotationYaw = this.renderYawOffset;
-            this.squidYaw = (float) ((double) this.squidYaw + Math.PI * (double) this.rotateSpeed * 1.5D);
-            this.squidPitch += (-((float) MathHelper.atan2((double) f1, this.motionY)) * (180F / (float) Math.PI) - this.squidPitch) * 0.1F;
-        } else {
-            this.tentacleAngle = MathHelper.abs(MathHelper.sin(this.squidRotation)) * (float) Math.PI * 0.25F;
-
-            if (!this.world.isRemote) {
-                this.motionX = 0.0D;
-                this.motionZ = 0.0D;
-
-                if (this.isPotionActive(MobEffects.LEVITATION)) {
-                    this.motionY += 0.05D * (double) (this.getActivePotionEffect(MobEffects.LEVITATION).getAmplifier() + 1) - this.motionY;
-                } else if (!this.hasNoGravity()) {
-                    this.motionY -= 0.08D;
-                }
-
-                this.motionY *= 0.9800000190734863D;
-            }
-
-            this.squidPitch = (float) ((double) this.squidPitch + (double) (-90.0F - this.squidPitch) * 0.02D);
-        }
-    }
-
-    public void travel(float strafe, float vertical, float forward) {
-        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
-    }
-
-    /**
-     * Checks if the entity's current position is a valid location to spawn this entity.
-     */
-    public boolean getCanSpawnHere() {
-        return this.posY > 45.0D && this.posY < (double) this.world.getSeaLevel() && super.getCanSpawnHere();
-    }
-
-    /**
-     * Handler for {@link World#setEntityState}
-     */
-    @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id) {
-        if (id == 19) {
-            this.squidRotation = 0.0F;
-        } else {
-            super.handleStatusUpdate(id);
-        }
-    }
-
-    public void setMovementVector(float randomMotionVecXIn, float randomMotionVecYIn, float randomMotionVecZIn) {
-        this.randomMotionVecX = randomMotionVecXIn;
-        this.randomMotionVecY = randomMotionVecYIn;
-        this.randomMotionVecZ = randomMotionVecZIn;
-    }
-
-    public boolean hasMovementVector() {
-        return this.randomMotionVecX != 0.0F || this.randomMotionVecY != 0.0F || this.randomMotionVecZ != 0.0F;
-    }
-
-    static class AIMoveRandom extends EntityAIBase {
-        private final EntityCod squid;
-
-        public AIMoveRandom(EntityCod p_i45859_1_) {
-            this.squid = p_i45859_1_;
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            return true;
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            int i = this.squid.getIdleTime();
-
-            if (i > 100) {
-                this.squid.setMovementVector(0.0F, 0.0F, 0.0F);
-            } else if (this.squid.getRNG().nextInt(50) == 0 || !this.squid.inWater || !this.squid.hasMovementVector()) {
-                float f = this.squid.getRNG().nextFloat() * ((float) Math.PI * 2F);
-                float f1 = MathHelper.cos(f) * 0.2F;
-                float f2 = -0.1F + this.squid.getRNG().nextFloat() * 0.2F;
-                float f3 = MathHelper.sin(f) * 0.2F;
-                this.squid.setMovementVector(f1, f2, f3);
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EventHandler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EventHandler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/util/handlers/EventHandler.java	(date 1525605768000)
@@ -1,100 +0,0 @@
-package net.thegaminghuskymc.mcaddon.util.handlers;
-
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.entity.item.EntityItem;
-import net.minecraft.entity.monster.EntityWitherSkeleton;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Enchantments;
-import net.minecraft.init.Items;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.DimensionType;
-import net.minecraft.world.World;
-import net.minecraftforge.common.util.FakePlayer;
-import net.minecraftforge.event.entity.living.LivingDropsEvent;
-import net.minecraftforge.event.world.BlockEvent;
-import net.minecraftforge.fml.common.Mod;
-import net.minecraftforge.fml.common.eventhandler.Event;
-import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
-import net.thegaminghuskymc.mcaddon.init.MCAddonItems;
-
-import java.util.ListIterator;
-import java.util.Random;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-@SuppressWarnings("ConstantConditions")
-@Mod.EventBusSubscriber(modid = MOD_ID)
-public class EventHandler {
-
-    @SubscribeEvent
-    public static void onBlockBreak(BlockEvent.BreakEvent event) {
-        World world = event.getWorld();
-        BlockPos pos = event.getPos();
-        IBlockState state = event.getState();
-
-        if (!(event.getPlayer() instanceof FakePlayer)) {
-            EntityPlayer player = event.getPlayer();
-
-            if (state.getBlock() == Blocks.MAGMA) {
-                if (ConfigHandler.block.magma.turnIntoLava) {
-                    if (EnchantmentHelper.getEnchantmentLevel(Enchantments.SILK_TOUCH, player.getHeldItemMainhand()) == 0) {
-                        world.setBlockState(pos, Blocks.LAVA.getDefaultState(), 3);
-                        player.getHeldItemMainhand().damageItem(1, player);
-                        event.setCanceled(true);
-                    }
-                }
-            }
-        }
-    }
-
-    @SubscribeEvent
-    public static void onBlockPlaced(BlockEvent.PlaceEvent event) {
-        World world = event.getWorld();
-        BlockPos pos = event.getPos();
-        IBlockState state = event.getState();
-        EntityPlayer player = event.getPlayer();
-
-        if (state.getBlock() == Blocks.BEDROCK) {
-            if (player.dimension != DimensionType.NETHER.getId() || pos.getY() < 120) {
-                event.setCanceled(true);
-            }
-        }
-    }
-
-    @SubscribeEvent
-    public static void onCreateFluidSource(BlockEvent.CreateFluidSourceEvent event) {
-        World world = event.getWorld();
-        BlockPos pos = event.getPos();
-        IBlockState state = event.getState();
-
-        if (world.provider.getDimension() == DimensionType.NETHER.getId()) {
-            if (state.getBlock() == Blocks.LAVA || state.getBlock() == Blocks.FLOWING_LAVA) {
-                event.setResult(ConfigHandler.dimension.nether.isLavaInfinite ? Event.Result.ALLOW : Event.Result.DEFAULT);
-            }
-        }
-    }
-
-    @SubscribeEvent
-    public static void onLivingDrops(LivingDropsEvent event) {
-        Random rand = new Random();
-        BlockPos deathPoint = event.getEntity().getPosition();
-
-        if (event.getEntity() instanceof EntityWitherSkeleton) {
-            ListIterator<EntityItem> iter = event.getDrops().listIterator();
-
-            while (iter.hasNext()) {
-                EntityItem entityItem = iter.next();
-                ItemStack stack = entityItem.getItem();
-
-                if (stack.getItem() == Items.BONE || stack.getItem() == Items.COAL) {
-                    iter.remove();
-                }
-            }
-
-            event.getDrops().add(new EntityItem(event.getEntity().world, deathPoint.getX(), deathPoint.getY(), deathPoint.getZ(), new ItemStack(MCAddonItems.witherBone, rand.nextInt(3), 0)));
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftStart.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftStart.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/structure/StructureMineshaftStart.java	(date 1525605768000)
@@ -1,42 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.structure;
-
-import net.minecraft.world.World;
-import net.minecraft.world.gen.structure.StructureComponent;
-import net.minecraft.world.gen.structure.StructureStart;
-
-import java.util.Random;
-
-public class StructureMineshaftStart extends StructureStart
-{
-    private MapGenMineshaft.Type mineShaftType;
-
-    public StructureMineshaftStart()
-    {
-    }
-
-    public StructureMineshaftStart(World p_i47149_1_, Random p_i47149_2_, int p_i47149_3_, int p_i47149_4_, MapGenMineshaft.Type p_i47149_5_)
-    {
-        super(p_i47149_3_, p_i47149_4_);
-        this.mineShaftType = p_i47149_5_;
-        StructureMineshaftPieces.Room structuremineshaftpieces$room = new StructureMineshaftPieces.Room(0, p_i47149_2_, (p_i47149_3_ << 4) + 2, (p_i47149_4_ << 4) + 2, this.mineShaftType);
-        this.components.add(structuremineshaftpieces$room);
-        structuremineshaftpieces$room.buildComponent(structuremineshaftpieces$room, this.components, p_i47149_2_);
-        this.updateBoundingBox();
-
-        if (p_i47149_5_ == MapGenMineshaft.Type.MESA)
-        {
-            int i = -5;
-            int j = p_i47149_1_.getSeaLevel() - this.boundingBox.maxY + this.boundingBox.getYSize() / 2 - -5;
-            this.boundingBox.offset(0, j, 0);
-
-            for (StructureComponent structurecomponent : this.components)
-            {
-                structurecomponent.offset(0, j, 0);
-            }
-        }
-        else
-        {
-            this.markAvailableHeight(p_i47149_1_, p_i47149_2_, 10);
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiomeManager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiomeManager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/biome/NetherBiomeManager.java	(date 1525605768000)
@@ -1,328 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.biome;
-
-import com.google.common.base.Charsets;
-import com.google.common.base.Strings;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.io.Files;
-import com.google.gson.Gson;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EnumCreatureType;
-import net.minecraft.init.Blocks;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.WeightedRandom;
-import net.minecraft.world.biome.Biome;
-import net.minecraftforge.common.BiomeManager;
-import net.minecraftforge.fml.common.registry.ForgeRegistries;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.util.BlockUtil;
-import net.thegaminghuskymc.mcaddon.util.FileUtil;
-import net.thegaminghuskymc.mcaddon.world.gen.feature.*;
-import net.thegaminghuskymc.mcaddon.world.gen.layer.GenLayerNether;
-import org.apache.commons.io.FileUtils;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-
-@SuppressWarnings("ConstantConditions")
-public class NetherBiomeManager {
-    private static final Logger LOGGER = LogManager.getLogger("Husky's Minecraft Additions | NetherBiomeManager");
-
-    public static void postInit(File directory) {
-        try {
-            if (!directory.exists()) {
-                directory.mkdirs();
-            }
-
-            LOGGER.info("Copying the Biome List Directory to the config folder.");
-
-            if (Main.isInDevEnv) {
-                FileUtils.copyDirectory(new File(Main.class.getResource("/assets/hmca/biome_lists").getFile()), directory);
-            } else {
-                FileUtil.extractFromJar("/assets/hmca/biome_lists", directory.getPath());
-            }
-        } catch (IOException e) {
-            LOGGER.fatal("The attempt to copy the Biome List Directory to the config folder was unsuccessful.");
-            LOGGER.fatal(e);
-        }
-
-        Gson gson = new Gson();
-        List<File> netherBiomeFiles = Lists.newArrayList(directory.listFiles());
-
-        try {
-            for (File netherBiomeFile : netherBiomeFiles) {
-                String jsonText = Files.toString(netherBiomeFile, Charsets.UTF_8);
-                NetherBiome.BiomeList biomeList = gson.fromJson(jsonText, NetherBiome.BiomeList.class);
-
-                LOGGER.info("Adding biomes from the " + biomeList.getName() + ".");
-
-                for (NetherBiome.Mod biomeMod : biomeList.getMods()) {
-                    for (NetherBiome netherBiome : biomeMod.getBiomes()) {
-                        ResourceLocation biomeRegistryName = new ResourceLocation(biomeMod.getId(), netherBiome.getId());
-                        Biome biome = ForgeRegistries.BIOMES.getValue(biomeRegistryName);
-
-                        if (biome == null) {
-                            continue;
-                        }
-
-                        NetherBiome.BiomeBlock biomeTopBlock = netherBiome.getTopBlock();
-                        NetherBiome.BiomeBlock biomeFillerBlock = netherBiome.getFillerBlock();
-                        NetherBiome.BiomeBlock biomeOceanBlock = netherBiome.getOceanBlock();
-                        IBlockState topBlock = biome.topBlock;
-                        IBlockState fillerBlock = biome.fillerBlock;
-                        IBlockState oceanBlock = Blocks.LAVA.getDefaultState();
-
-                        if (biomeTopBlock != null) {
-                            IBlockState state = BlockUtil.getBlock(biomeTopBlock, "minecraft:air");
-                            topBlock = state.getBlock() == Blocks.AIR ? topBlock : state;
-
-                            LOGGER.info("Set the " + biome.getRegistryName().toString() + " biome's top Block to " + topBlock.getBlock().getRegistryName().toString() + " with a meta of " + topBlock.getBlock().getMetaFromState(topBlock) + ".");
-                        }
-                        if (biomeFillerBlock != null) {
-                            IBlockState state = BlockUtil.getBlock(biomeFillerBlock, "minecraft:air");
-                            fillerBlock = state.getBlock() == Blocks.AIR ? fillerBlock : state;
-
-                            LOGGER.info("Set the " + biome.getRegistryName().toString() + " biome's filler Block to " + fillerBlock.getBlock().getRegistryName().toString() + " with a meta of " + fillerBlock.getBlock().getMetaFromState(fillerBlock) + ".");
-                        }
-                        if (biomeOceanBlock != null) {
-                            IBlockState state = BlockUtil.getBlock(biomeOceanBlock, "minecraft:air");
-                            oceanBlock = state.getBlock() == Blocks.AIR ? oceanBlock : state;
-
-                            LOGGER.info("Set the " + biome.getRegistryName().toString() + " biome's ocean Block to " + oceanBlock.getBlock().getRegistryName().toString() + " with a meta of " + oceanBlock.getBlock().getMetaFromState(oceanBlock) + ".");
-                        }
-
-                        Map<EnumCreatureType, List<Biome.SpawnListEntry>> entitySpawnList = Maps.newHashMap();
-
-                        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
-                            entitySpawnList.put(creatureType, Lists.newArrayList());
-                        }
-
-                        if (netherBiome.getEntitySpawnList() != null) {
-                            for (NetherBiome.BiomeEntity entity : netherBiome.getEntitySpawnList()) {
-                                for (EnumCreatureType creatureType : EnumCreatureType.values()) {
-                                    if (creatureType.toString().equalsIgnoreCase(entity.getCreatureType())) {
-                                        Class<? extends Entity> cls = ForgeRegistries.ENTITIES.getValue(new ResourceLocation(entity.getId())).getEntityClass();
-
-                                        if (cls != null && EntityLiving.class.isAssignableFrom(cls)) {
-                                            entitySpawnList.get(creatureType).add(new Biome.SpawnListEntry((Class<? extends EntityLiving>) cls, entity.getWeight(), entity.getMinGroupCount(), entity.getMaxGroupCount()));
-                                            LOGGER.info("Added the " + entity.getId() + " Entity to the " + biome.getRegistryName().toString() + " biome.");
-                                        }
-                                    }
-                                }
-                            }
-                        }
-
-                        List<Feature> features = Lists.newArrayList();
-
-                        if (netherBiome.getFeatureList() != null) {
-                            for (NetherBiome.BiomeFeature biomeFeature : netherBiome.getFeatureList()) {
-                                Feature.FeatureType featureType = Feature.FeatureType.getFromString(biomeFeature.getFeatureType());
-                                Feature feature;
-
-                                if (featureType == Feature.FeatureType.SCATTERED) {
-                                    feature = new FeatureScattered(biome, biomeFeature);
-                                } else if (featureType == Feature.FeatureType.CLUMPED) {
-                                    feature = new FeatureClumped(biome, biomeFeature);
-                                } else if (featureType == Feature.FeatureType.ORE) {
-                                    feature = new FeatureOre(biome, biomeFeature);
-                                } else if (featureType == Feature.FeatureType.FLUID) {
-                                    feature = new FeatureFluid(biome, biomeFeature);
-                                } else if (featureType == Feature.FeatureType.POOL) {
-                                    feature = new FeaturePool(biome, biomeFeature);
-                                } else if (featureType == Feature.FeatureType.STRUCTURE) {
-                                    feature = new FeatureStructure(biome, biomeFeature);
-                                } else {
-                                    LOGGER.info("A biome feature with the type of " + biomeFeature.getFeatureType() + " is unknown.");
-                                    continue;
-                                }
-
-                                features.add(feature);
-                            }
-                        }
-
-                        NetherBiomeManager.NetherBiomeType.getFromString(netherBiome.getClimateType()).addBiome(biome, netherBiome.getWeight(), topBlock, fillerBlock, oceanBlock, entitySpawnList, features);
-                        LOGGER.info("Added the " + biome.getRegistryName().toString() + " biome from the " + biomeList.getName() + " to the Nether.");
-                    }
-                }
-            }
-        } catch (IOException e) {
-            LOGGER.fatal("NetherEx was unable to read the Biome lists.");
-            LOGGER.fatal(e);
-        }
-    }
-
-    public static List<NetherBiomeEntry> getAllBiomeEntries() {
-        List<NetherBiomeEntry> biomes = Lists.newArrayList();
-
-        for (NetherBiomeType biomeType : NetherBiomeType.values()) {
-            biomes.addAll(biomeType.getBiomeEntries());
-        }
-
-        return biomes;
-    }
-
-    public static Biome getRandomBiome(List<NetherBiomeEntry> biomeEntryList, Random rand) {
-        return WeightedRandom.getRandomItem(biomeEntryList, rand.nextInt(WeightedRandom.getTotalWeight(biomeEntryList))).getBiome();
-    }
-
-    public static Biome getRandomBiome(List<NetherBiomeEntry> biomeEntryList, GenLayerNether layer) {
-        return WeightedRandom.getRandomItem(biomeEntryList, layer.nextInt(WeightedRandom.getTotalWeight(biomeEntryList))).getBiome();
-    }
-
-    public static IBlockState getBiomeTopBlock(Biome biome) {
-        Map<Biome, NetherBiomeEntry> biomeEntryMap = NetherBiomeType.getFromBiome(biome).getBiomeEntryMap();
-
-        if (biomeEntryMap.containsKey(biome)) {
-            return biomeEntryMap.get(biome).getTopBlock();
-        }
-
-        return biome.topBlock;
-    }
-
-    public static IBlockState getBiomeFillerBlock(Biome biome) {
-        Map<Biome, NetherBiomeEntry> biomeEntryMap = NetherBiomeType.getFromBiome(biome).getBiomeEntryMap();
-
-        if (biomeEntryMap.containsKey(biome)) {
-            return biomeEntryMap.get(biome).getFillerBlock();
-        }
-
-        return biome.fillerBlock;
-    }
-
-    public static IBlockState getBiomeOceanBlock(Biome biome) {
-        Map<Biome, NetherBiomeEntry> biomeEntryMap = NetherBiomeType.getFromBiome(biome).getBiomeEntryMap();
-
-        if (biomeEntryMap.containsKey(biome)) {
-            return biomeEntryMap.get(biome).getOceanBlock();
-        }
-
-        return Blocks.LAVA.getDefaultState();
-    }
-
-    public static Map<EnumCreatureType, List<Biome.SpawnListEntry>> getBiomeEntitySpawnList(Biome biome) {
-        Map<Biome, NetherBiomeEntry> biomeEntryMap = NetherBiomeType.getFromBiome(biome).getBiomeEntryMap();
-
-        if (biomeEntryMap.containsKey(biome)) {
-            return biomeEntryMap.get(biome).getEntitySpawnList();
-        }
-
-        Map<EnumCreatureType, List<Biome.SpawnListEntry>> entitySpawnList = Maps.newHashMap();
-
-        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
-            entitySpawnList.put(creatureType, Lists.newArrayList());
-        }
-
-        return entitySpawnList;
-    }
-
-    public static List<Feature> getBiomeFeatures(Biome biome) {
-        Map<Biome, NetherBiomeEntry> biomeEntryMap = NetherBiomeType.getFromBiome(biome).getBiomeEntryMap();
-
-        if (biomeEntryMap.containsKey(biome)) {
-            return biomeEntryMap.get(biome).getFeatures();
-        }
-
-        return Lists.newArrayList();
-    }
-
-    public enum NetherBiomeType {
-        HOT,
-        WARM,
-        TEMPERATE,
-        COOL,
-        COLD;
-
-        private static final Map<Biome, NetherBiomeEntry> biomeEntryMap = Maps.newHashMap();
-
-        public static NetherBiomeType getFromBiome(Biome biome) {
-            for (NetherBiomeType biomeType : values()) {
-                for (NetherBiomeEntry biomeEntry : biomeType.getBiomeEntries()) {
-                    if (biomeEntry.biome == biome) {
-                        return biomeType;
-                    }
-                }
-            }
-
-            return TEMPERATE;
-        }
-
-        public static NetherBiomeType getFromString(String string) {
-            if (!Strings.isNullOrEmpty(string)) {
-                for (NetherBiomeType biomeType : values()) {
-                    if (biomeType.name().equalsIgnoreCase(string)) {
-                        return biomeType;
-                    }
-                }
-            }
-
-            return TEMPERATE;
-        }
-
-        public void addBiome(Biome biome, int weight, IBlockState topBlock, IBlockState fillerBlock, IBlockState oceanBlock, Map<EnumCreatureType, List<Biome.SpawnListEntry>> entitySpawnList, List<Feature> features) {
-            biomeEntryMap.put(biome, new NetherBiomeEntry(biome, weight, topBlock, fillerBlock, oceanBlock, entitySpawnList, features));
-        }
-
-        public Map<Biome, NetherBiomeEntry> getBiomeEntryMap() {
-            return ImmutableMap.copyOf(biomeEntryMap);
-        }
-
-        public List<NetherBiomeEntry> getBiomeEntries() {
-            return ImmutableList.copyOf(biomeEntryMap.values());
-        }
-    }
-
-    public static class NetherBiomeEntry extends BiomeManager.BiomeEntry {
-        private final IBlockState topBlock;
-        private final IBlockState fillerBlock;
-        private final IBlockState oceanBlock;
-        private final Map<EnumCreatureType, List<Biome.SpawnListEntry>> entitySpawnList;
-        private final List<Feature> features;
-
-        public NetherBiomeEntry(Biome biome, int weight, IBlockState topBlockIn, IBlockState fillerBlockIn, IBlockState oceanBlockIn, Map<EnumCreatureType, List<Biome.SpawnListEntry>> entitySpawnListIn, List<Feature> featuresIn) {
-            super(biome, weight <= 0 ? 10 : weight);
-
-            topBlock = topBlockIn;
-            fillerBlock = fillerBlockIn;
-            oceanBlock = oceanBlockIn;
-            entitySpawnList = entitySpawnListIn;
-            features = featuresIn;
-        }
-
-        public Biome getBiome() {
-            return biome;
-        }
-
-        public int getWeight() {
-            return itemWeight;
-        }
-
-        public IBlockState getTopBlock() {
-            return topBlock;
-        }
-
-        public IBlockState getFillerBlock() {
-            return fillerBlock;
-        }
-
-        public IBlockState getOceanBlock() {
-            return oceanBlock;
-        }
-
-        public Map<EnumCreatureType, List<Biome.SpawnListEntry>> getEntitySpawnList() {
-            return entitySpawnList;
-        }
-
-        public List<Feature> getFeatures() {
-            return features;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseShovel.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseShovel.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/items/base/tools/BaseShovel.java	(date 1525605768000)
@@ -1,13 +0,0 @@
-package net.thegaminghuskymc.mcaddon.items.base.tools;
-
-import net.thegaminghuskymc.huskylib2.items.ItemModSpade;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BaseShovel extends ItemModSpade  {
-
-    public BaseShovel(String name, ToolMaterial material)  {
-        super(material, name, MOD_ID);
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNewStoneVariants.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNewStoneVariants.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/properties/EnumNewStoneVariants.java	(date 1525605768000)
@@ -1,69 +0,0 @@
-package net.thegaminghuskymc.mcaddon.properties;
-
-import net.minecraft.util.IStringSerializable;
-
-public enum EnumNewStoneVariants implements IStringSerializable {
-
-    GRANITE_BRICKS(0, "granite_bricks"),
-    GRANITE_COBBLE(1, "granite_cobble"),
-    DIORITE_BRICKS(2, "diorite_bricks"),
-    DIORITE_COBBLE(3, "diorite_cobble"),
-    ANDESITE_BRICKS(4, "andesite_bricks"),
-    ANDESITE_COBBLE(5, "andesite_cobble"),
-    BASALT(6, "raw_basalt"),
-    BASALT_SMOOTH(7, "smooth_basalt"),
-    BASALT_CHISELED(8, "chiseled_basalt"),
-    BASALT_BRICKS(9, "basalt_bricks"),
-    BASALT_COBBLE(10, "basalt_cobble"),
-    MARBLE(11, "raw_marble"),
-    MARBLE_SMOOTH(12, "smooth_marble"),
-    MARBLE_CHISELED(13, "marble_chiseled"),
-    MARBLE_BRICKS(14, "marble_bricks"),
-    MARBLE_COBBLE(15, "marble_cobblestone"),
-    ASPHALT(16, "raw_asphalt"),
-    LIMESTONE(17, "raw_limestone"),
-    LIMESTONE_SMOOTH(18, "smooth_limestone"),
-    LIMESTONE_CHISELED(19, "limestone_chiseled"),
-    LIMESTONE_BRICKS(20, "limestone_bricks"),
-    METEORITE(21, "raw_meteorite"),
-    METEORITE_BRICKS(22, "meteorite_bricks"),
-    METEORITE_SMOOTH(23, "smooth_meteorite"),
-    FROSTY_STONE(24, "frosty_stone");
-
-    private static final EnumNewStoneVariants[] META_LOOKUP = new EnumNewStoneVariants[values().length];
-
-    static {
-        for (EnumNewStoneVariants blockstone$enumtype : values()) {
-            META_LOOKUP[blockstone$enumtype.getMetadata()] = blockstone$enumtype;
-        }
-    }
-
-    private final int meta;
-    private final String name;
-
-    EnumNewStoneVariants(int p_i46384_3_, String p_i46384_5_) {
-        this.meta = p_i46384_3_;
-        this.name = p_i46384_5_;
-    }
-
-    public static EnumNewStoneVariants byMetadata(int meta) {
-        if (meta < 0 || meta >= META_LOOKUP.length) {
-            meta = 0;
-        }
-
-        return META_LOOKUP[meta];
-    }
-
-    public int getMetadata() {
-        return this.meta;
-    }
-
-    public String toString() {
-        return this.name;
-    }
-
-    public String getName() {
-        return this.name;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosPiranha.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosPiranha.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosPiranha.java	(date 1525605768000)
@@ -1,115 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosPiranha.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import axa;
-import ayf;
-import ke;
-import lq;
-import md;
-
-public class ModelAtmosPiranha extends axa
-{
-
-    public ModelAtmosPiranha()
-    {
-        t = 64;
-        u = 32;
-        Body = new ayf(this, 0, 11);
-        Body.a(-1F, -3F, -7F, 2, 2, 7);
-        Body.a(0.0F, 18F, 0.0F);
-        Body.b(64, 32);
-        Body.i = true;
-        setRotation(Body, 0.0F, 0.0F, 0.0F);
-        Body2 = new ayf(this, 0, 20);
-        Body2.a(-1F, -1F, -6F, 2, 1, 8);
-        Body2.a(0.0F, 18F, -1F);
-        Body2.b(64, 32);
-        Body2.i = true;
-        setRotation(Body2, 0.0F, 0.0F, 0.0F);
-        Fin1 = new ayf(this, 0, 0);
-        Fin1.a(-0.5F, -3F, 0.0F, 1, 3, 1);
-        Fin1.a(0.0F, 17F, 0.0F);
-        Fin1.b(64, 32);
-        Fin1.i = true;
-        setRotation(Fin1, -0.6632251F, 0.0F, 0.0F);
-        Fin2 = new ayf(this, 0, 0);
-        Fin2.a(-0.5F, 0.0F, 0.0F, 1, 3, 1);
-        Fin2.a(0.0F, 17F, 0.0F);
-        Fin2.b(64, 32);
-        Fin2.i = true;
-        setRotation(Fin2, -0.6632251F, 0.0F, 0.0F);
-        Beak = new ayf(this, 0, 5);
-        Beak.a(-1F, 0.0F, -4F, 3, 2, 4);
-        Beak.a(-0.5F, 17F, -4F);
-        Beak.b(64, 32);
-        Beak.i = true;
-        setRotation(Beak, 0.2268928F, 0.0F, 0.0F);
-        Teeth = new ayf(this, 14, 0);
-        Teeth.a(-1F, -1F, -4F, 3, 1, 4);
-        Teeth.a(-0.5F, 17F, -4F);
-        Teeth.b(64, 32);
-        Teeth.i = true;
-        setRotation(Teeth, 0.2268928F, 0.0F, 0.0F);
-        Fin3 = new ayf(this, 4, 0);
-        Fin3.a(0.0F, -2F, 0.0F, 1, 4, 1);
-        Fin3.a(-0.5F, 18F, -2F);
-        Fin3.b(64, 32);
-        Fin3.i = true;
-        setRotation(Fin3, -1.570796F, 0.0F, 0.0F);
-        Fin4 = new ayf(this, 8, 0);
-        Fin4.a(0.0F, -1F, -2F, 1, 2, 2);
-        Fin4.a(-0.5F, 16F, -1F);
-        Fin4.b(64, 32);
-        Fin4.i = true;
-        setRotation(Fin4, -1.797689F, 0.0F, 0.0F);
-    }
-
-    public void a(lq entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.a(entity, f, f1, f2, f3, f4, f5);
-        a(f, f1, f2, f3, f4, f5, entity);
-        Body.a(f5);
-        Body2.a(f5);
-        Fin1.a(f5);
-        Fin2.a(f5);
-        Beak.a(f5);
-        Teeth.a(f5);
-        Fin3.a(f5);
-        Fin4.a(f5);
-    }
-
-    public void a(md entityliving, float f, float f1, float f2)
-    {
-        Beak.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.6F * f2;
-        Teeth.f = ke.b(f1 * 0.6662F * 2.0F + 0.0F) * 0.6F * f2;
-    }
-
-    private void setRotation(ayf model, float x, float y, float z)
-    {
-        model.f = x;
-        model.g = y;
-        model.h = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, lq entity)
-    {
-        super.a(f, f1, f2, f3, f4, f5, entity);
-        Fin1.g = -ke.b(f3 * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-        Fin2.g = -ke.b(f3 * 0.6662F * 2.0F + 0.0F) * 0.6F * f1 + 3.141593F;
-    }
-
-    ayf Body;
-    ayf Body2;
-    ayf Fin1;
-    ayf Fin2;
-    ayf Beak;
-    ayf Teeth;
-    ayf Fin3;
-    ayf Fin4;
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummyVillager.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummyVillager.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderMummyVillager.java	(date 1525605768000)
@@ -1,49 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderBiped;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityMummyVillager;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelMummyVillager;
-
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class RenderMummyVillager extends RenderBiped<EntityMummyVillager> {
-
-    private static final ResourceLocation ZOMBIE_VILLAGER_TEXTURES = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/villager.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_FARMER_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/farmer.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_LIBRARIAN_LOC = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/librarian.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_PRIEST_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/priest.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_SMITH_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/smith.png");
-    private static final ResourceLocation ZOMBIE_VILLAGER_BUTCHER_LOCATION = new ResourceLocation(MOD_ID, "textures/entity/mummy_villagers/butcher.png");
-
-    public RenderMummyVillager(RenderManager renderManagerIn) {
-        super(renderManagerIn, new ModelMummyVillager(), 0.5F);
-    }
-
-    @Override
-    protected ResourceLocation getEntityTexture(EntityMummyVillager entity) {
-        switch (entity.getProfession()) {
-            case 0:
-                return ZOMBIE_VILLAGER_FARMER_LOCATION;
-            case 1:
-                return ZOMBIE_VILLAGER_LIBRARIAN_LOC;
-            case 2:
-                return ZOMBIE_VILLAGER_PRIEST_LOCATION;
-            case 3:
-                return ZOMBIE_VILLAGER_SMITH_LOCATION;
-            case 4:
-                return ZOMBIE_VILLAGER_BUTCHER_LOCATION;
-            case 5:
-            default:
-                return ZOMBIE_VILLAGER_TEXTURES;
-        }
-    }
-
-    @Override
-    protected void applyRotations(EntityMummyVillager entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
-        if (entityLiving.isConverting())
-            rotationYaw += (float)(Math.cos((double)entityLiving.ticksExisted * 3.25D) * Math.PI * 0.25D);
-        super.applyRotations(entityLiving, p_77043_2_, rotationYaw, partialTicks);
-    }
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosReefManta.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosReefManta.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/RenderAtmosReefManta.java	(date 1525605768000)
@@ -1,26 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity.render;
-
-import net.minecraft.client.renderer.entity.RenderLiving;
-import net.minecraft.client.renderer.entity.RenderManager;
-import net.minecraft.util.ResourceLocation;
-import net.thegaminghuskymc.mcaddon.entity.EntityAtmosReefManta;
-import net.thegaminghuskymc.mcaddon.entity.render.model.ModelAtmosReefManta;
-import net.thegaminghuskymc.mcaddon.util.Reference;
-
-import javax.annotation.Nullable;
-
-public class RenderAtmosReefManta extends RenderLiving<EntityAtmosReefManta> {
-
-    public static final ResourceLocation TEXTURE = new ResourceLocation(Reference.MOD_ID + ":textures/entity/ocean_creatures/reefmanta.png");
-
-    public RenderAtmosReefManta(RenderManager manager) {
-        super(manager, new ModelAtmosReefManta(), 0.5f);
-    }
-
-    @Nullable
-    @Override
-    protected ResourceLocation getEntityTexture(EntityAtmosReefManta entity) {
-        return TEXTURE;
-    }
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDoubleCoralPlant.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDoubleCoralPlant.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/blocks/overworld/BlockDoubleCoralPlant.java	(date 1525605768000)
@@ -1,232 +0,0 @@
-package net.thegaminghuskymc.mcaddon.blocks.overworld;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockHorizontal;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.properties.IProperty;
-import net.minecraft.block.properties.PropertyEnum;
-import net.minecraft.block.state.BlockStateContainer;
-import net.minecraft.block.state.IBlockState;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.stats.StatList;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.IStringSerializable;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.world.IBlockAccess;
-import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-import net.thegaminghuskymc.mcaddon.Main;
-import net.thegaminghuskymc.mcaddon.blocks.BlockModBush;
-import net.thegaminghuskymc.mcaddon.properties.EnumCoralColor;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-import java.util.Random;
-
-import static net.minecraft.block.BlockLiquid.LEVEL;
-import static net.thegaminghuskymc.mcaddon.util.Reference.MOD_ID;
-
-public class BlockDoubleCoralPlant extends BlockModBush {
-
-    public static final PropertyEnum<BlockDoubleCoralPlant.EnumBlockHalf> HALF = PropertyEnum.create("half", BlockDoubleCoralPlant.EnumBlockHalf.class);
-    public static final PropertyEnum<EnumFacing> FACING = BlockHorizontal.FACING;
-
-    public BlockDoubleCoralPlant(EnumCoralColor coralColor, String name) {
-        super(Material.WATER, coralColor + "_" + name, MOD_ID);
-        this.setDefaultState(this.blockState.getBaseState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.LOWER).withProperty(FACING, EnumFacing.NORTH).withProperty(LEVEL, 15));
-        setCreativeTab(Main.OVERWORLD_EXPANSION_TAB);
-    }
-
-    public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
-        return FULL_BLOCK_AABB;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public boolean hasCustomBreakingProgress(IBlockState state) {
-        return true;
-    }
-
-    public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos) {
-        return true;
-    }
-
-    @Override
-    public IProperty[] getIgnoredProperties() {
-        return new IProperty[] {LEVEL};
-    }
-
-    protected void checkAndDropBlock(World worldIn, BlockPos pos, IBlockState state) {
-        if (!this.canBlockStay(worldIn, pos, state)) {
-            boolean flag = state.getValue(HALF) == BlockDoubleCoralPlant.EnumBlockHalf.UPPER;
-            BlockPos blockpos = flag ? pos : pos.up();
-            BlockPos blockpos1 = flag ? pos.down() : pos;
-            Block block = (flag ? this : worldIn.getBlockState(blockpos).getBlock());
-            Block block1 = (flag ? worldIn.getBlockState(blockpos1).getBlock() : this);
-
-            if (!flag) this.dropBlockAsItem(worldIn, pos, state, 0); //Forge move above the setting to air.
-
-            if (block == this) {
-                worldIn.setBlockState(blockpos, Blocks.AIR.getDefaultState(), 2);
-            }
-
-            if (block1 == this) {
-                worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 3);
-            }
-        }
-    }
-
-    public boolean canBlockStay(World worldIn, BlockPos pos, IBlockState state) {
-        if (state.getBlock() != this)
-            return super.canBlockStay(worldIn, pos, state); //Forge: This function is called during world gen and placement, before this animation.animations.blocks is set, so if we are not 'here' then assume it's the pre-check.
-        if (state.getValue(HALF) == BlockDoubleCoralPlant.EnumBlockHalf.UPPER) {
-            return worldIn.getBlockState(pos.down()).getBlock() == this;
-        } else {
-            IBlockState iblockstate = worldIn.getBlockState(pos.up());
-            return iblockstate.getBlock() == this && super.canBlockStay(worldIn, pos, iblockstate);
-        }
-    }
-
-    public Item getItemDropped(IBlockState state, Random rand, int fortune) {
-        if (state.getValue(HALF) == BlockDoubleCoralPlant.EnumBlockHalf.UPPER) {
-            return Items.AIR;
-        } else {
-            return super.getItemDropped(state, rand, fortune);
-        }
-    }
-
-    public void placeAt(World worldIn, BlockPos lowerPos, int flags) {
-        worldIn.setBlockState(lowerPos, this.getDefaultState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.LOWER), flags);
-        worldIn.setBlockState(lowerPos.up(), this.getDefaultState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.UPPER), flags);
-    }
-
-    public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) {
-        worldIn.setBlockState(pos.up(), this.getDefaultState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.UPPER), 2);
-    }
-
-    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack) {
-        {
-            super.harvestBlock(worldIn, player, pos, state, te, stack);
-        }
-    }
-
-    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
-        if (state.getValue(HALF) == BlockDoubleCoralPlant.EnumBlockHalf.UPPER) {
-            if (worldIn.getBlockState(pos.down()).getBlock() == this) {
-                if (player.capabilities.isCreativeMode) {
-                    worldIn.setBlockToAir(pos.down());
-                } else {
-                    IBlockState iblockstate = worldIn.getBlockState(pos.down());
-
-                    if (worldIn.isRemote) {
-                        worldIn.setBlockToAir(pos.down());
-                    } else if (!player.getHeldItemMainhand().isEmpty() && player.getHeldItemMainhand().getItem() == Items.SHEARS) {
-                        this.onHarvest(worldIn, pos, iblockstate, player);
-                        worldIn.setBlockToAir(pos.down());
-                    } else {
-                        worldIn.destroyBlock(pos.down(), true);
-                    }
-                }
-            }
-        } else if (worldIn.getBlockState(pos.up()).getBlock() == this) {
-            worldIn.setBlockState(pos.up(), Blocks.AIR.getDefaultState(), 2);
-        }
-
-        super.onBlockHarvested(worldIn, pos, state, player);
-    }
-
-    private boolean onHarvest(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) {
-        player.addStat(Objects.requireNonNull(StatList.getBlockStats(this)));
-        return true;
-    }
-
-    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state) {
-        return new ItemStack(this, 1);
-    }
-
-    public IBlockState getStateFromMeta(int meta) {
-        return (meta & 8) > 0 ? this.getDefaultState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.UPPER) : this.getDefaultState().withProperty(HALF, BlockDoubleCoralPlant.EnumBlockHalf.LOWER);
-    }
-
-    public int getMetaFromState(IBlockState state) {
-        return state.getValue(HALF) == BlockDoubleCoralPlant.EnumBlockHalf.UPPER ? 8 : (state.getValue(FACING)).getHorizontalIndex() & state.getValue(LEVEL);
-    }
-
-    protected BlockStateContainer createBlockState() {
-        return new BlockStateContainer(this, HALF, FACING, LEVEL);
-    }
-
-    public EnumOffsetType getOffsetType() {
-        return EnumOffsetType.XZ;
-    }
-
-    public enum EnumBlockHalf implements IStringSerializable {
-        UPPER,
-        LOWER;
-
-        public String toString() {
-            return this.getName();
-        }
-
-        public String getName() {
-            return this == UPPER ? "upper" : "lower";
-        }
-    }
-
-    public enum EnumPlantType implements IStringSerializable {
-        PIPE_CORAL(0, "pipeCoral");
-
-        private static final BlockDoubleCoralPlant.EnumPlantType[] META_LOOKUP = new BlockDoubleCoralPlant.EnumPlantType[values().length];
-
-        static {
-            for (BlockDoubleCoralPlant.EnumPlantType blockdoubleplant$enumplanttype : values()) {
-                META_LOOKUP[blockdoubleplant$enumplanttype.getMeta()] = blockdoubleplant$enumplanttype;
-            }
-        }
-
-        private final int meta;
-        private final String name;
-        private final String unlocalizedName;
-
-        EnumPlantType(int meta, String name) {
-            this(meta, name, name);
-        }
-
-        EnumPlantType(int meta, String name, String unlocalizedName) {
-            this.meta = meta;
-            this.name = name;
-            this.unlocalizedName = unlocalizedName;
-        }
-
-        public static BlockDoubleCoralPlant.EnumPlantType byMetadata(int meta) {
-            if (meta < 0 || meta >= META_LOOKUP.length) {
-                meta = 0;
-            }
-
-            return META_LOOKUP[meta];
-        }
-
-        public int getMeta() {
-            return this.meta;
-        }
-
-        public String toString() {
-            return this.name;
-        }
-
-        public String getName() {
-            return this.name;
-        }
-
-        public String getUnlocalizedName() {
-            return this.unlocalizedName;
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWhale.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWhale.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityAtmosWhale.java	(date 1525605768000)
@@ -1,30 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   EntityAtmosWhale.java
-
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.world.World;
-
-public class EntityAtmosWhale extends EntityAtmosWater {
-
-    public EntityAtmosWhale(World world) {
-        super(world);
-        setSize(8F, 3F);
-        setMaxHealth(100);
-    }
-
-    /*@Nullable
-    @Override
-    protected SoundEvent getAmbientSound() {
-        return SoundEvent.REGISTRY.getObject(new ResourceLocation("whale_ambient"));
-    }
-
-    @Nullable
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvent.REGISTRY.getObject(new ResourceLocation("whale_hurt"));
-    }*/
-
-}
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScubaDivers.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScubaDivers.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/EntityScubaDivers.java	(date 1525605768000)
@@ -1,277 +0,0 @@
-package net.thegaminghuskymc.mcaddon.entity;
-
-import net.minecraft.entity.EntityLiving;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.*;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.projectile.EntitySmallFireball;
-import net.minecraft.init.SoundEvents;
-import net.minecraft.network.datasync.DataParameter;
-import net.minecraft.network.datasync.DataSerializers;
-import net.minecraft.network.datasync.EntityDataManager;
-import net.minecraft.pathfinding.PathNodeType;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.datafix.DataFixer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.world.World;
-import net.minecraft.world.storage.loot.LootTableList;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
-
-import javax.annotation.Nullable;
-import java.util.Objects;
-
-public class EntityScubaDivers extends EntityMob {
-
-    private static final DataParameter<Byte> ON_FIRE = EntityDataManager.createKey(EntityScubaDivers.class, DataSerializers.BYTE);
-    /**
-     * Random offset used in floating behaviour
-     */
-    private float heightOffset = 0.5F;
-    /**
-     * ticks until heightOffset is randomized
-     */
-    private int heightOffsetUpdateTime;
-
-    public EntityScubaDivers(World worldIn) {
-        super(worldIn);
-        this.setPathPriority(PathNodeType.WATER, -1.0F);
-        this.setPathPriority(PathNodeType.LAVA, 8.0F);
-        this.setPathPriority(PathNodeType.DANGER_FIRE, 0.0F);
-        this.setPathPriority(PathNodeType.DAMAGE_FIRE, 0.0F);
-        this.isImmuneToFire = true;
-        this.experienceValue = 10;
-    }
-
-    public static void registerFixesBlaze(DataFixer fixer) {
-        EntityLiving.registerFixesMob(fixer, EntityScubaDivers.class);
-    }
-
-    protected void initEntityAI() {
-        this.tasks.addTask(4, new EntityScubaDivers.AIFireballAttack(this));
-        this.tasks.addTask(5, new EntityAIMoveTowardsRestriction(this, 1.0D));
-        this.tasks.addTask(7, new EntityAIWanderAvoidWater(this, 1.0D, 0.0F));
-        this.tasks.addTask(8, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));
-        this.tasks.addTask(8, new EntityAILookIdle(this));
-        this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, true));
-        this.targetTasks.addTask(2, new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
-    }
-
-    protected void applyEntityAttributes() {
-        super.applyEntityAttributes();
-        this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(6.0D);
-        this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23000000417232513D);
-        this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(48.0D);
-    }
-
-    protected void entityInit() {
-        super.entityInit();
-        this.dataManager.register(ON_FIRE, (byte) 0);
-    }
-
-    protected SoundEvent getAmbientSound() {
-        return SoundEvents.ENTITY_BLAZE_AMBIENT;
-    }
-
-    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
-        return SoundEvents.ENTITY_BLAZE_HURT;
-    }
-
-    protected SoundEvent getDeathSound() {
-        return SoundEvents.ENTITY_BLAZE_DEATH;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender() {
-        return 15728880;
-    }
-
-    /**
-     * Gets how bright this entity is.
-     */
-    public float getBrightness() {
-        return 1.0F;
-    }
-
-    /**
-     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-     * use this to react to sunlight and start to burn.
-     */
-    public void onLivingUpdate() {
-        if (!this.onGround && this.motionY < 0.0D) {
-            this.motionY *= 0.6D;
-        }
-
-        if (this.world.isRemote) {
-            if (this.rand.nextInt(24) == 0 && !this.isSilent()) {
-                this.world.playSound(this.posX + 0.5D, this.posY + 0.5D, this.posZ + 0.5D, SoundEvents.ENTITY_BLAZE_BURN, this.getSoundCategory(), 1.0F + this.rand.nextFloat(), this.rand.nextFloat() * 0.7F + 0.3F, false);
-            }
-
-            for (int i = 0; i < 2; ++i) {
-                this.world.spawnParticle(EnumParticleTypes.SMOKE_LARGE, this.posX + (this.rand.nextDouble() - 0.5D) * (double) this.width, this.posY + this.rand.nextDouble() * (double) this.height, this.posZ + (this.rand.nextDouble() - 0.5D) * (double) this.width, 0.0D, 0.0D, 0.0D);
-            }
-        }
-
-        super.onLivingUpdate();
-    }
-
-    protected void updateAITasks() {
-        if (this.isWet()) {
-            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
-        }
-
-        --this.heightOffsetUpdateTime;
-
-        if (this.heightOffsetUpdateTime <= 0) {
-            this.heightOffsetUpdateTime = 100;
-            this.heightOffset = 0.5F + (float) this.rand.nextGaussian() * 3.0F;
-        }
-
-        EntityLivingBase entitylivingbase = this.getAttackTarget();
-
-        if (entitylivingbase != null && entitylivingbase.posY + (double) entitylivingbase.getEyeHeight() > this.posY + (double) this.getEyeHeight() + (double) this.heightOffset) {
-            this.motionY += (0.30000001192092896D - this.motionY) * 0.30000001192092896D;
-            this.isAirBorne = true;
-        }
-
-        super.updateAITasks();
-    }
-
-    public void fall(float distance, float damageMultiplier) {
-    }
-
-    /**
-     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
-     */
-    public boolean isBurning() {
-        return this.isCharged();
-    }
-
-    @Nullable
-    protected ResourceLocation getLootTable() {
-        return LootTableList.ENTITIES_BLAZE;
-    }
-
-    private boolean isCharged() {
-        return (this.dataManager.get(ON_FIRE) & 1) != 0;
-    }
-
-    private void setOnFire(boolean onFire) {
-        byte b0 = this.dataManager.get(ON_FIRE);
-
-        if (onFire) {
-            b0 = (byte) (b0 | 1);
-        } else {
-            b0 = (byte) (b0 & -2);
-        }
-
-        this.dataManager.set(ON_FIRE, b0);
-    }
-
-    /**
-     * Checks to make sure the light is not too bright where the mob is spawning
-     */
-    protected boolean isValidLightLevel() {
-        return true;
-    }
-
-    static class AIFireballAttack extends EntityAIBase {
-        private final EntityScubaDivers blaze;
-        private int attackStep;
-        private int attackTime;
-
-        AIFireballAttack(EntityScubaDivers blazeIn) {
-            this.blaze = blazeIn;
-            this.setMutexBits(3);
-        }
-
-        /**
-         * Returns whether the EntityAIBase should begin execution.
-         */
-        public boolean shouldExecute() {
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            return entitylivingbase != null && entitylivingbase.isEntityAlive();
-        }
-
-        /**
-         * Execute a one shot task or start executing a continuous task
-         */
-        public void startExecuting() {
-            this.attackStep = 0;
-        }
-
-        /**
-         * Reset the task's internal state. Called when this task is interrupted by another one
-         */
-        public void resetTask() {
-            this.blaze.setOnFire(false);
-        }
-
-        /**
-         * Keep ticking a continuous task that has already been started
-         */
-        public void updateTask() {
-            --this.attackTime;
-            EntityLivingBase entitylivingbase = this.blaze.getAttackTarget();
-            double d0 = this.blaze.getDistanceSq(Objects.requireNonNull(entitylivingbase));
-
-            if (d0 < 4.0D) {
-                if (this.attackTime <= 0) {
-                    this.attackTime = 20;
-                    this.blaze.attackEntityAsMob(entitylivingbase);
-                }
-
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            } else if (d0 < this.getFollowDistance() * this.getFollowDistance()) {
-                double d1 = entitylivingbase.posX - this.blaze.posX;
-                double d2 = entitylivingbase.getEntityBoundingBox().minY + (double) (entitylivingbase.height / 2.0F) - (this.blaze.posY + (double) (this.blaze.height / 2.0F));
-                double d3 = entitylivingbase.posZ - this.blaze.posZ;
-
-                if (this.attackTime <= 0) {
-                    ++this.attackStep;
-
-                    if (this.attackStep == 1) {
-                        this.attackTime = 60;
-                        this.blaze.setOnFire(true);
-                    } else if (this.attackStep <= 4) {
-                        this.attackTime = 6;
-                    } else {
-                        this.attackTime = 100;
-                        this.attackStep = 0;
-                        this.blaze.setOnFire(false);
-                    }
-
-                    if (this.attackStep > 1) {
-                        float f = MathHelper.sqrt(MathHelper.sqrt(d0)) * 0.5F;
-                        this.blaze.world.playEvent(null, 1018, new BlockPos((int) this.blaze.posX, (int) this.blaze.posY, (int) this.blaze.posZ), 0);
-
-                        for (int i = 0; i < 1; ++i) {
-                            EntitySmallFireball entitysmallfireball = new EntitySmallFireball(this.blaze.world, this.blaze, d1 + this.blaze.getRNG().nextGaussian() * (double) f, d2, d3 + this.blaze.getRNG().nextGaussian() * (double) f);
-                            entitysmallfireball.posY = this.blaze.posY + (double) (this.blaze.height / 2.0F) + 0.5D;
-                            this.blaze.world.spawnEntity(entitysmallfireball);
-                        }
-                    }
-                }
-
-                this.blaze.getLookHelper().setLookPositionWithEntity(entitylivingbase, 10.0F, 10.0F);
-            } else {
-                this.blaze.getNavigator().clearPath();
-                this.blaze.getMoveHelper().setMoveTo(entitylivingbase.posX, entitylivingbase.posY, entitylivingbase.posZ, 1.0D);
-            }
-
-            super.updateTask();
-        }
-
-        private double getFollowDistance() {
-            IAttributeInstance iattributeinstance = this.blaze.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
-            return iattributeinstance.getAttributeValue();
-        }
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosSwordFish.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosSwordFish.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosSwordFish.java	(date 1525605768000)
@@ -1,117 +0,0 @@
-/*
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosSwordFish.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import axa;
-import ayf;
-import ke;
-import lq;
-
-public class ModelAtmosSwordFish extends axa
-{
-
-    public ModelAtmosSwordFish()
-    {
-        t = 64;
-        u = 32;
-        Body1 = new ayf(this, 0, 18);
-        Body1.a(-1F, -3F, -7F, 2, 4, 10);
-        Body1.a(0.0F, 19F, 0.0F);
-        Body1.b(64, 32);
-        Body1.i = true;
-        setRotation(Body1, 0.0F, 0.0F, 0.0F);
-        Fin1 = new ayf(this, 0, 20);
-        Fin1.a(-0.5F, -4F, 0.0F, 1, 4, 2);
-        Fin1.a(0.0F, 16F, -6F);
-        Fin1.b(64, 32);
-        Fin1.i = true;
-        setRotation(Fin1, -0.5759587F, 0.0F, 0.0F);
-        Head1 = new ayf(this, 0, 11);
-        Head1.a(-1F, -3F, -4F, 2, 3, 4);
-        Head1.a(0.0F, 19F, -6F);
-        Head1.b(64, 32);
-        Head1.i = true;
-        setRotation(Head1, 0.2268928F, 0.0F, 0.0F);
-        Head2 = new ayf(this, 12, 0);
-        Head2.a(-0.5F, 0.0F, -8F, 1, 1, 8);
-        Head2.a(0.0F, 18F, -10F);
-        Head2.b(64, 32);
-        Head2.i = true;
-        setRotation(Head2, 0.0F, 0.0F, 0.0F);
-        Fin2 = new ayf(this, 12, 11);
-        Fin2.a(-0.5F, -6F, 1.0F, 1, 5, 2);
-        Fin2.a(0.0F, 18F, 3F);
-        Fin2.b(64, 32);
-        Fin2.i = true;
-        setRotation(Fin2, -0.5585054F, 0.0F, 0.0F);
-        Fin3 = new ayf(this, 18, 11);
-        Fin3.a(-0.5F, 1.0F, 1.0F, 1, 5, 2);
-        Fin3.a(0.0F, 18F, 3F);
-        Fin3.b(64, 32);
-        Fin3.i = true;
-        setRotation(Fin3, 0.5585054F, 0.0F, -0.0174533F);
-        Body2 = new ayf(this, 0, 5);
-        Body2.a(-1F, -1.5F, 0.0F, 2, 3, 3);
-        Body2.a(0.0F, 18F, 3F);
-        Body2.b(64, 32);
-        Body2.i = true;
-        setRotation(Body2, 0.0F, 0.0F, 0.0F);
-        Fin4 = new ayf(this, 10, 0);
-        Fin4.a(0.0F, 0.0F, 0.0F, 1, 1, 4);
-        Fin4.a(0.5F, 19F, -6F);
-        Fin4.b(64, 32);
-        Fin4.i = true;
-        setRotation(Fin4, 0.0F, 0.4014257F, 0.0F);
-        Fin5 = new ayf(this, 0, 0);
-        Fin5.a(-1F, 0.0F, 0.0F, 1, 1, 4);
-        Fin5.a(-0.5F, 19F, -6F);
-        Fin5.b(64, 32);
-        Fin5.i = true;
-        setRotation(Fin5, 0.0F, -0.4014257F, 0.0F);
-    }
-
-    public void a(lq entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.a(entity, f, f1, f2, f3, f4, f5);
-        a(f, f1, f2, f3, f4, f5, entity);
-        Body1.a(f5);
-        Fin1.a(f5);
-        Head1.a(f5);
-        Head2.a(f5);
-        Fin2.a(f5);
-        Fin3.a(f5);
-        Body2.a(f5);
-        Fin4.a(f5);
-        Fin5.a(f5);
-    }
-
-    private void setRotation(ayf model, float x, float y, float z)
-    {
-        model.f = x;
-        model.g = y;
-        model.h = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, lq entity)
-    {
-        super.a(f, f1, f2, f3, f4, f5, entity);
-        Fin2.g = -ke.b(f3 * 0.6662F * 2.0F + 1.0F) * 0.9F * f1;
-        Fin3.g = -ke.b(f3 * 0.6662F * 2.0F + 1.0F) * 0.9F * f1;
-        Body2.g = -ke.b(f3 * 0.6662F * 2.0F + 1.0F) * 0.9F * f1;
-    }
-
-    ayf Body1;
-    ayf Fin1;
-    ayf Head1;
-    ayf Head2;
-    ayf Fin2;
-    ayf Fin3;
-    ayf Body2;
-    ayf Fin4;
-    ayf Fin5;
-}
-*/
Index: src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNether.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNether.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/world/gen/layer/GenLayerNether.java	(date 1525605768000)
@@ -1,38 +0,0 @@
-package net.thegaminghuskymc.mcaddon.world.gen.layer;
-
-import net.minecraft.world.WorldType;
-import net.minecraft.world.gen.layer.*;
-
-public abstract class GenLayerNether extends GenLayer
-{
-    public GenLayerNether(long seed)
-    {
-        super(seed);
-    }
-
-    public static GenLayer[] initializeAllBiomeGenerators(long seed, WorldType type)
-    {
-        int biomeSize = type == WorldType.LARGE_BIOMES ? 6 : 4;
-        biomeSize = getModdedBiomeSize(type, biomeSize);
-
-        GenLayer genLayer = new GenLayerNetherBiome(1L);
-        genLayer = new GenLayerFuzzyZoom(1000L, genLayer);
-        genLayer = GenLayerZoom.magnify(1000L, genLayer, biomeSize);
-        genLayer = new GenLayerSmooth(1000L, genLayer);
-        GenLayer genLayerVoronoiZoom = new GenLayerVoronoiZoom(10L, genLayer);
-
-        genLayer.initWorldGenSeed(seed);
-        genLayerVoronoiZoom.initWorldGenSeed(seed);
-
-        return new GenLayer[]{genLayer, genLayerVoronoiZoom};
-    }
-
-    @Override
-    public abstract int[] getInts(int areaX, int areaZ, int areaWidth, int areaHeight);
-
-    @Override
-    public int nextInt(int i)
-    {
-        return super.nextInt(i);
-    }
-}
\ No newline at end of file
Index: src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosAngler.java
===================================================================
--- src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosAngler.java	(date 1525605768000)
+++ src/main/java/net/thegaminghuskymc/mcaddon/entity/render/model/ModelAtmosAngler.java	(date 1525605768000)
@@ -1,136 +0,0 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) 
-// Source File Name:   ModelAtmosAngler.java
-
-package net.thegaminghuskymc.mcaddon.entity.render.model;
-
-import net.minecraft.client.model.ModelBase;
-import net.minecraft.client.model.ModelRenderer;
-import net.minecraft.entity.Entity;
-
-public class ModelAtmosAngler extends ModelBase {
-
-    public ModelAtmosAngler()
-    {
-        textureWidth = 64;
-        textureHeight = 32;
-        Body1 = new ModelRenderer(this, 0, 18);
-        Body1.addBox(-2F, -4F, -5F, 4, 4, 10);
-        Body1.setRotationPoint(0.0F, 20F, 0.0F);
-        Body1.setTextureOffset(64, 32);
-        Body1.mirror = true;
-        setRotation(Body1, 0.0F, 0.0F, 0.0F);
-        Body2 = new ModelRenderer(this, 28, 19);
-        Body2.addBox(-2F, 2.0F, 3F, 4, 2, 2);
-        Body2.setRotationPoint(0.0F, 18F, 0.0F);
-        Body2.setTextureOffset(64, 32);
-        Body2.mirror = true;
-        setRotation(Body2, 0.0F, 0.0F, 0.0F);
-        Beak1 = new ModelRenderer(this, 0, 8);
-        Beak1.addBox(-3F, 0.0F, -7F, 6, 2, 8);
-        Beak1.setRotationPoint(0.0F, 20F, 2.0F);
-        Beak1.setTextureOffset(64, 32);
-        Beak1.mirror = true;
-        setRotation(Beak1, 0.2443461F, 0.0F, 0.0F);
-        Teeth1 = new ModelRenderer(this, 28, 20);
-        Teeth1.addBox(-3F, -2F, -7F, 6, 2, 8);
-        Teeth1.setRotationPoint(0.0F, 20F, 2.0F);
-        Teeth1.setTextureOffset(64, 32);
-        Teeth1.mirror = true;
-        setRotation(Teeth1, 0.2443461F, 0.0F, 0.0F);
-        Teeth2 = new ModelRenderer(this, 28, 24);
-        Teeth2.addBox(-2F, 0.0F, -5F, 4, 1, 7);
-        Teeth2.setRotationPoint(0.0F, 20F, 0.0F);
-        Teeth2.setTextureOffset(64, 32);
-        Teeth2.mirror = true;
-        setRotation(Teeth2, 0.0F, 0.0F, 0.0F);
-        Fin1 = new ModelRenderer(this, 0, 0);
-        Fin1.addBox(0.0F, 0.0F, 0.0F, 1, 4, 1);
-        Fin1.setRotationPoint(1.0F, 22F, 4F);
-        Fin1.setTextureOffset(64, 32);
-        Fin1.mirror = true;
-        setRotation(Fin1, 0.2792527F, 0.0F, -1.047198F);
-        Fin2 = new ModelRenderer(this, 4, 0);
-        Fin2.addBox(-1F, 0.0F, 0.0F, 1, 4, 1);
-        Fin2.setRotationPoint(-1F, 22F, 4F);
-        Fin2.setTextureOffset(64, 32);
-        Fin2.mirror = true;
-        setRotation(Fin2, 0.2792527F, 0.0F, 1.047198F);
-        Fin3 = new ModelRenderer(this, 19, 0);
-        Fin3.addBox(-0.5F, -1F, 1.0F, 1, 2, 4);
-        Fin3.setRotationPoint(0.0F, 19F, 4F);
-        Fin3.setTextureOffset(64, 32);
-        Fin3.mirror = true;
-        setRotation(Fin3, 0.7853982F, 0.0F, 0.0F);
-        Fin4 = new ModelRenderer(this, 29, 0);
-        Fin4.addBox(-0.5F, -1F, 1.0F, 1, 2, 4);
-        Fin4.setRotationPoint(0.0F, 19F, 4F);
-        Fin4.setTextureOffset(64, 32);
-        Fin4.mirror = true;
-        setRotation(Fin4, -0.7853982F, 0.0F, 0.0F);
-        Light1 = new ModelRenderer(this, 8, 0);
-        Light1.addBox(-0.5F, -4F, -1F, 1, 4, 1);
-        Light1.setRotationPoint(0.0F, 16F, -4F);
-        Light1.setTextureOffset(64, 32);
-        Light1.mirror = true;
-        setRotation(Light1, 0.0F, 0.0F, 0.0F);
-        Light2 = new ModelRenderer(this, 9, 2);
-        Light2.addBox(-0.5F, -4F, -4F, 1, 1, 3);
-        Light2.setRotationPoint(0.0F, 16F, -4F);
-        Light2.setTextureOffset(64, 32);
-        Light2.mirror = true;
-        setRotation(Light2, 0.0F, 0.0F, 0.0F);
-        Bulb = new ModelRenderer(this, 42, 16);
-        Bulb.addBox(-0.5F, -4F, -5F, 1, 1, 1);
-        Bulb.setRotationPoint(0.0F, 16F, -4F);
-        Bulb.setTextureOffset(64, 32);
-        Bulb.mirror = true;
-        setRotation(Bulb, 0.0F, 0.0F, 0.0F);
-    }
-
-    public void a(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
-    {
-        super.render(entity, f, f1, f2, f3, f4, f5);
-        setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-        Body1.render(f5);
-        Body2.render(f5);
-        Beak1.render(f5);
-        Teeth1.render(f5);
-        Teeth2.render(f5);
-        Fin1.render(f5);
-        Fin2.render(f5);
-        Fin3.render(f5);
-        Fin4.render(f5);
-        Light1.render(f5);
-        Light2.render(f5);
-        Bulb.render(f5);
-    }
-
-    private void setRotation(ModelRenderer model, float x, float y, float z)
-    {
-        model.rotateAngleX = x;
-        model.rotateAngleY = y;
-        model.rotateAngleZ = z;
-    }
-
-    public void a(float f, float f1, float f2, float f3, float f4, float f5, Entity entity)
-    {
-        super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
-//        Fin3.rotateAngleX = -ke.setTextureOffset(f3 * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-//        Fin4.rotateAngleZ = -ke.setTextureOffset(f3 * 0.6662F * 2.0F + 0.0F) * 0.6F * f1;
-    }
-
-    ModelRenderer Body1;
-    ModelRenderer Body2;
-    ModelRenderer Beak1;
-    ModelRenderer Teeth1;
-    ModelRenderer Teeth2;
-    ModelRenderer Fin1;
-    ModelRenderer Fin2;
-    ModelRenderer Fin3;
-    ModelRenderer Fin4;
-    ModelRenderer Light1;
-    ModelRenderer Light2;
-    ModelRenderer Bulb;
-}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>buildscript {\n    repositories {\n        jcenter()\n        maven { url = \"http://files.minecraftforge.net/maven\" }\n    }\n    dependencies {\n        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'\n        classpath 'com.android.tools.build:gradle:1.0.0'// For gradle 2.2.1 - 2.3\n    }\n}\napply plugin: 'net.minecraftforge.gradle.forge'\n\next.configFile = file('build.properties')\n\nconfigFile.withReader {\n    def prop = new Properties()\n    prop.load(it)\n    ext.config = new ConfigSlurper().parse prop\n}\n\nversion = \"${config.major_version}.${config.minor_version}.${config.build_number}\"\ngroup= \"net.hdt.neutronia\"\narchivesBaseName = config.mod_name + \"[1.12.2]\"\n\nsourceCompatibility = targetCompatibility = '1.8'\ncompileJava {\n    sourceCompatibility = targetCompatibility = '1.8'\n}\n\nminecraft {\n    version = \"1.12.2-14.23.3.2678\"\n    runDir = \"run\"\n    mappings = \"snapshot_20180501\"\n}\n\nrepositories {\n    maven { // The repo from which to get waila\n        name \"Mobius Repo\"\n        url \"http://tehnut.info/maven\"\n    }\n    maven {\n        name = \"JEI Maven\"\n        url = \"http://dvs1.progwml6.com/files/maven\"\n    }\n    maven {\n        url \"https://maven.mcmoddev.com/\"\n    }\n    mavenCentral()\n}\n\ndependencies {\n    deobfCompile \"mcp.mobius.waila:Hwyla:+\"\n    deobfCompile \"mezz.jei:jei_1.12.2:4.7.+\"\n}\n\nprocessResources {\n    inputs.property \"version\", project.version\n    inputs.property \"mcversion\", project.minecraft.version\n\n    from(sourceSets.main.resources.srcDirs) {\n        include 'mcmod.info'\n        expand 'version':project.version, 'mcversion':project.minecraft.version\n    }\n\n    from(sourceSets.main.resources.srcDirs) {\n        exclude 'mcmod.info'\n    }\n}\n\njar {\n    classifier = 'universal'\n}\n\ntask deobfJar(type: Jar) {\n    from sourceSets.main.output\n    classifier = 'deobf'\n}\n\ntask srcJar(type: Jar) {\n    from sourceSets.main.allSource\n    classifier = 'sources'\n}\n\nartifacts {\n    archives deobfJar\n    archives srcJar\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(date 1525605768000)
+++ build.gradle	(date 1525607254000)
@@ -30,7 +30,7 @@
 minecraft {
     version = "1.12.2-14.23.3.2678"
     runDir = "run"
-    mappings = "snapshot_20180501"
+    mappings = "snapshot_20180506"
 }
 
 repositories {
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># eclipse\nbin\n*.launch\n.settings\n.metadata\n.classpath\n.project\n\n# idea\nout\n*.ipr\n*.iws\n*.iml\n.idea\n\n# gradle\nbuild\n.gradle\n\n# other\neclipse\nrun\nrun-backup\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitignore	(date 1525605768000)
+++ .gitignore	(date 1525606773000)
@@ -20,4 +20,3 @@
 # other
 eclipse
 run
-run-backup
